*************************************
* COPYRIGHT (C) MOTOROLA, INC. 1979 *
*************************************

*************************************
* THIS IS THE BASE ASSIST09 ROM.
* IT MAY RUN WITH OR WITHOUT THE
* EXTENSION ROM WHICH
* WHEN PRESENT WILL BE AUTOMATICALLY
* INCORPORATED BY THE BLDVTR
* SUBROUTINE.
*************************************

*********************************************
* GLOBAL MODULE EQUATES
********************************************
ROMBEG EQU      $F800   ROM START ASSEMBLY ADDRESS
RAMOFS EQU      -$1900  ROM OFFSET TO RAM WORK PAGE
ROMSIZ EQU      2048            ROM SIZE
ROM2OF EQU      ROMBEG-ROMSIZ   START OF EXTENSION ROM
ACIA   EQU      $E008           DEFAULT ACIA ADDRESS
PTM    EQU      $E000           DEFAULT PTM ADDRESS
DFTCHP EQU      0               DEFAULT CHARACTER PAD COUNT
DFTNLP EQU      5               DEFAULT NEW LINE PAD COUNT
PROMPT EQU      '>'             PROMPT CHARACTER
NUMBKP EQU      8               NUMBER OF BREAKPOINTS
*********************************************

*********************************************
* MISCELANEOUS EQUATES
*********************************************
EOT     EQU     $04             END OF TRANSMISSION
BELL    EQU     $07             BELL CHARACTER
LF      EQU     $0A             LINE FEED
CR      EQU     $0D             CARRIAGE RETURN
DLE     EQU     $10             DATA LINK ESCAPE
CAN     EQU     $18             CANCEL (CTL-X)

* PTM ACCESS DEFINITIONS
PTMSTA  EQU     PTM+1           READ STATUS REGISTER
PTMC13  EQU     PTM             CONTROL REGISTERS 1 AND 3
PTMC2   EQU     PTM+1           CONTROL REGISTER 2
PTMTM1  EQU     PTM+2           LATCH 1
PTMTM2  EQU     PTM+4           LATCH 2
PTMTM3  EQU     PTM+6           LATCH 3
SKIP2   EQU     $8C             "CMPX #" OPCODE - SKIPS TWO BYTES

*******************************************
* ASSIST09 MONITOR SWI FUNCTIONS
* THE FOLLOWING EQUATES DEFINE FUNCTIONS PROVIDED
* BY THE ASSIST09 MONITOR VIA THE SWI INSTRUCTION.
******************************************
INCHNP  EQU     0               INPUT CHAR IN A REG - NO PARITY
OUTCH   EQU     1               OUTPUT CHAR FROM A REG
PDATA1  EQU     2               OUTPUT STRING
PDATA   EQU     3               OUTPUT CR/LF THEN STRING
OUT2HS  EQU     4               OUTPUT TWO HEX AND SPACE
OUT4HS  EQU     5               OUTPUT FOUR HEX AND SPACE
PCRLF   EQU     6               OUTPUT CR/LF
SPACE   EQU     7               OUTPUT A SPACE
MONITR  EQU     8               ENTER ASSIST09 MONITOR
VCTRSW  EQU     9               VECTOR EXAMINE/SWITCH
BRKPT   EQU     10              USER PROGRAM BREAKPOINT
PAUSE   EQU     11              TASK PAUSE FUNCTION
NUMFUN  EQU     11              NUMBER OF AVAILABLE FUNCTIONS

* NEXT SUB-CODES FOR ACCESSING THE VECTOR TABLE.
* THEY ARE EQUIVALENT TO OFFSETS IN THE TABLE.
* RELATIVE POSITIONING MUST BE MAINTAINED

.AVTBL
.CMDL1
.RSVD
.SWI3
.SWI2
.FIRQ
.IRQ
.SWI
.NMI
.RESET
.CION
.CIDTA
.CIOFF
.COON
.CODTA
.COOFF
.HSDTA
.BSON
.BSDTA
.BSOFF
.PAUSE
.EXPAN
.CMDL2
.ACIA
.PAD
.ECHO
.PTM
NUMVTR
HIVTR
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
EQU
0
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32
34
36
38
40
42
44
46
48
50
52
52/2+1
52
ADDRESS OF VECTOR TABLE
FIRST COMMAND LIST
RESERVED HARDWARE VECTOR
SWI3 ROUTINE
SWI2 ROUTINE
FIRQ ROUTINE
IRQ ROUTINE
SWI ROUTINE
NMI ROUTINE
RESET ROUTINE
CONSOLE ON
CONSOLE INPUT DATA
CONSOLE INPUT OFF
CONSOLE OUTPUT ON
CONSOLE OUTPUT DATA
CONSOLE OUTPUT OFF
HIGH SPEED PRINTDATA
PUNCH/LOAD ON
PUNCH/LOAD DATA
PUNCH/LOAD OFF
TASK PAUSE ROUTINE
EXPRESSION ANALYZER
SECOND COMMAND LIST
ACIA ADDRESS
CHARACTER PAD AND NEW LINE PAD
ECHO/LOAD AND NULL BKPT FLAG
PTM ADDRESS
NUMBER OF VECTORS
HIGHEST VECTOR OFFSETDUNFIELD 6809 ASSEMBLER: ASSIST09
0000
0000
0000
0000
0000
0000
0000
0000
0000
DF00
0000
E000
E000
E000
DFFC
DFFC
DFFB
DFFB
DFFA
DFFA
DFF8
DFF8
DFC2
DFC2
DFB2
DFB2
DFA2
DFA2
DFA0
DFA0
DF9E
DF9E
DF9D
DF9D
DF9B
DF9B
DF99
DF99
DF97
DF97
DF95
DF95
DF93
DF93
DF91
DF91
DF90
DF90
DF8F
DF8F
DF8E
DF8E
DF66
DF66
DF51
DF51
DF51
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
******************************************
*
WORK AREA
* THIS WORK AREA IS ASSIGNED TO THE PAGE ADDRESSED BY
* -$1800,PCR FROM THE BASE ADDRESS OF THE ASSIST09
* ROM. THE DIRECT PAGE REGISTER DURING MOST ROUTINE
* OPERATIONS WILL POINT TO THIS WORK AREA. THE STACK
* INITIALLY STARTS UNDER THE RESERVED WORK AREAS AS
* DEFINED HEREIN.
******************************************
WORKPG EQU
ROMBEG+RAMOFS
SETUP DIRECT PAGE ADDRESS
SETDP
=WORKPG
NOTIFY ASSEMBLER
ORG
WORKPG+256
READY PAGE DEFINITIONS
* THE FOLLOWING THRU BKPTOP MUST RESIDE IN THIS ORDER
* FOR PROPER INITIALIZATION
ORG
*-4
PAUSER EQU
*
PAUSE ROUTINE
ORG
*-1
SWIBFL EQU
*
BYPASS SWI AS BREAKPOINT FLAG
ORG
*-1
BKPTCT EQU
*
BREAKPOINT COUNT
ORG
*-2
SLEVEL EQU
*
STACK TRACE LEVEL
ORG
*-(NUMVTR*2)
VECTAB EQU
*
VECTOR TABLE
ORG
*-(2*NUMBKP)
BKPTBL EQU
*
BREAKPOINT TABLE
ORG
*-(2*NUMBKP)
BKPTOP EQU
*
BREAKPOINT OPCODE TABLE
ORG
*-2
WINDOW EQU
*
WINDOW
ORG
*-2
ADDR
EQU
*
ADDRESS POINTER VALUE
ORG
*-1
BASEPG EQU
*
BASE PAGE VALUE
ORG
*-2
NUMBER EQU
*
BINARY BUILD AREA
ORG
*-2
LASTOP EQU
*
LAST OPCODE TRACED
ORG
*-2
RSTACK EQU
*
RESET STACK POINTER
ORG
*-2
PSTACK EQU
*
COMMAND RECOVERY STACK
ORG
*-2
PCNTER EQU
*
LAST PROGRAM COUNTER
ORG
*-2
TRACEC EQU
*
TRACE COUNT
ORG
*-1
SWICNT EQU
*
TRACE "SWI" NEST LEVEL COUNT
ORG
*-1
(MISFLG MUST FOLLOW SWICNT)
MISFLG EQU
*
LOAD CMD/THRU BREAKPOINT FLAG
ORG
*-1
DELIM
EQU
*
EXPRESSION DELIMITER/WORK BYTE
ORG
*-40
ROM2WK EQU
*
EXTENSION ROM RESERVED AREA
ORG
*-21
TSTACK EQU
*
TEMPORARY STACK HOLD
STACK
EQU
*
START OF INITIAL STACKDUNFIELD 6809 ASSEMBLER: ASSIST09
DF51
DF51
DF51
DF51
DF51
DF51
DF51
F800
F800
F800
F800
F800
F800
F800
F800
F800
F800
F800
F800
F800
F800
F800
F800
F800
F804
F806
F808
F80A
F80C
F80F
F811
F813
F815
F817
F819
F81B
F81D
F81F
F821
F823
F825
F826
F828
F82C
F82F
F831
F833
F835
F837
F837
F837
F837
F837
F837
F837
F837
F837
F837
F83B
F83D
F83E
F840
F841
F842
F844
F844
F844
F844
30
1F
1F
97
33
31
EF
C6
34
1F
E3
ED
6A
26
C6
A6
A7
5A
26
31
8E
AC
26
AD
35
32
8D
4F
1F
3F
08
20
8D E7 BE
10
8B
9D
84
8C 35
81
16
04
20
A1
81
E4
F6
0D
A0
80
F9
8D F7 D4
20 FE
A1
02
A4
84
8D E7 16
C3
8B
F9
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
******************************************
* DEFAULT THE ROM BEGINNING ADDRESS TO 'ROMBEG'
* ASSIST09 IS POSITION ADDRESS INDEPENDENT, HOWEVER
* WE ASSEMBLE ASSUMING CONTROL OF THE HARDWARE VECTORS.
* NOTE THAT THE WORK RAM PAGE MUST BE 'RAMOFS'
* FROM THE ROM BEGINNING ADDRESS.
********************************************
ORG
ROMBEG
ROM ASSEMBLY/DEFAULT ADDRESS
*****************************************************
*
BLDVTR - BUILD ASSIST09 VECTOR TABLE
* HARDWARE RESET CALLS THIS SUBROUTINE TO BUILD THE
* ASSIST09 VECTOR TABLE. THIS SUBROUTINE RESIDES AT
* THE FIRST BYTE OF THE ASSIST09 ROM, AND CAN BE
* CALLED VIA EXTERNAL CONTROL CODE FOR REMOTE
* ASSIST09 EXECUTION.
* INPUT: S->VALID STACK RAM
* OUTPUT: U->VECTOR TABLE ADDRESS
*
DPR->ASSIST09 WORK AREA PAGE
*
THE VECTOR TABLE AND DEFAULTS ARE INITIALIZED
* ALL REGISTERS VOLATILE
*************************************************
BLDVTR
BLD2
BLD3
BLDRTN
LEAX
TFR
TFR
STA
LEAU
LEAY
STU
LDB
PSHS
TFR
ADDD
STD
DEC
BNE
LDB
LDA
STA
DECB
BNE
LEAY
LDX
CMPX
BNE
JSR
PULS
VECTAB,PCR
X,D
A,DP
BASEPG
,X
<INITVT,PCR
,X++
#NUMVTR-5
B
Y,D
,Y++
,X++
,S
BLD2
#INTVE-INTVS
,Y+
,X+
BLD3
ROM2OF,PCR
#$20FE
,Y++
BLDRTN
,Y
PC,B
ADDRESS VECTOR TABLE
OBTAIN BASE PAGE ADDRESS
SETUP DPR
STORE FOR QUICK REFERENCE
RETURN TABLE TO CALLER
LOAD FROM ADDR
INIT VECTOR TABLE ADDRESS
NUMBER RELOCATABLE VECTORS
STORE INDEX ON STACK
PREPARE ADDRESS RESOLVE
TO ABSOLUTE ADDRESS
INTO VECTOR TABLE
COUNT DOWN
BRANCH IF MORE TO INSERT
STATIC VALUE INIT LENGTH
LOAD NEXT BYTE
STORE INTO POSITION
COUNT DOWN
LOOP UNTIL DONE
TEST POSSIBLE EXTENSION ROM
LOAD "BRA *" FLAG PATTERN
? EXTENDED ROM HERE
BRANCH NOT OUR ROM TO RETURN
CALL EXTENDED ROM INITIALIZE
RETURN TO INITIALIZER
*****************************************************
*
RESET ENTRY POINT
* HARDWARE RESET ENTERS HERE IF ASSIST09 IS ENABLED
* TO RECEIVE THE MC6809 HARDWARE VECTORS. WE CALL
* THE BLDVTR SUBROUTINE TO INITIALIZE THE VECTOR
* TABLE, STACK, AND THEN FIREUP THE MONITOR VIA SWI
* CALL.
*******************************************************
RESET
LEAS
STACK,PCR
SETUP INITIAL STACK
BSR
BLDVTR
BUILD VECTOR TABLE
RESET2 CLRA
ISSUE STARTUP MESSAGE
TFR
A,DP
DEFAULT TO PAGE ZERO
SWI
PERFORM MONITOR FIREUP
FCB
MONITR
TO ENTER COMMAND PROCESSING
BRA
RESET2
REENTER MONITOR IF 'CONTINUE'
******************************************************
*
INITVT - INITIAL VECTOR TABLE
* THIS TABLE IS RELOCATED TO RAM AND REPRESENTS THEDUNFIELD 6809 ASSEMBLER: ASSIST09
F844
F844
F844
F844
F844
F844
F846
F848
F84A
F84C
F84E
F850
F852
F854
F856
F858
F85A
F85C
F85E
F860
F862
F864
F866
F868
F86A
F86C
F86E
F870
F870
F872
F874
F876
F878
F87A
F87B
F87C
F87D
F87D
F87D
F87D
F87D
F87D
F87D
F87D
F87D
F87D
F87D
F87D
F87D
F87D
F87D
F87D
F87D
F87D
F87D
F87D
F87F
F881
F883
F885
F887
F889
F88B
F88D
F88F
F891
F893
F895
01
02
02
02
02
02
00
02
FF
02
02
02
02
02
02
03
02
02
02
E7
04
01 58
92
90
8E
70
8A
45
2B
E3
90
84
96
8A
93
90
9A
B7
D2
BF
92
7D
2D
E0
00
00
E0
00
00
00
39 08
05
00
00
00
01
01
01
01
01
01
01
01
00
01
02
01
94
B1
CB
C3
75
73
C0
79
55
7D
56
D1
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
* INITIAL STATE OF THE VECTOR TABLE. ALL ADDRESSES
* ARE CONVERTED TO ABSOLUTE FORM. THIS TABLE STARTS
* WITH THE SECOND ENTRY, ENDS WITH STATIC CONSTANT
* INITIALIZATION DATA WHICH CARRIES BEYOND THE TABLE.
************************************************
INITVT FDB
CMDTBL-*
DEFAULT FIRST COMMAND TABLE
FDB
RSRVDR-*
DEFAULT UNDEFINED HARDWARE VECTOR
FDB
SWI3R-*
DEFAULT SWI3
FDB
SWI2R-*
DEFAULT SWI2
FDB
FIRQR-*
DEFAULT FIRQ
FDB
IRQR-*
DEFAULT IRQ ROUTINE
FDB
SWIR-*
DEFAULT SWI ROUTINE
FDB
NMIR-*
DEFAULT NMI ROUTINE
FDB
RESET-*
RESTART VECTOR
FDB
CION-*
DEFAULT CION
FDB
CIDTA-*
DEFAULT CIDTA
FDB
CIOFF-*
DEFAULT CIOFF
FDB
COON-*
DEFAULT COON
FDB
CODTA-*
DEFAULT CODTA
FDB
COOFF-*
DEFAULT COOFF
FDB
HSDTA-*
DEFAULT HSDTA
FDB
BSON-*
DEFAULT BSON
FDB
BSDTA-*
DEFAULT BSDTA
FDB
BSOFF-*
DEFAULT BSOFF
FDB
PAUSER-*
DEFAULT PAUSE ROUTINE
FDB
EXP1-*
DEFAULT EXPRESSION ANALYZER
FDB
CMDTB2-*
DEFAULT SECOND COMMAND TABLE
* CONSTANTS
INTVS
FDB
ACIA
DEFAULT ACIA
FCB
DFTCHP,DFTNLP
DEFAULT NULL PADDS
FDB
0
DEFAULT ECHO
FDB
PTM
DEFAULT PTM
FDB
0
INITIAL STACK TRACE LEVEL
FCB
0
INITIAL BREAKPOINT COUNT
FCB
0
SWI BREAKPOINT LEVEL
FCB
$39
DEFAULT PAUSE ROUTINE (RTS)
INTVE
EQU
*
*B
***********************************************
*
ASSIST09 SWI HANDLER
* THE SWI HANDLER PROVIDES ALL INTERFACING NECESSARY
* FOR A USER PROGRAM. A FUNCTION BYTE IS ASSUMED TO
* FOLLOW THE SWI INSTRUCTION. IT IS BOUND CHECKED
* AND THE PROPER ROUTINE IS GIVEN CONTROL. THIS
* INVOCATION MAY ALSO BE A BREAKPOINT INTERRUPT.
* IF SO, THE BREAKPOINT HANDLER IS ENTERED.
* INPUT: MACHINE STATE DEFINED FOR SWI
* OUTPUT: VARIES ACCORDING TO FUNCTION CALLED. PC ON
*
CALLERS STACK INCREMENTED BY ONE IF VALID CALL.
* VOLATILE REGISTERS: SEE FUNCTIONS CALLED
* STATE: RUNS DISABLED UNLESS FUNCTION CLEARS I FLAG.
************************************************
* SWI FUNCTION VECTOR TABLE
SWIVTB FDB
ZINCH-SWIVTB
FDB
ZOTCH1-SWIVTB
FDB
ZPDTA1-SWIVTB
FDB
ZPDATA-SWIVTB
FDB
ZOT2HS-SWIVTB
FDB
ZOT4HS-SWIVTB
FDB
ZPCRLF-SWIVTB
FDB
ZSPACE-SWIVTB
FDB
ZMONTR-SWIVTB
FDB
ZVSWTH-SWIVTB
FDB
ZBKPNT-SWIVTB
FDB
ZPAUSE-SWIVTB
INCHNP
OUTCH
PDATA1
PDATA
OUT2HS
OUT4HS
PCRLF
SPACE
MONITR
VCTRSW
BREAKPOINT
TASK PAUSEDUNFIELD 6809 ASSEMBLER: ASSIST09
F895
F899
F89C
F89C
F89E
F8A0
F8A2
F8A4
F8A7
F8A8
F8A9
F8AB
F8AE
F8B0
F8B2
F8B5
F8B7
F8B9
F8BB
F8BF
F8C1
F8C2
F8C5
F8C7
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8C9
F8D1
F8D2
F8D2
F8D5
F8D7
F8D9
F8DD
F8E1
F8E4
F8E5
F8E6
F8E8
F8EA
F8EC
F8EE
F8F1
F8F3
F8F5
F8F5
F8F7
F8F7
6A 8D E6 F7
17 02 25
EE
33
0D
26
17
50
5A
2B
11
26
EF
16
0F
37
C1
10
EF
58
33
EC
6E
6A
5F
FB
11
06 9B
0A
A3 A1
F8
6A
02 1E
FB
06
0B
22 02 0F
6A
8C B8
C5
CB
41 53 53 49 53 54 +
04
10
6D
26
AD
AD
30
3F
03
9E
27
6F
6F
CC
A7
E7
DF
61
0D
9D
9D
8C
97
E6 F9
E6 FB
E5
F6
0D
02
03
01 A6
01
00
6F 01
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
SWIR
DEC
SWICNT,PCR
LBSR
LDDP
* CHECK FOR BREAKPOINT TRAP
LDU
10,S
LEAU
-1,U
TST
SWIBFL
BNE
SWIDNE
LBSR
CBKLDR
NEGB
SWILP
DECB
BMI
SWIDNE
CMPU
,Y++
BNE
SWILP
STU
10,S
LBRA
ZBKPNT
SWIDNE CLR
SWIBFL
PULU
D
CMPB
#NUMFUN
LBHI
ERROR
STU
10,S
ASLB
FUNCTION
LEAU
SWIVTB,PCR
LDD
B,U
JMP
D,U
UP "SWI" LEVEL FOR TRACE
SETUP PAGE AND VERIFY STACK
LOAD PROGRAM COUNTER
BACK TO SWI ADDRESS
? THIS "SWI" BREAKPOINT
BRANCH IF SO TO LET THROUGH
OBTAIN BREAKPOINT POINTERS
OBTAIN POSITIVE COUNT
COUNT DOWN
BRANCH WHEN DONE
? WAS THIS A BREAKPOINT
BRANCH IF NOT
SET PROGRAM COUNTER BACK
GO DO BREAKPOINT
CLEAR IN CASE SET
OBTAIN FUNCTION BYTE, UP PC
? TOO HIGH
YES, DO BREAKPOINT
BUMP PROGRAM COUNTER PAST SWI
CODE TIMES TWO
OBTAIN VECTOR BRANCH ADDRESS
LOAD OFFSET
JUMP TO ROUTINE
**********************************************
* REGISTERS TO FUNCTION ROUTINES:
* DP-> WORK AREA PAGE
* D,Y,U=UNRELIABLE
X=AS CALLED FROM USER
* S=AS FROM SWI INTERRUPT
*********************************************
**************************************************
*
[SWI FUNCTION 8]
*
MONITOR ENTRY
* FIREUP THE ASSIST09 MONITOR.
* THE STACK WITH ITS VALUES FOR THE DIRECT PAGE
* REGISTER AND CONDITION CODE FLAGS ARE USED AS IS.
*
1) INITIALIZE CONSOLE I/O
*
2) OPTIONALLY PRINT SIGNON
*
3) INITIALIZE PTM FOR SINGLE STEPPING
*
4) ENTER COMMAND PROCESSOR
* INPUT: A=0 INIT CONSOLE AND PRINT STARTUP MESSAGE
*
A#0 OMIT CONSOLE INIT AND STARTUP MESSAGE
*************************************************
SIGNON
ZMONTR
FCC
FCB
/ASSIST09/
EOT
SIGNON EYE-CATCHER
STS
RSTACK
SAVE FOR BAD STACK RECOVERY
TST
1,S
? INIT CONSOLE AND SEND MSG
BNE
ZMONT2
BRANCH IF NOT
JSR
[VECTAB+.CION,PCR]
READY CONSOLE INPUT
JSR
[VECTAB+.COON,PCR]
READY CONSOLE OUTPUT
LEAX
SIGNON,PCR
READY SIGNON EYE-CATCHER
SWI
PERFORM
FCB
PDATA
PRINT STRING
ZMONT2 LDX
VECTAB+.PTM
LOAD PTM ADDRESS
BEQ
CMD
BRANCH IF NOT TO USE A PTM
CLR
PTMTM1-PTM,X
SET LATCH TO CLEAR RESET
CLR
PTMTM1+1-PTM,X AND SET GATE HIGH
LDD
#$01A6
SETUP TIMER 1 MODE
STA
PTMC2-PTM,X
SETUP FOR CONTROL REGISTER1
STB
PTMC13-PTM,X
SET OUTPUT ENABLED/
*
SINGLE SHOT/ DUAL 8 BIT/INTERNAL MODE/OPERATE
CLR
PTMC2-PTM,X
SET CR2 BACK TO RESET FORM
* FALL INTO COMMAND PROCESSORDUNFIELD 6809 ASSEMBLER: ASSIST09
F8F7
F8F7
F8F7
F8F7
F8F7
F8F7
F8F7
F8F7
F8F7
F8F7
F8F7
F8F7
F8F7
F8F7
F8F7
F8F7
F8F7
F8F8
F8F9
F8F9
F8FC
F8FE
F8FF
F901
F902
F904
F906
F908
F90A
F90C
F90E
F910
F911
F912
F914
F916
F917
F918
F91A
F91C
F91E
F920
F922
F922
F925
F929
F92B
F92D
F931
F933
F935
F935
F937
F939
F93B
F93D
F93F
F941
F944
F946
F948
F94B
F94D
F94D
F94F
F951
F953
F955
3F
06
17
2A
50
D7
5A
2B
A6
A7
20
AE
9F
86
3F
01
33
DF
4F
5F
DD
DD
DD
C6
34 06 46
0C
17
30
81
27
30
81
27 04 54
8D 05 81
2E
5A
8D 04 E9
2F
52
81
23
34
6C
81
27
17
27
6A
17
20 20
14
02
5F
2F
4F
04 0B
02
5E
04 2E
E8
80
A7
9E
E6
2A 0D
5D
C4
80
10
FA
06
30
B1
F7
6A
93
3E
E4
95
9B
8F
91
02
07
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
***************************************************
*
COMMAND HANDLER
* BREAKPOINTS ARE REMOVED AT THIS TIME.
* PROMPT FOR A COMMAND, AND STORE ALL CHARACTERS
* UNTIL A SEPARATOR ON THE STACK.
* SEARCH FOR FIRST MATCHING COMMAND SUBSET,
* CALL IT OR GIVE '?' RESPONSE.
* DURING COMMAND SEARCH:
*
B=OFFSET TO NEXT ENTRY ON X
*
U=SAVED S
*
U-1=ENTRY SIZE+2
*
U-2=VALID NUMBER FLAG (>=0 VALID)/COMPARE CNT
*
U-3=CARRIAGE RETURN FLAG (0=CR HAS BEEN DONE)
*
U-4=START OF COMMAND STORE
*
S+0=END OF COMMAND STORE
***********************************************
CMD
SWI
TO NEW LINE
FCB
PCRLF
FUNCTION
* DISARM THE BREAKPOINTS
CMDNEP LBSR
CBKLDR
OBTAIN BREAKPOINT POINTERS
BPL
CMDNOL
BRANCH IF NOT ARMED OR NONE
NEGB
MAKE POSITIVE
STB
BKPTCT
FLAG AS DISARMED
CMDDDL DECB
? FINISHED
BMI
CMDNOL
BRANCH IF SO
LDA
-NUMBKP*2,Y
LOAD OPCODE STORED
STA
[,Y++]
STORE BACK OVER "SWI"
BRA
CMDDDL
LOOP UNTIL DONE
CMDNOL LDX
10,S
LOAD USERS PROGRAM COUNTER
STX
PCNTER
SAVE FOR EXPRESSION ANALYZER
LDA
#PROMPT
LOAD PROMPT CHARACTER
SWI
SEND TO OUTPUT HANDLER
FCB
OUTCH
FUNCTION
LEAU
,S
REMEMBER STACK RESTORE ADDRESS
STU
PSTACK
REMEMBER STACK FOR ERROR USE
CLRA
PREPARE ZERO
CLRB
PREPARE ZERO
STD
NUMBER
CLEAR NUMBER BUILD AREA
STD
MISFLG
CLEAR MISCEL. AND SWICNT FLAGS
STD
TRACEC
CLEAR TRACE COUNT
LDB
#2
SET D TO TWO
PSHS
D,CC
PLACE DEFAULTS ONTO STACK
* CHECK FOR "QUICK" COMMANDS.
LBSR
READ
OBTAIN FIRST CHARACTER
LEAX
CDOT+2,PCR
PRESET FOR SINGLE TRACE
CMPA
#'.'
? QUICK TRACE
BEQ
CMDXQT
BRANCH EQUAL FOR TRACE ONE
LEAX
CMPADP+2,PCR
READY MEMORY ENTRY POINT
CMPA
#'/'
? OPEN LAST USED MEMORY
BEQ
CMDXQT
BRANCH TO DO IT IF SO
* PROCESS NEXT CHARACTER
CMD2
CMPA
#' '
? BLANK OR DELIMITER
BLS
CMDGOT
BRANCH YES, WE HAVE IT
PSHS
A
BUILD ONTO STACK
INC
-1,U
COUNT THIS CHARACTER
CMPA
#'/'
? MEMORY COMMAND
BEQ
CMDMEM
BRANCH IF SO
LBSR
BLDHXC
TREAT AS HEX VALUE
BEQ
CMD3
BRANCH IF STILL VALID NUMBER
DEC
-2,U
FLAG AS INVALID NUMBER
CMD3
LBSR
READ
OBTAIN NEXT CHARACTER
BRA
CMD2
TEST NEXT CHARACTER
* GOT COMMAND, NOW SEARCH TABLES
CMDGOT SUBA
#CR
SET ZERO IF CARRIAGE RETURN
STA
-3,U
SETUP FLAG
LDX
VECTAB+.CMDL1
START WITH FIRST CMD LIST
CMDSCH LDB
,X+
LOAD ENTRY LENGTH
BPL
CMDSME
BRANCH IF NOT LIST ENDDUNFIELD 6809 ASSEMBLER: ASSIST09
F957
F959
F95A
F95C
F95F
F963
F964
F965
F967
F967
F968
F96A
F96C
F96D
F96F
F971
F973
F975
F977
F978
F97A
F97C
F97E
F980
F982
F983
F985
F987
F989
F98B
F98D
F990
F992
F994
F997
F999
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99B
F99C
F99C
F99C
9E
5C
27
10
30
3F
02
20
5A
E1
24
3A
20
31
A6
80
A7
5A
A6
A1
26
6A
26
3A
EC
30
6D
32
AD
16
6D
2B
30
DC
20
FE
EE
F7
DE 95
8D 01 5A
90
5F
03
E4
5D
5F
02
5E
80
A2
EE
5E
F5
1E
8B
5D
C4
1E
FF 7A
5E
C8
88 AE
9B
EC
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
LDX
VECTAB+.CMDL2
INCB
BEQ
CMDSCH
CMDBAD LDS
PSTACK
LEAX
ERRMSG,PCR
SWI
FCB
PDATA1
BRA
CMD
* SEARCH NEXT ENTRY
CMDSME DECB
CMPB
-1,U
BHS
CMDSIZ
CMDFLS ABX
SKIP
BRA
CMDSCH
CMDSIZ LEAY
-3,U
LDA
-1,U
SUBA
#2
STA
-2,U
CMDCMP DECB
LDA
,X+
CMPA
,-Y
BNE
CMDFLS
DEC
-2,U
BNE
CMDCMP
ABX
TO
LDD
-2,X
LEAX
D,X
CMDXQT TST
-3,U
LEAS
,U
JSR
-2,X
LBRA
CMDNOL
CMDMEM TST
-2,U
BMI
CMDBAD
LEAX
<CMEMN-CMPADP,X
LDD
NUMBER
BRA
CMDXQT
NOW TO SECOND CMD LIST
? TO CONTINUE TO DEFAULT LIST
BRANCH IF SO
RESTORE STACK
POINT TO ERROR STRING
SEND OUT
TO CONSOLE
AND TRY AGAIN
TAKE ACCOUNT OF LENGTH BYTE
? ENTERED LONGER THAN ENTRY
BRANCH IF NOT TOO LONG
TO NEXT ENTRY
AND TRY NEXT
PREPARE TO COMPARE
LOAD SIZE+2
TO ACTUAL SIZE ENTERED
SAVE SIZE FOR COUNTDOWN
DOWN ONE BYTE
NEXT COMMAND CHARACTER
? SAME AS THAT ENTERED
BRANCH TO FLUSH IF NOT
COUNT DOWN LENGTH OF ENTRY
BRANCH IF MORE TO TEST
NEXT ENTRY
LOAD OFFSET
COMPUTE ROUTINE ADDRESS+2
SET CC FOR CARRIAGE RETURN TEST
DELETE STACK WORK AREA
CALL COMMAND
GO GET NEXT COMMAND
? VALID HEX NUMBER ENTERED
BRANCH ERROR IF NOT
TO DIFFERENT ENTRY
LOAD NUMBER ENTERED
AND ENTER MEMORY COMMAND
** COMMANDS ARE ENTERED AS A SUBROUTINE WITH:
**
DPR->ASSIST09 DIRECT PAGE WORK AREA
**
Z=1 CARRIAGE RETURN ENTERED
**
Z=0 NON CARRIAGE RETURN DELIMITER
**
S=NORMAL RETURN ADDRESS
** THE LABEL "CMDBAD" MAY BE ENTERED TO ISSUE AN
** AN ERROR FLAG (*).
**************************************************
*
ASSIST09 COMMAND TABLES
* THESE ARE THE DEFAULT COMMAND TABLES. EXTERNAL
* TABLES OF THE SAME FORMAT MAY EXTEND/REPLACE
* THESE BY USING THE VECTOR SWAP FUNCTION.
*
* ENTRY FORMAT:
*
+0...TOTAL SIZE OF ENTRY (INCLUDING THIS BYTE)
*
+1...COMMAND STRING
*
+N...TWO BYTE OFFSET TO COMMAND (ENTRYADDR-*)
*
* THE TABLES TERMINATE WITH A ONE BYTE -1 OR -2.
* THE -1 CONTINUES THE COMMAND SEARCH WITH THE
*
SECOND COMMAND TABLE.
* THE -2 TERMINATES COMMAND SEARCHES.
*****************************************************
* THIS IS THE DEFAULT LIST FOR THE SECOND COMMAND
* LIST ENTRY.
CMDTB2 FCB
-2
STOP COMMAND SEARCHES
* THIS IS THE DEFAULT LIST FOR THE FIRST COMMAND
* LIST ENTRY.DUNFIELD 6809 ASSEMBLER: ASSIST09
F99C
F99C
F99D
F99E
F9A0
F9A1
F9A2
F9A4
F9A5
F9A6
F9A8
F9A9
F9AA
F9AC
F9AD
F9AE
F9B0
F9B1
F9B2
F9B4
F9B5
F9B6
F9B8
F9B9
F9BA
F9BC
F9BD
F9BE
F9C0
F9C1
F9C2
F9C4
F9C5
F9C6
F9C8
F9C9
F9CA
F9CC
F9CD
F9CE
F9D0
F9D1
F9D2
F9D4
F9D5
F9D6
F9D8
F9D9
F9D9
F9D9
F9D9
F9D9
F9D9
F9D9
F9D9
F9D9
F9D9
F9D9
F9DB
F9DD
F9DF
F9E0
F9E2
F9E4
F9E6
F9E8
F9E9
F9EB
04
42
05
04
43
04
04
44
04
04
45
05
04
47
03
04
4C
04
04
4D
04
04
4E
04
04
4F
05
04
50
04
04
52
02
04
53
04
04
54
04
04
56
04
04
57
04
FF
A6
34
C6
3D
8D
35
84
8B
19
89
19
4D
17
9D
9F
D2
DD
0D
FD
0A
AF
84
F2
D6
CF
68
80
06
10
04
06
0F
90
40
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
CMDTBL
EQU
FCB
FCC
FDB
FCB
FCC
FDB
FCB
FCC
FDB
FCB
FCC
FDB
FCB
FCC
FDB
FCB
FCC
FDB
FCB
FCC
FDB
FCB
FCC
FDB
FCB
FCC
FDB
FCB
FCC
FDB
FCB
FCC
FDB
FCB
FCC
FDB
FCB
FCC
FDB
FCB
FCC
FDB
FCB
FCC
FDB
FCB
*
4
/B/
CBKPT-*
4
/C/
CCALL-*
4
/D/
CDISP-*
4
/E/
CENCDE-*
4
/G/
CGO-*
4
/L/
CLOAD-*
4
/M/
CMEM-*
4
/N/
CNULLS-*
4
/O/
COFFS-*
4
/P/
CPUNCH-*
4
/R/
CREG-*
4
/S/
CSTLEV-*
4
/T/
CTRACE-*
4
/V/
CVER-*
4
/W/
CWINDO-*
-1
MONITOR COMMAND TABLE
'BREAKPOINT' COMMAND
'CALL' COMMAND
'DISPLAY' COMMAND
'ENCODE' COMMAND
'GO' COMMAND
'LOAD' COMMAND
'MEMORY' COMMAND
'NULLS' COMMAND
'OFFSET' COMMAND
'PUNCH' COMMAND
'REGISTERS' COMMAND
'STLEVEL' COMMAND
'TRACE' COMMAND
'VERIFY' COMMAND
'WINDOW' COMMAND
END, CONTINUE WITH THE SECOND
*************************************************
*
[SWI FUNCTIONS 4 AND 5]
*
4 - OUT2HS - DECODE BYTE TO HEX AND ADD SPACE
*
5 - OUT4HS - DECODE WORD TO HEX AND ADD SPACE
* INPUT: X->BYTE OR WORD TO DECODE
* OUTPUT: CHARACTERS SENT TO OUTPUT HANDLER
*
X->NEXT BYTE OR WORD
**************************************************
ZOUT2H
ZOUTHX
LDA
PSHS
LDB
MUL
BSR
PULS
ANDA
ADDA
DAA
ADCA
DAA
,X+
D
#16
ZOUTHX
D
#$0F
#$90
ADJUST
#$40
ADJUST
LOAD NEXT BYTE
SAVE - DO NOT REREAD
SHIFT BY 4 BITS
WITH MULTIPLY
SEND OUT AS HEX
RESTORE BYTES
ISOLATE RIGHT HEX
PREPARE A-F ADJUST
PREPARE CHARACTER BITSDUNFIELD 6809 ASSEMBLER: ASSIST09
F9EC
F9F0
F9F0
F9F2
F9F4
F9F6
F9F6
F9F6
F9F6
F9F6
F9F6
F9F6
F9F6
F9F6
F9F8
F9FA
F9FA
F9FA
F9FA
F9FA
F9FA
F9FA
F9FA
F9FA
F9FC
F9FE
FA00
FA03
FA05
FA07
FA09
FA0B
FA0D
FA0F
FA0F
FA0F
FA0F
FA0F
FA0F
FA0F
FA0F
FA0F
FA0F
FA0F
FA11
FA13
FA15
FA16
FA18
FA1A
FA1C
FA1E
FA20
FA22
FA24
FA26
FA28
FA2A
FA2C
FA2E
FA2E
FA2E
FA2E
FA2E
FA2E
FA2E
FA2E
FA2E
6E 9D E5 EE
8D E7
8D E5
AF 64
86 20
20 3D
A6
81
22
10
EE
EF
AF
27
AF
20
8D
8D
24
4D
27
81
27
A7
0D
26
81
26
86
8D
0D
26
61
34
39
9E C2
A6
64
7E
2E
A6
2A
5D
5F
FA
F9
7F
F5
61
8F
17
0D
04
0A
C2
F4
0B
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
SEND
ZOT4HS
ZOT2HS
JMP
[VECTAB+.CODTA,PCR]
BSR
ZOUT2H
BSR
ZOUT2H
STX
4,S
* FALL INTO SPACE ROUTINE
SEND TO OUT HANDLER
CONVERT FIRST BYTE
CONVERT BYTE TO HEX
UPDATE USERS X REGISTER
*************************************************
*
[SWI FUNCTION 7]
*
SPACE - SEND BLANK TO OUTPUT HANDLER
* INPUT: NONE
* OUTPUT: BLANK SEND TO CONSOLE HANDLER
*************************************************
ZSPACE LDA
#' '
LOAD BLANK
BRA
ZOTCH2
SEND AND RETURN
***********************************************
*
[SWI FUNCTION 9]
*
SWAP VECTOR TABLE ENTRY
* INPUT: A=VECTOR TABLE CODE (OFFSET)
*
X=0 OR REPLACEMENT VALUE
* OUTPUT: X=PREVIOUS VALUE
***********************************************
ZVSWTH LDA
1,S
LOAD REQUESTERS A
CMPA
#HIVTR
? SUB-CODE TOO HIGH
BHI
ZOTCH3
IGNORE CALL IF SO
LDY
VECTAB+.AVTBL
LOAD VECTOR TABLE ADDRESS
LDU
A,Y
U=OLD ENTRY
STU
4,S
RETURN OLD VALUE TO CALLERS X
STX
-2,S
? X=0
BEQ
ZOTCH3
YES, DO NOT CHANGE ENTRY
STX
A,Y
REPLACE ENTRY
BRA
ZOTCH3
RETURN FROM SWI
*D
************************************************
*
[SWI FUNCTION 0]
*
INCHNP - OBTAIN INPUT CHAR IN A (NO PARITY)
* NULLS AND RUBOUTS ARE IGNORED.
* AUTOMATIC LINE FEED IS SENT UPON RECIEVING A
*
CARRIAGE RETURN.
* UNLESS WE ARE LOADING FROM TAPE.
************************************************
ZINCHP BSR
XQPAUS
RELEASE PROCESSOR
ZINCH
BSR
XQCIDT
CALL INPUT DATA APPENDAGE
BCC
ZINCHP
LOOP IF NONE AVAILABLE
TSTA
?
TEST FOR NULL
BEQ
ZINCH
IGNORE NULL
CMPA
#$7F
? RUBOUT
BEQ
ZINCH
BRANCH YES TO IGNORE
STA
1,S
STORE INTO CALLERS A
TST
MISFLG
? LOAD IN PROGRESS
BNE
ZOTCH3
BRANCH IF SO TO NOT ECHO
CMPA
#CR
? CARRIAGE RETURN
BNE
ZIN2
NO, TEST ECHO BYTE
LDA
#LF
LOAD LINE FEED
BSR
SEND
ALWAYS ECHO LINE FEED
ZIN2
TST
VECTAB+.ECHO
? ECHO DESIRED
BNE
ZOTCH3
NO, RETURN
* FALL THROUGH TO OUTCH
************************************************
*
[SWI FUNCTION 1]
*
OUTCH - OUTPUT CHARACTER FROM A
* INPUT: NONE
* OUTPUT: IF LINEFEED IS THE OUTPUT CHARACTER THEN
*
C=0 NO CTL-X RECIEVED, C=1 CTL-X RECIEVED
************************************************DUNFIELD 6809 ASSEMBLER: ASSIST09
FA2E
FA30
FA33
FA35
FA37
FA39
FA3B
FA3C
FA3C
FA3C
FA3C
FA3C
FA3C
FA3C
FA3C
FA3C
FA3C
FA3D
FA3D
FA40
FA40
FA40
FA40
FA40
FA40
FA40
FA40
FA40
FA40
FA40
FA40
FA40
FA42
FA44
FA46
FA46
FA46
FA46
FA46
FA46
FA46
FA46
FA46
FA46
FA46
FA46
FA46
FA48
FA4A
FA4C
FA4E
FA4E
FA4E
FA4E
FA4E
FA4E
FA4E
FA4E
FA4E
FA4E
FA4E
FA4E
FA4E
FA4E
FA4E
FA50
FA52
FA54
A6
30
81
27
8D
0C
3B
61
8C 09
0A
0F
B3
90
04
30 8C FC
86 0D
8D A8
86 0A
8D
A6
81
26
8D
8D
1F
E7
A4
80
04
F8
1E
06
A9
E4
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700
ZOTCH1
ZOTCH2
ZOTCH3
LDA
LEAX
CMPA
BEQ
BSR
INC
RTI
1,S
<ZPCRLS,PCR
#LF
ZPDTLP
SEND
SWICNT
RETURN
LOAD CHARACTER TO SEND
DEFAULT FOR LINE FEED
? LINE FEED
BRANCH TO CHECK PAUSE IF SO
SEND TO OUTPUT ROUTINE
BUMP UP "SWI" TRACE NEST LEVEL
FROM "SWI" FUNCTION
**************************************************
*
[SWI FUNCTION 6]
*
PCRLF - SEND CR/LF TO CONSOLE HANDLER
* INPUT: NONE
* OUTPUT: CR AND LF SENT TO HANDLER
*
C=0 NO CTL-X, C=1 CTL-X RECIEVED
**************************************************
ZPCRLS
FCB
EOT
ZPCRLF LEAX
ZPCRLS,PCR
* FALL INTO CR/LF CODE
NULL STRING
READY CR,LF STRING
**************************************************
*
[SWI FUNCTION 3]
*
PDATA - OUTPUT CR/LF AND STRING
* INPUT: X->STRING
* OUTPUT: CR/LF AND STRING SENT TO OUTPUT CONSOLE
*
HANDLER.
*
C=0 NO CTL-X, C=1 CTL-X RECIEVED
* NOTE: LINE FEED MUST FOLLOW CARRIAGE RETURN FOR
*
PROPER PUNCH DATA.
**************************************************
ZPDATA LDA
#CR
LOAD CARRIAGE RETURN
BSR
SEND
SEND IT
LDA
#LF
LOAD LINE FEED
* FALL INTO PDATA1
*************************************************
*
[SWI FUNCTION 2]
*
PDATA1 - OUTPUT STRING TILL EOT ($04)
* THIS ROUTINE PAUSES IF AN INPUT BYTE BECOMES
* AVAILABLE DURING OUTPUT TRANSMISSION UNTIL A
* SECOND IS RECIEVED.
* INPUT: X->STRING
* OUTPUT: STRING SENT TO OUTPUT CONSOLE DRIVER
*
C=0 NO CTL-X, C=1 CTL-X RECIEVED
*************************************************
ZPDTLP BSR
SEND
SEND CHARACTER TO DRIVER
ZPDTA1 LDA
,X+
LOAD NEXT CHARACTER
CMPA
#EOT
? EOT
BNE
ZPDTLP
LOOP IF NOT
* FALL INTO PAUSE CHECK FUNCTION
********************************************
*
[SWI FUNCTION 12]
*
PAUSE - RETURN TO TASK DISPATCHING AND CHECK
*
FOR FREEZE CONDITION OR CTL-X BREAK
* THIS FUNCTION ENTERS THE TASK PAUSE HANDLER SO
* OPTIONALLY OTHER 6809 PROCESSES MAY GAIN CONTROL.
* UPON RETURN, CHECK FOR A 'FREEZE' CONDITION
* WITH A RESULTING WAIT LOOP, OR CONDITION CODE
* RETURN IF A CONTROL-X IS ENTERED FROM THE INPUT
* HANDLER.
* OUTPUT: C=1 IF CTL-X HAS ENTERED, C=0 OTHERWISE
******************************************
ZPAUSE BSR
XQPAUS
RELEASE CONTROL AT EVERY LINE
BSR
CHKABT
CHECK FOR FREEZE OR ABORT
TFR
CC,B
PREPARE TO REPLACE CC
STB
,S
OVERLAY OLD ONE ON STACKDUNFIELD 6809 ASSEMBLER: ASSIST09
FA56
FA58
FA58
FA58
FA58
FA58
FA5A
FA5C
FA5E
FA60
FA61
FA62
FA64
FA66
FA68
FA6A
FA6C
FA6D
FA6E
FA6E
FA6E
FA72
FA76
FA78
FA79
FA79
FA79
FA79
FA79
FA79
FA79
FA79
FA79
FA79
FA79
FA7D
FA7D
FA7F
FA81
FA83
FA85
FA87
FA89
FA8B
FA8D
FA90
FA91
FA92
FA94
FA98
FA99
FA9A
FA9C
FA9E
FAA0
FAA2
FAA4
FAA6
FAA8
FAAA
FAAC
FAAE
FAB0
FAB3
FAB3
FAB6
FAB7
FAB7
20 E1
8D
24
81
26
53
39
8D
8D
24
81
27
4F
39
18
05
18
02
0A
0C
FA
18
F4
6E 9D E5 78
AD 9D E5 62
84 7F
39
4F 50 2D 04
8D
0D
26
0D
2B
30
9C
25
30
3F
02
09
30
3F
05
8D
25
06
25
9E
27
30
9F
27
8D
25
16
42
8F
34
90
29
6C
F8
23
8C E9
8E
8D E5 01
17
37
8E
33
91
2F
1F
91
29
AA
25
03 F7
17 01 B9
39
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
BRA
ZOTCH3
RETURN FROM "SWI"
* CHKABT - SCAN FOR INPUT PAUSE/ABORT DURING OUTPUT
* OUTPUT: C=0 OK, C=1 ABORT (CTL-X ISSUED)
* VOLATILE: U,X,D
CHKABT BSR
XQCIDT
ATTEMPT INPUT
BCC
CHKRTN
BRANCH NO TO RETURN
CMPA
#CAN
? CTL-X FOR ABORT
BNE
CHKWT
BRANCH NO TO PAUSE
CHKSEC COMB
SET
CARRY
CHKRTN RTS
RETURN TO CALLER WITH CC SET
CHKWT
BSR
XQPAUS
PAUSE FOR A MOMENT
BSR
XQCIDT
? KEY FOR START
BCC
CHKWT
LOOP UNTIL RECIEVED
CMPA
#CAN
? ABORT SIGNALED FROM WAIT
BEQ
CHKSEC
BRANCH YES
CLRA
SET C=0 FOR NO ABORT
RTS
AND RETURN
* SAVE MEMORY WITH JUMPS
XQPAUS JMP
[VECTAB+.PAUSE,PCR]
TO PAUSE ROUTINE
XQCIDT JSR
[VECTAB+.CIDTA,PCR]
TO INPUT ROUTINE
ANDA
#$7F
STRIP PARITY
RTS
RETURN TO CALLER
********************************************
*
NMI DEFAULT INTERRUPT HANDLER
* THE NMI HANDLER IS USED FOR TRACING INSTRUCTIONS.
* TRACE PRINTOUTS OCCUR ONLY AS LONG AS THE STACK
* TRACE LEVEL IS NOT BREACHED BY FALLING BELOW IT.
* TRACING CONTINUES UNTIL THE COUNT TURNS ZERO OR
* A CTL-X IS ENTERED FROM THE INPUT CONSOLE DEVICE.
*********************************************
MSHOWP FCB 'O','P','-',EOT OPCODE PREP
NMIR BSR
TST
BNE
TST
BMI
LEAX
CMPX
BLO
LEAX
SWI
FCB
ROL
LEAX
SWI
FCB
BSR
BCS
ROR
BCS
LDX
BEQ
LEAX
STX
BEQ
BSR
BCS
LBRA LDDP
MISFLG
NMICON
SWICNT
NMITRC
12,S
SLEVEL
NMITRC
MSHOWP,PCR
LBSR
RTS REGPRT
NMITRC
REGPRS
PDATA1
DELIM
LASTOP,PCR
OUT4HS
REGPRS
ZBKCMD
DELIM
ZBKCMD
TRACEC
ZBKCMD
-1,X
TRACEC
ZBKCMD
CHKABT
ZBKCMD
CTRCE3
* JUST EXECUTED THRU A BRKPNT.
LOAD PAGE AND VERIFY STACK
? THRU A BREAKPOINT
BRANCH IF SO TO CONTINUE
? INHIBIT "SWI" DURING TRACE
BRANCH YES
OBTAIN USERS STACK POINTER
? TO TRACE HERE
BRANCH IF TOO LOW TO DISPLAY
LOAD OP PREP
SEND TO CONSOLE
FUNCTION
SAVE CARRY BIT
POINT TO LAST OP
SEND OUT AS HEX
FUNCTION
FOLLOW MEMORY WITH REGISTERS
BRANCH IF "CANCEL"
RESTORE CARRY BIT
BRANCH IF "CANCEL"
LOAD TRACE COUNT
IF ZERO TO COMMAND HANDLER
MINUS ONE
REFRESH
STOP TRACE WHEN ZERO
? ABORT THE TRACE
BRANCH YES TO COMMAND HANDLER
NO, TRACE ANOTHER INSTRUCTION
PRINT REGISTERS AS FROM COMMAND
RETURN TO CALLER
NOW CONTINUE NORMALLYDUNFIELD 6809 ASSEMBLER: ASSIST09
FAB7
FAB9
FABC
FABD
FABD
FABD
FABD
FABD
FABD
FABD
FABD
FAC1
FAC1
FAC5
FAC7
FAC9
FACB
FACE
FAD1
FAD2
FAD3
FAD3
FAD3
FAD3
FAD3
FAD3
FAD3
FAD3
FAD5
FAD8
FAD8
FAD8
FAD8
FAD8
FAD8
FAD8
FAD8
FAD8
FADA
FADC
FADC
FADC
FADC
FADC
FABC
FADC
FADC
FADC
FADC
FADC
FADC
FADC
FADC
FADC
FADE
FAE0
FAE1
FAE3
FAE5
FAE6
FAE6
FAE6
FAE6
FAE6
FAE6
FAE8
FAEA
FAEC
0F 8F
17 02 EB
3B
3F 07 20 04
E6
1F
A1
27
10
30
3F
03
8D E4 D8
9B
63
25
DE 97
8C EC
8D DE
16 FE 21
8D E7
20 F7
DE
A6
44
24
A6
39
86
9E
A7
86
F0
C4
02
41
03
F0
84
51
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804
805
806
807
808
809
810
811
812
813
814
815
816
817
818
819
820
821
822
823
824
825
826
827
828
829
830
831
832
833
834
835
836
NMICON
RTI
*
*
*
*
*
CLR
LBSR
RTI
MISFLG
ARMBK2
AND
CLEAR THRU FLAG
ARM BREAKPOINTS
CONTINUE USERS PROGRAM
LDDP - SETUP DIRECT PAGE REGISTER, VERIFY STACK.
AN INVALID STACK CAUSES A RETURN TO THE COMMAND
HANDLER.
INPUT: FULLY STACKED REGISTERS FROM AN INTERRUPT
OUTPUT: DPR LOADED TO WORK PAGE
ERRMSG
LDDP
FCB
'?',BELL,$20,EOT ERROR RESPONSE
LDB
BASEPG,PCR
TFR
B,DP
CMPA
3,S
BEQ
RTS
LDS
RSTACK
ERROR
LEAX
ERRMSG,PCR
SWI
FCB
PDATA
* FALL INTO BREAKPOINT HANDLER
LOAD DIRECT PAGE HIGH BYTE
SETUP DIRECT PAGE REGISTER
? IS STACK VALID
YES, RETURN
RESET TO INITIAL STACK POINTER
LOAD ERROR REPORT
SEND OUT BEFORE REGISTERS
ON NEXT LINE
**********************************************
*
[SWI FUNCTION 10]
*
BREAKPOINT PROGRAM FUNCTION
* PRINT REGISTERS AND GO TO COMMAND HANLER
***********************************************
ZBKPNT BSR
REGPRS
PRINT OUT REGISTERS
ZBKCMD LBRA
CMDNEP
NOW ENTER COMMAND HANDLER
********************************************
*
IRQ, RESERVED, SWI2 AND SWI3 INTERRUPT HANDLERS
* THE DEFAULT HANDLING IS TO CAUSE A BREAKPOINT.
********************************************
SWI2R
EQU
*
SWI2 ENTRY
SWI3R
EQU
*
SWI3 ENTRY
IRQR
EQU
*
IRQ ENTRY
RSRVDR BSR
LDDP
SET BASE PAGE, VALIDATE STACK
BRA
ZBKPNT
FORCE A BREAKPOINT
******************************************
*
FIRQ HANDLER
* JUST RETURN FOR THE FIRQ INTERRUPT
******************************************
FIRQR
EQU
RTI
IMMEDIATE RETURN
**************************************************
*
DEFAULT I/O DRIVERS
**************************************************
* CIDTA - RETURN CONSOLE INPUT CHARACTER
* OUTPUT: C=0 IF NO DATA READY, C=1 A=CHARACTER
* U VOLATILE
CIDTA
LDU
VECTAB+.ACIA
LOAD ACIA ADDRESS
LDA
,U
LOAD STATUS REGISTER
LSRA
TEST RECEIVER REGISTER FLAG
BCC
CIRTN
RETURN IF NOTHING
LDA
1,U
LOAD DATA BYTE
CIRTN
RTS
RETURN TO CALLER
* CION - INPUT CONSOLE INITIALIZATION
* COON - OUTPUT CONSOLE INITIALIZATION
* A,X VOLATILE
CION
EQU
*
COON
LDA
#3
RESET ACIA CODE
LDX
VECTAB+.ACIA
LOAD ACIA ADDRESS
STA
,X
STORE INTO STATUS REGISTER
LDA
#$51
SET CONTROLDUNFIELD 6809 ASSEMBLER: ASSIST09
FAEE
FAF0
FAF1
FAF1
FAF0
FAF0
FAF1
FAF1
FAF1
FAF1
FAF1
FAF1
FAF1
FAF3
FAF5
FAF7
FAF9
FAFB
FAFD
FAFF
FB01
FB03
FB04
FB06
FB07
FB09
FB0B
FB0D
FB0F
FB0F
FB12
FB14
FB16
FB18
FB1A
FB1B
FB1B
FB1B
FB1B
FB1B
FB1B
FB1D
FB1F
FB21
FB22
FB23
FB24
FB26
FB27
FB27
FB27
FB27
FB29
FB2A
FB2B
FB2C
FB2D
FB2E
FB30
FB33
FB35
FB37
FB38
FB38
FB38
FB38
FB38
FB38
A7 84
39
34
DE
8D
81
27
D6
81
26
D6
4F
E7
8C
8D
6A
2A
35 47
F0
1B
10
12
F2
0D
02
F3
17
E6
C5
26
A7
39 FF 5C
C4
02
F7
41
86
6D
26
4C
3F
01
0C
39
86
3F
01
4A
3F
01
0A
8E
30
26
39
E4
09
E4
FA
C7
11
66
01
8F
14
8F
61 A8
1F
FC
837
838
839
840
841
842
843
844
845
846
847
848
849
850
851
852
853
854
855
856
857
858
859
860
861
862
863
864
865
866
867
868
869
870
871
872
873
874
875
876
877
878
879
880
881
882
883
884
885
886
887
888
889
890
891
892
893
894
895
896
897
898
899
900
901
902
903
904
RTS
STA
RTS
,X
REGISTER UP
RETURN TO CALLER
* THE FOLLOWING HAVE NO DUTIES TO PERFORM
CIOFF
EQU
RTS
CONSOLE INPUT OFF
COOFF
EQU
RTS
CONSOLE OUTPUT OFF
*
*
*
*
CODTA - OUTPUT CHARACTER TO CONSOLE DEVICE
INPUT: A=CHARACTER TO SEND
OUTPUT: CHAR SENT TO TERMINAL WITH PROPER PADDING
ALL REGISTERS TRANSPARENT
CODTA
CODTPD
CODTLP
CODTRT
CODTAD
CODTAO
PSHS
LDU
BSR
CMPA
BEQ
LDB
CMPA
BNE
LDB
CLRA
STB
FCB
BSR
DEC
BPL
PULS U,D,CC
VECTAB+.ACIA
CODTAO
#DLE
CODTRT
VECTAB+.PAD
#CR
CODTPD
VECTAB+.PAD+1
LBSR
LDB
BITB
BNE
STA
RTS XQPAUS
,U
#$02
CODTAD
1,U
,S
SKIP2
CODTAO
,S
CODTLP
PC,U,D,CC
SAVE REGISTERS,WORK BYTE
ADDRESS ACIA
CALL OUTPUT CHAR SUBROTINE
? DATA LINE ESCAPE
YES, RETURN
DEFAULT TO CHAR PAD COUNT
? CR
BRANCH NO
LOAD NEW LINE PAD COUNT
CREATE NULL
SAVE COUNT
ENTER LOOP
SEND NULL
? FINISHED
NO, CONTINUE WITH MORE
RESTORE REGISTERS AND RETURN
TEMPORARY GIVE UP CONTROL
LOAD ACIA CONTROL REGISTER
? TX REGISTER CLEAR >LSAB FIXME
RELEASE CONTROL IF NOT
STORE INTO DATA REGISTER
RETURN TO CALLER
*E
* BSON - TURN ON READ/VERIFY/PUNCH MECHANISM
* A IS VOLATILE
BSON
BSON2
LDA
TST
BNE
INCA
SWI
FCB
INC
RTS
#$11
6,S
BSON2
OUTCH
MISFLG
SET READ CODE
? READ OR VERIFY
BRANCH YES
SET TO WRITE
PERFORM OUTPUT
FUNCTION
SET LOAD IN PROGRESS FLAG
RETURN TO CALLER
* BSOFF - TURN OFF READ/VERIFY/PUNCH MECHANISM
* A,X VOLATILE
BSOFF
LDA
#$14
TO DC4 - STOP
SWI
SEND OUT
FCB
OUTCH
FUNCTION
DECA
CHANGE TO DC3 (X-OFF)
SWI
SEND OUT
FCB
OUTCH
FUNCTION
DEC
MISFLG
CLEAR LOAD IN PROGRESS FLAG
LDX
#25000
DELAY 1 SECOND (2MHZ CLOCK)
BSOFLP LEAX
-1,X
COUNT DOWN
BNE
BSOFLP
LOOP TILL DONE
RTS
RETURN TO CALLER
* BSDTA - READ/VERIFY/PUNCH HANDLER
* INPUT: S+6=CODE BYTE, VERIFY(-1),PUNCH(0),LOAD(1)
*
S+4=START ADDRESS
*
S+2=STOP ADDRESS
*
S+0=RETURN ADDRESSDUNFIELD 6809 ASSEMBLER: ASSIST09
FB38
FB38
FB38
FB38
FB3A
FB3C
FB3E
FB3E
FB3E
FB3E
FB3E
FB40
FB41
FB42
FB44
FB46
FB47
FB48
FB4A
FB4C
FB4E
FB50
FB52
FB54
FB56
FB56
FB58
FB5A
FB5C
FB5E
FB60
FB60
FB62
FB64
FB66
FB68
FB6A
FB6C
FB6E
FB70
FB70
FB71
FB73
FB75
FB75
FB75
FB77
FB79
FB7A
FB7C
FB7E
FB80
FB82
FB84
FB86
FB88
FB89
FB89
FB8A
FB8B
FB8E
FB90
FB92
FB92
FB92
FB92
FB92
FB92
EE 62
6D 66
27 54
32
3F
00
81
26
3F
00
81
27
81
26
6F
8D
E7 7D
8D
E7
8D
A6
31 1D
62
19
62
CB
8D
27
6D
2B
E7
E1
27
35 13
0C
69
02
A4
A0
F2
92
53
FA
39
22
31
F2
E4
21
61
4C
27 CD
20 F9
8D
C6
3D
8D
34
AB
1F
AB
A7
6A
39
12
10
0D
04
E0
89
62
62
63
3F
00
17 01 D4
27 F8
35 F2
905
906
907
908
909
910
911
912
913
914
915
916
917
918
919
920
921
922
923
924
925
926
927
928
929
930
931
932
933
934
935
936
937
938
939
940
941
942
943
944
945
946
947
948
949
950
951
952
953
954
955
956
957
958
959
960
961
962
963
964
965
966
967
968
969
970
971
972
* OUTPUT: Z=1 NORMAL COMPLETION, Z=0 INVALID LOAD/VER
* REGISTERS ARE VOLATILE
BSDTA
LDU
2,S
U=TO ADDRESS OR OFFSET
TST
6,S
? PUNCH
BEQ
BSDPUN
BRANCH YES
* DURING READ/VERIFY: S+2=MSB ADDRESS SAVE BYTE
*
S+1=BYTE COUNTER
*
S+0=CHECKSUM
*
U HOLDS OFFSET
LEAS
-3,S
ROOM FOR WORK/COUNTER/CHECKSUM
BSDLD1 SWI
GET NEXT CHARACTER
FCB
INCHNP
FUNCTION
BSDLD2 CMPA
#'S'
? START OF S1/S9
BNE
BSDLD1
BRANCH NOT
SWI
GET NEXT CHARACTER
FCB
INCHNP
FUNCTION
CMPA
#'9'
? HAVE S9
BEQ
BSDSRT
YES, RETURN GOOD CODE
CMPA
#'1'
? HAVE NEW RECORD
BNE
BSDLD2
BRANCH IF NOT
CLR
,S
CLEAR CHECKSUM
BSR
BYTE
OBTAIN BYTE COUNT
STB
1,S
SAVE FOR DECREMENT
* READ ADDRESS
BSR
BYTE
OBTAIN HIGH VALUE
STB
2,S
SAVE IT
BSR
BYTE
OBTAIN LOW VALUE
LDA
2,S
MAKE D=VALUE
LEAY
D,U
Y=ADDRESS+OFFSET
* STORE TEXT
BSDNXT BSR
BYTE
NEXT BYTE
BEQ
BSDEOL
BRANCH IF CHECKSUM
TST
9,S
? VERIFY ONLY
BMI
BSDCMP
YES, ONLY COMPARE
STB
,Y
STORE INTO MEMORY
BSDCMP CMPB
,Y+
? VALID RAM
BEQ
BSDNXT
YES, CONTINUE READING
BSDSRT PULS
PC,X,A
RETURN WITH Z SET PROPER
BSDEOL
INCA
BEQ
BRA
BSDLD1
BSDSRT
? VALID CHECKSUM
BRANCH YES
RETURN Z=0 INVALID
* BYTE BUILDS 8 BIT VALUE FROM TWO HEX DIGITS IN
BYTE
BSR
BYTHEX
OBTAIN FIRST HEX
LDB
#16
PREPARE SHIFT
MUL
OVER TO A
BSR
BYTHEX
OBTAIN SECOND HEX
PSHS
B
SAVE HIGH HEX
ADDA
,S+
COMBINE BOTH SIDES
TFR
A,B
SEND BACK IN B
ADDA
2,S
COMPUTE NEW CHECKSUM
STA
2,S
STORE BACK
DEC
3,S
DECREMENT BYTE COUNT
BYTRTS RTS
RETURN TO CALLER
BYTHEX
SWI
FCB
LBSR
BEQ
PULS
INCHNP
CNVHEX
BYTRTS
PC,U,Y,X,A
GET NEXT HEX
CHARACTER
CONVERT TO HEX
RETURN IF VALID HEX
RETURN TO CALLER WITH Z=0
* PUNCH STACK USE: S+8=TO ADDRESS
*
S+6=RETURN ADDRESS
*
S+4=SAVED PADDING VALUES
*
S+2 FROM ADDRESS
*
S+1=FRAME COUNT/CHECKSUMDUNFIELD 6809 ASSEMBLER: ASSIST09
FB92
FB92
FB94
FB96
FB98
FB9B
FB9D
FB9E
FB9F
FBA1
FBA3
FBA3
FBA5
FBA7
FBAB
FBAD
FBAF
FBB0
FBB2
FBB4
FBB6
FBB6
FBB9
FBBA
FBBB
FBBB
FBBC
FBBE
FBC0
FBC0
FBC2
FBC4
FBC4
FBC6
FBC8
FBCA
FBCC
FBCE
FBCE
FBCF
FBD1
FBD3
FBD5
FBD7
FBD9
FBDB
FBDE
FBDF
FBE0
FBE2
FBE4
FBE5
FBE7
FBE7
FBE9
FBEC
FBEC
FBEF
FBF9
FBFC
FBFC
FBFC
FBFC
FBFC
FBFC
FBFC
FBFC
FBFC
973
974
975
976
977
978
979
980
04
981
F2
982
983
EC 68
984
A3 62
985
10 83 00 18
986
25 02
987
C6 17
988
5C
989
E7 E4
990
CB 03
991
E7 61
992
993
30 8C 33
994
3F
995
03
996
997
5F
998
30 61
999
8D 27
1000
1001
8D 25
1002
8D 23
1003
1004
AE 62
1005
8D 1F
1006
6A E4
1007
26 FA
1008
AF 62
1009
1010
53
1011
E7 61
1012
30 61
1013
8D 14
1014
AE 68
1015
AC 62
1016
24 C8
1017
30 8C 11
1018
3F
1019
03
1020
EC 64
1021
DD F2
1022
4F
1023
35 D6
1024
1025
EB 84
1026
16 FD ED
1027
1028
53 31 04
1029
53 39 30 33 30 30 + 1030
0D 0A 04
1031
1032
1033
1034
1035
1036
1037
1038
1039
3F
1040
DE
AE
34
CC
D7
3F
01
C6
DD
F2
64
56
00 18
F2
*
BSDPUN
S+0=BYTE COUNT
LDU
VECTAB+.PAD
LOAD PADDING VALUES
LDX
4,S
X=FROM ADDRESS
PSHS
U,X,D
CREATE STACK WORK AREA
LDD
#24
SET A=0, B=24
STB
VECTAB+.PAD
SETUP 24 CHARACTER PADS
SWI
SEND NULLS OUT
FCB
OUTCH
FUNCTION
LDB
#4
SETUP NEW LINE PAD TO 4
STD
VECTAB+.PAD
SETUP PUNCH PADDING
* CALCULATE SIZE
BSPGO
LDD
8,S
LOAD TO
SUBD
2,S
MINUS FROM=LENGTH
CMPD
#24
? MORE THAN 23
BLO
BSPOK
NO, OK
LDB
#23
FORCE TO 23 MAX
BSPOK
INCB
PREPARE COUNTER
STB
,S
STORE BYTE COUNT
ADDB
#3
ADJUST TO FRAME COUNT
STB
1,S
SAVE
*PUNCH CR,LF,NULS,S,1
LEAX
<BSPSTR,PCR
LOAD START RECORD HEADER
SWI
SEND OUT
FCB
PDATA
FUNCTION
* SEND FRAME COUNT
CLRB
INITIALIZE CHECKSUM
LEAX
1,S
POINT TO FRAME COUNT AND ADDR
BSR
BSPUN2
SEND FRAME COUNT
*DATA ADDRESS
BSR
BSPUN2
SEND ADDRESS HI
BSR
BSPUN2
SEND ADDRESS LOW
*PUNCH DATA
LDX
2,S
LOAD START DATA ADDRESS
BSPMRE BSR
BSPUN2
SEND OUT NEXT BYTE
DEC
,S
? FINAL BYTE
BNE
BSPMRE
LOOP IF NOT DONE
STX
2,S
UPDATE FROM ADDRESS VALUE
*PUNCH CHECKSUM
COMB
COMPLEMENT
STB
1,S
STORE FOR SENDOUT
LEAX
1,S
POINT TO IT
BSR
BSPUNC
SEND OUT AS HEX
LDX
8,S
LOAD TOP ADDRESS
CMPX
2,S
? DONE
BHS
BSPGO
BRANCH NOT
LEAX
<BSPEOF,PCR
PREPARE END OF FILE
SWI
SEND OUT STRING
FCB
PDATA
FUNCTION
LDD
4,S
RECOVER PAD COUNTS
STD
VECTAB+.PAD
RESTORE
CLRA
SET Z=1 FOR OK RETURN
PULS
PC,U,X,D
RETURN WITH OK CODE
BSPUN2
BSPUNC ADDB
LBRA ,X
ZOUT2H ADD TO CHECKSUM
SEND OUT AS HEX AND RETURN
BSPSTR
BSPEOF FCB
FCC
FCB 'S','1',EOT
/S9030000FC/
CR,LF,EOT CR,LF,NULLS,S,1
EOF STRING
* HSDTA - HIGH SPEED PRINT MEMORY
* INPUT: S+4=START ADDRESS
*
S+2=STOP ADDRESS
*
S+0=RETURN ADDRESS
* X,D VOLATILE
* SEND TITLE
HSDTA
SWI
SEND NEW LINEDUNFIELD 6809 ASSEMBLER: ASSIST09
FBFD
FBFE
FC00
FC01
FC02
FC03
FC05
FC06
FC08
FC0B
FC0C
FC0D
FC0E
FC0F
FC10
FC12
FC14
FC15
FC16
FC18
FC1A
FC1B
FC1C
FC1E
FC20
FC21
FC22
FC23
FC25
FC26
FC27
FC29
FC2B
FC2D
FC2F
FC31
FC33
FC35
FC36
FC37
FC38
FC3A
FC3C
FC3E
FC40
FC42
FC43
FC45
FC47
FC48
FC49
FC4A
FC4A
FC4A
FC4A
FC4A
FC4A
FC4A
FC4A
FC4C
FC4D
FC4F
FC50
FC50
FC50
FC50
FC50
FC50
06
C6
3F
07
5A
26
5F
1F
17
3F
07
3F
07
5C
C1
25
3F
06
25
30
3F
05
AE
C6
3F
04
5A
26
3F
07
AE
C6
A6
2B
81
24
86
3F
01
5A
26
AC
24
AF
A6
48
26
20
3F
06
39
06
FB
98
FD DB
10
F2
2F
64
64
10
FB
64
10
80
04
20
02
2E
F1
62
09
64
65
CF
B5
8D 23
4C
8D 21
39
1041
1042
1043
1044
1045
1046
1047
1048
1049
1050
1051
1052
1053
1054
1055
1056
1057
1058
1059
1060
1061
1062
1063
1064
1065
1066
1067
1068
1069
1070
1071
1072
1073
1074
1075
1076
1077
1078
1079
1080
1081
1082
1083
1084
1085
1086
1087
1088
1089
1090
1091
1092
1093
1094
1095
1096
1097
1098
1099
1100
1101
1102
1103
1104
1105
1106
1107
1108
HSBLNK
HSHTTL
HSHLNE
HSHNXT
HSHCHR
HSHDOT
HSHCOK
HSDRTN
FCB
LDB
SWI
FCB
DECB
BNE
CLRB
TFR
LBSR
SWI
FCB
SWI
FCB
INCB
CMPB
BLO
SWI
FCB
BCS
LEAX
SWI
FCB
LDX
LDB
SWI
FCB
DECB
BNE
SWI
FCB
LDX
LDB
LDA
BMI
CMPA
BHS
LDA
SWI
FCB
DECB
BNE
CMPX
BHS
STX
LDA
ASLA
BNE
BRA
SWI
FCB
RTS
PCRLF
#6
SPACE
HSBLNK
B,A
ZOUTHX
SPACE
SPACE
#$10
HSHTTL
PCRLF
HSDRTN
4,S
OUT4HS
4,S
#16
OUT2HS
HSHNXT
SPACE
4,S
#16
,X+
HSHDOT
#' '
HSHCOK
#'.'
OUTCH
HSHCHR
2,S
HSDRTN
4,S
5,S
?
HSHLNE
HSDTA
PCRLF
FUNCTION
PREPARE 6 SPACES
SEND BLANK
FUNCTION
COUNT DOWN
LOOP IF MORE
SETUP BYTE COUNT
PREPARE FOR CONVERT
CONVERT TO A HEX DIGIT
SEND BLANK
FUNCTION
SEND ANOTHER
BLANK
UP ANOTHER
? PAST 'F'
LOOP UNTIL SO
TO NEXT LINE
FUNCTION
RETURN IF USER ENTERED CTL-X
POINT AT ADDRESS TO CONVERT
PRINT OUT ADDRESS
FUNCTION
LOAD ADDRESS PROPER
NEXT SIXTEEN
CONVERT BYTE TO HEX AND SEND
FUNCTION
COUNT DOWN
LOOP IF NOT SIXTEENTH
SEND BLANK
FUNCTION
RELOAD FROM ADDRESS
COUNT
NEXT BYTE
TOO LARGE, TO A DOT
? LOWER THAN A BLANK
NO, BRANCH OK
CONVERT INVALID TO A BLANK
SEND CHARACTER
FUNCTION
? DONE
BRANCH NO
? PAST LAST ADDRESS
QUIT IF SO
UPDATE FROM ADDRESS
LOAD LOW BYTE ADDRESS
TO SECTION BOUNDRY
BRANCH IF NOT
BRANCH IF SO
SEND NEW LINE
FUNCTION
RETURN TO CALLER
*F
***********************************************
*
A S S I S T 0 9
C O M M A N D S
***********************************************
*************REGISTERS - DISPLAY AND CHANGE REGISTERS
CREG
BSR
REGPRT
PRINT REGISTERS
INCA
SET FOR CHANGE FUNCTION
BSR
REGCHG
GO CHANGE, DISPLAY REGISTERS
RTS
RETURN TO COMMAND PROCESSOR
********************************************
*
REGPRT - PRINT/CHANGE REGISTERS SUBROUTINE
* WILL ABORT TO 'CMDBAD' IF OVERFLOW DETECTED DURING
* A CHANGE OPERATION. CHANGE DISPLAYS REGISTERS WHEN
* DONE.DUNFIELD 6809 ASSEMBLER: ASSIST09
FC50
FC50
FC50
FC50
FC50
FC50
FC50
FC50
FC50
FC50
FC50
FC50
FC54
FC57
FC5A
FC5D
FC60
FC63
FC66
FC6A
FC6E
FC6F
FC6F
FC70
FC73
FC75
FC78
FC7A
FC7B
FC7D
FC7E
FC7F
FC81
FC83
FC84
FC85
FC87
FC89
FC8B
FC8D
FC8F
FC90
FC91
FC92
FC93
FC94
FC96
FC97
FC99
FC9A
FC9B
FC9D
FC9D
FC9F
FCA1
FCA3
FCA5
FCA7
FCA8
FCA9
FCAA
FCAB
FCAC
FCAD
FCAF
FCB1
FCB3
FCB3
50
41
42
58
59
55
53
43
44
00
4F
30
34
31
EC
4D
2F
3F
01
20
86
3F
01
30
6D
26
6D
27
3F
05
8C
3F
04
EC
5D
26
3F
06
35
8D
27
81
27
E6
5A
50
58
3F
07
5A
26
20
A7
43
00
00
FF
FF
FF
FF
43
50
FF 13
0A
0B
0D
0F
11
01
00 09
00 0C
E8 10
32
8C D8
A0
04
F7
2D
E5
E4
12
3F
03
A0
DF
B2
40
10
0D
1E
3F
FB
E3
E4
DC 9B
1109
1110
1111
1112
1113
1114
1115
1116
1117
1118
1119
1120
1121
1122
1123
1124
1125
1126
1127
1128
1129
1130
1131
1132
1133
1134
1135
1136
1137
1138
1139
1140
1141
1142
1143
1144
1145
1146
1147
1148
1149
1150
1151
1152
1153
1154
1155
1156
1157
1158
1159
1160
1161
1162
1163
1164
1165
1166
1167
1168
1169
1170
1171
1172
1173
1174
1175
1176
* REGISTER MASK LIST CONSISTS OF:
* A) CHARACTERS DENOTING REGISTER
* B) ZERO FOR ONE BYTE, -1 FOR TWO
* C) OFFSET ON STACK TO REGISTER POSITION
* INPUT: SP+4=STACKED REGISTERS
*
A=0 PRINT, A#0 PRINT AND CHANGE
* OUTPUT: (ONLY FOR REGISTER DISPLAY)
*
C=1 CONTROL-X ENTERED, C=0 OTHERWISE
* VOLATILE: D,X (CHANGE)
*
B,X (DISPLAY)
*******************************************
REGMSK FCB
'P','C',-1,19
PC REG
FCB
'A',0,10 A REG
FCB
'B',0,11 B REG
FCB
'X',-1,13 X REG
FCB
'Y',-1,15 Y REG
FCB
'U',-1,17 U REG
FCB
'S',-1,1 S REG
FCB
'C','C',0,9
CC REG
FCB
'D','P',0,12
DP REG
FCB
0
END OF LIST
REGPRT
REGCHG
REGP1
REGP2
REGP3
REG4
REGRTN
REGCNG
REGSKP
REGNXC
*
CLRA
LEAX
PSHS
LEAY
LDD
TSTA
BLE
SWI
FCB
BRA
LDA
SWI
FCB
LEAX
TST
BNE
TST
BEQ
SWI
FCB
FCB
SWI
FCB
LDD
TSTB
BNE
SWI
FCB
PULS
BSR
BEQ
CMPA
BEQ
LDB
DECB
NEGB
ASLB
SWI
FCB
DECB
BNE
BRA
STA
LDD
4+12,S
Y,X,A
REGMSK,PCR
,Y+
?
REGP2
OUTCH
REGP1
#'-'
OUTCH
B,S
,S
REGCNG
-1,Y
REGP3
OUT4HS
SKIP2
OUT2HS
,Y+
?
REGP1
PCRLF
PC,Y,X,A
BLDNNB
REGNXC
#CR
REGAGN
-1,Y
TIMES
SPACE
SETUP PRINT ONLY FLAG
READY STACK VALUE
SAVE ON STACK WITH OPTION
LOAD REGISTER MASK
LOAD NEXT CHAR OR <=0
END OF CHARACTERS
BRANCH NOT CHARACTER
SEND TO CONSOLE
FUNCTION BYTE
CHECK NEXT
READY '-'
SEND OUT
WITH OUTCH
X->REGISTER TO PRINT
? CHANGE OPTION
BRANCH YES
? ONE OR TWO BYTES
BRANCH ZERO MEANS ONE
PERFORM WORD HEX
FUNCTION
SKIP BYTE PRINT
PERFORM BYTE HEX
FUNCTION
TO FRONT OF NEXT ENTRY
END OF ENTRIES
LOOP IF MORE
FORCE NEW LINE
FUNCTION
RESTORE STACK AND RETURN
INPUT BINARY NUMBER
IF CHANGE THEN JUMP
? NO MORE DESIRED
BRANCH NOPE
LOAD SIZE FLAG
MINUS ONE
MAKE POSITIVE
TWO (=2 OR =4)
PERFORM SPACES
FUNCTION
REGSKP
LOOP IF MORE
REG4
CONTINUE WITH NEXT REGISTER
,S
SAVE DELIMITER IN OPTION
(ALWAYS > 0)
NUMBER
OBTAIN BINARY RESULTDUNFIELD 6809 ASSEMBLER: ASSIST09
FCB5
FCB7
FCB9
FCBB
FCBD
FCBF
FCC1
FCC3
FCC3
FCC3
FCC7
FCC9
FCCB
FCCD
FCCE
FCD0
FCD4
FCD6
FCD8
FCDA
FCDB
FCDD
FCDF
FCDF
FCDF
FCDF
FCDF
FCDF
FCDF
FCDF
FCDF
FCDF
FCDF
FCDF
FCDF
FCDF
FCDF
FCDF
FCDF
FCDF
FCE0
FCE1
FCE1
FCE3
FCE5
FCE9
FCE9
FCE9
FCE9
FCE9
FCE9
FCE9
FCE9
FCEB
FCED
FCEF
FCEF
FCF1
FCF3
FCF3
FCF5
FCF7
FCF9
FCFB
FCFD
FCFF
FD01
FD03
6D
26
A6
ED
A6
81
26 3F
02
82
84
E4
0D
D1
30
C6
35
A7
5A
26
10
C6
A6
34
5A
26
20 8D E2 8A
15
02
80
F9
EE 88 EC
15
82
02
F9
BC
4F
8C
86 20
97 8E
6E 9D E3 03
34 14
8D 5C
27 18
91 8E
27 F8
9E
81
27
9E
81
27
9E
81
27
9E
4D
16
93
50
10
A0
57
0A
1177
1178
1179
1180
1181
1182
1183
1184
1185
1186
1187
1188
1189
1190
1191
1192
1193
1194
1195
1196
1197
1198
1199
1200
1201
1202
1203
1204
1205
1206
1207
1208
1209
1210
1211
1212
1213
1214
1215
1216
1217
1218
1219
1220
1221
1222
1223
1224
1225
1226
1227
1228
1229
1230
1231
1232
1233
1234
1235
1236
1237
1238
1239
1240
1241
1242
1243
1244
TST
-1,Y
? TWO BYTES WORTH
BNE
REGTWO
BRANCH YES
LDA
,-X
SETUP FOR TWO
REGTWO STD
,X
STORE IN NEW VALUE
LDA
,S
RECOVER DELIMITER
CMPA
#CR
? END OF CHANGES
BNE
REG4
NO, KEEP ON TRUCK'N
* MOVE STACKED DATA TO NEW STACK IN CASE STACK
* POINTER HAS CHANGED
REGAGN LEAX
TSTACK,PCR
LOAD TEMP AREA
LDB
#21
LOAD COUNT
REGTF1 PULS
A
NEXT BYTE
STA
,X+
STORE INTO TEMP
DECB
COUNT DOWN
BNE
REGTF1
LOOP IF MORE
LDS
-20,X
LOAD NEW STACK POINTER
LDB
#21
LOAD COUNT AGAIN
REGTF2 LDA
,-X
NEXT TO STORE
PSHS
A
BACK ONTO NEW STACK
DECB
COUNT DOWN
BNE
REGTF2
LOOP IF MORE
BRA
REGRTN
GO RESTART COMMAND
*********************************************
* BLDNUM - BUILDS BINARY VALUE FROM INPUT HEX
* THE ACTIVE EXPRESSION HANDLER IS USED.
* INPUT: S=RETURN ADDRESS
* OUTPUT: A=DELIMITER WHICH TERMINATED VALUE
*
(IF DELM NOT ZERO)
*
"NUMBER"=WORD BINARY RESULT
*
Z=1 IF INPUT RECIEVED, Z=0 IF NO HEX RECIEVED
* REGISTERS ARE TRANSPARENT
**********************************************
* EXECUTE SINGLE OR EXTENDED ROM EXPRESSION HANDLER
*
* THE FLAG "DELIM" IS USED AS FOLLOWS:
*
DELIM=0 NO LEADING BLANKS, NO FORCED TERMINATOR
*
DELIM=CHR ACCEPT LEADING 'CHR'S, FORCED TERMINATOR
BLDNNB CLRA
NO DYNAMIC DELIMITER
FCB
SKIP2
SKIP NEXT INSTRUCTION
* BUILD WITH LEADING BLANKS
BLDNUM LDA
#' '
ALLOW LEADING BLANKS
STA
DELIM
STORE AS DELIMITER
JMP
[VECTAB+.EXPAN,PCR]
TO EXP ANALYZER
* THIS IS THE DEFAULT SINGLE ROM ANALYZER. WE ACCEPT:
*
1) HEX INPUT
*
2) 'M' FOR LAST MEMORY EXAMINE ADDRESS
*
3) 'P' FOR PROGRAM COUNTER ADDRESS
*
4) 'W' FOR WINDOW VALUE
*
5) '@' FOR INDIRECT VALUE
EXP1
PSHS
X,B
SAVE REGISTERS
EXPDLM BSR
BLDHXI
CLEAR NUMBER, CHECK FIRST CHAR
BEQ
EXP2
IF HEX DIGIT CONTINUE BUILDING
* SKIP BLANKS IF DESIRED
CMPA
DELIM
? CORRECT DELIMITER
BEQ
EXPDLM
YES, IGNORE IT
* TEST FOR M OR P
LDX
ADDR
DEFAULT FOR 'M'
CMPA
#'M'
? MEMORY EXAMINE ADDR WANTED
BEQ
EXPTDL
BRANCH IF SO
LDX
PCNTER
DEFAULT FOR 'P'
CMPA
#'P'
? LAST PROGRAM COUNTER WANTED
BEQ
EXPTDL
BRANCH IF SO
LDX
WINDOW
DEFAULT TO WINDOW
CMPA
#'W'
? WINDOW WANTED
BEQ
EXPTDLDUNFIELD 6809 ASSEMBLER: ASSIST09
FD05
FD07
FD07
FD09
FD0B
FD0D
FD0D
FD0F
FD11
FD13
FD15
FD17
FD17
FD19
FD1B
FD1D
FD1F
FD21
FD23
FD25
FD27
FD29
FD2B
FD2D
FD2F
FD31
FD33
FD34
FD36
FD38
FD3A
FD3C
FD3D
FD3E
FD40
FD42
FD42
FD42
FD42
FD44
FD46
FD49
FD49
FD49
FD49
FD49
FD49
FD49
FD49
FD49
FD49
FD49
FD4B
FD4D
FD4F
FD51
FD53
FD55
FD56
FD58
FD59
FD5B
FD5D
FD5E
FD60
FD62
FD62
FD62
35 94
8D 44
27 FC
20 0A
AE
9F
0D
27
8D 84
9B
8E
F0
62
9E
81
26
8D
34
DC
30
9F
35
20
81
27
81
27
5F
20
8D
34
DC
40
50
82
20 9B
2B
0E
23
02
9B
8B
9B
02
EC
2D
07
40
DA
CF
0A
02
9B
00
E1
8D 9D
27 32
16 FC 13
0F
0F
8D
8D
26
C6
3D
86
58
09
09
4A
26
20
9B
9C
2A
11
25
10
04
9C
9B
F8
14
1245
1246
1247
1248
1249
1250
1251
1252
1253
1254
1255
1256
1257
1258
1259
1260
1261
1262
1263
1264
1265
1266
1267
1268
1269
1270
1271
1272
1273
1274
1275
1276
1277
1278
1279
1280
1281
1282
1283
1284
1285
1286
1287
1288
1289
1290
1291
1292
1293
1294
1295
1296
1297
1298
1299
1300
1301
1302
1303
1304
1305
1306
1307
1308
1309
1310
1311
1312
EXPRTN PULS
PC,X,B
RETURN AND RESTORE REGISTERS
* GOT HEX, NOW CONTINUE BUILDING
EXP2
BSR
BLDHEX
COMPUTE NEXT DIGIT
BEQ
EXP2
CONTINUE IF MORE
BRA
EXPCDL
SEARCH FOR +/-
* STORE VALUE AND CHECK IF NEED DELIMITER
EXPTDI LDX
,X
INDIRECTION DESIRED
EXPTDL STX
NUMBER
STORE RESULT
TST
DELIM
? TO FORCE A DELIMITER
BEQ
EXPRTN
RETURN IF NOT WITH VALUE
BSR
READ
OBTAIN NEXT CHARACTER
* TEST FOR + OR -
EXPCDL LDX
NUMBER
LOAD LAST VALUE
CMPA
#'+'
? ADD OPERATOR
BNE
EXPCHM
BRANCH NOT
BSR
EXPTRM
COMPUTE NEXT TERM
PSHS
A
SAVE DELIMITER
LDD
NUMBER
LOAD NEW TERM
EXPADD LEAX
D,X
ADD TO X
STX
NUMBER
STORE AS NEW RESULT
PULS
A
RESTORE DELIMITER
BRA
EXPCDL
NOW TEST IT
EXPCHM CMPA
#'-'
? SUBTRACT OPERATOR
BEQ
EXPSUB
BRANCH IF SO
CMPA
#'@'
? INDIRECTION DESIRED
BEQ
EXPTDI
BRANCH IF SO
CLRB
SET DELIMITER RETURN
BRA
EXPRTN
AND RETURN TO CALLER
EXPSUB BSR
EXPTRM
OBTAIN NEXT TERM
PSHS
A
SAVE DELIMITER
LDD
NUMBER
LOAD UP NEXT TERM
NEGA
NEGATE A
NEGB
NEGATE B
SBCA
#0
CORRECT FOR A
BRA
EXPADD
GO ADD TO EXPRESION
* COMPUTE NEXT EXPRESSION TERM
* OUTPUT: X=OLD VALUE
*
'NUMBER'=NEXT TERM
EXPTRM BSR
BLDNUM
OBTAIN NEXT VALUE
BEQ
CNVRTS
RETURN IF VALID NUMBER
BLDBAD LBRA
CMDBAD
ABORT COMMAND IF INVALID
*********************************************
* BUILD BINARY VALUE USING INPUT CHARACTERS.
* INPUT: A=ASCII HEX VALUE OR DELIMITER
*
SP+0=RETURN ADDRESS
*
SP+2=16 BIT RESULT AREA
* OUTPUT: Z=1 A=BINARY VALUE
*
Z=0 IF INVALID HEX CHARACTER (A UNCHANGED)
* VOLATILE: D
****************************************
BLDHXI CLR
NUMBER
CLEAR NUMBER
CLR
NUMBER+1
CLEAR NUMBER
BLDHEX BSR
READ
GET INPUT CHARACTER
BLDHXC BSR
CNVHEX
CONVERT AND TEST CHARACTER
BNE
CNVRTS
RETURN IF NOT A NUMBER
LDB
#16
PREPARE SHIFT
MUL
BY FOUR PLACES
LDA
#4
ROTATE BINARY INTO VALUE
BLDSHF ASLB
OBTAIN
NEXT BIT
ROL
NUMBER+1
INTO LOW BYTE
ROL
NUMBER
INTO HI BYTE
DECA
COUNT DOWN
BNE
BLDSHF
BRANCH IF MORE TO DO
BRA
CNVOK
SET GOOD RETURN CODE
****************************************
* CONVERT ASCII CHARACTER TO BINARY BYTEDUNFIELD 6809 ASSEMBLER: ASSIST09
FD62
FD62
FD62
FD62
FD62
FD62
FD62
FD64
FD66
FD68
FD6A
FD6C
FD6E
FD70
FD72
FD74
FD76
FD78
FD79
FD79
FD79
FD7A
FD7B
FD7D
FD7F
FD80
FD80
FD80
FD80
FD82
FD83
FD83
FD83
FD83
FD85
FD87
FD89
FD89
FD89
FD8C
FD8E
FD8F
FD91
FD93
FD95
FD97
FD99
FD9B
FD9D
FD9F
FDA2
FDA2
FDA5
FDA7
FDAA
FDAC
FDAD
FDAF
FDB1
FDB3
FDB5
FDB7
FDB9
FDB9
FDB9
FDBB
FDBD
FDBF
81
25
81
2F
81
25
81
22
80
84
1A
39
30
12
39
0A
41
0A
46
06
07
0F
04
3F
00
81 18
27 C7
39
8D 01
3B
35 30
34 10
26 19
17
AE
5A
2B
A6
AC
26
81
26
97
0C
16 01 B6
6C
17
ED
17
00
5A
2B
A6
A7
86
A7
20 00 BB
6C
01 98
FA
16
30
A1
F7
3F
02
FB
8F
01 06
C9
B4
30
3F
B1
F3
8D C8
35 7F
AD F1
3F
1313
1314
1315
1316
1317
1318
1319
1320
1321
1322
1323
1324
1325
1326
1327
1328
1329
1330
1331
1332
1333
1334
1335
1336
1337
1338
1339
1340
1341
1342
1343
1344
1345
1346
1347
1348
1349
1350
1351
1352
1353
1354
1355
1356
1357
1358
1359
1360
1361
1362
1363
1364
1365
1366
1367
1368
1369
1370
1371
1372
1373
1374
1375
1376
1377
1378
1379
1380
* INPUT: A=ASCII
* OUTPUT: Z=1 A=BINARY VALUE
*
Z=0 IF INVALID
* ALL REGISTERS TRANSPARENT
* (A UNALTERED IF INVALID HEX)
**************************************
CNVHEX CMPA
#'0'
? LOWER THAN A ZERO
BLO
CNVRTS
BRANCH NOT VALUE
CMPA
#'9'
? POSSIBLE A-F
BLE
CNVGOT
BRANCH NO TO ACCEPT
CMPA
#'A'
? LESS THEN TEN
BLO
CNVRTS
RETURN IF MINUS (INVALID)
CMPA
#'F'
? NOT TOO LARGE
BHI
CNVRTS
NO, RETURN TOO LARGE
SUBA
#7
DOWN TO BINARY
CNVGOT ANDA
#$0F
CLEAR HIGH HEX
CNVOK
ORCC
#4
FORCE ZERO ON FOR VALID HEX
CNVRTS RTS
RETURN TO CALLER
* GET INPUT CHAR, ABORT COMMAND IF CONTROL-X (CANCEL)
READ
SWI
GET NEXT CHARACTER
FCB
INCHNP
FUNCTION
CMPA
#CAN
? ABORT COMMAND
BEQ
BLDBAD
BRANCH TO ABORT IF SO
RTS
RETURN TO CALLER
*G
***************GO - START PROGRAM EXECUTION
CGO
BSR
GOADDR
BUILD ADDRESS IF NEEDED
RTI
START
EXECUTING
* FIND OPTIONAL NEW PROGRAM COUNTER. ALSO ARM THE
* BREAKPOINTS.
GOADDR PULS
Y,X
RECOVER RETURN ADDRESS
PSHS
X
STORE RETURN BACK
BNE
GONDFT
IF NO CARRIAGE RETURN THEN NEW PC
* DEFAULT PROGRAM COUNTER, SO FALL THROUGH IF
* IMMEDIATE BREAKPOINT.
LBSR
CBKLDR
SEARCH BREAKPOINTS
LDX
12,S
LOAD PROGRAM COUNTER
ARMBLP DECB
COUNT DOWN
BMI
ARMBK2
DONE, NONE TO SINGLE TRACE
LDA
-NUMBKP*2,Y
PRE-FETCH OPCODE
CMPX
,Y++
? IS THIS A BREAKPOINT
BNE
ARMBLP
LOOP IF NOT
CMPA
#$3F
? SWI BREAKPOINTED
BNE
ARMNSW
NO, SKIP SETTING OF PASS FLAG
STA
SWIBFL
SHOW UPCOMMING SWI NOT BRKPNT
ARMNSW INC
MISFLG
FLAG THRU A BREAKPOINT
LBRA
CDOT
DO SINGLE TRACE W/O BREAKPOINTS
* OBTAIN NEW PROGRAM COUNTER
GONDFT LBSR
CDNUM
OBTAIN NEW PROGRAM COUNTER
STD
12,S
STORE INTO STACK
ARMBK2 LBSR
CBKLDR
OBTAIN TABLE
NEG
BKPTCT
COMPLEMENT TO SHOW ARMED
ARMLOP DECB
? DONE
BMI
CNVRTS
RETURN WHEN DONE
LDA
[,Y]
LOAD OPCODE
STA
-NUMBKP*2,Y
STORE INTO OPCODE TABLE
LDA
#$3F
READY "SWI" OPCODE
STA
[,Y++]
STORE AND MOVE UP TABLE
BRA
ARMLOP
AND CONTINUE
*******************CALL - CALL ADDRESS AS SUBROUTINE
CCALL
BSR
GOADDR
FETCH ADDRESS IF NEEDED
PULS
U,Y,X,DP,D,CC
RESTORE USERS REGISTERS
JSR
[,S++]
CALL USER SUBROUTINE
CGOBRK SWI
PERFORM BREAKPOINTDUNFIELD 6809 ASSEMBLER: ASSIST09
FDC0
FDC1
FDC3
FDC3
FDC3
FDC3
FDC3
FDC6
FDC8
FDCA
FDCD
FDCF
FDD0
FDD1
FDD4
FDD6
FDD6
FDD8
FDDA
FDDC
FDDE
FDE0
FDE2
FDE4
FDE6
FDE8
FDE8
FDEA
FDEC
FDEE
FDF0
FDF2
FDF4
FDF6
FDF8
FDF8
FDFA
FDFC
FDFE
FDFF
FE00
FE02
FE02
FE04
FE06
FE08
FE09
FE0A
FE0C
FE0E
FE0E
FE10
FE12
FE14
FE16
FE17
FE18
FE1A
FE1C
FE1C
FE1E
FE20
FE21
FE21
FE21
FE23
FE25
FE27
0A
20 FC
17
DD
9E
17
86
3F
01
17
27 00 9A
9E
9E
FC 0C
2D
81
26
9F
30
20
D6
8D
81
27 2C
0E
9E
01
F1
9C
47
2C
E9
81
26
8D
81
27
1F
8D
20 27
0C
8B
27
0C
89
35
F4
81
26
9F
3F
07
20 20
06
9E
81
26
86
3F
01
9F
20 0A
08
0D
81
26
30
9F
3F
06
8D
20 5E
0A
1E
9E
FF 0B
0A
C6
9E
0A
07
AC
81 2F
27 F6
39
9E 9E
34 10
30 E4
3F
1381
1382
1383
1384
1385
1386
1387
1388
1389
1390
1391
1392
1393
1394
1395
1396
1397
1398
1399
1400
1401
1402
1403
1404
1405
1406
1407
1408
1409
1410
1411
1412
1413
1414
1415
1416
1417
1418
1419
1420
1421
1422
1423
1424
1425
1426
1427
1428
1429
1430
1431
1432
1433
1434
1435
1436
1437
1438
1439
1440
1441
1442
1443
1444
1445
1446
1447
1448
FCB
BRA
BRKPT
CGOBRK
FUNCTION
LOOP UNTIL USER CHANGES PC
****************MEMORY - DISPLAY/CHANGE MEMORY
* CMEMN AND CMPADP ARE DIRECT ENTRY POINTS FROM
* THE COMMAND HANDLER FOR QUICK COMMANDS
CMEM
LBSR
CDNUM
OBTAIN ADDRESS
CMEMN
STD
ADDR
STORE DEFAULT
CMEM2
LDX
ADDR
LOAD POINTER
LBSR
ZOUT2H
SEND OUT HEX VALUE OF BYTE
LDA
#'-'
LOAD DELIMITER
SWI
SEND OUT
FCB
OUTCH
FUNCTION
CMEM4
LBSR
BLDNNB
OBTAIN NEW BYTE VALUE
BEQ
CMENUM
BRANCH IF NUMBER
* COMA - SKIP BYTE
CMPA
#','
? COMMA
BNE
CMNOTC
BRANCH NOT
STX
ADDR
UPDATE POINTER
LEAX
1,X
TO NEXT BYTE
BRA
CMEM4
AND INPUT IT
CMENUM LDB
NUMBER+1
LOAD LOW BYTE VALUE
BSR
MUPDAT
GO OVERLAY MEMORY BYTE
CMPA
#','
? CONTINUE WITH NO DISPLAY
BEQ
CMEM4
BRANCH YES
* QUOTED STRING
CMNOTC CMPA
#$27
? QUOTED STRING
BNE
CMNOTQ
BRANCH NO
CMESTR BSR
READ
OBTAIN NEXT CHARACTER
CMPA
#$27
? END OF QUOTED STRING
BEQ
CMSPCE
YES, QUIT STRING MODE
TFR
A,B
TO B FOR SUBROUTINE
BSR
MUPDAT
GO UPDATE BYTE
BRA
CMESTR
GET NEXT CHARACTER
* BLANK - NEXT BYTE
CMNOTQ CMPA
#$20
? BLANK FOR NEXT BYTE
BNE
CMNOTB
BRANCH NOT
STX
ADDR
UPDATE POINTER
CMSPCE SWI
GIVE SPACE
FCB
SPACE
FUNCTION
BRA
CMEM2
NOW PROMPT FOR NEXT
* LINE FEED - NEXT BYTE WITH ADDRESS
CMNOTB CMPA
#LF
? LINE FEED FOR NEXT BYTE
BNE
CMNOTL
BRANCH NO
LDA
#CR
GIVE CARRIAGE RETURN
SWI
TO CONSOLE
FCB
OUTCH
HANDLER
STX
ADDR
STORE NEXT ADDRESS
BRA
CMPADP
BRANCH TO SHOW
* UP ARROW - PREVIOUS BYTE AND ADDRESS
CMNOTL CMPA
#'^'
? UP ARROW FOR PREVIOUS BYTE
BNE
CMNOTU
BRANCH NOT
LEAX
-2,X
DOWN TO PREVIOUS BYTE
STX
ADDR
STORE NEW POINTER
CMPADS SWI
FORCE NEW LINE
FCB
PCRLF
FUNCTION
CMPADP BSR
PRTADR
GO PRINT ITS VALUE
BRA
CMEM2
THEN PROMPT FOR INPUT
* SLASH - NEXT BYTE WITH ADDRESS
CMNOTU CMPA
#'/'
? SLASH FOR CURRENT DISPLAY
BEQ
CMPADS
YES, SEND ADDRESS
RTS
RETURN FROM COMMAND
* PRINT CURRENT ADDRESS
PRTADR LDX
ADDR
PSHS
X
LEAX
,S
SWI
LOAD POINTER VALUE
SAVE X ON STACK
POINT TO IT FOR DISPLAY
DISPLAY POINTER IN HEXDUNFIELD 6809 ASSEMBLER: ASSIST09
FE28
FE29
FE2B
FE2B
FE2B
FE2D
FE2F
FE31
FE33
FE35
FE36
FE38
FE3A
FE3B
FE3C
FE3E
FE3E
FE3E
FE40
FE42
FE43
FE43
FE43
FE45
FE47
FE49
FE4B
FE4D
FE4F
FE51
FE53
FE56
FE58
FE5A
FE5E
FE60
FE60
FE60
FE60
FE60
FE60
FE63
FE65
FE67
FE69
FE6B
FE6D
FE6E
FE71
FE71
FE71
FE73
FE75
FE77
FE79
FE7B
FE7F
FE83
FE85
FE89
FE8B
FE8D
FE8F
FE8F
FE8F
FE91
FE92
FE92
05
35 90
9E
E7
E1
26
9F
39
34
86
3F
01
35
9E
80
1F
03
9E
02
3F
82
8D 20
DD A0
39
8D
C4
1F
30
25
8D
30
34
10
23
ED
AD
35
1B
F0
02
2F
04
11
AB
30
A3 62
02
E4
9D E1 84
E0
17
26
81
22
81
DC
39
16 FE 7E
09
2F
05
0E
9B
8D
1F
8D
6F
34
AD
AD
34
AD
35
26
35 ED
02
E9
E2
26
9D E1 65
9D E1 63
01
9D E1 5F
01
E1
B2
FA EB
8D 01
01
33 F1
1449
1450
1451
1452
1453
1454
1455
1456
1457
1458
1459
1460
1461
1462
1463
1464
1465
1466
1467
1468
1469
1470
1471
1472
1473
1474
1475
1476
1477
1478
1479
1480
1481
1482
1483
1484
1485
1486
1487
1488
1489
1490
1491
1492
1493
1494
1495
1496
1497
1498
1499
1500
1501
1502
1503
1504
1505
1506
1507
1508
1509
1510
1511
1512
1513
1514
1515
1516
FCB
PULS
* UPDATE BYTE
MUPDAT LDX
STB
CMPB
BNE
STX
RTS
MUPBAD PSHS
LDA
SWI
FCB
PULS
OUT4HS
PC,X FUNCTION
RECOVER POINTER AND RETURN
ADDR
,X+
-1,X
MUPBAD
ADDR LOAD NEXT BYTE POINTER
STORE AND INCREMENT X
? SUCCESFULL STORE
BRANCH FOR '?' IF NOT
STORE NEW POINTER VALUE
BACK TO CALLER
SAVE A REGISTER
SHOW INVALID
SEND OUT
FUNCTION
RETURN TO CALLER
A
#'?'
OUTCH
PC,A
********************WINDOW
CWINDO BSR
CDNUM
STD
WINDOW
RTS
-
SET WINDOW VALUE
OBTAIN WINDOW VALUE
STORE IT IN
END COMMAND
******************DISPLAY - HIGH SPEED DISPLAY MEMORY
CDISP
BSR
CDNUM
FETCH ADDRESS
ANDB
#$F0
FORCE TO 16 BOUNDRY
TFR
D,Y
SAVE IN Y
LEAX
15,Y
DEFAULT LENGTH
BCS
CDISPS
BRANCH IF END OF INPUT
BSR
CDNUM
OBTAIN COUNT
LEAX
D,Y
ASSUME COUNT, COMPUTE END ADDR
CDISPS PSHS
Y,X
SETUP PARAMETERS FOR HSDATA
CMPD
2,S
? WAS IT COUNT
BLS
CDCNT
BRANCH YES
STD
,S
STORE HIGH ADDRESS
CDCNT
JSR
[VECTAB+.HSDTA,PCR]
CALL PRINT ROUTINE
PULS
PC,U,Y
CLEAN STACK AND END COMMAND
* OBTAIN NUMBER - ABORT IF NONE
* ONLY DELIMITERS OF CR, BLANK, OR '/' ARE ACCEPTED
* OUTPUT: D=VALUE, C=1 IF CARRIAGE RETURN DELMITER,
*
ELSE C=0
CDNUM
LBSR
BLDNUM
OBTAIN NUMBER
BNE
CDBADN
BRANCH IF INVALID
CMPA
#'/'
? VALID DELIMITER
BHI
CDBADN
BRANCH IF NOT FOR ERROR
CMPA
#CR+1
LEAVE COMPARE FOR CARRIAGE RET
LDD
NUMBER
LOAD NUMBER
RTS
RETURN WITH COMPARE
CDBADN LBRA
CMDBAD
RETURN TO ERROR MECHANISM
*****************PUNCH - PUNCH MEMORY IN S1-S9 FORMAT
CPUNCH BSR
CDNUM
OBTAIN START ADDRESS
TFR
D,Y
SAVE IN Y
BSR
CDNUM
OBTAIN END ADDRESS
CLR
,-S
SETUP PUNCH FUNCTION CODE
PSHS
Y,D
STORE VALUES ON STACK
CCALBS JSR
[VECTAB+.BSON,PCR]
INITIALIZE HANDLER
JSR
[VECTAB+.BSDTA,PCR]
PERFORM FUNCTION
PSHS
CC
SAVE RETURN CODE
JSR
[VECTAB+.BSOFF,PCR]
TURN OFF HANDLER
PULS
CC
OBTAIN CONDITION CODE SAVED
BNE
CDBADN
BRANCH IF ERROR
PULS
PC,Y,X,A
RETURN FROM COMMAND
*****************LOAD - LOAD MEMORY FROM S1-S9 FORMAT
CLOAD
BSR
CLVOFS
CALL SETUP AND PASS CODE
FCB
1
LOAD FUNCTION CODE FOR PACKET
CLVOFS
LEAU
[,S++]
LOAD CODE IN HIGH BYTE OF UDUNFIELD 6809 ASSEMBLER: ASSIST09
FE94
FE96
FE98
FE9A
FE9B
FE9C
FE9D
FE9F
FEA1
FEA1
FEA1
FEA3
FEA4
FEA4
FEA4
FEA4
FEA6
FEA8
FEAA
FEAD
FEAF
FEB1
FEB4
FEB6
FEB7
FEB7
FEB7
FEB9
FEBB
FEBC
FEBC
FEBC
FEBE
FEC0
FEC2
FEC3
FEC5
FEC7
FEC8
FEC8
FEC8
FEC8
FECA
FECC
FECE
FECE
FED0
FED2
FED4
FED6
FED8
FED9
FEDB
FEDD
FEDE
FEDF
FEE1
FEE3
FEE5
FEE6
FEE7
FEE8
FEE9
FEEB
FEEB
FEEB
FEEB
FEEB
33
27
8D
8C
4F
5F
34
20
D4
03
C6
4E
DA
8D EF
FF
8D
DD
32
EE
DF
DE
CC
ED
3B
BA
91
62
F8 0A
99
F6
07 01
42
8D A7
DD F2
39
27
8D
DD
39
30
9F
39
05
A0
F8
6E
F8
8D 96
1F 01
8D 92
30
34
A3
ED
30
1D
A1
26
3F
04
EE
33
EF
3F
05
3F
06
35
01
30
E4
E4
61
E4
02
E4
5F
84
96
27 23
1517
1518
1519
1520
1521
1522
1523
1524
1525
1526
1527
1528
1529
1530
1531
1532
1533
1534
1535
1536
1537
1538
1539
1540
1541
1542
1543
1544
1545
1546
1547
1548
1549
1550
1551
1552
1553
1554
1555
1556
1557
1558
1559
1560
1561
1562
1563
1564
1565
1566
1567
1568
1569
1570
1571
1572
1573
1574
1575
1576
1577
1578
1579
1580
1581
1582
1583
1584
CLVDFT
LEAU
BEQ
BSR
FCB
CLRA
CLRB
PSHS
BRA
[,U]
CLVDFT
CDNUM
SKIP2
U,DP,D
CCALBS
NOT CHANGING CC AND RESTORE S
BRANCH IF CARRIAGE RETURN NEXT
OBTAIN OFFSET
SKIP DEFAULT OFFSET
CREATE ZERO OFFSET
AS DEFAULT
SETUP CODE, NULL WORD, OFFSET
ENTER CALL TO BS ROUTINES
******************VERIFY - COMPARE MEMORY WITH FILES
CVER
BSR
CLVOFS
COMPUTE OFFSET IF ANY
FCB
-1
VERIFY FNCTN CODE FOR PACKET
*******************TRACE - TRACE INSTRUCTIONS
******************* . - SINGLE STEP TRACE
CTRACE BSR
CDNUM
OBTAIN TRACE COUNT
STD
TRACEC
STORE COUNT
CDOT
LEAS
2,S
RID COMMAND RETURN FROM STACK
CTRCE3 LDU
[10,S]
LOAD OPCODE TO EXECUTE
STU
LASTOP
STORE FOR TRACE INTERRUPT
LDU
VECTAB+.PTM
LOAD PTM ADDRESS
LDD
#$0701
7,1 CYCLES DOWN+CYCLES UP
STD
PTMTM1-PTM,U
START NMI TIMEOUT
RTI
RETURN
FOR ONE INSTRUCTION
*************NULLS - SET NEW LINE AND CHAR PADDING
CNULLS BSR
CDNUM
OBTAIN NEW LINE PAD
STD
VECTAB+.PAD
RESET VALUES
RTS
END COMMAND
******************STLEVEL - SET STACK TRACE LEVEL
CSTLEV BEQ
STLDFT
TAKE DEFAULT
BSR
CDNUM
OBTAIN NEW STACK LEVEL
STD
SLEVEL
STORE NEW ENTRY
RTS
TO COMMAND HANDLER
STLDFT LEAX
14,S
COMPUTE NMI COMPARE
STX
SLEVEL
AND STORE IT
RTS
END COMMAND
******************OFFSET - COMPUTE SHORT AND LONG
******************
BRANCH OFFSETS
COFFS
BSR
CDNUM
OBTAIN INSTRUCTION ADDRESS
TFR
D,X
USE AS FROM ADDRESS
BSR
CDNUM
OBTAIN TO ADDRESS
* D=TO INSTRUCTION, X=FROM INSTRUCTION OFFSET BYTE(S)
LEAX
1,X
ADJUST FOR *+2 SHORT BRANCH
PSHS
Y,X
STORE WORK WORD AND VALUE ON S
SUBD
,S
FIND OFFSET
STD
,S
SAVE OVER STACK
LEAX
1,S
POINT FOR ONE BYTE DISPLAY
SEX
SIGN
EXTEND LOW BYTE
CMPA
,S
? VALID ONE BYTE OFFSET
BNE
COFNO1
BRANCH IF NOT
SWI
SHOW ONE BYTE OFFSET
FCB
OUT2HS
FUNCTION
COFNO1 LDU
,S
RELOAD OFFSET
LEAU
-1,U
CONVERT TO LONG BRANCH OFFSET
STU
,X
STORE BACK WHERE X POINTS NOW
SWI
SHOW TWO BYTE OFFSET
FCB
OUT4HS
FUNCTION
SWI
FORCE NEW LINE
FCB
PCRLF
FUNCTION
PULS
PC,X,D
RESTORE STACK AND END COMMAND
*H
*************BREAKPOINT - DISPLAY/ENTER/DELETE/CLEAR
*************
BREAKPOINTS
CBKPT
BEQ
CBKDSP
BRANCH DISPLAY OF JUST 'B'DUNFIELD 6809 ASSEMBLER: ASSIST09
FEED
FEF0
FEF2
FEF4
FEF6
FEF9
FEFB
FEFD
FEFE
FEFE
FF00
FF01
FF03
FF05
FF07
FF07
FF09
FF0B
FF0C
FF0E
FF10
FF12
FF14
FF16
FF17
FF18
FF19
FF1B
FF1C
FF1D
FF1E
FF1E
FF20
FF22
FF24
FF26
FF28
FF2A
FF2C
FF2E
FF2F
FF31
FF33
FF35
FF38
FF3A
FF3C
FF3E
FF40
FF40
FF42
FF46
FF48
FF49
FF49
FF49
FF4B
FF4C
FF4F
FF50
FF51
FF53
FF55
FF57
FF59
FF5A
FF5B
FF5D
17
27
81
26
17
27
0F
39 FD F1
2C
2D
3F
FD E8
03
FA
8D
5A
2B
AC
26 40
AE
AF
5A
2A
0A
8D
27
30
3F
05
5A
26
3F
06
39 A1
3C
8D
C1
27
A6
E7
E1
26
A7
5A
2B
AC
26
16
AF
6F
0C
20 20
08
11
84
84
84
09
84
32
A1
F9
F9
FA
2E
E9
A1
F9
07
A1
F9
FA 24
A4
31
FA
D0
9E 9B
31 8D E0 6C
D6 FA
39
6F
5F
30
3F
00
81
26
86
A7
3F
00
81
27
E2
8C 3F
5B
06
10
E4
0D
0C
1585
1586
1587
1588
1589
1590
1591
1592
1593
1594
1595
1596
1597
1598
1599
1600
1601
1602
1603
1604
1605
1606
1607
1608
1609
1610
1611
1612
1613
1614
1615
1616
1617
1618
1619
1620
1621
1622
1623
1624
1625
1626
1627
1628
1629
1630
1631
1632
1633
1634
1635
1636
1637
1638
1639
1640
1641
1642
1643
1644
1645
1646
1647
1648
1649
1650
1651
1652
LBSR
BLDNUM
ATTEMPT VALUE ENTRY
BEQ
CBKADD
BRANCH TO ADD IF SO
CMPA
#'-'
? CORRECT DELIMITER
BNE
CBKERR
NO, BRANCH FOR ERROR
LBSR
BLDNUM
ATTEMPT DELETE VALUE
BEQ
CBKDLE
GOT ONE, GO DELETE IT
CLR
BKPTCT
WAS 'B -', SO ZERO COUNT
CBKRTS RTS
END COMMAND
* DELETE THE ENTRY
CBKDLE BSR
CBKSET
SETUP REGISTERS AND VALUE
CBKDLP DECB
? ANY ENTRIES IN TABLE
BMI
CBKERR
BRANCH NO, ERROR
CMPX
,Y++
? IS THIS THE ENTRY
BNE
CBKDLP
NO, TRY NEXT
* FOUND, NOW MOVE OTHERS UP IN ITS PLACE
CBKDLM LDX
,Y++
LOAD NEXT ONE UP
STX
-4,Y
MOVE DOWN BY ONE
DECB
? DONE
BPL
CBKDLM
NO, CONTINUE MOVE
DEC
BKPTCT
DECREMENT BREAKPOINT COUNT
CBKDSP BSR
CBKSET
SETUP REGISTERS AND LOAD VALUE
BEQ
CBKRTS
RETURN IF NONE TO DISPLY
CBKDSL LEAX
,Y++
POINT TO NEXT ENTRY
SWI
DISPLAY IN HEX
FCB
OUT4HS
FUNCTION
DECB
COUNT DOWN
BNE
CBKDSL
LOOP IF NGABLE RAM
SWI
SKIP TO NEW LINK
FCB
PCRLF
FUNCTIONRTS
RTS
* ADD NEW ENTRY
CBKADD BSR
CBKSET
SETUP REGISTERS
CMPB
#NUMBKP
? ALREADY FULL
BEQ
CBKERR
BRANCH ERROR IF SO
LDA
,X
LOAD BYTE TO TRAP
STB
,X
TRY TO CHANGE
CMPB
,X
? CHANGEABLE RAM
BNE
CBKERR
BRANCH ERROR IF NOT
STA
,X
RESTORE BYTE
CBKADL DECB
COUNT DOWN
BMI
CBKADT
BRANCH IF DONE TO ADD IT
CMPX
,Y++
? ENTRY ALREADY HERE
BNE
CBKADL
LOOP IF NOT
CBKERR LBRA
CMDBAD
RETURN TO ERROR PRODUCE
CBKADT STX
,Y
ADD THIS ENTRY
CLR
-NUMBKP*2+1,Y
CLEAR OPTIONAL BYTE
INC
BKPTCT
ADD ONE TO COUNT
BRA
CBKDSP
AND NOW DISPLAY ALL OF 'EM
* SETUP REGISTERS FOR SCAN
CBKSET LDX
NUMBER
LOAD VALUE DESIRED
CBKLDR LEAY
BKPTBL,PCR
LOAD START OF TABLE
LDB
BKPTCT
LOAD ENTRY COUNT
RTS
RETURN
*****************ENCODE -
CENCDE CLR
,-S
CLRB
LEAX
<CONV1,PCR
SWI
FCB
INCHNP
CMPA
#'['
BNE
CEN2
LDA
#$10
STA
,S
CENGET SWI
FCB
INCHNP
CEN2
CMPA
#CR
BEQ
CEND1
ENCODE A POSTBYTE
DEFAULT TO NOT INDIRECT
ZERO POSTBYTE VALUE
START TABLE SEARCH
OBTAIN FIRST CHARACTER
FUNCTION
? INDIRECT HERE
BRANCH IF NOT
SET INDIRECT BIT ON
SAVE FOR LATER
OBTAIN NEXT CHARACTER
FUNCTION
? END OF ENTRY
BRANCH YESDUNFIELD 6809 ASSEMBLER: ASSIST09
FF5F
FF61
FF63
FF65
FF67
FF69
FF6B
FF6E
FF70
FF72
FF74
FF76
FF78
FF7A
FF7C
FF7E
FF80
FF82
FF84
FF86
FF88
FF89
FF8A
FF8B
FF8C
FF8E
FF8E
FF8E
FF96
FF9E
FFA6
FFAE
FFB6
FFB7
FFB7
FFB7
FFBB
FFBF
FFC3
FFC7
FFCB
FFCF
FFD3
FFD4
FFD4
FFD4
FFD4
FFD4
FFD8
FFDC
FFE0
FFE4
FFE8
FFEC
FFF0
FFF0
FFF0
FFF0
FFF0
FFF0
FFF0
FFF0
FFF2
FFF4
FFF6
FFF8
FFFA
FFFC
6D
2B
A1
26
EB
20
30
1F
84
AA
A7
C4
6D
27
E1
26
E6
EA
E7
30
3F
04
3F
06
35 84
D2
81
F8
1F
EE
8C 49
98
60
E4
E4
9F
84
B9
81
F8
1F
E4
E4
E4 41
48
2D
55
50
FF 04
01
09
50
80 42
48
2D
58
43 05
01
01
10
00
10
12
14
16
18
1A
83
00 84
88
86
8B
81
83
8D 11
13
15
17
19
82
03 00
89
85
80
82
8C
9F
6E
6E
6E
6E
6E
6E
6E
FF
FF
FF
FF
FF
FF
FF
84
9D
9D
9D
9D
9D
9D
9D
D4
D8
DC
E0
E4
E8
EC
DF
DF
DF
DF
DF
DF
DF
EE
EC
EA
E8
E6
E4
E2
44
48
53
2B
52
06
00
70
07
00
+
+
+
+
+
1653
1654
1655
1656
1657
1658
1659
1660
1661
1662
1663
1664
1665
1666
1667
1668
1669
1670
1671
1672
1673
1674
1675
1676
1677
1678
1679
1680
1681
1682
1683
1684
1685
1686
1687
1688
1689
1690
1691
1692
1693
1694
1695
1696
1697
1698
1699
1700
1701
1702
1703
1704
1705
1706
1707
1708
1709
1710
1711
1712
1713
1714
1715
1716
1717
1718
1719
1720
CENLP1
CEND1
CENLP2
TST
BMI
CMPA
BNE
ADDB
BRA
LEAX
TFR
ANDA
ORA
STA
ANDB
TST
BEQ
CMPB
BNE
LDB
ORB
STB
LEAX
SWI
FCB
SWI
FCB
PULS
,X
CBKERR
,X++
CENLP1
-1,X
CENGET
<CONV2,PCR
B,A
#$60
,S
,S
#$9F
,X
CBKERR
,X++
CENLP2
-1,X
,S
,S
,S
OUT2HS
PCRLF
PC,B
? END OF TABLE
BRANCH ERROR IF SO
? THIS THE CHARACTER
BRANCH IF NOT
ADD THIS VALUE
GET NEXT INPUT
POINT AT TABLE 2
SAVE COPY IN A
ISOLATE REGISTER MASK
ADD IN INDIRECTION BIT
SAVE BACK AS POSTBYTE SKELETON
CLEAR REGISTER BITS
? END OF TABLE
BRANCH ERROR IF SO
? SAME VALUE
LOOP IF NOT
LOAD RESULT VALUE
ADD TO BASE SKELETON
SAVE POSTBYTE ON STACK
POINT TO IT
SEND OUT AS HEX
FUNCTION
TO NEXT LINE
FUNCTION
END OF COMMAND
* TABLE ONE DEFINES VALID INPUT IN SEQUENCE
CONV1
FCB
'A',$04,'B',$05,'D',$06,'H',$01
FCB
'H',$01,'H',$01,'H',$00,',',$00
FCB
'-',$09,'-',$01,'S',$70,'Y',$30
FCB
'U',$50,'X',$10,'+',$07,'+',$01
FCB
'P',$80,'C',$00,'R',$00,']',$00
FCB
$FF
END OF TABLE
*CONV2 USES ABOVE CONVERSION TO SET POSTBYTE
*
BIT SKELETON.
CONV2
FDB
$1084,$1100
R,
H,R
FDB
$1288,$1389
HH,R
HHHH,R
FDB
$1486,$1585
A,R
B,R
FDB
$168B,$1780
D,R
,R+
FDB
$1881,$1982
,R++
,-R
FDB
$1A83,$828C
,--R
HH,PCR
FDB
$838D,$039F
HHHH,PCR [HHHH]
FCB
0
END OF TABLE
****************************************************
*
DEFAULT INTERRUPT TRANSFERS
*
****************************************************
RSRVD
JMP
[VECTAB+.RSVD,PCR]
RESERVED VECTOR
SWI3
JMP
[VECTAB+.SWI3,PCR]
SWI3 VECTOR
SWI2
JMP
[VECTAB+.SWI2,PCR]
SWI2 VECTOR
FIRQ
JMP
[VECTAB+.FIRQ,PCR]
FIRQ VECTOR
IRQ
JMP
[VECTAB+.IRQ,PCR]
IRQ VECTOR
SWI
JMP
[VECTAB+.SWI,PCR]
SWI VECTOR
NMI
JMP
[VECTAB+.NMI,PCR]
NMI VECTOR
******************************************************
* ASSIST09 HARDWARE VECTOR TABLE
* THIS TABLE IS USED IF THE ASSIST09 ROM ADDRESSES
* THE MC6809 HARDWARE VECTORS.
******************************************************
ORG
ROMBEG+ROMSIZ-16
SETUP HARDWARE VECTORS
FDB
RSRVD
RESERVED SLOT
FDB
SWI3
SOFTWARE INTERRUPT 3
FDB
SWI2
SOFTWARE INTERRUPT 2
FDB
FIRQ
FAST INTERRUPT REQUEST
FDB  IRQ     INTERRUPT REQUEST
FDB       SWI     SOFTWARE INTERRUPT
FDB      NMI     NON-MASKABLE INTERRUPT
FDB   RESET     RESTART
