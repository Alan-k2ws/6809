0001 a000                    UART      EQU  $A000
0002 a001                    RECEV     EQU  UART+1
0003 a001                    TRANS     EQU  UART+1
0004 a000                    USTAT     EQU  UART
0005 a000                    UCTRL     EQU  UART
0006                         
0007 0008                    BS        EQU  8              ; BACKSPACE
0008 000d                    CR        EQU  $D             ; ENTER KEY
0009 001b                    ESC       EQU  $1B            ; ESCAPE CODE
0010 0020                    SPACE     EQU  $20            ; SPACE (BLANK)
0011 003a                    STKBUF    EQU  58             ; STACK BUFFER ROOM
0012 00fa                    LBUFMX    EQU  250            ; MAX NUMBER OF CHARS IN A BASIC LINE
0013 00fa                    MAXLIN    EQU  $FA            ; MAXIMUM MS BYTE OF LINE NUMBER
0014                         * PSEUDO OPS
0015 0021                    SKP1      EQU  $21            ; OP CODE OF BRN - SKIP ONE BYTE
0016 008c                    SKP2      EQU  $8C            ; OP CODE OF CMPX # - SKIP TWO BYTES
0017 0086                    SKP1LD    EQU  $86            ; OP CODE OF LDA # - SKIP THE NEXT BYTE
0018                         *                             ; AND LOAD THE VALUE OF THAT BYTE INTO ACCA - THIS
0019                         *                             ; IS USUALLY USED TO LOAD ACCA WITH A NON ZERO VALUE
0020 0015                    RTS_LOW   EQU  $15            ; 6850 ACIA CONTROL REGISTER: RX INT DISABLED, RTS LOW, TX INT DISABLED, 8N1, CLK/16
0021 0000                              ORG  0
0022 0000                    ENDFLG    RMB  1              ; STOP/END FLAG: POSITIVE=STOP, NEG=END
0023 0001                    CHARAC    RMB  1              ; TERMINATOR FLAG 1
0024 0002                    ENDCHR    RMB  1              ; TERMINATOR FLAG 2
0025 0003                    TMPLOC    RMB  1              ; SCRATCH VARIABLE
0026 0004                    IFCTR     RMB  1              ; IF COUNTER - HOW MANY IF STATEMENTS IN A LINE
0027 0005                    DIMFLG    RMB  1              ; *DV* ARRAY FLAG 0=EVALUATE, 1=DIMENSIONING
0028 0006                    VALTYP    RMB  1              ; *DV* *PV TYPE FLAG: 0=NUMERIC, $FF=STRING
0029 0007                    GARBFL    RMB  1              ; *TV STRING SPACE HOUSEKEEPING FLAG
0030 0008                    ARYDIS    RMB  1              ; DISABLE ARRAY SEARCH: 00=ALLOW SEARCH
0031 0009                    INPFLG    RMB  1              ; *TV INPUT FLAG: READ=0, INPUT<>0
0032 000a                    RELFLG    RMB  1              ; *TV RELATIONAL OPERATOR FLAG
0033 000b                    TEMPPT    RMB  2              ; *PV TEMPORARY STRING STACK POINTER
0034 000d                    LASTPT    RMB  2              ; *PV ADDR OF LAST USED STRING STACK ADDRESS
0035 000f                    TEMPTR    RMB  2              ; TEMPORARY POINTER
0036 0011                    TMPTR1    RMB  2              ; TEMPORARY DESCRIPTOR STORAGE (STACK SEARCH)
0037 0013                    FPA2      RMB  4              ; FLOATING POINT ACCUMULATOR #2 MANTISSA
0038 0017                    BOTSTK    RMB  2              ; BOTTOM OF STACK AT LAST CHECK
0039 0019                    TXTTAB    RMB  2              ; *PV BEGINNING OF BASIC PROGRAM
0040 001b                    VARTAB    RMB  2              ; *PV START OF VARIABLES
0041 001d                    ARYTAB    RMB  2              ; *PV START OF ARRAYS
0042 001f                    ARYEND    RMB  2              ; *PV END OF ARRAYS (+1)
0043 0021                    FRETOP    RMB  2              ; *PV START OF STRING STORAGE (TOP OF FREE RAM)
0044 0023                    STRTAB    RMB  2              ; *PV START OF STRING VARIABLES
0045 0025                    FRESPC    RMB  2              ; UTILITY STRING POINTER
0046 0027                    MEMSIZ    RMB  2              ; *PV TOP OF STRING SPACE
0047 0029                    OLDTXT    RMB  2              ; SAVED LINE NUMBER DURING A "STOP"
0048 002b                    BINVAL    RMB  2              ; BINARY VALUE OF A CONVERTED LINE NUMBER
0049 002d                    OLDPTR    RMB  2              ; SAVED INPUT PTR DURING A "STOP"
0050 002f                    TINPTR    RMB  2              ; TEMPORARY INPUT POINTER STORAGE
0051 0031                    DATTXT    RMB  2              ; *PV 'DATA' STATEMENT LINE NUMBER POINTER
0052 0033                    DATPTR    RMB  2              ; *PV 'DATA' STATEMENT ADDRESS POINTER
0053 0035                    DATTMP    RMB  2              ; DATA POINTER FOR 'INPUT' & 'READ'
0054 0037                    VARNAM    RMB  2              ; *TV TEMP STORAGE FOR A VARIABLE NAME
0055 0039                    VARPTR    RMB  2              ; *TV POINTER TO A VARIABLE DESCRIPTOR
0056 003b                    VARDES    RMB  2              ; TEMP POINTER TO A VARIABLE DESCRIPTOR
0057 003d                    RELPTR    RMB  2              ; POINTER TO RELATIONAL OPERATOR PROCESSING ROUTINE
0058 003f                    TRELFL    RMB  1              ; TEMPORARY RELATIONAL OPERATOR FLAG BYTE
0059                         * FLOATING POINT ACCUMULATORS #3,4 & 5 ARE MOSTLY
0060                         * USED AS SCRATCH PAD VARIABLES.
0061                         ** FLOATING POINT ACCUMULATOR #3 :PACKED: ($40-$44)
0062 0040                    V40       RMB  1
0063 0041                    V41       RMB  1
0064 0042                    V42       RMB  1
0065 0043                    V43       RMB  1
0066 0044                    V44       RMB  1
0067                         ** FLOATING POINT ACCUMULATOR #4 :PACKED: ($45-$49)
0068 0045                    V45       RMB  1
0069 0046                    V46       RMB  1
0070 0047                    V47       RMB  1
0071 0048                    V48       RMB  2
0072                         ** FLOATING POINT ACCUMULATOR #5 :PACKED: ($4A-$4E)
0073 004a                    V4A       RMB  1
0074 004b                    V4B       RMB  2
0075 004d                    V4D       RMB  2
0076                         ** FLOATING POINT ACCUMULATOR #0
0077 004f                    FP0EXP    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #0 EXPONENT
0078 0050                    FPA0      RMB  4              ; *PV FLOATING POINT ACCUMULATOR #0 MANTISSA
0079 0054                    FP0SGN    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #0 SIGN
0080 0055                    COEFCT    RMB  1              ; POLYNOMIAL COEFFICIENT COUNTER
0081 0056                    STRDES    RMB  5              ; TEMPORARY STRING DESCRIPTOR
0082 005b                    FPCARY    RMB  1              ; FLOATING POINT CARRY BYTE
0083                         ** FLOATING POINT ACCUMULATOR #1
0084 005c                    FP1EXP    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #1 EXPONENT
0085 005d                    FPA1      RMB  4              ; *PV FLOATING POINT ACCUMULATOR #1 MANTISSA
0086 0061                    FP1SGN    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #1 SIGN
0087 0062                    RESSGN    RMB  1              ; SIGN OF RESULT OF FLOATING POINT OPERATION
0088 0063                    FPSBYT    RMB  1              ; FLOATING POINT SUB BYTE (FIFTH BYTE)
0089 0064                    COEFPT    RMB  2              ; POLYNOMIAL COEFFICIENT POINTER
0090 0066                    LSTTXT    RMB  2              ; CURRENT LINE POINTER DURING LIST
0091 0068                    CURLIN    RMB  2              ; *PV CURRENT LINE # OF BASIC PROGRAM, $FFFF = DIRECT
0092 006a                    DEVCFW    RMB  1              ; *TV TAB FIELD WIDTH
0093 006b                    DEVLCF    RMB  1              ; *TV TAB ZONE
0094 006c                    DEVPOS    RMB  1              ; *TV PRINT POSITION
0095 006d                    DEVWID    RMB  1              ; *TV PRINT WIDTH
0096 006e                    RSTFLG    RMB  1              ; *PV WARM START FLAG: $55=WARM, OTHER=COLD
0097 006f                    RSTVEC    RMB  2              ; *PV WARM START VECTOR - JUMP ADDRESS FOR WARM START
0098 0071                    TOPRAM    RMB  2              ; *PV TOP OF RAM
0099 0073                    IKEYIM    RMB  1              ; *TV INKEY$ RAM IMAGE
0100 0074                    ZERO      RMB  2              ; *PV DUMMY - THESE TWO BYTES ARE ALWAYS ZERO
0101                         * THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM
0102 0076                    LPTCFW    RMB  1              ; 16
0103 0077                    LPTLCF    RMB  1              ; 112
0104 0078                    LPTWID    RMB  1              ; 132
0105 0079                    LPTPOS    RMB  1              ; 0
0106 007a                    EXECJP    RMB  2              ; LB4AA
0107                         
0108                         * THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM
0109                         * BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE
0110                         * INTERPRETED IS STORED AT CHARAD.
0111 007c 0c 84              GETNCH    INC  <CHARAD+1      ; *PV INCREMENT LS BYTE OF INPUT POINTER
0112 007e 26 02                        BNE  GETCCH         ; *PV BRANCH IF NOT ZERO (NO CARRY)
0113 0080 0c 83                        INC  <CHARAD        ; *PV INCREMENT MS BYTE OF INPUT POINTER
0114 0082 b6                 GETCCH    FCB  $B6            ; *PV OP CODE OF LDA EXTENDED
0115 0083                    CHARAD    RMB  2              ; *PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT
0116                         *         *    CHARACTER WHICH THE BASIC INTERPRETER IS
0117                         *         *    PROCESSING
0118 0085 7e d1 c2                     JMP  BROMHK         ; JUMP BACK INTO THE BASIC RUM
0119                         
0120 0088                    VAB       RMB  1              ; = LOW ORDER FOUR BYTES OF THE PRODUCT
0121 0089                    VAC       RMB  1              ; = OF A FLOATING POINT MULTIPLICATION
0122 008a                    VAD       RMB  1              ; = THESE BYTES ARE USE AS RANDOM DATA
0123 008b                    VAE       RMB  1              ; = BY THE RND STATEMENT
0124                         
0125                         * EXTENDED BASIC VARIABLES
0126 008c                    TRCFLG    RMB  1              ; *PV TRACE FLAG 0=OFF ELSE=ON
0127 008d                    USRADR    RMB  2              ; *PV ADDRESS OF THE START OF USR VECTORS
0128                         
0129                         * EXTENDED BASIC SCRATCH PAD VARIABLES
0130 008f                    VCF       RMB  2
0131 0091                    VD1       RMB  2
0132 0093                    VD3       RMB  2
0133 0095                    VD5       RMB  2
0134 0097                    VD7       RMB  1
0135 0098                    VD8       RMB  1
0136 0099                    VD9       RMB  1
0137 009a                    VDA       RMB  1
0138 009b                    SW3VEC    RMB  3
0139 009e                    SW2VEC    RMB  3
0140 00a1                    SWIVEC    RMB  3
0141 00a4                    NMIVEC    RMB  3
0142 00a7                    IRQVEC    RMB  3
0143 00aa                    FRQVEC    RMB  3
0144 00ad                    USRJMP    RMB  3              ; JUMP ADDRESS FOR BASIC'S USR FUNCTION
0145 00b0                    RVSEED    RMB  1              ; * FLOATING POINT RANDOM NUMBER SEED EXPONENT
0146 00b1                              RMB  4              ; * MANTISSA: INITIALLY SET TO $804FC75259
0147                         
0148                         **** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)
0149 00b5                    USR0      RMB  2              ; USR 0 VECTOR
0150 00b7                              RMB  2              ; USR 1
0151 00b9                              RMB  2              ; USR 2
0152 00bb                              RMB  2              ; USR 3
0153 00bd                              RMB  2              ; USR 4
0154 00bf                              RMB  2              ; USR 5
0155 00c1                              RMB  2              ; USR 6
0156 00c3                              RMB  2              ; USR 7
0157 00c5                              RMB  2              ; USR 8
0158 00c7                              RMB  2              ; USR 9
0159                         
0160 00c9                    STRSTK    RMB  8*5            ; STRING DESCRIPTOR STACK
0161 00f1                    LINHDR    RMB  2              ; LINE INPUT BUFFER HEADER
0162 00f3                    LINBUF    RMB  LBUFMX+1       ; BASIC LINE INPUT BUFFER
0163 01ee                    STRBUF    RMB  41             ; STRING BUFFER
0164                         
0165 0217                    PROGST    RMB  1              ; START OF PROGRAM SPACE
0166                         *         INTERRUPT VECTORS
0167                         *          ORG  $FFF2
0168                         *SWI3      RMB  2
0169                         *SWI2      RMB  2
0170                         *FIRQ      RMB  2
0171                         *IRQ       RMB  2
0172                         *SWI       RMB  2
0173                         *NMI       RMB  2
0174                         *RESETV    RMB  2
0175                         
0176 c000                              ORG  $C000
0177 c000 ff ff ff ff ff ff            FILL $FF, $D000-*   ; Fill ROM with FFs until $D000
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff
0178                         
0179                         * JUMP TO BASIC COLD START AT START OF ROM FOR CONVENIENCE
0180 d000 7e d0 49                     JMP   RESVEC
0181                         
0182                         * CONSOLE IN
0183 d003 8d 03              LA171     BSR  KEYIN          ; GET A CHARACTER FROM CONSOLE IN
0184 d005 27 fc                        BEQ  LA171          ; LOOP IF NO KEY DOWN
0185 d007 39                           RTS
0186                         
0187                         *
0188                         * THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A KEY
0189                         * IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DOWN.
0190                         *
0191                         *
0192                         LA1C1
0193 d008 b6 a0 00           KEYIN     LDA  USTAT
0194 d00b 85 01                        BITA #1
0195 d00d 27 06                        BEQ  NOCHAR
0196 d00f b6 a0 01                     LDA  RECEV
0197 d012 84 7f                        ANDA #$7F
0198 d014 39                           RTS
0199 d015 4f                 NOCHAR    CLRA
0200 d016 39                           RTS
0201                         
0202                         
0203                         
0204                         * CONSOLE OUT
0205 d017 8d 24              PUTCHR    BSR  WAITACIA
0206 d019 34 02                        PSHS A              ;
0207 d01b 81 0d                        CMPA #CR            ; IS IT CARRIAGE RETURN?
0208 d01d 27 0b                        BEQ  NEWLINE        ; YES
0209 d01f b7 a0 01                     STA  TRANS
0210 d022 0c 79                        INC  LPTPOS         ; INCREMENT CHARACTER COUNTER
0211 d024 96 79                        LDA  LPTPOS         ; CHECK FOR END OF LINE PRINTER LINE
0212 d026 91 78                        CMPA LPTWID         ; AT END OF LINE PRINTER LINE?
0213 d028 25 10                        BLO  PUTEND         ; NO
0214 d02a 0f 79              NEWLINE   CLR  LPTPOS         ; RESET CHARACTER COUNTER
0215 d02c 8d 0f                        BSR  WAITACIA
0216 d02e 86 0d                        LDA  #13
0217 d030 b7 a0 01                     STA  TRANS
0218 d033 8d 08                        BSR  WAITACIA
0219 d035 86 0a                        LDA  #10            ; DO LINEFEED AFTER CR
0220 d037 b7 a0 01                     STA  TRANS
0221 d03a 35 02              PUTEND    PULS A              ;
0222 d03c 39                           RTS
0223                         
0224 d03d 34 02              WAITACIA  PSHS A
0225 d03f b6 a0 00           WRWAIT    LDA  USTAT
0226 d042 85 02                        BITA #2
0227 d044 27 f9                        BEQ  WRWAIT
0228 d046 35 02                        PULS A              ;
0229 d048 39                           RTS
0230                         
0231                         *
0232                         RESVEC
0233 d049 10 ce 01 ee        LA00E     LDS  #LINBUF+LBUFMX+1 ; SET STACK TO TOP OF LINE INPUT BUFFER
0234 d04d 96 6e                        LDA  RSTFLG         ; GET WARM START FLAG
0235 d04f 81 55                        CMPA #$55           ; IS IT A WARM START?
0236 d051 26 0a                        BNE  BACDST         ; NO - D0 A COLD START
0237 d053 9e 6f                        LDX  RSTVEC         ; WARM START VECTOR
0238 d055 a6 84                        LDA  ,X             ; GET FIRST BYTE OF WARM START ADDR
0239 d057 81 12                        CMPA #$12           ; IS IT NOP?
0240 d059 26 02                        BNE  BACDST         ; NO - DO A COLD START
0241 d05b 6e 84                        JMP  ,X             ; YES, G0 THERE
0242                         
0243                         * COLD START ENTRY
0244                         
0245 d05d 8e 02 18           BACDST    LDX  #PROGST+1      ; POINT X TO CLEAR 1ST 1K OF RAM
0246 d060 6f 83              LA077     CLR  ,--X           ; MOVE POINTER DOWN TWO-CLEAR BYTE
0247 d062 30 01                        LEAX 1,X            ; ADVANCE POINTER ONE
0248 d064 26 fa                        BNE  LA077          ; KEEP GOING IF NOT AT BOTTOM OF PAGE 0
0249 d066 8e 02 17                     LDX  #PROGST        ; SET TO START OF PROGRAM SPACE
0250 d069 6f 80                        CLR  ,X+            ; CLEAR 1ST BYTE OF BASIC PROGRAM
0251 d06b 9f 19                        STX  TXTTAB         ; BEGINNING OF BASIC PROGRAM
0252 d06d a6 02              LA084     LDA  2,X            ; LOOK FOR END OF MEMORY
0253 d06f 43                           COMA                ; * COMPLEMENT IT AND PUT IT BACK
0254 d070 a7 02                        STA  2,X            ; * INTO SYSTEM MEMORY
0255 d072 a1 02                        CMPA 2,X            ; IS IT RAM?
0256 d074 26 06                        BNE  LA093          ; BRANCH IF NOT (ROM, BAD RAM OR NO RAM)
0257 d076 30 01                        LEAX 1,X            ; MOVE POINTER UP ONE
0258 d078 63 01                        COM  1,X            ; RE-COMPLEMENT TO RESTORE BYTE
0259 d07a 20 f1                        BRA  LA084          ; KEEP LOOKING FOR END OF RAM
0260 d07c 9f 71              LA093     STX  TOPRAM         ; SAVE ABSOLUTE TOP OF RAM
0261 d07e 9f 27                        STX  MEMSIZ         ; SAVE TOP OF STRING SPACE
0262 d080 9f 23                        STX  STRTAB         ; SAVE START OF STRING VARIABLES
0263 d082 30 89 ff 38                  LEAX -200,X         ; CLEAR 200 - DEFAULT STRING SPACE TO 200 BYTES
0264 d086 9f 21                        STX  FRETOP         ; SAVE START OF STRING SPACE
0265 d088 1f 14                        TFR  X,S            ; PUT STACK THERE
0266 d08a 8e d0 d1                     LDX  #LA10D         ; POINT X TO ROM SOURCE DATA
0267 d08d ce 00 76                     LDU  #LPTCFW        ; POINT U TO RAM DESTINATION
0268 d090 c6 12                        LDB  #18            ; MOVE 18 BYTES
0269 d092 bd d1 b1                     JSR  LA59A          ; MOVE 18 BYTES FROM ROM TO RAM
0270 d095 ce 00 a7                     LDU  #IRQVEC        ; POINT U TO NEXT RAM DESTINATION
0271 d098 c6 04                        LDB  #4             ; MOVE 4 MORE BYTES
0272 d09a bd d1 b1                     JSR  LA59A          ; MOVE 4 BYTES FROM ROM TO RAM
0273 d09d 86 39                        LDA  #$39
0274 d09f 97 f0                        STA  LINHDR-1       ; PUT RTS IN LINHDR-1
0275 d0a1 bd d4 bd                     JSR  LAD19          ; G0 DO A 'NEW'
0276                         * EXTENDED BASIC INITIALISATION
0277 d0a4 8e 00 b5                     LDX  #USR0          ; INITIALIZE ADDRESS OF START OF
0278 d0a7 9f 8d                        STX  USRADR         ; USR JUMP TABLE
0279                         * INITIALIZE THE USR CALLS TO 'FC ERROR'
0280 d0a9 ce db d1                     LDU  #LB44A         ; ADDRESS OF 'FC ERROR' ROUTINE
0281 d0ac c6 0a                        LDB  #10            ; 10 USR CALLS IN EX BASIC
0282 d0ae ef 81              L8031     STU  ,X++           ; STORE 'FC' ERROR AT USR ADDRESSES
0283 d0b0 5a                           DECB                ; FINISHED ALL 10?
0284 d0b1 26 fb                        BNE  L8031          ; NO
0285                         
0286                         * INITIALISE ACIA
0287 d0b3 86 15                        LDA  #RTS_LOW       ; DIV16 CLOCK -> 7372800 / 4 / 16 = 115200
0288 d0b5 b7 a0 00                     STA  UCTRL
0289 d0b8 8e d1 06                     LDX  #LA147-1       ; POINT X TO COLOR BASIC COPYRIGHT MESSAGE
0290 d0bb bd e0 e8                     JSR  LB99C          ; PRINT 'COLOR BASIC'
0291 d0be 8e d0 c9                     LDX  #BAWMST        ; WARM START ADDRESS
0292 d0c1 9f 6f                        STX  RSTVEC         ; SAVE IT
0293 d0c3 86 55                        LDA  #$55           ; WARM START FLAG
0294 d0c5 97 6e                        STA  RSTFLG         ; SAVE IT
0295 d0c7 20 04                        BRA  LA0F3          ; GO TO BASIC'S MAIN LOOP
0296 d0c9 12                 BAWMST    NOP                 ; NOP REQ'D FOR WARM START
0297 d0ca bd d4 d7                     JSR  LAD33          ; DO PART OF A NEW
0298 d0cd 7e d4 25           LA0F3     JMP  LAC73          ; GO TO MAIN LOOP OF BASIC
0299                         *
0300                         * FIRQ SERVICE ROUTINE
0301                         BFRQSV
0302 d0d0 3b                           RTI
0303                         *
0304                         * THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIRECT PAGE
0305 d0d1 10                 LA10D     FCB  16             ; TAB FIELD WIDTH
0306 d0d2 40                           FCB  64             ; LAST TAB ZONE
0307 d0d3 50                           FCB  80             ; PRINTER WIDTH
0308 d0d4 00                           FCB  0              ; LINE PRINTER POSITION
0309 d0d5 db d1                        FDB  LB44A          ; ARGUMENT OF EXEC COMMAND - SET TO 'FC' ERROR
0310                         * LINE INPUT ROUTINE
0311 d0d7 0c 84                        INC  CHARAD+1
0312 d0d9 26 02                        BNE  LA123
0313 d0db 0c 83                        INC  CHARAD
0314 d0dd b6 00 00           LA123     LDA  >0000
0315 d0e0 7e d1 c2                     JMP  BROMHK
0316                         *
0317                         * THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1
0318 d0e3 7e d1 c1                     JMP  BIRQSV         ; IRQ SERVICE
0319 d0e6 7e d0 d0                     JMP  BFRQSV         ; FIRQ SERVICE
0320 d0e9 7e db d1                     JMP  LB44A          ; USR ADDRESS FOR 8K BASIC (INITIALIZED TO 'FC' ERROR)
0321 d0ec 80                           FCB  $80            ; *RANDOM SEED
0322 d0ed 4f c7                        FDB  $4FC7          ; *RANDON SEED OF MANTISSA
0323 d0ef 52 59                        FDB  $5259          ; *.811635157
0324                         * BASIC COMMAND INTERPRETATION TABLE ROM IMAGE
0325 d0f1 32                 COMVEC    FCB  50             ; 50 BASIC COMMANDS
0326 d0f2 d2 20                        FDB  LAA66          ; POINTS TO RESERVED WORDS
0327 d0f4 d3 2d                        FDB  LAB67          ; POINTS TO JUMP TABLE FOR COMMANDS
0328 d0f6 1d                           FCB  29             ; 29 BASIC SECONDARY COMMANDS
0329 d0f7 d2 c0                        FDB  LAB1A          ; POINTS TO SECONDARY FUNCTION RESERVED WORDS
0330 d0f9 d1 d1                        FDB  LAA29          ; POINTS TO SECONDARY FUNCTION JUMP TABLE
0331 d0fb 00 00                        FDB  0              ; NO MORE TABLES (RES WORDS=0)
0332 d0fd 00 00                        FDB  0              ; NO MORE TABLES
0333 d0ff 00 00                        FDB  0              ; NO MORE TABLES
0334 d101 00 00                        FDB  0              ; NO MORE TABLES
0335 d103 00 00                        FDB  0              ; NO MORE TABLES
0336 d105 00 00                        FDB  0              ; NO MORE TABLES (SECONDARY FNS =0)
0337                         
0338                         * COPYRIGHT MESSAGES
0339 d107 36 38 30 39 20 45  LA147     FCC  "6809 EXTENDED BASIC"
     58 54 45 4e 44 45
     44 20 42 41 53 49
     43
0340 d11a 0d                           FCB  CR
0341 d11b 28 43 29 20 31 39            FCC  "(C) 1982 BY MICROSOFT"
     38 32 20 42 59 20
     4d 49 43 52 4f 53
     4f 46 54
0342 d130 0d 0d              LA156     FCB  CR,CR
0343 d132 00                 LA165     FCB  $00
0344                         
0345                         
0346 d133 34 16              LA35F     PSHS X,B,A          ; SAVE REGISTERS
0347 d135 9e 76                        LDX  LPTCFW         ; TAB FIELD WIDTH AND TAB ZONE
0348 d137 dc 78                        LDD  LPTWID         ; PRINTER WIDTH AND POSITION
0349 d139 9f 6a              LA37C     STX  DEVCFW         ; SAVE TAB FIELD WIDTH AND ZONE
0350 d13b d7 6c                        STB  DEVPOS         ; SAVE PRINT POSITION
0351 d13d 97 6d                        STA  DEVWID         ; SAVE PRINT WIDTH
0352 d13f 35 96                        PULS A,B,X,PC       ; RESTORE REGISTERS
0353                         
0354                         * THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASIC
0355                         * EXIT WITH BREAK KEY: CARRY = 1
0356                         * EXIT WITH ENTER KEY: CARRY = 0
0357                         LA38D
0358 d141 0f 73              LA390     CLR  IKEYIM         ; RESET BREAK CHECK KEY TEMP KEY STORAGE
0359 d143 8e 00 f4                     LDX  #LINBUF+1      ; INPUT LINE BUFFER
0360 d146 c6 01                        LDB  #1             ; ACCB CHAR COUNTER: SET TO 1 TO ALLOW A
0361                         *         BACKSPACE AS FIRST CHARACTER
0362 d148 bd d0 03           LA39A     JSR  LA171          ; GO GET A CHARACTER FROM CONSOLE IN
0363 d14b 81 08                        CMPA #BS            ; BACKSPACE
0364 d14d 26 07                        BNE  LA3B4          ; NO
0365 d14f 5a                           DECB                ; YES - DECREMENT CHAR COUNTER
0366 d150 27 ef                        BEQ  LA390          ; BRANCH IF BACK AT START OF LINE AGAIN
0367 d152 30 1f                        LEAX -1,X           ; DECREMENT BUFFER POINTER
0368 d154 20 34                        BRA  LA3E8          ; ECHO CHAR TO SCREEN
0369 d156 81 15              LA3B4     CMPA #$15           ; SHIFT RIGHT ARROW?
0370 d158 26 0a                        BNE  LA3C2          ; NO
0371                         * YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LINE
0372 d15a 5a                 LA3B8     DECB                ; DEC CHAR CTR
0373 d15b 27 e4                        BEQ  LA390          ; GO BACK TO START IF CHAR CTR = 0
0374 d15d 86 08                        LDA  #BS            ; BACKSPACE?
0375 d15f bd d0 17                     JSR  PUTCHR         ; SEND TO CONSOLE OUT (SCREEN)
0376 d162 20 f6                        BRA  LA3B8          ; KEEP GOING
0377 d164 81 03              LA3C2     CMPA #3             ; BREAK KEY?
0378 d166 1a 01                        ORCC #1             ; SET CARRY FLAG
0379 d168 27 05                        BEQ  LA3CD          ; BRANCH IF BREAK KEY DOWN
0380 d16a 81 0d              LA3C8     CMPA #CR            ; ENTER KEY?
0381 d16c 26 0d                        BNE  LA3D9          ; NO
0382 d16e 4f                 LA3CC     CLRA                ; CLEAR CARRY FLAG IF ENTER KEY - END LINE ENTRY
0383 d16f 34 01              LA3CD     PSHS CC             ; SAVE CARRY FLAG
0384 d171 bd e0 a8                     JSR  LB958          ; SEND CR TO SCREEN
0385 d174 6f 84                        CLR  ,X             ; MAKE LAST BYTE IN INPUT BUFFER = 0
0386 d176 8e 00 f3                     LDX  #LINBUF        ; RESET INPUT BUFFER POINTER
0387 d179 35 81                        PULS CC,PC          ; RESTORE CARRY FLAG
0388                         
0389                         * INSERT A CHARACTER INTO THE BASIC LINE INPUT BUFFER
0390 d17b 81 20              LA3D9     CMPA #$20           ; IS IT CONTROL CHAR?
0391 d17d 25 c9                        BLO  LA39A          ; BRANCH IF CONTROL CHARACTER
0392 d17f 81 7b                        CMPA #'z+1          ; *
0393 d181 24 c5                        BCC  LA39A          ; * IGNORE IF > LOWER CASE Z
0394 d183 c1 fa                        CMPB #LBUFMX        ; HAVE 250 OR MORE CHARACTERS BEEN ENTERED?
0395 d185 24 c1                        BCC  LA39A          ; YES, IGNORE ANY MORE
0396 d187 a7 80                        STA  ,X+            ; PUT IT IN INPUT BUFFER
0397 d189 5c                           INCB                ; INCREMENT CHARACTER COUNTER
0398 d18a bd d0 17           LA3E8     JSR  PUTCHR         ; ECHO IT TO SCREEN
0399 d18d 20 b9                        BRA  LA39A          ; GO SET SOME MORE
0400                         
0401                         
0402                         * EXEC
0403 d18f 27 05              EXEC      BEQ  LA545          ; BRANCH IF NO ARGUMENT
0404 d191 bd de c4                     JSR  LB73D          ; EVALUATE ARGUMENT - ARGUMENT RETURNED IN X
0405 d194 9f 7a                        STX  EXECJP         ; STORE X TO EXEC JUMP ADDRESS
0406 d196 6e 9f 00 7a        LA545     JMP  [EXECJP]       ; GO DO IT
0407                         
0408                         * BREAK CHECK
0409 d19a 7e d5 a6           LA549     JMP  LADEB          ; GO DO BREAK KEY CHECK
0410                         
0411                         * INKEY$
0412 d19d 96 73              INKEY     LDA  IKEYIM         ; WAS A KEY DOWN IN THE BREAK CHECK?
0413 d19f 26 03                        BNE  LA56B          ; YES
0414 d1a1 bd d0 08                     JSR  KEYIN          ; GO GET A KEY
0415 d1a4 0f 73              LA56B     CLR  IKEYIM         ; CLEAR INKEY RAM IMAGE
0416 d1a6 97 53                        STA  FPA0+3         ; STORE THE KEY IN FPA0
0417 d1a8 10 26 0c 6a                  LBNE LB68F          ; CONVERT FPA0+3 TO A STRING
0418 d1ac 97 56                        STA  STRDES         ; SET LENGTH OF STRING = 0 IF NO KEY DOWN
0419 d1ae 7e de 22                     JMP  LB69B          ; PUT A NULL STRING ONTO THE STRING STACK
0420                         
0421                         * MOVE ACCB BYTES FROM (X) TO (U)
0422 d1b1 a6 80              LA59A     LDA  ,X+            ; GET BYTE FROM X
0423 d1b3 a7 c0                        STA  ,U+            ; STORE IT AT U
0424 d1b5 5a                           DECB                ; MOVED ALL BYTES?
0425 d1b6 26 f9                        BNE  LA59A          ; NO
0426 d1b8 39                 LA5A1     RTS
0427                         
0428 d1b9 39                 LA5C4     RTS
0429                         
0430                         ** THIS ROUTINE WILL SCAN OFF THE FILE NAME FROM A BASIC LINE
0431                         ** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTERS
0432                         ** FOLLOWING THE END OF THE NAME
0433 d1ba 9d 82              LA5C7     JSR  GETCCH         ; GET CURRENT INPUT CHAR FROM BASIC LINE
0434 d1bc 27 fb              LA5C9     BEQ  LA5C4          ; RETURN IF END OF LINE
0435 d1be 7e da 03                     JMP  LB277          ; SYNTAX ERROR IF ANY MORE CHARACTERS
0436                         * IRQ SERVICE
0437                         BIRQSV
0438 d1c1 3b                 LA9C5     RTI                 ; RETURN FROM INTERRUPT
0439                         
0440                         * SET CARRY IF NUMERIC - RETURN WITH
0441                         * ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END
0442                         * OF BASIC LINE OR SUB LINE
0443 d1c2 81 3a              BROMHK    CMPA #'9+1          ; IS THIS CHARACTER >=(ASCII 9)+1?
0444 d1c4 24 0a                        BHS  LAA28          ; BRANCH IF > 9; Z SET IF = COLON
0445 d1c6 81 20                        CMPA #SPACE         ; SPACE?
0446 d1c8 26 02                        BNE  LAA24          ; NO - SET CARRY IF NUMERIC
0447 d1ca 0e 7c                        JMP  GETNCH         ; IF SPACE, GET NECT CHAR (IGNORE SPACES)
0448 d1cc 80 30              LAA24     SUBA #'0            ; * SET CARRY IF
0449 d1ce 80 d0                        SUBA #-'0           ; * CHARACTER > ASCII 0
0450 d1d0 39                 LAA28     RTS
0451                         
0452                         * DISPATCH TABLE FOR SECONDARY FUNCTIONS
0453                         * TOKENS ARE PRECEEDED BY $FF
0454                         * FIRST SET ALWAYS HAS ONE PARAMETER
0455                         FUNC_TAB
0456 d1d1 e3 c6              LAA29     FDB  SGN            ; SGN
0457 d1d3 e4 3a                        FDB  INT            ; INT
0458 d1d5 e3 df                        FDB  ABS            ; ABS
0459 d1d7 00 ad                        FDB  USRJMP         ; USR
0460 0083                    TOK_USR   EQU  *-FUNC_TAB/2+$7F
0461 ff83                    TOK_FF_USR EQU  *-FUNC_TAB/2+$FF7F
0462 d1d9 e6 6b                        FDB  RND            ; RND
0463 d1db e6 c0                        FDB  SIN            ; SIN
0464 d1dd de d7                        FDB  PEEK           ; PEEK
0465 d1df de 08                        FDB  LEN            ; LEN
0466 d1e1 dc 84                        FDB  STR            ; STR$
0467 d1e3 de 9d                        FDB  VAL            ; VAL
0468 d1e5 de 27                        FDB  ASC            ; ASC
0469 d1e7 de 13                        FDB  CHR            ; CHR$
0470 d1e9 e7 70                        FDB  ATN            ; ATN
0471 d1eb e7 38                        FDB  COS            ; COS
0472 d1ed e7 41                        FDB  TAN            ; TAN
0473 d1ef e8 b2                        FDB  EXP            ; EXP
0474 d1f1 e8 e4                        FDB  FIX            ; FIX
0475 d1f3 e8 06                        FDB  LOG            ; LOG
0476 d1f5 ea 6c                        FDB  POS            ; POS
0477 d1f7 e8 40                        FDB  SQR            ; SQR
0478 d1f9 ef 3e                        FDB  HEXDOL         ; HEX$
0479                         * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
0480 d1fb de 32                        FDB  LEFT           ; LEFT$
0481 0095                    TOK_LEFT  EQU  *-FUNC_TAB/2+$7F
0482 d1fd de 4f                        FDB  RIGHT          ; RIGHT$
0483 d1ff de 56                        FDB  MID            ; MID$
0484 0097                    TOK_MID   EQU  *-FUNC_TAB/2+$7F
0485                         * REMAINING FUNCTIONS
0486 d201 d1 9d                        FDB  INKEY          ; INKEY$
0487 0098                    TOK_INKEY EQU  *-FUNC_TAB/2+$7F
0488 d203 dc 75                        FDB  MEM            ; MEM
0489 d205 ea 74                        FDB  VARPT          ; VARPTR
0490 d207 eb 34                        FDB  INSTR          ; INSTR
0491 d209 eb 04                        FDB  STRING         ; STRING$
0492 001d                    NUM_SEC_FNS EQU  *-FUNC_TAB/2
0493                         
0494                         * THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESSES FOR ARITHMETIC
0495                         * AND LOGICAL OPERATORS - THE NEGATION OPERATORS DO NOT ACT ON TWO OPERANDS
0496                         * S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREATED SEPARATELY IN THE
0497                         * EXPRESSION EVALUATION ROUTINE. THEY ARE:
0498                         * UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGATION (NOT), PRECEDENCE $5A
0499                         * THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, PRECEDENCE $64.
0500                         * A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSION OR PARENTHESES
0501                         *
0502 d20b 79                 LAA51     FCB  $79
0503 d20c e1 11                        FDB  LB9C5          ; +
0504 d20e 79                           FCB  $79
0505 d20f e1 08                        FDB  LB9BC          ; -
0506 d211 7b                           FCB  $7B
0507 d212 e2 18                        FDB  LBACC          ; *
0508 d214 7b                           FCB  $7B
0509 d215 e2 dd                        FDB  LBB91          ; /
0510 d217 7f                           FCB  $7F
0511 d218 e8 49                        FDB  L8489          ; EXPONENTIATION
0512 d21a 50                           FCB  $50
0513 d21b da 5c                        FDB  LB2D5          ; AND
0514 d21d 46                           FCB  $46
0515 d21e da 5b                        FDB  LB2D4          ; OR
0516                         
0517                         * THIS IS THE RESERVED WORD TABLE
0518                         * FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS
0519 d220 46 4f              LAA66     FCC  "FO"           ; 80
0520 d222 d2                           FCB  $80+'R
0521 d223 47                           FCC  "G"            ; 81
0522 d224 cf                           FCB  $80+'O
0523 0081                    TOK_GO    EQU  $81
0524 d225 52 45                        FCC  "RE"           ; 82
0525 d227 cd                           FCB  $80+'M
0526 d228 a7                           FCB  ''+$80         ; 83
0527 d229 45 4c 53                     FCC  "ELS"          ; 84
0528 d22c c5                           FCB  $80+'E
0529 d22d 49                           FCC  "I"            ; 85
0530 d22e c6                           FCB  $80+'F
0531 d22f 44 41 54                     FCC  "DAT"          ; 86
0532 d232 c1                           FCB  $80+'A
0533 d233 50 52 49 4e                  FCC  "PRIN"         ; 87
0534 d237 d4                           FCB  $80+'T
0535 d238 4f                           FCC  "O"            ; 88
0536 d239 ce                           FCB  $80+'N
0537 d23a 49 4e 50 55                  FCC  "INPU"         ; 89
0538 d23e d4                           FCB  $80+'T
0539 d23f 45 4e                        FCC  "EN"           ; 8A
0540 d241 c4                           FCB  $80+'D
0541 d242 4e 45 58                     FCC  "NEX"          ; 8B
0542 d245 d4                           FCB  $80+'T
0543 d246 44 49                        FCC  "DI"           ; 8C
0544 d248 cd                           FCB  $80+'M
0545 d249 52 45 41                     FCC  "REA"          ; 8D
0546 d24c c4                           FCB  $80+'D
0547 d24d 52 55                        FCC  "RU"           ; 8E
0548 d24f ce                           FCB  $80+'N
0549 d250 52 45 53 54 4f 52            FCC  "RESTOR"       ; 8F
0550 d256 c5                           FCB  $80+'E
0551 d257 52 45 54 55 52               FCC  "RETUR"        ; 90
0552 d25c ce                           FCB  $80+'N
0553 d25d 53 54 4f                     FCC  "STO"          ; 91
0554 d260 d0                           FCB  $80+'P
0555 d261 50 4f 4b                     FCC  "POK"          ; 92
0556 d264 c5                           FCB  $80+'E
0557 d265 43 4f 4e                     FCC  "CON"          ; 93
0558 d268 d4                           FCB  $80+'T
0559 d269 4c 49 53                     FCC  "LIS"          ; 94
0560 d26c d4                           FCB  $80+'T
0561 d26d 43 4c 45 41                  FCC  "CLEA"         ; 95
0562 d271 d2                           FCB  $80+'R
0563 d272 4e 45                        FCC  "NE"           ; 96
0564 d274 d7                           FCB  $80+'W
0565 d275 45 58 45                     FCC  "EXE"          ; 97
0566 d278 c3                           FCB  $80+'C
0567 d279 54 52 4f                     FCC  "TRO"          ; 98
0568 d27c ce                           FCB  $80+'N
0569 d27d 54 52 4f 46                  FCC  "TROF"         ; 99
0570 d281 c6                           FCB  $80+'F
0571 d282 44 45                        FCC  "DE"           ; 9A
0572 d284 cc                           FCB  $80+'L
0573 d285 44 45                        FCC  "DE"           ; 9B
0574 d287 c6                           FCB  $80+'F
0575 d288 4c 49 4e                     FCC  "LIN"          ; 9C
0576 d28b c5                           FCB  $80+'E
0577 d28c 52 45 4e 55                  FCC  "RENU"         ; 9D
0578 d290 cd                           FCB  $80+'M
0579 d291 45 44 49                     FCC  "EDI"          ; 9E
0580 d294 d4                           FCB  $80+'T
0581                         * END OF EXECUTABLE COMMANDS. THE REMAINDER OF THE TABLE ARE NON-EXECUTABLE TOKENS
0582 d295 54 41 42                     FCC  "TAB"          ; 9F
0583 d298 a8                           FCB  $80+'(
0584 009f                    TOK_TAB   EQU  $9F
0585 d299 54                           FCC  "T"            ; A0
0586 d29a cf                           FCB  $80+'O
0587 00a0                    TOK_TO    EQU  $A0
0588 d29b 53 55                        FCC  "SU"           ; A1
0589 d29d c2                           FCB  $80+'B
0590 00a1                    TOK_SUB   EQU  $A1
0591 d29e 54 48 45                     FCC  "THE"          ; A2
0592 d2a1 ce                           FCB  $80+'N
0593 00a2                    TOK_THEN  EQU  $A2
0594 d2a2 4e 4f                        FCC  "NO"           ; A3
0595 d2a4 d4                           FCB  $80+'T
0596 00a3                    TOK_NOT   EQU  $A3
0597 d2a5 53 54 45                     FCC  "STE"          ; A4
0598 d2a8 d0                           FCB  $80+'P
0599 00a4                    TOK_STEP  EQU  $A4
0600 d2a9 4f 46                        FCC  "OF"           ; A5
0601 d2ab c6                           FCB  $80+'F
0602 d2ac ab                           FCB  '++$80         ; A6
0603 00a6                    TOK_PLUS  EQU  $A6
0604 d2ad ad                           FCB  '-+$80         ; A7
0605 00a7                    TOK_MINUS EQU  $A7
0606 d2ae aa                           FCB  '*+$80         ; A8
0607 d2af af                           FCB  '/+$80         ; A9
0608 d2b0 de                           FCB  '^+$80         ; AA
0609 d2b1 41 4e                        FCC  "AN"           ; AB
0610 d2b3 c4                           FCB  $80+'D
0611 d2b4 4f                           FCC  "O"            ; AC
0612 d2b5 d2                           FCB  $80+'R
0613 d2b6 be                           FCB  '>+$80         ; AD
0614 00ad                    TOK_GREATER EQU  $AD
0615 d2b7 bd                           FCB  '=+$80         ; AE
0616 00ae                    TOK_EQUALS EQU  $AE
0617 d2b8 bc                           FCB  '<+$80         ; AF
0618 d2b9 46                           FCC  "F"            ; B0
0619 d2ba ce                           FCB  $80+'N
0620 00b0                    TOK_FN    EQU  $B0
0621 d2bb 55 53 49 4e                  FCC  "USIN"         ; B1
0622 d2bf c7                           FCB  $80+'G
0623 00b1                    TOK_USING EQU  $B1
0624                         *
0625                         
0626                         * FIRST SET ALWAYS HAS ONE PARAMETER
0627 d2c0 53 47              LAB1A     FCC  "SG"           ; 80
0628 d2c2 ce                           FCB  $80+'N
0629 d2c3 49 4e                        FCC  "IN"           ; 81
0630 d2c5 d4                           FCB  $80+'T
0631 d2c6 41 42                        FCC  "AB"           ; 82
0632 d2c8 d3                           FCB  $80+'S
0633 d2c9 55 53                        FCC  "US"           ; 83
0634 d2cb d2                           FCB  $80+'R
0635 d2cc 52 4e                        FCC  "RN"           ; 84
0636 d2ce c4                           FCB  $80+'D
0637 d2cf 53 49                        FCC  "SI"           ; 85
0638 d2d1 ce                           FCB  $80+'N
0639 d2d2 50 45 45                     FCC  "PEE"          ; 86
0640 d2d5 cb                           FCB  $80+'K
0641 d2d6 4c 45                        FCC  "LE"           ; 87
0642 d2d8 ce                           FCB  $80+'N
0643 d2d9 53 54 52                     FCC  "STR"          ; 88
0644 d2dc a4                           FCB  $80+'$
0645 d2dd 56 41                        FCC  "VA"           ; 89
0646 d2df cc                           FCB  $80+'L
0647 d2e0 41 53                        FCC  "AS"           ; 8A
0648 d2e2 c3                           FCB  $80+'C
0649 d2e3 43 48 52                     FCC  "CHR"          ; 8B
0650 d2e6 a4                           FCB  $80+'$
0651 d2e7 41 54                        FCC  "AT"           ; 8C
0652 d2e9 ce                           FCB  $80+'N
0653 d2ea 43 4f                        FCC  "CO"           ; 8D
0654 d2ec d3                           FCB  $80+'S
0655 d2ed 54 41                        FCC  "TA"           ; 8E
0656 d2ef ce                           FCB  $80+'N
0657 d2f0 45 58                        FCC  "EX"           ; 8F
0658 d2f2 d0                           FCB  $80+'P
0659 d2f3 46 49                        FCC  "FI"           ; 90
0660 d2f5 d8                           FCB  $80+'X
0661 d2f6 4c 4f                        FCC  "LO"           ; 91
0662 d2f8 c7                           FCB  $80+'G
0663 d2f9 50 4f                        FCC  "PO"           ; 92
0664 d2fb d3                           FCB  $80+'S
0665 d2fc 53 51                        FCC  "SQ"           ; 93
0666 d2fe d2                           FCB  $80+'R
0667 d2ff 48 45 58                     FCC  "HEX"          ; 94
0668 d302 a4                           FCB  $80+'$
0669                         * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
0670 d303 4c 45 46 54                  FCC  "LEFT"         ; 95
0671 d307 a4                           FCB  $80+'$
0672 d308 52 49 47 48 54               FCC  "RIGHT"        ; 96
0673 d30d a4                           FCB  $80+'$
0674 d30e 4d 49 44                     FCC  "MID"          ; 97
0675 d311 a4                           FCB  $80+'$
0676                         * REMAINING FUNCTIONS
0677 d312 49 4e 4b 45 59               FCC  "INKEY"        ; 98
0678 d317 a4                           FCB  $80+'$
0679 d318 4d 45                        FCC  "ME"           ; 99
0680 d31a cd                           FCB  $80+'M
0681 d31b 56 41 52 50 54               FCC  "VARPT"        ; 9A
0682 d320 d2                           FCB  $80+'R
0683 d321 49 4e 53 54                  FCC  "INST"         ; 9B
0684 d325 d2                           FCB  $80+'R
0685 d326 53 54 52 49 4e 47            FCC  "STRING"       ; 9C
0686 d32c a4                           FCB  $80+'$
0687                         
0688                         *
0689                         * DISPATCH TABLE FOR COMMANDS TOKEN #
0690                         CMD_TAB
0691 d32d d4 eb              LAB67     FDB  FOR            ; 80
0692 d32f d6 36                        FDB  GO             ; 81
0693 d331 d6 93                        FDB  REM            ; 82
0694 0082                    TOK_REM   EQU  *-CMD_TAB/2+$7F
0695 d333 d6 93                        FDB  REM            ; 83 (')
0696 0083                    TOK_SNGL_Q EQU  *-CMD_TAB/2+$7F
0697 d335 d6 93                        FDB  REM            ; 84 (ELSE)
0698 0084                    TOK_ELSE  EQU  *-CMD_TAB/2+$7F
0699 d337 d6 c4                        FDB  IF             ; 85
0700 0085                    TOK_IF    EQU  *-CMD_TAB/2+$7F
0701 d339 d6 90                        FDB  DATA           ; 86
0702 0086                    TOK_DATA  EQU  *-CMD_TAB/2+$7F
0703 d33b e0 6d                        FDB  PRINT          ; 87
0704 0087                    TOK_PRINT EQU  *-CMD_TAB/2+$7F
0705 d33d d6 f2                        FDB  ON             ; 88
0706 d33f d7 9f                        FDB  INPUT          ; 89
0707 0089                    TOK_INPUT EQU  *-CMD_TAB/2+$7F
0708 d341 d5 bd                        FDB  END            ; 8A
0709 d343 d8 84                        FDB  NEXT           ; 8B
0710 d345 da d5                        FDB  DIM            ; 8C
0711 d347 d7 d9                        FDB  READ           ; 8D
0712 d349 d6 2b                        FDB  RUN            ; 8E
0713 d34b d5 9f                        FDB  RESTOR         ; 8F
0714 d34d d6 70                        FDB  RETURN         ; 90
0715 d34f d5 c1                        FDB  STOP           ; 91
0716 d351 de de                        FDB  POKE           ; 92
0717 d353 d5 e6                        FDB  CONT           ; 93
0718 d355 de e5                        FDB  LIST           ; 94
0719 d357 d5 f7                        FDB  CLEAR          ; 95
0720 d359 d4 bb                        FDB  NEW            ; 96
0721 d35b d1 8f                        FDB  EXEC           ; 97
0722 d35d ea 67                        FDB  TRON           ; 98
0723 d35f ea 68                        FDB  TROFF          ; 99
0724 d361 ec e3                        FDB  DEL            ; 9A
0725 d363 ec 27                        FDB  DEF            ; 9B
0726 d365 f3 d1                        FDB  LINE           ; 9C
0727 d367 ed 6d                        FDB  RENUM          ; 9D
0728 d369 e8 f3                        FDB  EDIT           ; 9E
0729 009e                    TOK_HIGH_EXEC EQU  *-CMD_TAB/2+$7F
0730                         
0731                         * ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY
0732 d36b 4e 46              LABAF     FCC  "NF"           ; 0 NEXT WITHOUT FOR
0733 d36d 53 4e                        FCC  "SN"           ; 1 SYNTAX ERROR
0734 d36f 52 47                        FCC  "RG"           ; 2 RETURN WITHOUT GOSUB
0735 d371 4f 44                        FCC  "OD"           ; 3 OUT OF DATA
0736 d373 46 43                        FCC  "FC"           ; 4 ILLEGAL FUNCTION CALL
0737 d375 4f 56                        FCC  "OV"           ; 5 OVERFLOW
0738 d377 4f 4d                        FCC  "OM"           ; 6 OUT OF MEMORY
0739 d379 55 4c                        FCC  "UL"           ; 7 UNDEFINED LINE NUMBER
0740 d37b 42 53                        FCC  "BS"           ; 8 BAD SUBSCRIPT
0741 d37d 44 44                        FCC  "DD"           ; 9 REDIMENSIONED ARRAY
0742 d37f 2f 30                        FCC  "/0"           ; 10 DIVISION BY ZERO
0743 d381 49 44                        FCC  "ID"           ; 11 ILLEGAL DIRECT STATEMENT
0744 d383 54 4d                        FCC  "TM"           ; 12 TYPE MISMATCH
0745 d385 4f 53                        FCC  "OS"           ; 13 OUT OF STRING SPACE
0746 d387 4c 53                        FCC  "LS"           ; 14 STRING TOO LONG
0747 d389 53 54                        FCC  "ST"           ; 15 STRING FORMULA TOO COMPLEX
0748 d38b 43 4e                        FCC  "CN"           ; 16 CAN'T CONTINUE
0749 d38d 46 44                        FCC  "FD"           ; 17 BAD FILE DATA
0750 d38f 41 4f                        FCC  "AO"           ; 18 FILE ALREADY OPEN
0751 d391 44 4e                        FCC  "DN"           ; 19 DEVICE NUMBER ERROR
0752 d393 49 4f                        FCC  "IO"           ; 20 I/O ERROR
0753 d395 46 4d                        FCC  "FM"           ; 21 BAD FILE MODE
0754 d397 4e 4f                        FCC  "NO"           ; 22 FILE NOT OPEN
0755 d399 49 45                        FCC  "IE"           ; 23 INPUT PAST END OF FILE
0756 d39b 44 53                        FCC  "DS"           ; 24 DIRECT STATEMENT IN FILE
0757                         * ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC
0758 d39d 55 46              L890B     FCC  "UF"           ; 25 UNDEFINED FUNCTION (FN) CALL
0759 d39f 4e 45              L890D     FCC  "NE"           ; 26 FILE NOT FOUND
0760                         
0761 d3a1 20 45 52 52 4f 52  LABE1     FCC  " ERROR"
0762 d3a7 00                           FCB  $00
0763 d3a8 20 49 4e 20        LABE8     FCC  " IN "
0764 d3ac 00                           FCB  $00
0765 d3ad 0d                 LABED     FCB  CR
0766 d3ae 4f 4b              LABEE     FCC  "OK"
0767 d3b0 0d 00                        FCB  CR,$00
0768 d3b2 0d                 LABF2     FCB  CR
0769 d3b3 42 52 45 41 4b               FCC  "BREAK"
0770 d3b8 00                           FCB  $00
0771                         
0772                         * SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DATA.
0773                         * THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEING
0774                         * SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT DATA IS 18
0775                         * BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DATA IS 5 BYTES
0776                         * WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DATA
0777                         * IS CONSIDERED 'GOSUB/RETURN'
0778 d3b9 30 64              LABF9     LEAX 4,S            ; POINT X TO 3RD ADDRESS ON STACK - IGNORE THE
0779                         *         FIRST TWO RETURN ADDRESSES ON THE STACK
0780 d3bb c6 12              LABFB     LDB  #18            ; 18 BYTES SAVED ON STACK FOR EACH 'FOR' LOOP
0781 d3bd 9f 0f                        STX  TEMPTR         ; SAVE POINTER
0782 d3bf a6 84                        LDA  ,X             ; GET 1ST BYTE
0783 d3c1 80 80                        SUBA #$80           ; * CHECK FOR TYPE OF STACK JUMP FOUND
0784 d3c3 26 15                        BNE  LAC1A          ; * BRANCH IF NOT 'FOR/NEXT'
0785 d3c5 ae 01                        LDX  1,X            ; = GET INDEX VARIABLE DESCRIPTOR
0786 d3c7 9f 11                        STX  TMPTR1         ; = POINTER AND SAVE IT IN TMPTR1
0787 d3c9 9e 3b                        LDX  VARDES         ; GET INDEX VARIABLE BEING SEARCHED FOR
0788 d3cb 27 09                        BEQ  LAC16          ; BRANCH IF DEFAULT INDEX VARIABLE - USE THE
0789                         *                             ; FIRST 'FOR/NEXT' DATA FOUND ON STACK
0790                         *                             ; IF NO INDEX VARIABLE AFTER 'NEXT'
0791 d3cd 9c 11                        CMPX TMPTR1         ; DOES THE STACK INDEX MATCH THE ONE
0792                         *                             ; BEING SEARCHED FOR?
0793 d3cf 27 09                        BEQ  LAC1A          ; YES
0794 d3d1 9e 0f                        LDX  TEMPTR         ; * RESTORE INITIAL POINTER, ADD
0795 d3d3 3a                           ABX                 ; * 18 TO IT AND LOOK FOR
0796 d3d4 20 e5                        BRA  LABFB          ; * NEXT BLOCK OF DATA
0797 d3d6 9e 11              LAC16     LDX  TMPTR1         ; = GET 1ST INDEX VARIABLE FOUND AND
0798 d3d8 9f 3b                        STX  VARDES         ; = SAVE AS 'NEXT' INDEX
0799 d3da 9e 0f              LAC1A     LDX  TEMPTR         ; POINT X TO START OF 'FOR/NEXT' DATA
0800 d3dc 4d                           TSTA                ; SET ZERO FLAG IF 'FOR/NEXT' DATA
0801 d3dd 39                           RTS
0802                         * CHECK FOR MEMORY SPACE FOR NEW TOP OF
0803                         * ARRAYS AND MOVE ARRAYS TO NEW LOCATION
0804 d3de 8d 17              LAC1E     BSR  LAC37          ; ACCD = NEW BOTTOM OF FREE RAM - IS THERE
0805                         *                             ; ROOM FOR THE STACK?
0806                         * MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND
0807                         * SAVE FINAL VALUE OF U IN V45
0808 d3e0 de 41              LAC20     LDU  V41            ; POINT U TO DESTINATION ADDRESS (V41)
0809 d3e2 33 41                        LEAU 1,U            ; ADD ONE TO U - COMPENSATE FOR FIRST PSHU
0810 d3e4 9e 43                        LDX  V43            ; POINT X TO SOURCE ADDRESS (V43)
0811 d3e6 30 01                        LEAX 1,X            ; ADD ONE - COMPENSATE FOR FIRST LDA ,X
0812 d3e8 a6 82              LAC28     LDA  ,-X            ; GRAB A BYTE FROM SOURCE
0813 d3ea 36 02                        PSHU A              ; MOVE IT TO DESTINATION
0814 d3ec 9c 47                        CMPX V47            ; DONE?
0815 d3ee 26 f8                        BNE  LAC28          ; NO - KEEP MOVING BYTES
0816 d3f0 df 45                        STU  V45            ; SAVE FINAL DESTINATION ADDRESS
0817 d3f2 39                 LAC32     RTS
0818                         * CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB
0819                         * BYTES IN FREE RAM - OM ERROR IF NOT
0820 d3f3 4f                 LAC33     CLRA                ; * ACCD CONTAINS NUMBER OF EXTRA
0821 d3f4 58                           ASLB                ; * BYTES TO PUT ON STACK
0822 d3f5 d3 1f                        ADDD ARYEND         ; END OF PROGRAM AND VARIABLES
0823 d3f7 c3 00 3a           LAC37     ADDD #STKBUF        ; ADD STACK BUFFER - ROOM FOR STACK?
0824 d3fa 25 08                        BCS  LAC44          ; BRANCH IF GREATER THAN $FFFF
0825 d3fc 10 df 17                     STS  BOTSTK         ; CURRENT NEW BOTTOM OF STACK STACK POINTER
0826 d3ff 10 93 17                     CMPD BOTSTK         ; ARE WE GOING TO BE BELOW STACK?
0827 d402 25 ee                        BCS  LAC32          ; YES - NO ERROR
0828 d404 c6 0c              LAC44     LDB  #6*2           ; OUT OF MEMORY ERROR
0829                         
0830                         * ERROR SERVICING ROUTINE
0831 d406 bd d4 d7           LAC46     JSR  LAD33          ; RESET STACK, STRING STACK, CONTINUE POINTER
0832 d409 bd e0 ac                     JSR  LB95C          ; SEND A CR TO SCREEN
0833 d40c bd e0 fb                     JSR  LB9AF          ; SEND A '?' TO SCREEN
0834 d40f 8e d3 6b                     LDX  #LABAF         ; POINT TO ERROR TABLE
0835 d412 3a                 LAC60     ABX                 ; ADD MESSAGE NUMBER OFFSET
0836 d413 8d 31                        BSR  LACA0          ; * GET TWO CHARACTERS FROM X AND
0837 d415 8d 2f                        BSR  LACA0          ; * SEND TO CONSOLE OUT (SCREEN)
0838 d417 8e d3 a0                     LDX  #LABE1-1       ; POINT TO "ERROR" MESSAGE
0839 d41a bd e0 e8           LAC68     JSR  LB99C          ; PRINT MESSAGE POINTED TO BY X
0840 d41d 96 68                        LDA  CURLIN         ; GET CURRENT LINE NUMBER (CURL IN)
0841 d41f 4c                           INCA                ; TEST FOR DIRECT MODE
0842 d420 27 03                        BEQ  LAC73          ; BRANCH IF DIRECT MODE
0843 d422 bd e5 11                     JSR  LBDC5          ; PRINT 'IN ****'
0844                         
0845                         * THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE
0846 d425 bd e0 ac           LAC73     JSR  LB95C          ; MOVE CURSOR TO START OF LINE
0847 d428 8e d3 ad                     LDX  #LABED         ; POINT X TO 'OK', CR MESSAGE
0848 d42b bd e0 e8                     JSR  LB99C          ; PRINT 'OK', CR
0849 d42e bd d1 41           LAC7C     JSR  LA390          ; GO GET AN INPUT LINE
0850 d431 ce ff ff                     LDU  #$FFFF         ; THE LINE NUMBER FOR DIRECT MODE IS $FFFF
0851 d434 df 68                        STU  CURLIN         ; SAVE IT IN CURLIN
0852 d436 25 f6                        BCS  LAC7C          ; BRANCH IF LINE INPUT TERMINATED BY BREAK
0853 d438 9f 83                        STX  CHARAD         ; SAVE (X) AS CURRENT INPUT POINTER - THIS WILL
0854                         *         ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. THE
0855                         *         LINE JUST ENTERED WILL BE INTERPRETED
0856 d43a 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
0857 d43c 27 f0                        BEQ  LAC7C          ; NO LINE INPUT - GET ANOTHER LINE
0858 d43e 25 0b                        BCS  LACA5          ; BRANCH IF NUMER1C - THERE WAS A LINE NUMBER BEFORE
0859                         *         THE  STATEMENT ENTERED, SO THIS STATEMENT
0860                         *         WILL BE MERGED INTO THE BASIC PROGRAM
0861 d440 bd df 9a                     JSR  LB821          ; GO CRUNCH LINE
0862 d443 7e d5 74                     JMP  LADC0          ; GO EXECUTE THE STATEMENT (LIVE KEYBOARD)
0863                         *
0864 d446 a6 80              LACA0     LDA  ,X+            ; GET A CHARACTER
0865 d448 7e e0 fd                     JMP  LB9B1          ; SEND TO CONSOLE OUT
0866                         * TAKE A LINE FROM THE LINE INPUT BUFFER
0867                         * AND INSERT IT INTO THE BASIC PROGRAM
0868 d44b bd d7 17           LACA5     JSR  LAF67          ; CONVERT LINE NUMBER TO BINARY
0869 d44e 9e 2b              LACA8     LDX  BINVAL         ; GET CONVERTED LINE NUMBER
0870 d450 9f f1                        STX  LINHDR         ; STORE IT IN LINE INPUT HEADER
0871 d452 bd df 9a                     JSR  LB821          ; GO CRUNCH THE LINE
0872 d455 d7 03                        STB  TMPLOC         ; SAVE LINE LENGTH
0873 d457 8d 4c                        BSR  LAD01          ; FIND OUT WHERE TO INSERT LINE
0874 d459 25 12                        BCS  LACC8          ; RANCH IF LINE NUMBER DOES NOT ALREADY EXIST
0875 d45b dc 47                        LDD  V47            ; GET ABSOLUTE ADDRESS OF LINE NUMBER
0876 d45d a3 84                        SUBD ,X             ; SUBTRACT ADDRESS OF NEXT LINE NUMBER
0877 d45f d3 1b                        ADDD VARTAB         ; * ADD TO CURRENT END OF PROGRAM - THIS WILL REMOVE
0878 d461 dd 1b                        STD  VARTAB         ; * THE LENGTH OF THIS LINE NUMBER FROM THE PROGRAM
0879 d463 ee 84                        LDU  ,X             ; POINT U TO ADDRESS OF NEXT LINE NUMBER
0880                         * DELETE OLD LINE FROM BASIC PROGRAM
0881 d465 37 02              LACC0     PULU A              ; GET A BYTE FROM WHAT'S LEFT OF PROGRAM
0882 d467 a7 80                        STA  ,X+            ; MOVE IT DOWN
0883 d469 9c 1b                        CMPX VARTAB         ; COMPARE TO END OF BASIC PROGRAM
0884 d46b 26 f8                        BNE  LACC0          ; BRANCH IF NOT AT END
0885 d46d 96 f3              LACC8     LDA  LINBUF         ; * CHECK TO SEE IF THERE IS A LINE IN
0886 d46f 27 1c                        BEQ  LACE9          ; * THE BUFFER AND BRANCH IF NONE
0887 d471 dc 1b                        LDD  VARTAB         ; = SAVE CURRENT END OF
0888 d473 dd 43                        STD  V43            ; = PROGRAM IN V43
0889 d475 db 03                        ADDB TMPLOC         ; * ADD LENGTH OF CRUNCHED LINE,
0890 d477 89 00                        ADCA #0             ; * PROPOGATE CARRY AND SAVE NEW END
0891 d479 dd 41                        STD  V41            ; * OF PROGRAM IN V41
0892 d47b bd d3 de                     JSR  LAC1E          ; = MAKE SURE THERE'S ENOUGH RAM FOR THIS
0893                         *         =    LINE & MAKE A HOLE IN BASIC FOR NEW LINE
0894 d47e ce 00 ef                     LDU  #LINHDR-2      ; POINT U TO LINE TO BE INSERTED
0895 d481 37 02              LACDD     PULU A              ; GET A BYTE FROM NEW LINE
0896 d483 a7 80                        STA  ,X+            ; INSERT IT IN PROGRAM
0897 d485 9c 45                        CMPX V45            ; * COMPARE TO ADDRESS OF END OF INSERTED
0898 d487 26 f8                        BNE  LACDD          ; * LINE AND BRANCH IF NOT DONE
0899 d489 9e 41                        LDX  V41            ; = GET AND SAVE
0900 d48b 9f 1b                        STX  VARTAB         ; = END OF PROGRAM
0901 d48d 8d 36              LACE9     BSR  LAD21          ; RESET INPUT POINTER, CLEAR VARIABLES, INITIALIZE
0902 d48f 8d 02                        BSR  LACEF          ; ADJUST START OF NEXT LINE ADDRESSES
0903 d491 20 9b                        BRA  LAC7C          ; EENTER BASIC'S INPUT LOOP
0904                         * COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BASIC PROGRAM
0905 d493 9e 19              LACEF     LDX  TXTTAB         ; POINT X TO START OF PROGRAM
0906 d495 ec 84              LACF1     LDD  ,X             ; GET ADDRESS OF NEXT LINE
0907 d497 27 21                        BEQ  LAD16          ; RETURN IF END OF PROGRAM
0908 d499 33 04                        LEAU 4,X            ; POINT U TO START OF BASIC TEXT IN LINE
0909 d49b a6 c0              LACF7     LDA  ,U+            ; * SKIP THROUGH THE LINE UNTIL A
0910 d49d 26 fc                        BNE  LACF7          ; * ZERO (END OF LINE) IS FOUND
0911 d49f ef 84                        STU  ,X             ; SAVE THE NEW START OF NEXT LINE ADDRESS
0912 d4a1 ae 84                        LDX  ,X             ; POINT X TO START OF NEXT LINE
0913 d4a3 20 f0                        BRA  LACF1          ; KEEP GOING
0914                         *
0915                         * FIND A LINE NUMBER IN THE BASIC PROGRAM
0916                         * RETURN WITH CARRY SET IF NO MATCH FOUND
0917 d4a5 dc 2b              LAD01     LDD  BINVAL         ; GET THE LINE NUMBER TO FIND
0918 d4a7 9e 19                        LDX  TXTTAB         ; BEGINNING OF PROGRAM
0919 d4a9 ee 84              LAD05     LDU  ,X             ; GET ADDRESS OF NEXT LINE NUMBER
0920 d4ab 27 09                        BEQ  LAD12          ; BRANCH IF END OF PROG
0921 d4ad 10 a3 02                     CMPD 2,X            ; IS IT A MATCH?
0922 d4b0 23 06                        BLS  LAD14          ; CARRY SET IF LOWER; CARRY CLEAR IF MATCH
0923 d4b2 ae 84                        LDX  ,X             ; X = ADDRESS OF NEXT LINE
0924 d4b4 20 f3                        BRA  LAD05          ; KEEP LOOPING FOR LINE NUMBER
0925 d4b6 1a 01              LAD12     ORCC #1             ; SET CARRY FLAG
0926 d4b8 9f 47              LAD14     STX  V47            ; SAVE MATCH LINE NUMBER OR NUMBER OF LINE JUST AFTER
0927                         *                             ; WHERE IT SHOULD HAVE BEEN
0928 d4ba 39                 LAD16     RTS
0929                         
0930                         * NEW
0931 d4bb 26 fb              NEW       BNE  LAD14          ; BRANCH IF ARGUMENT GIVEN
0932 d4bd 9e 19              LAD19     LDX  TXTTAB         ; GET START OF BASIC
0933 d4bf 6f 80                        CLR  ,X+            ; * PUT 2 ZERO BYTES THERE - ERASE
0934 d4c1 6f 80                        CLR  ,X+            ; * THE BASIC PROGRAM
0935 d4c3 9f 1b                        STX  VARTAB         ; AND THE NEXT ADDRESS IS NOW THE END OF PROGRAM
0936 d4c5 9e 19              LAD21     LDX  TXTTAB         ; GET START OF BASIC
0937 d4c7 bd d6 6b                     JSR  LAEBB          ; PUT INPUT POINTER ONE BEFORE START OF BASIC
0938                         * ERASE ALL VARIABLES
0939 d4ca 9e 27              LAD26     LDX  MEMSIZ         ; * RESET START OF STRING VARIABLES
0940 d4cc 9f 23                        STX  STRTAB         ; * TO TOP OF STRING SPACE
0941 d4ce bd d5 9f                     JSR  RESTOR         ; RESET 'DATA' POINTER TO START OF BASIC
0942 d4d1 9e 1b                        LDX  VARTAB         ; * GET START OF VARIABLES AND USE IT
0943 d4d3 9f 1d                        STX  ARYTAB         ; * TO RESET START OF ARRAYS
0944 d4d5 9f 1f                        STX  ARYEND         ; RESET END OF ARRAYS
0945 d4d7 8e 00 c9           LAD33     LDX  #STRSTK        ; * RESET STRING STACK POINTER TO
0946 d4da 9f 0b                        STX  TEMPPT         ; * BOTTOM OF STRING STACK
0947 d4dc ae e4                        LDX  ,S             ; GET RETURN ADDRESS OFF STACK
0948 d4de 10 de 21                     LDS  FRETOP         ; RESTORE STACK POINTER
0949 d4e1 6f e2                        CLR  ,-S            ; PUT A ZERO BYTE ON STACK - TO CLEAR ANY RETURN OF
0950                         *                             ; FOR/NEXT DATA FROM THE STACK
0951 d4e3 0f 2d                        CLR  OLDPTR         ; RESET 'CONT' ADDRESS SO YOU
0952 d4e5 0f 2e                        CLR  OLDPTR+1       ; 'CAN'T CONTINUE'
0953 d4e7 0f 08                        CLR  ARYDIS         ; CLEAR THE ARRAY DISABLE FLAG
0954 d4e9 6e 84                        JMP  ,X             ; RETURN TO CALLING ROUTINE - THIS IS NECESSARY
0955                         *                             ; SINCE THE STACK WAS RESET
0956                         *
0957                         * FOR
0958                         *
0959                         * THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR
0960                         * EACH FOR-NEXT LOOP WHICH IS BEING PROCESSED. THESE
0961                         * BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);
0962                         *         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=FP VALUE OF STEP;
0963                         *         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO; 1 IF POSITIVE;
0964                         * 9-13=FP VALUE OF 'TO' PARAMETER;
0965                         * 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE END
0966                         *         OF   THE LINE CONTAINING THE 'FOR' STATEMENT
0967 d4eb 86 80              FOR       LDA  #$80           ; * SAVE THE DISABLE ARRAY FLAG IN VO8
0968 d4ed 97 08                        STA  ARYDIS         ; * DO NOT ALLOW THE INDEX VARIABLE TO BE AN ARRAY
0969 d4ef bd d7 39                     JSR  LET            ; SET INDEX VARIABLE TO INITIAL VALUE
0970 d4f2 bd d3 b9                     JSR  LABF9          ; SEARCH THE STACK FOR 'FOR/NEXT' DATA
0971 d4f5 32 62                        LEAS 2,S            ; PURGE RETURN ADDRESS OFF OF THE STACK
0972 d4f7 26 04                        BNE  LAD59          ; BRANCH IF INDEX VARIABLE NOT ALREADY BEING USED
0973 d4f9 9e 0f                        LDX  TEMPTR         ; GET (ADDRESS + 18) OF MATCHED 'FOR/NEXT' DATA
0974 d4fb 32 85                        LEAS B,X            ; MOVE THE STACK POINTER TO THE BEGINNING OF THE
0975                         * MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
0976                         * OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY
0977                         * ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
0978                         * THIS POINT ON THE STACK
0979 d4fd c6 09              LAD59     LDB  #$09           ; * CHECK FOR ROOM FOR 18 BYTES
0980 d4ff bd d3 f3                     JSR  LAC33          ; * IN FREE RAM
0981 d502 bd d6 98                     JSR  LAEE8          ; GET ADDR OF END OF SUBLINE IN X
0982 d505 dc 68                        LDD  CURLIN         ; GET CURRENT LINE NUMBER
0983 d507 34 16                        PSHS X,B,A          ; SAVE LINE ADDR AND LINE NUMBER ON STACK
0984 d509 c6 a0                        LDB  #TOK_TO        ; TOKEN FOR 'TO'
0985 d50b bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR 'TO'
0986 d50e bd d8 cf                     JSR  LB143          ; 'TM' ERROR IF INDEX VARIABLE SET TO STRING
0987 d511 bd d8 cd                     JSR  LB141          ; EVALUATE EXPRESSION
0988                         *
0989 d514 d6 54                        LDB  FP0SGN         ; GET FPA0 MANTISSA SIGN
0990 d516 ca 7f                        ORB  #$7F           ; FORM A MASK TO SAVE DATA BITS OF HIGH ORDER MANTISSA
0991 d518 d4 50                        ANDB FPA0           ; PUT THE MANTISSA SIGN IN BIT 7 OF HIGH ORDER MANTISSA
0992 d51a d7 50                        STB  FPA0           ; SAVE THE PACKED HIGH ORDER MANTISSA
0993 d51c 10 8e d5 23                  LDY  #LAD7F         ; LOAD FOLLOWING ADDRESS INTO Y AS A RETURN
0994 d520 7e d9 76                     JMP  LB1EA          ; ADDRESS - PUSH FPA0 ONTO THE STACK
0995 d523 8e e2 11           LAD7F     LDX  #LBAC5         ; POINT X TO FLOATING POINT NUMBER 1.0 (DEFAULT STEP VALUE)
0996 d526 bd e3 60                     JSR  LBC14          ; MOVE (X) TO FPA0
0997 d529 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
0998 d52b 81 a4                        CMPA #TOK_STEP      ; STEP TOKEN
0999 d52d 26 05                        BNE  LAD90          ; BRANCH IF NO 'STEP' VALUE
1000 d52f 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1001 d531 bd d8 cd                     JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
1002 d534 bd e3 b9           LAD90     JSR  LBC6D          ; CHECK STATUS OF FPA0
1003 d537 bd d9 72                     JSR  LB1E6          ; SAVE STATUS AND FPA0 ON THE STACK
1004 d53a dc 3b                        LDD  VARDES         ; * GET DESCRIPTOR POINTER FOR THE 'STEP'
1005 d53c 34 06                        PSHS B,A            ; * VARIABLE AND SAVE IT ON THE STACK
1006 d53e 86 80                        LDA  #$80           ; = GET THE 'FOR' FLAG AND
1007 d540 34 02                        PSHS A              ; = SAVE IT ON THE STACK
1008                         *
1009                         * MAIN COMMAND INTERPRETATION LOOP
1010 d542 1c af              LAD9E     ANDCC #$AF          ; ENABLE IRQ,FIRQ
1011 d544 8d 60                        BSR  LADEB          ; CHECK FOR KEYBOARD BREAK
1012 d546 9e 83                        LDX  CHARAD         ; GET BASIC'S INPUT POINTER
1013 d548 9f 2f                        STX  TINPTR         ; SAVE IT
1014 d54a a6 80                        LDA  ,X+            ; GET CURRENT INPUT CHAR & MOVE POINTER
1015 d54c 27 07                        BEQ  LADB4          ; BRANCH IF END OF LINE
1016 d54e 81 3a                        CMPA #':            ; CHECK FOR LINE SEPARATOR
1017 d550 27 22                        BEQ  LADC0          ; BRANCH IF COLON
1018 d552 7e da 03           LADB1     JMP  LB277          ; 'SYNTAX ERROR'-IF NOT LINE SEPARATOR
1019 d555 a6 81              LADB4     LDA  ,X++           ; GET MS BYTE OF ADDRESS OF NEXT BASIC LINE
1020 d557 97 00                        STA  ENDFLG         ; SAVE IN STOP/END FLAG - CAUSE A STOP IF
1021                         *                             ; NEXT LINE ADDRESS IS < $8000; CAUSE
1022                         *                             ; AN END IF ADDRESS > $8000
1023 d559 27 72                        BEQ  LAE15          ; BRANCH TO 'STOP' - END OF PROGRAM
1024 d55b ec 80                        LDD  ,X+            ; GET CURRENT LINE NUMBER
1025 d55d dd 68                        STD  CURLIN         ; SAVE IN CURLIN
1026 d55f 9f 83                        STX  CHARAD         ; SAVE ADDRESS OF FIRST BYTE OF LINE
1027                         * EXTENDED BASIC TRACE
1028 d561 96 8c                        LDA  TRCFLG         ; TEST THE TRACE FLAG
1029 d563 27 0f                        BEQ  LADC0          ; BRANCH IF TRACE OFF
1030 d565 86 5b                        LDA  #$5B           ; <LEFT HAND MARKER FOR TRON LINE NUMBER
1031 d567 bd d0 17                     JSR  PUTCHR         ; OUTPUT A CHARACTER
1032 d56a 96 68                        LDA  CURLIN         ; GET MS BYTE OF LINE NUMBER
1033 d56c bd e5 18                     JSR  LBDCC          ; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN
1034 d56f 86 5d                        LDA  #$5D           ; > RIGHT HAND MARKER FOR TRON LINE NUMBER
1035 d571 bd d0 17                     JSR  PUTCHR         ; OUTPUT A CHARACTER
1036                         * END OF EXTENDED BASIC TRACE
1037 d574 9d 7c              LADC0     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1038 d576 8d 02                        BSR  LADC6          ; GO PROCESS COMMAND
1039 d578 20 c8                        BRA  LAD9E          ; GO BACK TO MAIN LOOP
1040 d57a 27 29              LADC6     BEQ  LADEA          ; RETURN IF END OF LINE (RTS - was BEQ LAE40)
1041 d57c 4d                           TSTA                ; CHECK FOR TOKEN - BIT 7 SET (NEGATIVE)
1042 d57d 10 2a 01 b8                  LBPL LET            ; BRANCH IF NOT A TOKEN - GO DO A 'LET' WHICH
1043                         *                             ; IS THE 'DEFAULT' TOKEN FOR MICROSOFT BASIC
1044 d581 81 ff                        CMPA #$FF           ; SECONDARY TOKEN
1045 d583 27 0f                        BEQ  SECTOK
1046 d585 81 9e                        CMPA #TOK_HIGH_EXEC ; SKIPF TOKEN - HIGHEST EXECUTABLE COMMAND IN BASIC
1047 d587 22 c9                        BHI  LADB1          ; 'SYNTAX ERROR' IF NON-EXECUTABLE TOKEN
1048 d589 be d0 f4                     LDX  COMVEC+3       ; GET ADDRESS OF BASIC'S COMMAND TABLE
1049 d58c 48                 LADD4     ASLA                ; X2 (2 BYTE/JUMP ADDRESS) & DISCARD BIT 7
1050 d58d 1f 89                        TFR  A,B            ; SAVE COMMAND OFFSET IN ACCB
1051 d58f 3a                           ABX                 ; NON X POINTS TO COMMAND JUMP ADDR
1052 d590 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
1053                         *
1054                         * HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
1055 d592 6e 94                        JMP  [,X]           ; GO DO A COMMAND
1056                         SECTOK
1057                         * THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTABLE IS
1058                         * THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHECK DONE HERE
1059 d594 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
1060 d596 81 97                        CMPA #TOK_MID       ; TOKEN FOR "MID$"
1061 d598 10 27 14 f0                  LBEQ L86D6          ; PROCESS MID$ REPLACEMENT
1062 d59c 7e da 03                     JMP  LB277          ; SYNTAX ERROR
1063                         
1064                         *
1065                         * RESTORE
1066 d59f 9e 19              RESTOR    LDX  TXTTAB         ; BEGINNING OF PROGRAM ADDRESS
1067 d5a1 30 1f                        LEAX -1,X           ; MOVE TO ONE BYTE BEFORE PROGRAM
1068 d5a3 9f 33              LADE8     STX  DATPTR         ; SAVE NEW DATA POINTER
1069 d5a5 39                 LADEA     RTS
1070                         *
1071                         * BREAK CHECK
1072 d5a6 bd d0 08           LADEB     JSR  LA1C1          ; GET A KEYSTROKE ENTRY
1073 d5a9 27 0a                        BEQ  LADFA          ; RETURN IF NO INPUT
1074 d5ab 81 03              LADF0     CMPA #3             ; CONTROL C? (BREAK)
1075 d5ad 27 12                        BEQ  STOP           ; YES
1076 d5af 81 13                        CMPA #$13           ; CONTROL S? (PAUSE)
1077 d5b1 27 03                        BEQ  LADFB          ; YES
1078 d5b3 97 73                        STA  IKEYIM         ; SAVE KEYSTROKE IN INKEY IMAGE
1079 d5b5 39                 LADFA     RTS
1080 d5b6 bd d0 08           LADFB     JSR  KEYIN          ; GET A KEY
1081 d5b9 27 fb                        BEQ  LADFB          ; BRANCH IF NO KEY DOWN
1082 d5bb 20 ee                        BRA  LADF0          ; CONTINUE - DO A BREAK CHECK
1083                         *
1084                         * END
1085 d5bd 9d 82              END       JSR  GETCCH         ; GET CURRENT INPUT CHAR
1086 d5bf 20 02                        BRA  LAE0B
1087                         *
1088                         * STOP
1089 d5c1 1a 01              STOP      ORCC #$01           ; SET CARRY FLAG
1090 d5c3 26 31              LAE0B     BNE  LAE40          ; BRANCH IF ARGUMENT EXISTS
1091 d5c5 9e 83                        LDX  CHARAD         ; * SAVE CURRENT POSITION OF
1092 d5c7 9f 2f                        STX  TINPTR         ; * BASIC'S INPUT POINTER
1093 d5c9 06 00              LAE11     ROR  ENDFLG         ; ROTATE CARRY INTO BIT 7 OF STOP/END FLAG
1094 d5cb 32 62                        LEAS 2,S            ; PURGE RETURN ADDRESS OFF STACK
1095 d5cd 9e 68              LAE15     LDX  CURLIN         ; GET CURRENT LINE NUMBER
1096 d5cf 8c ff ff                     CMPX #$FFFF         ; DIRECT MODE?
1097 d5d2 27 06                        BEQ  LAE22          ; YES
1098 d5d4 9f 29                        STX  OLDTXT         ; SAVE CURRENT LINE NUMBER
1099 d5d6 9e 2f                        LDX  TINPTR         ; * GET AND SAVE CURRENT POSITION
1100 d5d8 9f 2d                        STX  OLDPTR         ; * OF BASIC'S INPUT POINTER
1101                         LAE22
1102 d5da 8e d3 b1                     LDX  #LABF2-1       ; POINT TO CR, 'BREAK' MESSAGE
1103 d5dd 0d 00                        TST  ENDFLG         ; CHECK STOP/END FLAG
1104 d5df 10 2a fe 42                  LBPL LAC73          ; BRANCH TO MAIN LOOP OF BASIC IF END
1105 d5e3 7e d4 1a                     JMP  LAC68          ; PRINT 'BREAK AT ####' AND GO TO
1106                         *                             ; BASIC'S MAIN LOOP IF 'STOP'
1107                         
1108                         * CONT
1109 d5e6 26 0e              CONT      BNE  LAE40          ; RETURN IF ARGUMENT GIVEN
1110 d5e8 c6 20                        LDB  #2*16          ; 'CAN'T CONTINUE' ERROR
1111 d5ea 9e 2d                        LDX  OLDPTR         ; GET CONTINUE ADDRESS (INPUT POINTER)
1112 d5ec 10 27 fe 16                  LBEQ LAC46          ; 'CN' ERROR IF CONTINUE ADDRESS = 0
1113 d5f0 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1114 d5f2 9e 29                        LDX  OLDTXT         ; GET LINE NUMBER
1115 d5f4 9f 68                        STX  CURLIN         ; RESET CURRENT LINE NUMBER
1116 d5f6 39                 LAE40     RTS
1117                         *
1118                         * CLEAR
1119 d5f7 27 2c              CLEAR     BEQ  LAE6F          ; BRANCH IF NO ARGUMENT
1120 d5f9 bd db 6d                     JSR  LB3E6          ; EVALUATE ARGUMENT
1121 d5fc 34 06                        PSHS B,A            ; SAVE AMOUNT OF STRING SPACE ON STACK
1122 d5fe 9e 27                        LDX  MEMSIZ         ; GET CURRENT TOP OF CLEARED SPACE
1123 d600 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1124 d602 27 0c                        BEQ  LAE5A          ; BRANCH IF NO NEW TOP OF CLEARED SPACE
1125 d604 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
1126 d607 bd de c4                     JSR  LB73D          ; EVALUATE EXPRESSlON; RETURN VALUE IN X
1127 d60a 30 1f                        LEAX -1,X           ; X = TOP OF CLEARED SPACE
1128 d60c 9c 71                        CMPX TOPRAM         ; COMPARE TO TOP OF RAM
1129 d60e 22 18                        BHI  LAE72          ; 'OM' ERROR IF > TOP OF RAM
1130 d610 1f 10              LAE5A     TFR  X,D            ; ACCD = TOP OF CLEARED SPACE
1131 d612 a3 e1                        SUBD ,S++           ; SUBTRACT OUT AMOUNT OF CLEARED SPACE
1132 d614 25 12                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
1133 d616 1f 03                        TFR  D,U            ; U = BOTTOM OF CLEARED SPACE
1134 d618 83 00 3a                     SUBD #STKBUF        ; SUBTRACT OUT STACK BUFFER
1135 d61b 25 0b                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
1136 d61d 93 1b                        SUBD VARTAB         ; SUBTRACT OUT START OF VARIABLES
1137 d61f 25 07                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
1138 d621 df 21                        STU  FRETOP         ; SAVE NEW BOTTOM OF CLEARED SPACE
1139 d623 9f 27                        STX  MEMSIZ         ; SAVE NEW TOP OF CLEARED SPACE
1140 d625 7e d4 ca           LAE6F     JMP  LAD26          ; ERASE ALL VARIABLES, INITIALIZE POINTERS, ETC
1141 d628 7e d4 04           LAE72     JMP  LAC44          ; 'OM' ERROR
1142                         *
1143                         * RUN
1144 d62b 9d 82              RUN       JSR  GETCCH         ; * GET CURRENT INPUT CHARACTER
1145 d62d 10 27 fe 94                  LBEQ LAD21          ; * IF NO LINE NUMBER
1146 d631 bd d4 ca                     JSR  LAD26          ; ERASE ALL VARIABLES
1147 d634 20 19                        BRA  LAE9F          ; 'GOTO' THE RUN ADDRESS
1148                         *
1149                         * GO
1150 d636 1f 89              GO        TFR  A,B            ; SAVE INPUT CHARACTER IN ACCB
1151 d638 9d 7c              LAE88     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1152 d63a c1 a0                        CMPB #TOK_TO        ; 'TO' TOKEN
1153 d63c 27 16                        BEQ  LAEA4          ; BRANCH IF GOTO
1154 d63e c1 a1                        CMPB #TOK_SUB       ; 'SUB' TOKEN
1155 d640 26 45                        BNE  LAED7          ; 'SYNTAX ERROR' IF NEITHER
1156 d642 c6 03                        LDB  #3             ; =ROOM FOR 6
1157 d644 bd d3 f3                     JSR  LAC33          ; =BYTES ON STACK?
1158 d647 de 83                        LDU  CHARAD         ; * SAVE CURRENT BASIC INPUT POINTER, LINE
1159 d649 9e 68                        LDX  CURLIN         ; * NUMBER AND SUB TOKEN ON STACK
1160 d64b 86 a1                        LDA  #TOK_SUB       ; *
1161 d64d 34 52                        PSHS U,X,A          ; *
1162 d64f 8d 03              LAE9F     BSR  LAEA4          ; GO DO A 'GOTO'
1163 d651 7e d5 42                     JMP  LAD9E          ; JUMP BACK TO BASIC'S MAIN LOOP
1164                         * GOTO
1165 d654 9d 82              LAEA4     JSR  GETCCH         ; GET CURRENT INPUT CHAR
1166 d656 bd d7 17                     JSR  LAF67          ; GET LINE NUMBER TO BINARY IN BINVAL
1167 d659 8d 40                        BSR  LAEEB          ; ADVANCE BASIC'S POINTER TO END OF LINE
1168 d65b 30 01                        LEAX $01,X          ; POINT TO START OF NEXT LINE
1169 d65d dc 2b                        LDD  BINVAL         ; GET THE LINE NUMBER TO RUN
1170 d65f 10 93 68                     CMPD CURLIN         ; COMPARE TO CURRENT LINE NUMBER
1171 d662 22 02                        BHI  LAEB6          ; IF REO'D LINE NUMBER IS > CURRENT LINE NUMBER,
1172                         *              ; DON'T START LOOKING FROM
1173                         *              ; START OF PROGRAM
1174 d664 9e 19                        LDX  TXTTAB         ; BEGINNING OF PROGRAM
1175 d666 bd d4 a9           LAEB6     JSR  LAD05          ; GO FIND A LINE NUMBER
1176 d669 25 17                        BCS  LAED2          ; 'UNDEFINED LINE NUMBER'
1177 d66b 30 1f              LAEBB     LEAX -1,X           ; MOVE BACK TO JUST BEFORE START OF LINE
1178 d66d 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1179 d66f 39                 LAEBF     RTS
1180                         *
1181                         * RETURN
1182 d670 26 fd              RETURN    BNE  LAEBF          ; EXIT ROUTINE IF ARGUMENT GIVEN
1183 d672 86 ff                        LDA  #$FF           ; * PUT AN ILLEGAL VARIABLE NAME IN FIRST BYTE OF
1184 d674 97 3b                        STA  VARDES         ; * VARDES WHICH WILL CAUSE 'FOR/NEXT' DATA ON THE
1185                         *              ; STACK TO BE IGNORED
1186 d676 bd d3 b9                     JSR  LABF9          ; CHECK FOR RETURN DATA ON THE STACK
1187 d679 1f 14                        TFR  X,S            ; RESET STACK POINTER - PURGE TWO RETURN ADDRESSES
1188                         *              ; FROM THE STACK
1189 d67b 81 21                        CMPA #TOK_SUB-$80   ; SUB TOKEN - $80
1190 d67d 27 0b                        BEQ  LAEDA          ; BRANCH IF 'RETURN' FROM SUBROUTINE
1191 d67f c6 04                        LDB  #2*2           ; ERROR #2 'RETURN WITHOUT GOSUB'
1192 d681 8c                           FCB  SKP2           ; SKIP TWO BYTES
1193 d682 c6 0e              LAED2     LDB  #7*2           ; ERROR #7 'UNDEFINED LINE NUMBER'
1194 d684 7e d4 06                     JMP  LAC46          ; JUMP TO ERROR HANDLER
1195 d687 7e da 03           LAED7     JMP  LB277          ; 'SYNTAX ERROR'
1196 d68a 35 52              LAEDA     PULS A,X,U          ; * RESTORE VALUES OF CURRENT LINE NUMBER AND
1197 d68c 9f 68                        STX  CURLIN         ; * BASIC'S INPUT POINTER FOR THIS SUBROUTINE
1198 d68e df 83                        STU  CHARAD         ; * AND LOAD ACCA WITH SUB TOKEN ($A6)
1199                         *
1200                         * DATA
1201 d690 8d 06              DATA      BSR  LAEE8          ; MOVE INPUT POINTER TO END OF SUBLINE OR LINE
1202 d692 8c                           FCB  SKP2           ; SKIP 2 BYTES
1203                         
1204                         * REM, ELSE
1205                         ELSE
1206 d693 8d 06              REM       BSR  LAEEB          ; MOVE INPUT POINTER TO END OF LINE
1207 d695 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1208 d697 39                 LAEE7     RTS
1209                         * ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE
1210 d698 c6 3a              LAEE8     LDB  #':            ; COLON = SUBLINE TERMINATOR CHARACTER
1211 d69a 86                 LAEEA     FCB  SKP1LD         ; SKPILD SKIP ONE BYTE; LDA #$5F
1212                         * ADVANCE BASIC'S INPUT POINTER TO END OF
1213                         * LINE - RETURN ADDRESS OF END OF LINE+1 IN X
1214 d69b 5f                 LAEEB     CLRB                ; 0 = LINE TERMINATOR CHARACTER
1215 d69c d7 01                        STB  CHARAC         ; TEMP STORE PRIMARY TERMINATOR CHARACTER
1216 d69e 5f                           CLRB                ; 0 (END OF LINE) = ALTERNATE TERM. CHAR.
1217 d69f 9e 83                        LDX  CHARAD         ; LOAD X W/BASIC'S INPUT POINTER
1218 d6a1 1f 98              LAEF1     TFR  B,A            ; * CHANGE TERMINATOR CHARACTER
1219 d6a3 d6 01                        LDB  CHARAC         ; * FROM ACCB TO CHARAC - SAVE OLD TERMINATOR
1220                         *         IN   CHARAC
1221 d6a5 97 01                        STA  CHARAC         ; SWAP PRIMARY AND SECONDARY TERMINATORS
1222 d6a7 a6 84              LAEF7     LDA  ,X             ; GET NEXT INPUT CHARACTER
1223 d6a9 27 ec                        BEQ  LAEE7          ; RETURN IF 0 (END OF LINE)
1224 d6ab 34 04                        PSHS B              ; SAVE TERMINATOR ON STACK
1225 d6ad a1 e0                        CMPA ,S+            ; COMPARE TO INPUT CHARACTER
1226 d6af 27 e6                        BEQ  LAEE7          ; RETURN IF EQUAL
1227 d6b1 30 01                        LEAX 1,X            ; MOVE POINTER UP ONE
1228 d6b3 81 22                        CMPA #'"            ; CHECK FOR DOUBLE QUOTES
1229 d6b5 27 ea                        BEQ  LAEF1          ; BRANCH IF " - TOGGLE TERMINATOR CHARACTERS
1230 d6b7 4c                           INCA                ; * CHECK FOR $FF AND BRANCH IF
1231 d6b8 26 02                        BNE  LAF0C          ; * NOT SECONDARY TOKEN
1232 d6ba 30 01                        LEAX 1,X            ; MOVE INPUT POINTER 1 MORE IF SECONDARY
1233 d6bc 81 86              LAF0C     CMPA #TOK_IF+1      ; TOKEN FOR IF?
1234 d6be 26 e7                        BNE  LAEF7          ; NO - GET ANOTHER INPUT CHARACTER
1235 d6c0 0c 04                        INC  IFCTR          ; INCREMENT IF COUNTER - KEEP TRACK OF HOW MANY
1236                         *                             ; 'IF' STATEMENTS ARE NESTED IN ONE LINE
1237 d6c2 20 e3                        BRA  LAEF7          ; GET ANOTHER INPUT CHARACTER
1238                         
1239                         * IF
1240 d6c4 bd d8 cd           IF        JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
1241 d6c7 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1242 d6c9 81 81                        CMPA #TOK_GO        ; TOKEN FOR GO
1243 d6cb 27 05                        BEQ  LAF22          ; TREAT 'GO' THE SAME AS 'THEN'
1244 d6cd c6 a2                        LDB  #TOK_THEN      ; TOKEN FOR THEN
1245 d6cf bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK ON ACCB
1246 d6d2 96 4f              LAF22     LDA  FP0EXP         ; CHECK FOR TRUE/FALSE - FALSE IF FPA0 EXPONENT = ZERO
1247 d6d4 26 13                        BNE  LAF39          ; BRANCH IF CONDITION TRUE
1248 d6d6 0f 04                        CLR  IFCTR          ; CLEAR FLAG - KEEP TRACK OF WHICH NESTED ELSE STATEMENT
1249                         *                             ; TO SEARCH FOR IN NESTED 'IF' LOOPS
1250 d6d8 8d b6              LAF28     BSR  DATA           ; MOVE BASIC'S POINTER TO END OF SUBLINE
1251 d6da 4d                           TSTA                ; * CHECK TO SEE IF END OF LINE OR SUBLINE
1252 d6db 27 ba                        BEQ  LAEE7          ; * AND RETURN IF END OF LINE
1253 d6dd 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
1254 d6df 81 84                        CMPA #TOK_ELSE      ; TOKEN FOR ELSE
1255 d6e1 26 f5                        BNE  LAF28          ; IGNORE ALL DATA EXCEPT 'ELSE' UNTIL
1256                         *                             ; END OF LINE (ZERO BYTE)
1257 d6e3 0a 04                        DEC  IFCTR          ; CHECK TO SEE IF YOU MUST SEARCH ANOTHER SUBLINE
1258 d6e5 2a f1                        BPL  LAF28          ; BRANCH TO SEARCH ANOTHER SUBLINE FOR 'ELSE'
1259 d6e7 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
1260 d6e9 9d 82              LAF39     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1261 d6eb 10 25 ff 65                  LBCS LAEA4          ; BRANCH TO 'GOTO' IF NUMERIC CHARACTER
1262 d6ef 7e d5 7a                     JMP  LADC6          ; RETURN TO MAIN INTERPRETATION LOOP
1263                         
1264                         * ON
1265 d6f2 bd de 92           ON        JSR  LB70B          ; EVALUATE EXPRESSION
1266 d6f5 c6 81                        LDB  #TOK_GO        ; TOKEN FOR GO
1267 d6f7 bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR GO
1268 d6fa 34 02                        PSHS A              ; SAVE NEW TOKEN (TO,SUB)
1269 d6fc 81 a1                        CMPA #TOK_SUB       ; TOKEN FOR SUB?
1270 d6fe 27 04                        BEQ  LAF54          ; YES
1271 d700 81 a0                        CMPA #TOK_TO        ; TOKEN FOR TO?
1272 d702 26 83              LAF52     BNE  LAED7          ; 'SYNTAX' ERROR IF NOT 'SUB' OR 'TO'
1273 d704 0a 53              LAF54     DEC  FPA0+3         ; DECREMENT IS BYTE OF MANTISSA OF FPA0 - THIS
1274                         *                             ; IS THE ARGUMENT OF THE 'ON' STATEMENT
1275 d706 26 05                        BNE  LAF5D          ; BRANCH IF NOT AT THE PROPER GOTO OR GOSUB LINE NUMBER
1276 d708 35 04                        PULS B              ; GET BACK THE TOKEN FOLLOWING 'GO'
1277 d70a 7e d6 38                     JMP  LAE88          ; GO DO A 'GOTO' OR 'GOSUB'
1278 d70d 9d 7c              LAF5D     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1279 d70f 8d 06                        BSR  LAF67          ; CONVERT BASIC LINE NUMBER TO BINARY
1280 d711 81 2c                        CMPA #',            ; IS CHARACTER FOLLOWING LINE NUMBER A COMMA?
1281 d713 27 ef                        BEQ  LAF54          ; YES
1282 d715 35 84                        PULS B,PC           ; IF NOT, FALL THROUGH TO NEXT COMMAND
1283 d717 9e 74              LAF67     LDX  ZERO           ; DEFAULT LINE NUMBER OF ZERO
1284 d719 9f 2b                        STX  BINVAL         ; SAVE IT IN BINVAL
1285                         *
1286                         * CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINVAL
1287                         *
1288 d71b 24 61              LAF6B     BCC  LAFCE          ; RETURN IF NOT NUMERIC CHARACTER
1289 d71d 80 30                        SUBA #'0            ; MASK OFF ASCII
1290 d71f 97 01                        STA  CHARAC         ; SAVE DIGIT IN VO1
1291 d721 dc 2b                        LDD  BINVAL         ; GET ACCUMULATED LINE NUMBER VALUE
1292 d723 81 18                        CMPA #24            ; LARGEST LINE NUMBER IS $F9FF (63999) -
1293                         *         (24*256+255)*10+9
1294 d725 22 db                        BHI  LAF52          ; 'SYNTAX' ERROR IF TOO BIG
1295                         * MULT ACCD X 10
1296 d727 58                           ASLB                ; *
1297 d728 49                           ROLA                ; * TIMES 2
1298 d729 58                           ASLB                ; =
1299 d72a 49                           ROLA                ; = TIMES 4
1300 d72b d3 2b                        ADDD BINVAL         ; ADD 1 = TIMES 5
1301 d72d 58                           ASLB                ; *
1302 d72e 49                           ROLA                ; * TIMES 10
1303 d72f db 01                        ADDB CHARAC         ; ADD NEXT DIGIT
1304 d731 89 00                        ADCA #0             ; PROPAGATE CARRY
1305 d733 dd 2b                        STD  BINVAL         ; SAVE NEW ACCUMULATED LINE NUMBER
1306 d735 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
1307 d737 20 e2                        BRA  LAF6B          ; LOOP- PROCESS NEXT DIGIT
1308                         *
1309                         * LET (EXBAS)
1310                         * EVALUATE A NON-TOKEN EXPRESSION
1311                         * TARGET = REPLACEMENT
1312 d739 bd da de           LET       JSR  LB357          ; FIND TARGET VARIABLE DESCRIPTOR
1313 d73c 9f 3b                        STX  VARDES         ; SAVE DESCRIPTOR ADDRESS OF 1ST EXPRESSION
1314 d73e c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR "="
1315 d740 bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR '='
1316 d743 96 06                        LDA  VALTYP         ; * GET VARIABLE TYPE AND
1317 d745 34 02                        PSHS A              ; * SAVE ON THE STACK
1318 d747 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
1319 d74a 35 02                        PULS A              ; * REGET VARIABLE TYPE OF 1ST EXPRESSION AND
1320 d74c 46                           RORA                ; * SET CARRY IF STRING
1321 d74d bd d8 d4                     JSR  LB148          ; TYPE CHECK-TM ERROR IF VARIABLE TYPES ON
1322                         *                             ; BOTH SIDES OF EQUALS SIGN NOT THE SAME
1323 d750 10 27 0c 2b                  LBEQ LBC33          ; GO PUT FPA0 INTO VARIABLE DESCRIPTOR IF NUMERIC
1324                         * MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT
1325                         * FPA0+2 INTO THE STRING SPACE. TRANSFER THE
1326                         * DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES
1327                         * DON'T MOVE THE STRING IF IT IS ALREADY IN THE
1328                         * STRING SPACE. REMOVE DESCRIPTOR FROM STRING
1329                         * STACK IF IT IS LAST ONE ON THE STACK
1330 d754 9e 52              LAFA4     LDX  FPA0+2         ; POINT X TO DESCRIPTOR OF REPLACEMENT STRING
1331 d756 dc 21                        LDD  FRETOP         ; LOAD ACCD WITH START OF STRING SPACE
1332 d758 10 a3 02                     CMPD 2,X            ; IS THE STRING IN STRING SPACE?
1333 d75b 24 11                        BCC  LAFBE          ; BRANCH IF IT'S NOT IN THE STRING SPACE
1334 d75d 9c 1b                        CMPX VARTAB         ; COMPARE DESCRIPTOR ADDRESS TO START OF VARIABLES
1335 d75f 25 0d                        BCS  LAFBE          ; BRANCH IF DESCRIPTOR ADDRESS NOT IN VARIABLES
1336 d761 e6 84              LAFB1     LDB  ,X             ; GET LENGTH OF REPLACEMENT STRING
1337 d763 bd dc 94                     JSR  LB50D          ; RESERVE ACCB BYTES OF STRING SPACE
1338 d766 9e 4d                        LDX  V4D            ; GET DESCRIPTOR ADDRESS BACK
1339 d768 bd dd ca                     JSR  LB643          ; MOVE STRING INTO STRING SPACE
1340 d76b 8e 00 56                     LDX  #STRDES        ; POINT X TO TEMP STRING DESCRIPTOR ADDRESS
1341 d76e 9f 4d              LAFBE     STX  V4D            ; SAVE STRING DESCRIPTOR ADDRESS IN V4D
1342 d770 bd dd fc                     JSR  LB675          ; REMOVE STRING DESCRIPTOR IF LAST ONE
1343                         *              ; ON STRING STACK
1344 d773 de 4d                        LDU  V4D            ; POINT U TO REPLACEMENT DESCRIPTOR ADDRESS
1345 d775 9e 3b                        LDX  VARDES         ; GET TARGET DESCRIPTOR ADDRESS
1346 d777 37 26                        PULU A,B,Y          ; GET LENGTH AND START OF REPLACEMENT STRING
1347 d779 a7 84                        STA  ,X             ; * SAVE STRING LENGTH AND START IN
1348 d77b 10 af 02                     STY  2,X            ; * TARGET DESCRIPTOR LOCATION
1349 d77e 39                 LAFCE     RTS
1350                         
1351 d77f 3f 52 45 44 4f     LAFCF     FCC  "?REDO"        ; ?REDO MESSAGE
1352 d784 0d 00                        FCB  CR,$00
1353                         
1354                         LAFD6
1355 d786 7e d4 06           LAFDC     JMP  LAC46          ; JMP TO ERROR HANDLER
1356 d789 96 09              LAFDF     LDA  INPFLG         ; = GET THE INPUT FLAG AND BRANCH
1357 d78b 27 07                        BEQ  LAFEA          ; = IF 'INPUT'
1358 d78d 9e 31                        LDX  DATTXT         ; * GET LINE NUMBER WHERE THE ERROR OCCURRED
1359 d78f 9f 68                        STX  CURLIN         ; * AND USE IT AS THE CURRENT LINE NUMBER
1360 d791 7e da 03                     JMP  LB277          ; 'SYNTAX ERROR'
1361 d794 8e d7 7e           LAFEA     LDX  #LAFCF-1       ; * POINT X TO '?REDO' AND PRINT
1362 d797 bd e0 e8                     JSR  LB99C          ; * IT ON THE SCREEN
1363 d79a 9e 2f                        LDX  TINPTR         ; = GET THE SAVED ABSOLUTE ADDRESS OF
1364 d79c 9f 83                        STX  CHARAD         ; = INPUT POINTER AND RESTORE IT
1365 d79e 39                           RTS
1366                         *
1367                         * INPUT
1368 d79f c6 16              INPUT     LDB  #11*2          ; 'ID' ERROR
1369 d7a1 9e 68                        LDX  CURLIN         ; GET CURRENT LINE NUMBER
1370 d7a3 30 01                        LEAX 1,X            ; ADD ONE
1371 d7a5 27 df                        BEQ  LAFDC          ; 'ID' ERROR BRANCH IF DIRECT MODE
1372 d7a7 8d 01                        BSR  LB00F          ; GET SOME INPUT DATA - WAS LB002
1373 d7a9 39                           RTS
1374 d7aa 81 22              LB00F     CMPA #'"            ; CHECK FOR PROMPT STRING DELIMITER
1375 d7ac 26 0b                        BNE  LB01E          ; BRANCH IF NO PROMPT STRING
1376 d7ae bd d9 d0                     JSR  LB244          ; PUT PROMPT STRING ON STRING STACK
1377 d7b1 c6 3b                        LDB  #';            ; *
1378 d7b3 bd d9 fb                     JSR  LB26F          ; * DO A SYNTAX CHECK FOR SEMICOLON
1379 d7b6 bd e0 eb                     JSR  LB99F          ; PRINT MESSAGE TO CONSOLE OUT
1380 d7b9 8e 00 f3           LB01E     LDX  #LINBUF        ; POINT TO BASIC'S LINE BUFFER
1381 d7bc 6f 84                        CLR  ,X             ; CLEAR 1ST BYTE - FLAG TO INDICATE NO DATA
1382                         *              ; IN LINE BUFFER
1383 d7be 8d 06                        BSR  LB02F          ; INPUT A STRING TO LINE BUFFER
1384 d7c0 c6 2c                        LDB  #',            ; * INSERT A COMMA AT THE END
1385 d7c2 e7 84                        STB  ,X             ; * OF THE LINE INPUT BUFFER
1386 d7c4 20 16                        BRA  LB049
1387                         * FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
1388 d7c6 bd e0 fb           LB02F     JSR  LB9AF          ; SEND A "?" TO CONSOLE OUT
1389 d7c9 bd e0 f8                     JSR  LB9AC          ; SEND A 'SPACE' TO CONSOLE OUT
1390 d7cc bd d1 41           LB035     JSR  LA390          ; GO READ IN A BASIC LINE
1391 d7cf 24 05                        BCC  LB03F          ; BRANCH IF ENTER KEY ENDED ENTRY
1392 d7d1 32 64                        LEAS 4,S            ; PURGE TWO RETURN ADDRESSES OFF THE STACK
1393 d7d3 7e d5 c9                     JMP  LAE11          ; GO DO A 'STOP' IF BREAK KEY ENDED LINE ENTRY
1394 d7d6 c6 2e              LB03F     LDB  #2*23          ; 'INPUT PAST END OF FILE' ERROR
1395 d7d8 39                           RTS
1396                         *
1397                         * READ
1398 d7d9 9e 33              READ      LDX  DATPTR         ; GET 'READ' START ADDRESS
1399 d7db 86                           FCB  SKP1LD         ; SKIP ONE BYTE - LDA #*$4F
1400 d7dc 4f                 LB049     CLRA                ; 'INPUT' ENTRY POINT: INPUT FLAG = 0
1401 d7dd 97 09                        STA  INPFLG         ; SET INPUT FLAG; 0 = INPUT: <> 0 = READ
1402 d7df 9f 35                        STX  DATTMP         ; SAVE 'READ' START ADDRESS/'INPUT' BUFFER START
1403 d7e1 bd da de           LB04E     JSR  LB357          ; EVALUATE A VARIABLE
1404 d7e4 9f 3b                        STX  VARDES         ; SAVE DESCRIPTOR ADDRESS
1405 d7e6 9e 83                        LDX  CHARAD         ; * GET BASIC'S INPUT POINTER
1406 d7e8 9f 2b                        STX  BINVAL         ; * AND SAVE IT
1407 d7ea 9e 35                        LDX  DATTMP         ; GET 'READ' ADDRESS START/'INPUT' BUFFER POINTER
1408 d7ec a6 84                        LDA  ,X             ; GET A CHARACTER FROM THE BASIC PROGRAM
1409 d7ee 26 09                        BNE  LB069          ; BRANCH IF NOT END OF LINE
1410 d7f0 96 09                        LDA  INPFLG         ; * CHECK INPUT FLAG AND BRANCH
1411 d7f2 26 51                        BNE  LB0B9          ; * IF LOOKING FOR DATA (READ)
1412                         * NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
1413                         * NOT COMING FROM SCREEN
1414 d7f4 bd e0 fb                     JSR  LB9AF          ; SEND A '?' TO CONSOLE OUT
1415 d7f7 8d cd                        BSR  LB02F          ; FILL INPUT BUFFER FROM CONSOLE IN
1416 d7f9 9f 83              LB069     STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1417 d7fb 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1418 d7fd d6 06                        LDB  VALTYP         ; * CHECK VARIABLE TYPE AND
1419 d7ff 27 23                        BEQ  LB098          ; * BRANCH IF NUMERIC
1420                         * READ/INPUT A STRING VARIABLE
1421 d801 9e 83                        LDX  CHARAD         ; LOAD X WITH CURRENT BASIC INPUT POINTER
1422 d803 97 01                        STA  CHARAC         ; SAVE CURRENT INPUT CHARACTER
1423 d805 81 22                        CMPA #'"            ; CHECK FOR STRING DELIMITER
1424 d807 27 0e                        BEQ  LB08B          ; BRANCH IF STRING DELIMITER
1425 d809 30 1f                        LEAX -1,X           ; BACK UP POINTER
1426 d80b 4f                           CLRA                ; * ZERO = END OF LINE CHARACTER
1427 d80c 97 01                        STA  CHARAC         ; * SAVE AS TERMINATOR
1428 d80e bd d1 33                     JSR  LA35F          ; SET UP PRINT PARAMETERS
1429 d811 86 3a                        LDA  #':            ; END OF SUBLINE CHARACTER
1430 d813 97 01                        STA  CHARAC         ; SAVE AS TERMINATOR I
1431 d815 86 2c                        LDA  #',            ; COMMA
1432 d817 97 02              LB08B     STA  ENDCHR         ; SAVE AS TERMINATOR 2
1433 d819 bd dc a5                     JSR  LB51E          ; STRIP A STRING FROM THE INPUT BUFFER
1434 d81c bd d9 d5                     JSR  LB249          ; MOVE INPUT POINTER TO END OF STRING
1435 d81f bd d7 54                     JSR  LAFA4          ; PUT A STRING INTO THE STRING SPACE IF NECESSARY
1436 d822 20 06                        BRA  LB09E          ; CHECK FOR ANOTHER DATA ITEM
1437                         * SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM
1438 d824 bd e4 5e           LB098     JSR  LBD12          ; CONVERT AN ASCII STRING TO FP NUMBER
1439 d827 bd e3 7f                     JSR  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS IN VARDES -
1440                         *                             ; INPUT OR READ DATA ITEM
1441 d82a 9d 82              LB09E     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1442 d82c 27 06                        BEQ  LB0A8          ; BRANCH IF END OF LINE
1443 d82e 81 2c                        CMPA #',            ; CHECK FOR A COMMA
1444 d830 10 26 ff 52                  LBNE LAFD6          ; BAD FILE DATA' ERROR OR RETRY
1445 d834 9e 83              LB0A8     LDX  CHARAD         ; * GET CURRENT INPUT
1446 d836 9f 35                        STX  DATTMP         ; * POINTER (USED AS A DATA POINTER) AND SAVE IT
1447 d838 9e 2b                        LDX  BINVAL         ; * RESET INPUT POINTER TO INPUT OR
1448 d83a 9f 83                        STX  CHARAD         ; * READ STATEMENT
1449 d83c 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
1450 d83e 27 21                        BEQ  LB0D5          ; BRANCH IF END OF LINE - EXIT COMMAND
1451 d840 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
1452 d843 20 9c                        BRA  LB04E          ; GET ANOTHER INPUT OR READ ITEM
1453                         * SEARCH FROM ADDRESS IN X FOR
1454                         * 1ST OCCURENCE OF THE TOKEN FOR DATA
1455 d845 9f 83              LB0B9     STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1456 d847 bd d6 98                     JSR  LAEE8          ; SEARCH FOR END OF CURRENT LINE OR SUBLINE
1457 d84a 30 01                        LEAX 1,X            ; MOVE X ONE PAST END OF LINE
1458 d84c 4d                           TSTA                ; CHECK FOR END OF LINE
1459 d84d 26 0a                        BNE  LB0CD          ; BRANCH IF END OF SUBLINE
1460 d84f c6 06                        LDB  #2*3           ; 'OUT OF DATA' ERROR
1461 d851 ee 81                        LDU  ,X++           ; GET NEXT 2 CHARACTERS
1462 d853 27 41                        BEQ  LB10A          ; 'OD' ERROR IF END OF PROGRAM
1463 d855 ec 81                        LDD  ,X++           ; GET BASIC LINE NUMBER AND
1464 d857 dd 31                        STD  DATTXT         ; SAVE IT IN DATTXT
1465 d859 a6 84              LB0CD     LDA  ,X             ; GET AN INPUT CHARACTER
1466 d85b 81 86                        CMPA #TOK_DATA      ; DATA TOKEN?
1467 d85d 26 e6                        BNE  LB0B9          ; NO - KEEP LOOKING
1468 d85f 20 98                        BRA  LB069          ; YES
1469                         * EXIT READ AND INPUT COMMANDS
1470 d861 9e 35              LB0D5     LDX  DATTMP         ; GET DATA POINTER
1471 d863 d6 09                        LDB  INPFLG         ; * CHECK INPUT FLAG
1472 d865 10 26 fd 3a                  LBNE LADE8          ; * SAVE NEW DATA POINTER IF READ
1473 d869 a6 84                        LDA  ,X             ; = CHECK NEXT CHARACTER IN 'INPUT' BUFFER
1474 d86b 27 06                        BEQ  LB0E7          ; =
1475 d86d 8e d8 73                     LDX  #LB0E8-1       ; POINT X TO '?EXTRA IGNORED'
1476 d870 7e e0 e8                     JMP  LB99C          ; PRINT THE MESSAGE
1477 d873 39                 LB0E7     RTS
1478                         
1479 d874 3f 45 58 54 52 41  LB0E8     FCC  "?EXTRA IGNORED" ; ?EXTRA IGNORED MESSAGE
     20 49 47 4e 4f 52
     45 44
1480                         
1481                         
1482 d882 0d 00                        FCB  CR,$00
1483                         
1484                         * NEXT
1485 d884 26 04              NEXT      BNE  LB0FE          ; BRANCH IF ARGUMENT GIVEN
1486 d886 9e 74                        LDX  ZERO           ; X = 0: DEFAULT FOR NO ARGUMENT
1487 d888 20 03                        BRA  LB101
1488 d88a bd da de           LB0FE     JSR  LB357          ; EVALUATE AN ALPHA EXPRESSION
1489 d88d 9f 3b              LB101     STX  VARDES         ; SAVE VARIABLE DESCRIPTOR POINTER
1490 d88f bd d3 b9                     JSR  LABF9          ; GO SCAN FOR 'FOR/NEXT' DATA ON STACK
1491 d892 27 04                        BEQ  LB10C          ; BRANCH IF DATA FOUND
1492 d894 c6 00                        LDB  #0             ; 'NEXT WITHOUT FOR' ERROR (SHOULD BE CLRB)
1493 d896 20 47              LB10A     BRA  LB153          ; PROCESS ERROR
1494 d898 1f 14              LB10C     TFR  X,S            ; POINT S TO START OF 'FOR/NEXT' DATA
1495 d89a 30 03                        LEAX 3,X            ; POINT X TO FP VALUE OF STEP
1496 d89c bd e3 60                     JSR  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
1497 d89f a6 68                        LDA  8,S            ; GET THE DIRECTION OF STEP
1498 d8a1 97 54                        STA  FP0SGN         ; SAVE IT AS THE SIGN OF FPA0
1499 d8a3 9e 3b                        LDX  VARDES         ; POINT (X) TO INDEX VARIABLE DESCRIPTOR
1500 d8a5 bd e1 0e                     JSR  LB9C2          ; ADD (X) TO FPA0 (STEP TO INDEX)
1501 d8a8 bd e3 7f                     JSR  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS
1502                         *                             ; CONTAINED IN VARDES
1503 d8ab 30 69                        LEAX 9,S            ; POINT (X) TO TERMINAL VALUE OF INDEX
1504 d8ad bd e3 e2                     JSR  LBC96          ; COMPARE CURRENT INDEX VALUE TO TERMINAL VALUE OF INDEX
1505 d8b0 e0 68                        SUBB 8,S            ; ACCB = 0 IF TERMINAL VALUE=CURRENT VALUE AND STEP=0 OR IF
1506                         *                             ; STEP IS POSITIVE AND CURRENT VALUE>TERMINAL VALUE OR
1507                         *                             ; STEP IS NEGATIVE AND CURRENT VALUE<TERMINAL VALUE
1508 d8b2 27 0c                        BEQ  LB134          ; BRANCH IF 'FOR/NEXT' LOOP DONE
1509 d8b4 ae 6e                        LDX  14,S           ; * GET LINE NUMBER AND
1510 d8b6 9f 68                        STX  CURLIN         ; * BASIC POINTER OF
1511 d8b8 ae e8 10                     LDX  16,S           ; * STATEMENT FOLLOWING THE
1512 d8bb 9f 83                        STX  CHARAD         ; * PROPER FOR STATEMENT
1513 d8bd 7e d5 42           LB131     JMP  LAD9E          ; JUMP BACK TO COMMAND INTEPR. LOOP
1514 d8c0 32 e8 12           LB134     LEAS 18,S           ; PULL THE 'FOR-NEXT' DATA OFF THE STACK
1515 d8c3 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1516 d8c5 81 2c                        CMPA #',            ; CHECK FOR ANOTHER ARGUMENT
1517 d8c7 26 f4                        BNE  LB131          ; RETURN IF NONE
1518 d8c9 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
1519 d8cb 8d bd                        BSR  LB0FE          ; BSR SIMULATES A CALL TO 'NEXT' FROM COMMAND LOOP
1520                         
1521                         
1522 d8cd 8d 13              LB141     BSR  LB156          ; EVALUATE EXPRESSION AND DO A TYPE CHECK FOR NUMERIC
1523 d8cf 1c fe              LB143     ANDCC #$FE          ; CLEAR CARRY FLAG
1524 d8d1 7d                 LB145     FCB  $7D            ; OP CODE OF TST $1A01 - SKIP TWO BYTES (DO
1525                         *              ; NOT CHANGE CARRY FLAG)
1526 d8d2 1a 01              LB146     ORCC #1             ; SET CARRY
1527                         
1528                         * STRING TYPE MODE CHECK - IF ENTERED AT LB146 THEN VALTYP PLUS IS 'TM' ERROR
1529                         * NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN VALTYP MINUS IS 'TM' ERROR
1530                         * IF ENTERED AT LB148, A TYPE CHECK IS DONE ON VALTYP
1531                         * IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERIC
1532                         * IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRING.
1533 d8d4 0d 06              LB148     TST  VALTYP         ; TEST TYPE FLAG; DO NOT CHANGE CARRY
1534 d8d6 25 03                        BCS  LB14F          ; BRANCH IF STRING
1535 d8d8 2a 99                        BPL  LB0E7          ; RETURN ON PLUS
1536 d8da 8c                           FCB  SKP2           ; SKIP 2 BYTES - 'TM' ERROR
1537 d8db 2b 96              LB14F     BMI  LB0E7          ; RETURN ON MINUS
1538 d8dd c6 18                        LDB  #12*2          ; 'TYPE M1SMATCH' ERROR
1539 d8df 7e d4 06           LB153     JMP  LAC46          ; PROCESS ERROR
1540                         * EVALUATE EXPRESSION
1541 d8e2 8d 6e              LB156     BSR  LB1C6          ; BACK UP INPUT POINTER
1542 d8e4 4f                 LB158     CLRA                ; END OF OPERATION PRECEDENCE FLAG
1543 d8e5 8c                           FCB  SKP2           ; SKIP TWO BYTES
1544 d8e6 34 04              LB15A     PSHS B              ; SAVE FLAG (RELATIONAL OPERATOR FLAG)
1545 d8e8 34 02                        PSHS A              ; SAVE FLAG (PRECEDENCE FLAG)
1546 d8ea c6 01                        LDB  #1             ; *
1547 d8ec bd d3 f3                     JSR  LAC33          ; * SEE IF ROOM IN FREE RAM FOR (B) WORDS
1548 d8ef bd d9 af                     JSR  LB223          ; GO EVALUATE AN EXPRESSION
1549 d8f2 0f 3f                        CLR  TRELFL         ; RESET RELATIONAL OPERATOR FLAG
1550 d8f4 9d 82              LB168     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1551                         * CHECK FOR RELATIONAL OPERATORS
1552 d8f6 80 ad              LB16A     SUBA #TOK_GREATER   ; TOKEN FOR >
1553 d8f8 25 13                        BCS  LB181          ; BRANCH IF LESS THAN RELATIONAL OPERATORS
1554 d8fa 81 03                        CMPA #3             ; *
1555 d8fc 24 0f                        BCC  LB181          ; * BRANCH IF GREATER THAN RELATIONAL OPERATORS
1556 d8fe 81 01                        CMPA #1             ; SET CARRY IF '>'
1557 d900 49                           ROLA                ; CARRY TO BIT 0
1558 d901 98 3f                        EORA TRELFL         ; * CARRY SET IF
1559 d903 91 3f                        CMPA TRELFL         ; * TRELFL = ACCA
1560 d905 25 64                        BCS  LB1DF          ; BRANCH IF SYNTAX ERROR : == << OR >>
1561 d907 97 3f                        STA  TRELFL         ; BIT 0: >, BIT 1 =, BIT 2: <
1562 d909 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER
1563 d90b 20 e9                        BRA  LB16A          ; CHECK FOR ANOTHER RELATIONAL OPERATOR
1564                         *
1565 d90d d6 3f              LB181     LDB  TRELFL         ; GET RELATIONAL OPERATOR FLAG
1566 d90f 26 33                        BNE  LB1B8          ; BRANCH IF RELATIONAL COMPARISON
1567 d911 10 24 00 6b                  LBCC LB1F4          ; BRANCH IF > RELATIONAL OPERATOR
1568 d915 8b 07                        ADDA #7             ; SEVEN ARITHMETIC/LOGICAL OPERATORS
1569 d917 24 67                        BCC  LB1F4          ; BRANCH IF NOT ARITHMETIC/LOGICAL OPERATOR
1570 d919 99 06                        ADCA VALTYP         ; ADD CARRY, NUMERIC FLAG AND MODIFIED TOKEN NUMBER
1571 d91b 10 27 04 77                  LBEQ LB60F          ; BRANCH IF VALTYP = FF, AND ACCA = '+' TOKEN -
1572                         *                             ; CONCATENATE TWO STRINGS
1573 d91f 89 ff                        ADCA #-1            ; RESTORE ARITHMETIC/LOGICAL OPERATOR NUMBER
1574 d921 34 02                        PSHS A              ; * STORE OPERATOR NUMBER ON STACK; MULTIPLY IT BY 2
1575 d923 48                           ASLA                ; * THEN ADD THE STORED STACK DATA = MULTIPLY
1576 d924 ab e0                        ADDA ,S+            ; * X 3; 3 BYTE/TABLE ENTRY
1577 d926 8e d2 0b                     LDX  #LAA51         ; JUMP TABLE FOR ARITHMETIC & LOGICAL OPERATORS
1578 d929 30 86                        LEAX A,X            ; POINT X TO PROPER TABLE
1579 d92b 35 02              LB19F     PULS A              ; GET PRECEDENCE FLAG FROM STACK
1580 d92d a1 84                        CMPA ,X             ; COMPARE TO CURRENT OPERATOR
1581 d92f 24 55                        BCC  LB1FA          ; BRANCH IF STACK OPERATOR > CURRENT OPERATOR
1582 d931 8d 9c                        BSR  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
1583                         
1584                         * OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE THAN THE PREVIOUS OPERATION.
1585 d933 34 02              LB1A7     PSHS A              ; SAVE PRECEDENCE FLAG
1586 d935 8d 29                        BSR  LB1D4          ; PUSH OPERATOR ROUTINE ADDRESS AND FPA0 ONTO STACK
1587 d937 9e 3d                        LDX  RELPTR         ; GET POINTER TO ARITHMETIC/LOGICAL TABLE ENTRY FOR
1588                         *                             ; LAST CALCULATED OPERATION
1589 d939 35 02                        PULS A              ; GET PRECEDENCE FLAG OF PREVIOUS OPERATION
1590 d93b 26 1d                        BNE  LB1CE          ; BRANCH IF NOT END OF OPERATION
1591 d93d 4d                           TSTA                ; CHECK TYPE OF PRECEDENCE FLAG
1592 d93e 10 27 00 6a                  LBEQ LB220          ; BRANCH IF END OF EXPRESSION OR SUB-EXPRESSION
1593 d942 20 4b                        BRA  LB203          ; EVALUATE AN OPERATION
1594                         
1595 d944 08 06              LB1B8     ASL  VALTYP         ; BIT 7 OF TYPE FLAG TO CARRY
1596 d946 59                           ROLB                ; SHIFT RELATIONAL FLAG LEFT - VALTYP TO BIT 0
1597 d947 8d 09                        BSR  LB1C6          ; MOVE THE INPUT POINTER BACK ONE
1598 d949 8e d9 57                     LDX  #LB1CB         ; POINT X TO RELATIONAL COMPARISON JUMP TABLE
1599 d94c d7 3f                        STB  TRELFL         ; SAVE RELATIONAL COMPARISON DATA
1600 d94e 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
1601 d950 20 d9                        BRA  LB19F          ; PERFORM OPERATION OR SAVE ON STACK
1602                         
1603 d952 9e 83              LB1C6     LDX  CHARAD         ; * GET BASIC'S INPUT POINTER AND
1604 d954 7e d6 6b                     JMP  LAEBB          ; * MOVE IT BACK ONE
1605                         * RELATIONAL COMPARISON JUMP TABLE
1606 d957 64                 LB1CB     FCB  $64            ; RELATIONAL COMPARISON FLAG
1607 d958 da 7b              LB1CC     FDB  LB2F4          ; JUMP ADDRESS
1608                         
1609 d95a a1 84              LB1CE     CMPA ,X             ; COMPARE PRECEDENCE OF LAST DONE OPERATION TO
1610                         *         NEXT TO BE DONE OPERATION
1611 d95c 24 31                        BCC  LB203          ; EVALUATE OPERATION IF LOWER PRECEDENCE
1612 d95e 20 d3                        BRA  LB1A7          ; PUSH OPERATION DATA ON STACK IF HIGHER PRECEDENCE
1613                         
1614                         * PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK AND EVALUATE ANOTHER EXPR
1615 d960 ec 01              LB1D4     LDD  1,X            ; GET ADDRESS OF OPERATOR ROUTINE
1616 d962 34 06                        PSHS B,A            ; SAVE IT ON THE STACK
1617 d964 8d 08                        BSR  LB1E2          ; PUSH FPA0 ONTO STACK
1618 d966 d6 3f                        LDB  TRELFL         ; GET BACK RELATIONAL OPERATOR FLAG
1619 d968 16 ff 7b                     LBRA LB15A          ; EVALUATE ANOTHER EXPRESSION
1620 d96b 7e da 03           LB1DF     JMP  LB277          ; 'SYNTAX ERROR'
1621                         * PUSH FPA0 ONTO THE STACK. ,S   = EXPONENT
1622                         * 1-2,S =HIGH ORDER MANTISSA 3-4,S = LOW ORDER MANTISSA
1623                         * 5,S = SIGN RETURN WITH PRECEDENCE CODE IN ACCA
1624 d96e d6 54              LB1E2     LDB  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
1625 d970 a6 84                        LDA  ,X             ; GET PRECEDENCE CODE TO ACCA
1626 d972 35 20              LB1E6     PULS Y              ; GET RETURN ADDRESS FROM STACK & PUT IT IN Y
1627 d974 34 04                        PSHS B              ; SAVE ACCB ON STACK
1628 d976 d6 4f              LB1EA     LDB  FP0EXP         ; * PUSH FPA0 ONTO THE STACK
1629 d978 9e 50                        LDX  FPA0           ; *
1630 d97a de 52                        LDU  FPA0+2         ; *
1631 d97c 34 54                        PSHS U,X,B          ; *
1632 d97e 6e a4                        JMP  ,Y             ; JUMP TO ADDRESS IN Y
1633                         
1634                         * BRANCH HERE IF NON-OPERATOR CHARACTER FOUND - USUALLY ')' OR END OF LINE
1635 d980 9e 74              LB1F4     LDX  ZERO           ; POINT X TO DUMMY VALUE (ZERO)
1636 d982 a6 e0                        LDA  ,S+            ; GET PRECEDENCE FLAG FROM STACK
1637 d984 27 26                        BEQ  LB220          ; BRANCH IF END OF EXPRESSION
1638 d986 81 64              LB1FA     CMPA #$64           ; * CHECK FOR RELATIONAL COMPARISON FLAG
1639 d988 27 03                        BEQ  LB201          ; * AND BRANCH IF RELATIONAL COMPARISON
1640 d98a bd d8 cf                     JSR  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
1641 d98d 9f 3d              LB201     STX  RELPTR         ; SAVE POINTER TO OPERATOR ROUTINE
1642 d98f 35 04              LB203     PULS B              ; GET RELATIONAL OPERATOR FLAG FROM STACK
1643 d991 81 5a                        CMPA #$5A           ; CHECK FOR 'NOT' OPERATOR
1644 d993 27 19                        BEQ  LB222          ; RETURN IF 'NOT' - NO RELATIONAL COMPARISON
1645 d995 81 7d                        CMPA #$7D           ; CHECK FOR NEGATION (UNARY) FLAG
1646 d997 27 15                        BEQ  LB222          ; RETURN IF NEGATION - NO RELATIONAL COMPARISON
1647                         
1648                         * EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON STACK, FIRST SIX BYTES
1649                         * ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRESS OF ROUTINE WHICH
1650                         * WILL EVALUATE THE OPERATION. THE RTS AT END OF ROUTINE WILL VECTOR
1651                         * TO EVALUATING ROUTINE.
1652 d999 54                           LSRB                ; = ROTATE VALTYP BIT INTO CARRY
1653 d99a d7 0a                        STB  RELFLG         ; = FLAG AND SAVE NEW RELFLG
1654 d99c 35 52                        PULS A,X,U          ; * PULL A FP VALUE OFF OF THE STACK
1655 d99e 97 5c                        STA  FP1EXP         ; * AND SAVE IT IN FPA1
1656 d9a0 9f 5d                        STX  FPA1           ; *
1657 d9a2 df 5f                        STU  FPA1+2         ; *
1658 d9a4 35 04                        PULS B              ; = GET MANTISSA SIGN AND
1659 d9a6 d7 61                        STB  FP1SGN         ; = SAVE IT IN FPA1
1660 d9a8 d8 54                        EORB FP0SGN         ; EOR IT WITH FPA1 MANTISSA SIGN
1661 d9aa d7 62                        STB  RESSGN         ; SAVE IT IN RESULT SIGN BYTE
1662 d9ac d6 4f              LB220     LDB  FP0EXP         ; GET EXPONENT OF FPA0
1663 d9ae 39                 LB222     RTS
1664                         
1665 d9af bd eb fc           LB223     JSR  XVEC15         ; CALL EXTENDED BASIC ADD-IN
1666 d9b2 0f 06                        CLR  VALTYP         ; INITIALIZE TYPE FLAG TO NUMERIC
1667 d9b4 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
1668 d9b6 24 03                        BCC  LB22F          ; BRANCH IF NOT NUMERIC
1669 d9b8 7e e4 5e           LB22C     JMP  LBD12          ; CONVERT ASCII STRING TO FLOATING POINT -
1670                         *         RETURN RESULT IN FPA0
1671                         * PROCESS A NON NUMERIC FIRST CHARACTER
1672 d9bb bd db 29           LB22F     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
1673 d9be 24 50                        BCC  LB284          ; BRANCH IF ALPHA CHARACTER
1674 d9c0 81 2e                        CMPA #'.            ; IS IT '.' (DECIMAL POINT)?
1675 d9c2 27 f4                        BEQ  LB22C          ; CONVERT ASCII STRING TO FLOATING POINT
1676 d9c4 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN
1677 d9c6 27 40                        BEQ  LB27C          ; YES - GO PROCESS THE MINUS OPERATOR
1678 d9c8 81 a6                        CMPA #TOK_PLUS      ; PLUS TOKEN
1679 d9ca 27 e3                        BEQ  LB223          ; YES - GET ANOTHER CHARACTER
1680 d9cc 81 22                        CMPA #'"            ; STRING DELIMITER?
1681 d9ce 26 0a                        BNE  LB24E          ; NO
1682 d9d0 9e 83              LB244     LDX  CHARAD         ; CURRENT BASIC POINTER TO X
1683 d9d2 bd dc 9f                     JSR  LB518          ; SAVE STRING ON STRING STACK
1684 d9d5 9e 64              LB249     LDX  COEFPT         ; * GET ADDRESS OF END OF STRING AND
1685 d9d7 9f 83                        STX  CHARAD         ; * PUT BASIC'S INPUT POINTER THERE
1686 d9d9 39                           RTS
1687 d9da 81 a3              LB24E     CMPA #TOK_NOT       ; NOT TOKEN?
1688 d9dc 26 0d                        BNE  LB25F          ; NO
1689                         * PROCESS THE NOT OPERATOR
1690 d9de 86 5a                        LDA  #$5A           ; 'NOT' PRECEDENCE FLAG
1691 d9e0 bd d8 e6                     JSR  LB15A          ; PROCESS OPERATION FOLLOWING 'NOT'
1692 d9e3 bd db 74                     JSR  INTCNV         ; CONVERT FPA0 TO INTEGER IN ACCD
1693 d9e6 43                           COMA                ; * 'NOT' THE INTEGER
1694 d9e7 53                           COMB                ; *
1695 d9e8 7e dc 7b                     JMP  GIVABF         ; CONVERT ACCD TO FLOATING POINT (FPA0)
1696 d9eb 4c                 LB25F     INCA                ; CHECK FOR TOKENS PRECEEDED BY $FF
1697 d9ec 27 2e                        BEQ  LB290          ; IT WAS PRECEEDED BY $FF
1698 d9ee 8d 06              LB262     BSR  LB26A          ; SYNTAX CHECK FOR A '('
1699 d9f0 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSIONS WITHIN PARENTHESES AT
1700                         *         HIGHEST PRECEDENCE
1701 d9f3 c6 29              LB267     LDB  #')            ; SYNTAX CHECK FOR ')'
1702 d9f5 8c                           FCB  SKP2           ; SKIP 2 BYTES
1703 d9f6 c6 28              LB26A     LDB  #'(            ; SYNTAX CHECK FOR '('
1704 d9f8 8c                           FCB  SKP2           ; SKIP 2 BYTES
1705 d9f9 c6 2c              LB26D     LDB  #',            ; SYNTAX CHECK FOR COMMA
1706 d9fb e1 9f 00 83        LB26F     CMPB [CHARAD]       ; * COMPARE ACCB TO CURRENT INPUT
1707 d9ff 26 02                        BNE  LB277          ; * CHARACTER - SYNTAX ERROR IF NO MATCH
1708 da01 0e 7c                        JMP  GETNCH         ; GET A CHARACTER FROM BASIC
1709 da03 c6 02              LB277     LDB  #2*1           ; SYNTAX ERROR
1710 da05 7e d4 06                     JMP  LAC46          ; JUMP TO ERROR HANDLER
1711                         
1712                         * PROCESS THE MINUS (UNARY) OPERATOR
1713 da08 86 7d              LB27C     LDA  #$7D           ; MINUS (UNARY) PRECEDENCE FLAG
1714 da0a bd d8 e6                     JSR  LB15A          ; PROCESS OPERATION FOLLOWING 'UNARY' NEGATION
1715 da0d 7e e6 35                     JMP  LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
1716                         
1717                         * EVALUATE ALPHA EXPRESSION
1718 da10 bd da de           LB284     JSR  LB357          ; FIND THE DESCRIPTOR ADDRESS OF A VARIABLE
1719 da13 9f 52              LB287     STX  FPA0+2         ; SAVE DESCRIPTOR ADDRESS IN FPA0
1720 da15 96 06                        LDA  VALTYP         ; TEST VARIABLE TYPE
1721 da17 26 95                        BNE  LB222          ; RETURN IF STRING
1722 da19 7e e3 60                     JMP  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
1723                         
1724                         * EVALUATING A SECONDARY TOKEN
1725 da1c 9d 7c              LB290     JSR  GETNCH         ; GET AN INPUT CHARACTER (SECONDARY TOKEN)
1726 da1e 1f 89                        TFR  A,B            ; SAVE IT IN ACCB
1727 da20 58                           ASLB                ; X2 & BET RID OF BIT 7
1728 da21 9d 7c                        JSR  GETNCH         ; GET ANOTHER INPUT CHARACTER
1729 da23 c1 38                        CMPB #NUM_SEC_FNS-1*2 ; 29 SECONDARY FUNCTIONS - 1
1730 da25 23 03                        BLS  LB29F          ; BRANCH IF COLOR BASIC TOKEN
1731 da27 7e da 03                     JMP  LB277          ; SYNTAX ERROR
1732 da2a 34 04              LB29F     PSHS B              ; SAVE TOKEN OFFSET ON STACK
1733 da2c c1 2a                        CMPB #TOK_LEFT-$80*2 ; CHECK FOR TOKEN WITH AN ARGUMENT
1734 da2e 25 1e                        BCS  LB2C7          ; DO SECONDARIES STRING$ OR LESS
1735 da30 c1 30                        CMPB #TOK_INKEY-$80*2 ; *
1736 da32 24 1c                        BCC  LB2C9          ; * DO SECONDARIES $92 (INKEY$) OR >
1737 da34 8d c0                        BSR  LB26A          ; SYNTAX CHECK FOR A '('
1738 da36 a6 e4                        LDA  ,S             ; GET TOKEN NUMBER
1739                         * DO SECONDARIES (LEFT$, RIGHT$, MID$)
1740 da38 bd d8 e2                     JSR  LB156          ; EVALUATE FIRST STRING IN ARGUMENT
1741 da3b 8d bc                        BSR  LB26D          ; SYNTAX CHECK FOR A COMMA
1742 da3d bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARiABLE
1743 da40 35 02                        PULS A              ; GET TOKEN OFFSET FROM STACK
1744 da42 de 52                        LDU  FPA0+2         ; POINT U TO STRING DESCRIPTOR
1745 da44 34 42                        PSHS U,A            ; SAVE TOKEN OFFSET AND DESCRIPTOR ADDRESS
1746 da46 bd de 92                     JSR  LB70B          ; EVALUATE FIRST NUMERIC ARGUMENT
1747 da49 35 02                        PULS A              ; GET TOKEN OFFSET FROM STACK
1748 da4b 34 06                        PSHS B,A            ; SAVE TOKEN OFFSET AND NUMERIC ARGUMENT
1749 da4d 8e                           FCB  $8E            ; OP CODE OF LDX# - SKlP 2 BYTES
1750 da4e 8d 9e              LB2C7     BSR  LB262          ; SYNTAX CHECK FOR A '('
1751 da50 35 04              LB2C9     PULS B              ; GET TOKEN OFFSET
1752 da52 be d0 f9                     LDX  COMVEC+8       ; GET SECONDARY FUNCTION JUMP TABLE ADDRESS
1753 da55 3a                 LB2CE     ABX                 ; ADD IN COMMAND OFFSET
1754                         *
1755                         * HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION
1756 da56 ad 94                        JSR  [,X]           ; GO DO AN SECONDARY FUNCTION
1757 da58 7e d8 cf                     JMP  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
1758                         
1759                         * LOGICAL OPERATOR 'OR' JUMPS HERE
1760 da5b 86                 LB2D4     FCB  SKP1LD         ; SKIP ONE BYTE - 'OR' FLAG = $4F
1761                         
1762                         * LOGICAL OPERATOR 'AND' JUMPS HERE
1763 da5c 4f                 LB2D5     CLRA                ; AND FLAG = 0
1764 da5d 97 03                        STA  TMPLOC         ; AND/OR FLAG
1765 da5f bd db 74                     JSR  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
1766 da62 dd 01                        STD  CHARAC         ; TEMP SAVE ACCD
1767 da64 bd e3 96                     JSR  LBC4A          ; MOVE FPA1 TO FPA0
1768 da67 bd db 74                     JSR  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
1769 da6a 0d 03                        TST  TMPLOC         ; CHECK AND/OR FLAG
1770 da6c 26 06                        BNE  LB2ED          ; BRANCH IF OR
1771 da6e 94 01                        ANDA CHARAC         ; * 'AND' ACCD WITH FPA0 INTEGER
1772 da70 d4 02                        ANDB ENDCHR         ; * STORED IN ENDCHR
1773 da72 20 04                        BRA  LB2F1          ; CONVERT TO FP
1774 da74 9a 01              LB2ED     ORA  CHARAC         ; * 'OR' ACCD WITH FPA0 INTEGER
1775 da76 da 02                        ORB  ENDCHR         ; * STORED IN CHARAC
1776 da78 7e dc 7b           LB2F1     JMP  GIVABF         ; CONVERT THE VALUE IN ACCD INTO A FP NUMBER
1777                         
1778                         * RELATIONAL COMPARISON PROCESS HANDLER
1779 da7b bd d8 d4           LB2F4     JSR  LB148          ; 'TM' ERROR IF TYPE MISMATCH
1780 da7e 26 10                        BNE  LB309          ; BRANCH IF STRING VARIABLE
1781 da80 96 61                        LDA  FP1SGN         ; * 'PACK' THE MANTISSA
1782 da82 8a 7f                        ORA  #$7F           ; * SIGN OF FPA1 INTO
1783 da84 94 5d                        ANDA FPA1           ; * BIT 7 OF THE
1784 da86 97 5d                        STA  FPA1           ; * MANTISSA MS BYTE
1785 da88 8e 00 5c                     LDX  #FP1EXP        ; POINT X TO FPA1
1786 da8b bd e3 e2                     JSR  LBC96          ; COMPARE FPA0 TO FPA1
1787 da8e 20 36                        BRA  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
1788                         
1789                         * RELATIONAL COMPARISON OF STRINGS
1790 da90 0f 06              LB309     CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
1791 da92 0a 3f                        DEC  TRELFL         ; REMOVE STRING TYPE FLAG (BIT0=1 FOR STRINGS) FROM THE
1792                         *                             ; DESIRED RELATIONAL COMPARISON DATA
1793 da94 bd dd de                     JSR  LB657          ; GET LENGTH AND ADDRESS OF STRING WHOSE
1794                         *                             ; DESCRIPTOR ADDRESS IS IN THE BOTTOM OF FPA0
1795 da97 d7 56                        STB  STRDES         ; * SAVE LENGTH AND ADDRESS IN TEMPORARY
1796 da99 9f 58                        STX  STRDES+2       ; * DESCRIPTOR (STRING B)
1797 da9b 9e 5f                        LDX  FPA1+2         ; = RETURN LENGTH AND ADDRESS OF STRING
1798 da9d bd dd e0                     JSR  LB659          ; = WHOSE DESCRIPTOR ADDRESS IS STORED IN FPA1+2
1799 daa0 96 56                        LDA  STRDES         ; LOAD ACCA WITH LENGTH OF STRING B
1800 daa2 34 04                        PSHS B              ; SAVE LENGTH A ON STACK
1801 daa4 a0 e0                        SUBA ,S+            ; SUBTRACT LENGTH A FROM LENGTH B
1802 daa6 27 07                        BEQ  LB328          ; BRANCH IF STRINGS OF EQUAL LENGTH
1803 daa8 86 01                        LDA  #1             ; ; TRUE FLAG
1804 daaa 24 03                        BCC  LB328          ; TRUE IF LENGTH B > LENGTH A
1805 daac d6 56                        LDB  STRDES         ; LOAD ACCB WITH LENGTH B
1806 daae 40                           NEGA                ; SET FLAG = FALSE (1FF)
1807 daaf 97 54              LB328     STA  FP0SGN         ; SAVE TRUE/FALSE FLAG
1808 dab1 de 58                        LDU  STRDES+2       ; POINT U TO START OF STRING
1809 dab3 5c                           INCB                ; COMPENSATE FOR THE DECB BELOW
1810                         * ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING
1811 dab4 5a                 LB32D     DECB                ; DECREMENT SHORTER STRING LENGTH
1812 dab5 26 04                        BNE  LB334          ; BRANCH IF ALL OF STRING NOT COMPARED
1813 dab7 d6 54                        LDB  FP0SGN         ; GET TRUE/FALSE FLAB
1814 dab9 20 0b                        BRA  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
1815 dabb a6 80              LB334     LDA  ,X+            ; GET A BYTE FROM STRING A
1816 dabd a1 c0                        CMPA ,U+            ; COMPARE TO STRING B
1817 dabf 27 f3                        BEQ  LB32D          ; CHECK ANOTHER CHARACTER IF =
1818 dac1 c6 ff                        LDB  #$FF           ; FALSE FLAG IF STRING A > B
1819 dac3 24 01                        BCC  LB33F          ; BRANCH IF STRING A > STRING B
1820 dac5 50                           NEGB                ; SET FLAG = TRUE
1821                         
1822                         * DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA0
1823 dac6 cb 01              LB33F     ADDB #1             ; CONVERT $FF,0,1 TO 0,1,2
1824 dac8 59                           ROLB                ; NOW IT'S 1,2,4 FOR > = <
1825 dac9 d4 0a                        ANDB RELFLG         ; 'AND' THE ACTUAL COMPARISON WITH THE DESIRED -
1826                         COMPARISON
1827 dacb 27 02                        BEQ  LB348          ; BRANCH IF FALSE (NO MATCHING BITS)
1828 dacd c6 ff                        LDB  #$FF           ; TRUE FLAG
1829 dacf 7e e3 c8           LB348     JMP  LBC7C          ; CONVERT ACCB INTO FP NUMBER IN FPA0
1830                         
1831                         * DIM
1832 dad2 bd d9 f9           LB34B     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
1833 dad5 c6 01              DIM       LDB  #1             ; DIMENSION FLAG
1834 dad7 8d 08                        BSR  LB35A          ; SAVE ARRAY SPACE FOR THIS VARIABLE
1835 dad9 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1836 dadb 26 f5                        BNE  LB34B          ; KEEP DIMENSIONING IF NOT END OF LINE
1837 dadd 39                           RTS
1838                         * EVALUATE A VARIABLE - RETURN X AND
1839                         * VARPTR POINTING TO VARIABLE DESCRIPTOR
1840                         * EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO
1841                         * BYTES ARE THE VARIABLE NAME AND THE NEXT 5
1842                         * BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE
1843                         * FIRST BYTE OF VARlABLE NAME IS SET, THE
1844                         * VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF
1845                         * THE SECOND BYTE OF VARIABLE NAME IS SET, THE
1846                         * VARIABLE IS A STRING, OTHERWISE THE VARIABLE
1847                         * IS NUMERIC.
1848                         * IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS
1849                         * INSERTED INTO THE VARIABLE SPACE
1850 dade 5f                 LB357     CLRB                ; DIMENSION FLAG = 0; DO NOT SET UP AN ARRAY
1851 dadf 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1852 dae1 d7 05              LB35A     STB  DIMFLG         ; SAVE ARRAY FLAG
1853                         * ENTRY POINT FOR DEF FN VARIABLE SEARCH
1854 dae3 97 37              LB35C     STA  VARNAM         ; SAVE INPUT CHARACTER
1855 dae5 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1856 dae7 8d 40                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
1857 dae9 10 25 ff 16                  LBCS LB277          ; SYNTAX ERROR IF NOT ALPHA
1858 daed 5f                           CLRB                ; DEFAULT 2ND VARIABLE CHARACTER TO ZERO
1859 daee d7 06                        STB  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
1860 daf0 9d 7c                        JSR  GETNCH         ; GET ANOTHER CHARACTER FROM BASIC
1861 daf2 25 04                        BCS  LB371          ; BRANCH IF NUMERIC (2ND CHARACTER IN
1862                         *                             ; VARIABLE MAY BE NUMERIC)
1863 daf4 8d 33                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
1864 daf6 25 0a                        BCS  LB37B          ; BRANCH IF NOT ALPHA
1865 daf8 1f 89              LB371     TFR  A,B            ; SAVE 2ND CHARACTER IN ACCB
1866                         * READ INPUT CHARACTERS UNTIL A NON ALPHA OR
1867                         * NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS
1868                         * IN VARIABLE NAME AFTER THE 1ST TWO
1869 dafa 9d 7c              LB373     JSR  GETNCH         ; GET AN INPUT CHARACTER
1870 dafc 25 fc                        BCS  LB373          ; BRANCH IF NUMERIC
1871 dafe 8d 29                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
1872 db00 24 f8                        BCC  LB373          ; BRANCH IF ALPHA
1873 db02 81 24              LB37B     CMPA #'$            ; CHECK FOR A STRING VARIABLE
1874 db04 26 06                        BNE  LB385          ; BRANCH IF IT IS NOT A STRING
1875 db06 03 06                        COM  VALTYP         ; SET VARIABLE TYPE TO STRING
1876 db08 cb 80                        ADDB #$80           ; SET BIT 7 OF 2ND CHARACTER (STRING)
1877 db0a 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER
1878 db0c d7 38              LB385     STB  VARNAM+1       ; SAVE 2ND CHARACTER IN VARNAM+1
1879 db0e 9a 08                        ORA  ARYDIS         ; OR IN THE ARRAY DISABLE FLAG - IF = $80,
1880                         *              ; DON'T SEARCH FOR VARIABLES IN THE ARRAYS
1881 db10 80 28                        SUBA #'(            ; IS THIS AN ARRAY VARIABLE?
1882 db12 10 27 00 75                  LBEQ LB404          ; BRANCH IF IT IS
1883 db16 0f 08                        CLR  ARYDIS         ; RESET THE ARRAY DISABLE FLAG
1884 db18 9e 1b                        LDX  VARTAB         ; POINT X TO THE START OF VARIABLES
1885 db1a dc 37                        LDD  VARNAM         ; GET VARIABLE IN QUESTION
1886 db1c 9c 1d              LB395     CMPX ARYTAB         ; COMPARE X TO THE END OF VARIABLES
1887 db1e 27 12                        BEQ  LB3AB          ; BRANCH IF END OF VARIABLES
1888 db20 10 a3 81                     CMPD ,X++           ; * COMPARE VARIABLE IN QUESTION TO CURRENT
1889 db23 27 3e                        BEQ  LB3DC          ; * VARIABLE AND BRANCH IF MATCH
1890 db25 30 05                        LEAX 5,X            ; = MOVE POINTER TO NEXT VARIABLE AND
1891 db27 20 f3                        BRA  LB395          ; = KEEP LOOKING
1892                         
1893                         * SET CARRY IF NOT UPPER CASE ALPHA
1894 db29 81 41              LB3A2     CMPA #'A            ; * CARRY SET IF < 'A'
1895 db2b 25 04                        BCS  LB3AA          ; *
1896 db2d 80 5b                        SUBA #'Z+1          ; =
1897                         *         SUBA #-('Z+1)       ; = CARRY CLEAR IF <= 'Z'
1898 db2f 80 a5                        FCB  $80,$A5
1899 db31 39                 LB3AA     RTS
1900                         * PUT A NEW VARIABLE IN TABLE OF VARIABLES
1901 db32 8e 00 74           LB3AB     LDX  #ZERO          ; POINT X TO ZERO LOCATION
1902 db35 ee e4                        LDU  ,S             ; GET CURRENT RETURN ADDRESS
1903 db37 11 83 da 13                  CMPU #LB287         ; DID WE COME FROM 'EVALUATE ALPHA EXPR'?
1904 db3b 27 28                        BEQ  LB3DE          ; YES - RETURN A ZERO VALUE
1905 db3d dc 1f                        LDD  ARYEND         ; * GET END OF ARRAYS ADDRESS AND
1906 db3f dd 43                        STD  V43            ; * SAVE IT AT V43
1907 db41 c3 00 07                     ADDD #7             ; = ADD 7 TO END OF ARRAYS (EACH
1908 db44 dd 41                        STD  V41            ; = VARIABLE = 7 BYTES) AND SAVE AT V41
1909 db46 9e 1d                        LDX  ARYTAB         ; * GET END OF VARIABLES AND SAVE AT V47
1910 db48 9f 47                        STX  V47            ; *
1911 db4a bd d3 de                     JSR  LAC1E          ; MAKE A SEVEN BYTE SLOT FOR NEW VARIABLE AT
1912                         *         TOP  OF VARIABLES
1913 db4d 9e 41                        LDX  V41            ; = GET NEW END OF ARRAYS AND SAVE IT
1914 db4f 9f 1f                        STX  ARYEND         ; =
1915 db51 9e 45                        LDX  V45            ; * GET NEW END OF VARIABLES AND SAVE IT
1916 db53 9f 1d                        STX  ARYTAB         ; *
1917 db55 9e 47                        LDX  V47            ; GET OLD END OF VARIABLES
1918 db57 dc 37                        LDD  VARNAM         ; GET NEW VARIABLE NAME
1919 db59 ed 81                        STD  ,X++           ; SAVE VARIABLE NAME
1920 db5b 4f                           CLRA                ; * ZERO OUT THE FP VALUE OF THE NUMERIC
1921 db5c 5f                           CLRB                ; * VARIABLE OR THE LENGTH AND ADDRESS
1922 db5d ed 84                        STD  ,X             ; * OF A STRING VARIABLE
1923 db5f ed 02                        STD  2,X            ; *
1924 db61 a7 04                        STA  4,X            ; *
1925 db63 9f 39              LB3DC     STX  VARPTR         ; STORE ADDRESS OF VARIABLE VALUE
1926 db65 39                 LB3DE     RTS
1927                         *
1928 db66 90 80 00 00 00     LB3DF     FCB  $90,$80,$00,$00,$00 ; * FLOATING POINT -32768
1929                         *                             ; SMALLEST SIGNED TWO BYTE INTEGER
1930                         *
1931 db6b 9d 7c              LB3E4     JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
1932 db6d bd d8 cd           LB3E6     JSR  LB141          ; GO EVALUATE NUMERIC EXPRESSION
1933 db70 96 54              LB3E9     LDA  FP0SGN         ; GET FPA0 MANTISSA SIGN
1934 db72 2b 5d                        BMI  LB44A          ; 'FC' ERROR IF NEGATIVE NUMBER
1935                         
1936                         
1937 db74 bd d8 cf           INTCNV    JSR  LB143          ; 'TM' ERROR IF STRING VARIABLE
1938 db77 96 4f                        LDA  FP0EXP         ; GET FPA0 EXPONENT
1939 db79 81 90                        CMPA #$90           ; * COMPARE TO 32768 - LARGEST INTEGER EXPONENT AND
1940 db7b 25 08                        BCS  LB3FE          ; * BRANCH IF FPA0 < 32768
1941 db7d 8e db 66                     LDX  #LB3DF         ; POINT X TO FP VALUE OF -32768
1942 db80 bd e3 e2                     JSR  LBC96          ; COMPARE -32768 TO FPA0
1943 db83 26 4c                        BNE  LB44A          ; 'FC' ERROR IF NOT =
1944 db85 bd e4 14           LB3FE     JSR  LBCC8          ; CONVERT FPA0 TO A TWO BYTE INTEGER
1945 db88 dc 52                        LDD  FPA0+2         ; GET THE INTEGER
1946 db8a 39                           RTS
1947                         * EVALUATE AN ARRAY VARIABLE
1948 db8b dc 05              LB404     LDD  DIMFLG         ; GET ARRAY FLAG AND VARIABLE TYPE
1949 db8d 34 06                        PSHS B,A            ; SAVE THEM ON STACK
1950 db8f 12                           NOP                 ; DEAD SPACE CAUSED BY 1.2 REVISION
1951 db90 5f                           CLRB                ; RESET DIMENSION COUNTER
1952 db91 9e 37              LB40A     LDX  VARNAM         ; GET VARIABLE NAME
1953 db93 34 14                        PSHS X,B            ; SAVE VARIABLE NAME AND DIMENSION COUNTER
1954 db95 8d d4                        BSR  LB3E4          ; EVALUATE EXPRESSION (DIMENSlON LENGTH)
1955 db97 35 34                        PULS B,X,Y          ; PULL OFF VARIABLE NAME, DIMENSlON COUNTER,
1956                         *                             ; ARRAY FLAG
1957 db99 9f 37                        STX  VARNAM         ; SAVE VARIABLE NAME AND VARIABLE TYPE
1958 db9b de 52                        LDU  FPA0+2         ; GET DIMENSION LENGTH
1959 db9d 34 60                        PSHS U,Y            ; SAVE DIMENSION LENGTH, ARRAY FLAG, VARIABLE TYPE
1960 db9f 5c                           INCB                ; INCREASE DIMENSION COUNTER
1961 dba0 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1962 dba2 81 2c                        CMPA #',            ; CHECK FOR ANOTHER DIMENSION
1963 dba4 27 eb                        BEQ  LB40A          ; BRANCH IF MORE
1964 dba6 d7 03                        STB  TMPLOC         ; SAVE DIMENSION COUNTER
1965 dba8 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR A ')'
1966 dbab 35 06                        PULS A,B            ; * RESTORE VARIABLE TYPE AND ARRAY
1967 dbad dd 05                        STD  DIMFLG         ; * FLAG - LEAVE DIMENSION LENGTH ON STACK
1968 dbaf 9e 1d                        LDX  ARYTAB         ; GET START OF ARRAYS
1969 dbb1 9c 1f              LB42A     CMPX ARYEND         ; COMPARE TO END OF ARRAYS
1970 dbb3 27 21                        BEQ  LB44F          ; BRANCH IF NO MATCH FOUND
1971 dbb5 dc 37                        LDD  VARNAM         ; GET VARIABLE IN QUESTION
1972 dbb7 10 a3 84                     CMPD ,X             ; COMPARE TO CURRENT VARIABLE
1973 dbba 27 06                        BEQ  LB43B          ; BRANCH IF =
1974 dbbc ec 02                        LDD  2,X            ; GET OFFSET TO NEXT ARRAY VARIABLE
1975 dbbe 30 8b                        LEAX D,X            ; ADD TO CURRENT POINTER
1976 dbc0 20 ef                        BRA  LB42A          ; KEEP SEARCHING
1977 dbc2 c6 12              LB43B     LDB  #2*9           ; 'REDIMENSIONED ARRAY' ERROR
1978 dbc4 96 05                        LDA  DIMFLG         ; * TEST ARRAY FLAG - IF <>0 YOU ARE TRYING
1979 dbc6 26 0b                        BNE  LB44C          ; * TO REDIMENSION AN ARRAY
1980 dbc8 d6 03                        LDB  TMPLOC         ; GET NUMBER OF DIMENSIONS IN ARRAY
1981 dbca e1 04                        CMPB 4,X            ; COMPARE TO THIS ARRAYS DIMENSIONS
1982 dbcc 27 59                        BEQ  LB4A0          ; BRANCH IF =
1983 dbce c6 10              LB447     LDB  #8*2           ; 'BAD SUBSCRIPT'
1984 dbd0 8c                           FCB  SKP2           ; SKIP TWO BYTES
1985 dbd1 c6 08              LB44A     LDB  #4*2           ; 'ILLEGAL FUNCTION CALL'
1986 dbd3 7e d4 06           LB44C     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
1987                         
1988                         * INSERT A NEW ARRAY INTO ARRAY VARIABLES
1989                         * EACH SET OF ARRAY VARIABLES IS PRECEEDED BY A DE-
1990                         * SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS THE
1991                         * NUMBER OF DIMENSIONS IN THE ARRAY. THE BLOCK IS DEFINED
1992                         * AS FOLLOWS: BYTES 0,1:VARIABLE'S NAME; 2,3:TOTAL LENGTH
1993                         * OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIMEN-
1994                         * ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIMEN-
1995                         * SION 2;... 4+N,5+N:LENGTH OF DIMENSION N.
1996                         
1997 dbd6 cc 00 05           LB44F     LDD  #5             ; * 5 BYTES/ARRAY ENTRY SAVE AT COEFPT
1998 dbd9 dd 64                        STD  COEFPT         ; *
1999 dbdb dc 37                        LDD  VARNAM         ; = GET NAME OF ARRAY AND SAVE IN
2000 dbdd ed 84                        STD  ,X             ; = FIRST 2 BYTES OF DESCRIPTOR
2001 dbdf d6 03                        LDB  TMPLOC         ; GET NUMBER OF DIMENSIONS AND SAVE IN
2002 dbe1 e7 04                        STB  4,X            ; * 5TH BYTE OF DESCRIPTOR
2003 dbe3 bd d3 f3                     JSR  LAC33          ; CHECK FOR ROOM FOR DESCRIPTOR IN FREE RAM
2004 dbe6 9f 41                        STX  V41            ; TEMPORARILY SAVE DESCRIPTOR ADDRESS
2005 dbe8 c6 0b              LB461     LDB  #11            ; * DEFAULT DIMENSION VALUE:X(10)
2006 dbea 4f                           CLRA                ; *
2007 dbeb 0d 05                        TST  DIMFLG         ; = CHECK ARRAY FLAG AND BRANCH IF
2008 dbed 27 05                        BEQ  LB46D          ; = NOT DIMENSIONING AN ARRAY
2009 dbef 35 06                        PULS A,B            ; GET DIMENSION LENGTH
2010 dbf1 c3 00 01                     ADDD #1             ; ADD ONE (X(0) HAS A LENGTH OF ONE)
2011 dbf4 ed 05              LB46D     STD  5,X            ; SAVE LENGTH OF ARRAY DIMENSION
2012 dbf6 8d 5d                        BSR  LB4CE          ; MULTIPLY ACCUM ARRAY SIZE NUMBER LENGTH
2013                         *                             ; OF NEW DIMENSION
2014 dbf8 dd 64                        STD  COEFPT         ; TEMP STORE NEW CURRENT ACCUMULATED ARRAY SIZE
2015 dbfa 30 02                        LEAX 2,X            ; BUMP POINTER UP TWO
2016 dbfc 0a 03                        DEC  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND BRANCH IF
2017 dbfe 26 e8                        BNE  LB461          ; * NOT DONE WITH ALL DIMENSIONS
2018 dc00 9f 0f                        STX  TEMPTR         ; SAVE ADDRESS OF (END OF ARRAY DESCRIPTOR - 5)
2019 dc02 d3 0f                        ADDD TEMPTR         ; ADD TOTAL SIZE OF NEW ARRAY
2020 dc04 10 25 f7 fc                  LBCS LAC44          ; 'OM' ERROR IF > $FFFF
2021 dc08 1f 01                        TFR  D,X            ; SAVE END OF ARRAY IN X
2022 dc0a bd d3 f7                     JSR  LAC37          ; MAKE SURE THERE IS ENOUGH FREE RAM FOR ARRAY
2023 dc0d 83 00 35                     SUBD #STKBUF-5      ; SUBTRACT OUT THE (STACK BUFFER - 5)
2024 dc10 dd 1f                        STD  ARYEND         ; SAVE NEW END OF ARRAYS
2025 dc12 4f                           CLRA                ; ZERO = TERMINATOR BYTE
2026 dc13 30 1f              LB48C     LEAX -1,X           ; * STORE TWO TERMINATOR BYTES AT
2027 dc15 a7 05                        STA  5,X            ; * THE END OF THE ARRAY DESCRIPTOR
2028 dc17 9c 0f                        CMPX TEMPTR         ; *
2029 dc19 26 f8                        BNE  LB48C          ; *
2030 dc1b 9e 41                        LDX  V41            ; GET ADDRESS OF START OF DESCRIPTOR
2031 dc1d 96 1f                        LDA  ARYEND         ; GET MSB OF END OF ARRAYS; LSB ALREADY THERE
2032 dc1f 93 41                        SUBD V41            ; SUBTRACT OUT ADDRESS OF START OF DESCRIPTOR
2033 dc21 ed 02                        STD  2,X            ; SAVE LENGTH OF (ARRAY AND DESCRIPTOR)
2034 dc23 96 05                        LDA  DIMFLG         ; * GET ARRAY FLAG AND BRANCH
2035 dc25 26 2d                        BNE  LB4CD          ; * BACK IF DIMENSIONING
2036                         * CALCULATE POINTER TO CORRECT ELEMENT
2037 dc27 e6 04              LB4A0     LDB  4,X            ; GET THE NUMBER OF DIMENSIONS
2038 dc29 d7 03                        STB  TMPLOC         ; TEMPORARILY SAVE
2039 dc2b 4f                           CLRA                ; * INITIALIZE POINTER
2040 dc2c 5f                           CLRB                ; * TO ZERO
2041 dc2d dd 64              LB4A6     STD  COEFPT         ; SAVE ACCUMULATED POINTER
2042 dc2f 35 06                        PULS A,B            ; * PULL DIMENSION ARGUMENT OFF THE
2043 dc31 dd 52                        STD  FPA0+2         ; * STACK AND SAVE IT
2044 dc33 10 a3 05                     CMPD 5,X            ; COMPARE TO STORED 'DIM' ARGUMENT
2045 dc36 24 3a                        BCC  LB4EB          ; 'BS' ERROR IF > = "DIM" ARGUMENT
2046 dc38 de 64                        LDU  COEFPT         ; * GET ACCUMULATED POINTER AND
2047 dc3a 27 04                        BEQ  LB4B9          ; * BRANCH IF 1ST DIMENSION
2048 dc3c 8d 17                        BSR  LB4CE          ; = MULTIPLY ACCUMULATED POINTER AND DIMENSION
2049 dc3e d3 52                        ADDD FPA0+2         ; = LENGTH AND ADD TO CURRENT ARGUMENT
2050 dc40 30 02              LB4B9     LEAX 2,X            ; MOVE POINTER TO NEXT DIMENSION
2051 dc42 0a 03                        DEC  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND
2052 dc44 26 e7                        BNE  LB4A6          ; * BRANCH IF ANY DIMENSIONS LEFT
2053                         * MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE
2054 dc46 ed e3                        STD  ,--S
2055 dc48 58                           ASLB
2056 dc49 49                           ROLA                ; TIMES 2
2057 dc4a 58                           ASLB
2058 dc4b 49                           ROLA                ; TIMES 4
2059 dc4c e3 e1                        ADDD ,S++           ; TIMES 5
2060 dc4e 30 8b                        LEAX D,X            ; ADD OFFSET TO START OF ARRAY
2061 dc50 30 05                        LEAX 5,X            ; ADJUST POINTER FOR SIZE OF DESCRIPTOR
2062 dc52 9f 39                        STX  VARPTR         ; SAVE POINTER TO ARRAY VALUE
2063 dc54 39                 LB4CD     RTS
2064                         * MULTIPLY 2 BYTE NUMBER IN 5,X BY THE 2 BYTE NUMBER
2065                         * IN COEFPT. RETURN RESULT IN ACCD, BS ERROR IF > $FFFF
2066 dc55 86 10              LB4CE     LDA  #16            ; 16 SHIFTS TO DO A MULTIPLY
2067 dc57 97 45                        STA  V45            ; SHIFT COUNTER
2068 dc59 ec 05                        LDD  5,X            ; * GET SIZE OF DIMENSION
2069 dc5b dd 17                        STD  BOTSTK         ; * AND SAVE IT
2070 dc5d 4f                           CLRA                ; * ZERO
2071 dc5e 5f                           CLRB                ; * ACCD
2072 dc5f 58                 LB4D8     ASLB                ; = SHIFT ACCB LEFT
2073 dc60 49                           ROLA                ; = ONE BIT
2074 dc61 25 0f                        BCS  LB4EB          ; 'BS' ERROR IF CARRY
2075 dc63 08 65                        ASL  COEFPT+1       ; * SHIFT MULTIPLICAND LEFT ONE
2076 dc65 09 64                        ROL  COEFPT         ; * BIT - ADD MULTIPLIER TO ACCUMULATOR
2077 dc67 24 04                        BCC  LB4E6          ; * IF CARRY <> 0
2078 dc69 d3 17                        ADDD BOTSTK         ; ADD MULTIPLIER TO ACCD
2079 dc6b 25 05                        BCS  LB4EB          ; 'BS' ERROR IF CARRY (>$FFFF)
2080 dc6d 0a 45              LB4E6     DEC  V45            ; * DECREMENT SHIFT COUNTER
2081 dc6f 26 ee                        BNE  LB4D8          ; * IF NOT DONE
2082 dc71 39                           RTS
2083 dc72 7e db ce           LB4EB     JMP  LB447          ; 'BS' ERROR
2084                         *
2085                         * MEM
2086                         * THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE
2087                         * BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK
2088                         * FOR WHICH MEM DOES NOT ALLOW.
2089                         *
2090 dc75 1f 40              MEM       TFR  S,D            ; PUT STACK POINTER INTO ACCD
2091 dc77 93 1f                        SUBD ARYEND         ; SUBTRACT END OF ARRAYS
2092 dc79 21                           FCB  SKP1           ; SKIP ONE BYTE
2093                         *CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0
2094 dc7a 4f                 LB4F3     CLRA                ; CLEAR MS BYTE OF ACCD
2095                         * CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMBER IN FPA0
2096 dc7b 0f 06              GIVABF    CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
2097 dc7d dd 50                        STD  FPA0           ; SAVE ACCD IN TOP OF FACA
2098 dc7f c6 90                        LDB  #$90           ; EXPONENT REQUIRED IF THE TOP TWO BYTES
2099                         *         OF   FPA0 ARE TO BE TREATED AS AN INTEGER IN FPA0
2100 dc81 7e e3 ce                     JMP  LBC82          ; CONVERT THE REST OF FPA0 TO AN INTEGER
2101                         
2102                         * STR$
2103 dc84 bd d8 cf           STR       JSR  LB143          ; 'TM' ERROR IF STRING VARIABLE
2104 dc87 ce 01 f0                     LDU  #STRBUF+2      ; *CONVERT FP NUMBER TO ASCII STRING IN
2105 dc8a bd e5 28                     JSR  LBDDC          ; *THE STRING BUFFER
2106 dc8d 32 62                        LEAS 2,S            ; PURGE THE RETURN ADDRESS FROM THE STACK
2107 dc8f 8e 01 ef                     LDX  #STRBUF+1      ; *POINT X TO STRING BUFFER AND SAVE
2108 dc92 20 0b                        BRA  LB518          ; *THE STRING IN THE STRING SPACE
2109                         * RESERVE ACCB BYTES OF STRING SPACE. RETURN START
2110                         * ADDRESS IN (X) AND FRESPC
2111 dc94 9f 4d              LB50D     STX  V4D            ; SAVE X IN V4D
2112 dc96 8d 5c              LB50F     BSR  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
2113 dc98 9f 58              LB511     STX  STRDES+2       ; SAVE NEW STRING ADDRESS
2114 dc9a d7 56                        STB  STRDES         ; SAVE LENGTH OF RESERVED BLOCK
2115 dc9c 39                           RTS
2116 dc9d 30 1f              LB516     LEAX -1,X           ; MOVE POINTER BACK ONE
2117                         * SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO) OR
2118                         * EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR ENDCHR IS MATCHED.
2119                         * THE RESULTING STRING IS STORED IN THE STRING SPACE
2120                         * ONLY IF THE START OF THE STRING IS <= STRBUF+2
2121 dc9f 86 22              LB518     LDA  #'"            ; * INITIALIZE
2122 dca1 97 01                        STA  CHARAC         ; * TERMINATORS
2123 dca3 97 02              LB51A     STA  ENDCHR         ; * TO "
2124 dca5 30 01              LB51E     LEAX 1,X            ; MOVE POINTER UP ONE
2125 dca7 9f 62                        STX  RESSGN         ; TEMPORARILY SAVE START OF STRING
2126 dca9 9f 58                        STX  STRDES+2       ; SAVE START OF STRING IN TEMP DESCRIPTOR
2127 dcab c6 ff                        LDB  #-1            ; INITIALIZE CHARACTER COUNTER TO - 1
2128 dcad 5c                 LB526     INCB                ; INCREMENT CHARACTER COUNTER
2129 dcae a6 80                        LDA  ,X+            ; GET CHARACTER
2130 dcb0 27 0c                        BEQ  LB537          ; BRANCH IF END OF LINE
2131 dcb2 91 01                        CMPA CHARAC         ; * CHECK FOR TERMINATORS
2132 dcb4 27 04                        BEQ  LB533          ; * IN CHARAC AND ENDCHR
2133 dcb6 91 02                        CMPA ENDCHR         ; * DON'T MOVE POINTER BACK
2134 dcb8 26 f3                        BNE  LB526          ; * ONE IF TERMINATOR IS "MATCHED"
2135 dcba 81 22              LB533     CMPA #'"            ; = COMPARE CHARACTER TO STRING DELIMITER
2136 dcbc 27 02                        BEQ  LB539          ; = & DON'T MOVE POINTER BACK IF SO
2137 dcbe 30 1f              LB537     LEAX -1,X           ; MOVE POINTER BACK ONE
2138 dcc0 9f 64              LB539     STX  COEFPT         ; SAVE END OF STRING ADDRESS
2139 dcc2 d7 56                        STB  STRDES         ; SAVE STRING LENGTH IN TEMP DESCRIPTOR
2140 dcc4 de 62                        LDU  RESSGN         ; GET INITlAL STRING START
2141 dcc6 11 83 01 f0                  CMPU #STRBUF+2      ; COMPARE TO START OF STRING BUFFER
2142 dcca 22 07              LB543     BHI  LB54C          ; BRANCH IF > START OF STRING BUFFER
2143 dccc 8d c6                        BSR  LB50D          ; GO RESERVE SPACE FOR THE STRING
2144 dcce 9e 62                        LDX  RESSGN         ; POINT X TO THE BEGINNING OF THE STRING
2145 dcd0 bd dd cc                     JSR  LB645          ; MOVE (B) BYTES FROM (X) TO
2146                         *                             [FRESPC] - MOVE STRING DATA
2147                         * PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA
2148                         * ON THE STRING STACK. SET VARIABLE TYPE TO STRING
2149 dcd3 9e 0b              LB54C     LDX  TEMPPT         ; GET NEXT AVAILABLE STRING STACK DESCRIPTOR
2150 dcd5 8c 00 f1                     CMPX #LINHDR        ; COMPARE TO TOP OF STRING DESCRIPTOR STACK - WAS #CFNBUF
2151 dcd8 26 05                        BNE  LB558          ; FORMULA O.K.
2152 dcda c6 1e                        LDB  #15*2          ; STRING FORMULA TOO COMPLEX' ERROR
2153 dcdc 7e d4 06           LB555     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
2154 dcdf 96 56              LB558     LDA  STRDES         ; * GET LENGTH OF STRING AND SAVE IT
2155                         *         STA  ,X             ; * IN BYTE 0 OF DESCRIPTOR
2156 dce1 a7 00                        FCB  $A7,$00
2157 dce3 dc 58                        LDD  STRDES+2       ; = GET START ADDRESS OF ACTUAL STRING
2158 dce5 ed 02                        STD  2,X            ; = AND SAVE IN BYTES 2,3 OF DESCRIPTOR
2159 dce7 86 ff                        LDA  #$FF           ; * VARIABLE TYPE = STRING
2160 dce9 97 06                        STA  VALTYP         ; * SAVE IN VARIABLE TYPE FLAG
2161 dceb 9f 0d                        STX  LASTPT         ; = SAVE START OF DESCRIPTOR
2162 dced 9f 52                        STX  FPA0+2         ; = ADDRESS IN LASTPT AND FPA0
2163 dcef 30 05                        LEAX 5,X            ; 5 BYTES/STRING DESCRIPTOR
2164 dcf1 9f 0b                        STX  TEMPPT         ; NEXT AVAILABLE STRING VARIABLE DESCRIPTOR
2165 dcf3 39                           RTS
2166                         * RESERVE ACCB BYTES IN STRING STORAGE SPACE
2167                         * RETURN WITH THE STARTING ADDRESS OF THE
2168                         * RESERVED STRING SPACE IN (X) AND FRESPC
2169 dcf4 0f 07              LB56D     CLR  GARBFL         ; CLEAR STRING REORGANIZATION FLAG
2170 dcf6 4f                 LB56F     CLRA                ; * PUSH THE LENGTH OF THE
2171 dcf7 34 06                        PSHS B,A            ; * STRING ONTO THE STACK
2172 dcf9 dc 23                        LDD  STRTAB         ; GET START OF STRING VARIABLES
2173 dcfb a3 e0                        SUBD ,S+            ; SUBTRACT STRING LENGTH
2174 dcfd 10 93 21                     CMPD FRETOP         ; COMPARE TO START OF STRING STORAGE
2175 dd00 25 0a                        BCS  LB585          ; IF BELOW START, THEN REORGANIZE
2176 dd02 dd 23                        STD  STRTAB         ; SAVE NEW START OF STRING VARIABLES
2177 dd04 9e 23                        LDX  STRTAB         ; GET START OF STRING VARIABLES
2178 dd06 30 01                        LEAX 1,X            ; ADD ONE
2179 dd08 9f 25                        STX  FRESPC         ; SAVE START ADDRESS OF NEWLY RESERVED SPACE
2180 dd0a 35 84                        PULS B,PC           ; RESTORE NUMBER OF BYTES RESERVED AND RETURN
2181 dd0c c6 1a              LB585     LDB  #2*13          ; OUT OF STRING SPACE' ERROR
2182 dd0e 03 07                        COM  GARBFL         ; TOGGLE REORGANIZATiON FLAG
2183 dd10 27 ca                        BEQ  LB555          ; ERROR IF FRESHLY REORGANIZED
2184 dd12 8d 04                        BSR  LB591          ; GO REORGANIZE STRING SPACE
2185 dd14 35 04                        PULS B              ; GET BACK THE NUMBER OF BYTES TO RESERVE
2186 dd16 20 de                        BRA  LB56F          ; TRY TO RESERVE ACCB BYTES AGAIN
2187                         * REORGANIZE THE STRING SPACE
2188 dd18 9e 27              LB591     LDX  MEMSIZ         ; GET THE TOP OF STRING SPACE
2189 dd1a 9f 23              LB593     STX  STRTAB         ; SAVE TOP OF UNORGANIZED STRING SPACE
2190 dd1c 4f                           CLRA                ; * ZERO OUT ACCD
2191 dd1d 5f                           CLRB                ; * AND RESET VARIABLE
2192 dd1e dd 4b                        STD  V4B            ; * POINTER TO 0
2193 dd20 9e 21                        LDX  FRETOP         ; POINT X TO START OF STRING SPACE
2194 dd22 9f 47                        STX  V47            ; SAVE POINTER IN V47
2195 dd24 8e 00 c9                     LDX  #STRSTK        ; POINT X TO START OF STRING DESCRIPTOR STACK
2196 dd27 9c 0b              LB5A0     CMPX TEMPPT         ; COMPARE TO ADDRESS OF NEXT AVAILABLE DESCRIPTOR
2197 dd29 27 04                        BEQ  LB5A8          ; BRANCH IF TOP OF STRING STACK
2198 dd2b 8d 32                        BSR  LB5D8          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
2199 dd2d 20 f8                        BRA  LB5A0          ; KEEP CHECKING
2200 dd2f 9e 1b              LB5A8     LDX  VARTAB         ; GET THE END OF BASIC PROGRAM
2201 dd31 9c 1d              LB5AA     CMPX ARYTAB         ; COMPARE TO END OF VARIABLES
2202 dd33 27 04                        BEQ  LB5B2          ; BRANCH IF AT TOP OF VARIABLES
2203 dd35 8d 22                        BSR  LB5D2          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
2204 dd37 20 f8                        BRA  LB5AA          ; KEEP CHECKING VARIABLES
2205 dd39 9f 41              LB5B2     STX  V41            ; SAVE ADDRESS OF THE END OF VARIABLES
2206 dd3b 9e 41              LB5B4     LDX  V41            ; GET CURRENT ARRAY POINTER
2207 dd3d 9c 1f              LB5B6     CMPX ARYEND         ; COMPARE TO THE END OF ARRAYS
2208 dd3f 27 35                        BEQ  LB5EF          ; BRANCH IF AT END OF ARRAYS
2209 dd41 ec 02                        LDD  2,X            ; GET LENGTH OF ARRAY AND DESCRIPTOR
2210 dd43 d3 41                        ADDD V41            ; * ADD TO CURRENT ARRAY POINTER
2211 dd45 dd 41                        STD  V41            ; * AND SAVE IT
2212 dd47 a6 01                        LDA  1,X            ; GET 1ST CHARACTER OF VARIABLE NAME
2213 dd49 2a f0                        BPL  LB5B4          ; BRANCH IF NUMERIC ARRAY
2214 dd4b e6 04                        LDB  4,X            ; GET THE NUMBER OF DIMENSIONS IN THIS ARRAY
2215 dd4d 58                           ASLB                ; MULTIPLY BY 2
2216 dd4e cb 05                        ADDB #5             ; ADD FIVE BYTES (VARIABLE NAME, ARRAY
2217                         *                             ; LENGTH, NUMBER DIMENSIONS)
2218 dd50 3a                           ABX                 ; X NOW POINTS TO START OF ARRAY ELEMENTS
2219 dd51 9c 41              LB5CA     CMPX V41            ; AT END OF THIS ARRAY?
2220 dd53 27 e8                        BEQ  LB5B6          ; YES - CHECK FOR ANOTHER
2221 dd55 8d 08                        BSR  LB5D8          ; CHECK FOR STRING LOCATED IN
2222                         *                             ; UNORGANIZED STRING SPACE
2223 dd57 20 f8                        BRA  LB5CA          ; KEEP CHECKING ELEMENTS IN THIS ARRAY
2224 dd59 a6 01              LB5D2     LDA  1,X            ; GET F1RST BYTE OF VARIABLE NAME
2225 dd5b 30 02                        LEAX 2,X            ; MOVE POINTER TO DESCRIPTOR
2226 dd5d 2a 14                        BPL  LB5EC          ; BRANCH IF VARIABLE IS NUMERIC
2227                         * SEARCH FOR STRING - ENTER WITH X POINTING TO
2228                         * THE STRING DESCRIPTOR. IF STRING IS STORED
2229                         * BETWEEN V47 AND STRTAB, SAVE DESCRIPTOR POINTER
2230                         * IN V4B AND RESET V47 TO STRING ADDRESS
2231 dd5f e6 84              LB5D8     LDB  ,X             ; GET THE LENGTH OF THE STRING
2232 dd61 27 10                        BEQ  LB5EC          ; BRANCH IF NULL - NO STRING
2233 dd63 ec 02                        LDD  2,X            ; GET STARTING ADDRESS OF THE STRING
2234 dd65 10 93 23                     CMPD STRTAB         ; COMPARE TO THE START OF STRING VARIABLES
2235 dd68 22 09                        BHI  LB5EC          ; BRANCH IF THIS STRING IS STORED IN
2236                         *              ; THE STRING VARIABLES
2237 dd6a 10 93 47                     CMPD V47            ; COMPARE TO START OF STRING SPACE
2238 dd6d 23 04                        BLS  LB5EC          ; BRANCH IF NOT STORED IN THE STRING SPACE
2239 dd6f 9f 4b                        STX  V4B            ; SAVE VARIABLE POINTER IF STORED IN STRING SPACE
2240 dd71 dd 47                        STD  V47            ; SAVE STRING STARTING ADDRESS
2241 dd73 30 05              LB5EC     LEAX 5,X            ; MOVE TO NEXT VARIABLE DESCRIPTOR
2242 dd75 39                 LB5EE     RTS
2243 dd76 9e 4b              LB5EF     LDX  V4B            ; GET ADDRESS OF THE DESCRIPTOR FOR THE
2244                         *              ; STRING WHICH IS STORED IN THE HIGHEST RAM ADDRESS IN
2245                         *              ; THE UNORGANIZED STRING SPACE
2246 dd78 27 fb                        BEQ  LB5EE          ; BRANCH IF NONE FOUND AND REORGANIZATION DONE
2247 dd7a 4f                           CLRA                ; CLEAR MS BYTE OF LENGTH
2248 dd7b e6 84                        LDB  ,X             ; GET LENGTH OF STRING
2249 dd7d 5a                           DECB                ; SUBTRACT ONE
2250 dd7e d3 47                        ADDD V47            ; ADD LENGTH OF STRING TO ITS STARTING ADDRESS
2251 dd80 dd 43                        STD  V43            ; SAVE AS MOVE STARTING ADDRESS
2252 dd82 9e 23                        LDX  STRTAB         ; POINT X TO THE START OF ORGANIZED STRING VARIABLES
2253 dd84 9f 41                        STX  V41            ; SAVE AS MOVE ENDING ADDRESS
2254 dd86 bd d3 e0                     JSR  LAC20          ; MOVE STRING FROM CURRENT POSITION TO THE
2255                         *              ; TOP OF UNORGANIZED STRING SPACE
2256 dd89 9e 4b                        LDX  V4B            ; POINT X TO STRING DESCRIPTOR
2257 dd8b dc 45                        LDD  V45            ; * GET NEW STARTING ADDRESS OF STRING AND
2258 dd8d ed 02                        STD  2,X            ; * SAVE IT IN DESCRIPTOR
2259 dd8f 9e 45                        LDX  V45            ; GET NEW TOP OF UNORGANIZED STRING SPACE
2260 dd91 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
2261 dd93 7e dd 1a                     JMP  LB593          ; JUMP BACK AND REORGANIZE SOME MORE
2262                         
2263                         
2264 dd96 dc 52              LB60F     LDD  FPA0+2         ; * GET DESCRIPTOR ADDRESS OF STRING A
2265 dd98 34 06                        PSHS B,A            ; * AND SAVE IT ON THE STACK
2266 dd9a bd d9 af                     JSR  LB223          ; GET DESCRIPTOR ADDRESS OF STRING B
2267 dd9d bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
2268 dda0 35 10                        PULS X              ; * POINT X TO STRING A DESCRIPTOR
2269 dda2 9f 62                        STX  RESSGN         ; * ADDRESS AND SAVE IT IN RESSGN
2270 dda4 e6 84                        LDB  ,X             ; GET LENGTH OF STRING A
2271 dda6 9e 52                        LDX  FPA0+2         ; POINT X TO DESCRIPTOR OF STRING B
2272 dda8 eb 84                        ADDB ,X             ; ADD LENGTH OF STRING B TO STR1NG A
2273 ddaa 24 05                        BCC  LB62A          ; BRANCH IF LENGTH < 256
2274 ddac c6 1c                        LDB  #2*14          ; 'STRING TOO LONG' ERROR IF LENGTH > 255
2275 ddae 7e d4 06                     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
2276 ddb1 bd dc 94           LB62A     JSR  LB50D          ; RESERVE ROOM IN STRING SPACE FOR NEW STRING
2277 ddb4 9e 62                        LDX  RESSGN         ; GET DESCRIPTOR ADDRESS OF STRING A
2278 ddb6 e6 84                        LDB  ,X             ; GET LENGTH OF STRING A
2279 ddb8 8d 10                        BSR  LB643          ; MOVE STRING A INTO RESERVED BUFFER IN STRING SPACE
2280 ddba 9e 4d                        LDX  V4D            ; GET DESCRIPTOR ADDRESS OF STRING B
2281 ddbc 8d 22                        BSR  LB659          ; GET LENGTH AND ADDRESS OF STRING B
2282 ddbe 8d 0c                        BSR  LB645          ; MOVE STRING B INTO REST OF RESERVED BUFFER
2283 ddc0 9e 62                        LDX  RESSGN         ; POINT X TO DESCRIPTOR OF STRING A
2284 ddc2 8d 1c                        BSR  LB659          ; DELETE STRING A IF LAST STRING ON STRING STACK
2285 ddc4 bd dc d3                     JSR  LB54C          ; PUT STRING DESCRIPTOR ON THE STRING STACK
2286 ddc7 7e d8 f4                     JMP  LB168          ; BRANCH BACK TO EXPRESSION EVALUATION
2287                         
2288                         * MOVE (B) BYTES FROM 2,X TO FRESPC
2289 ddca ae 02              LB643     LDX  2,X            ; POINT X TO SOURCE ADDRESS
2290 ddcc de 25              LB645     LDU  FRESPC         ; POINT U TO DESTINATION ADDRESS
2291 ddce 5c                           INCB                ; COMPENSATION FOR THE DECB BELOW
2292 ddcf 20 04                        BRA  LB64E          ; GO MOVE THE BYTES
2293                         * MOVE B BYTES FROM (X) TO (U)
2294 ddd1 a6 80              LB64A     LDA  ,X+            ; * GET A SOURCE BYTE AND MOVE IT
2295 ddd3 a7 c0                        STA  ,U+            ; * TO THE DESTINATION
2296 ddd5 5a                 LB64E     DECB                ; DECREMENT BYTE COUNTER
2297 ddd6 26 f9                        BNE  LB64A          ; BRANCH IF ALL BYTES NOT MOVED
2298 ddd8 df 25                        STU  FRESPC         ; SAVE ENDING ADDRESS IN FRESPC
2299 ddda 39                           RTS
2300                         * RETURN LENGTH (ACCB) AND ADDRESS (X) OF
2301                         * STRING WHOSE DESCRIPTOR IS IN FPA0+2
2302                         * DELETE THE STRING IF IT IS THE LAST ONE
2303                         * PUT ON THE STRING STACK. REMOVE STRING FROM STRING
2304                         * SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.
2305 dddb bd d8 d2           LB654     JSR  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
2306 ddde 9e 52              LB657     LDX  FPA0+2         ; GET ADDRESS OF SELECTED STRING DESCRIPTOR
2307 dde0 e6 84              LB659     LDB  ,X             ; GET LENGTH OF STRING
2308 dde2 8d 18                        BSR  LB675          ; * CHECK TO SEE IF THIS STRING DESCRIPTOR WAS
2309 dde4 26 13                        BNE  LB672          ; * THE LAST ONE PUT ON THE STRING STACK AND
2310                         *                             ; * BRANCH IF NOT
2311 dde6 ae 07                        LDX  5+2,X          ; GET START ADDRESS OF STRING JUST REMOVED
2312 dde8 30 1f                        LEAX -1,X           ; MOVE POINTER DOWN ONE
2313 ddea 9c 23                        CMPX STRTAB         ; COMPARE TO START OF STRING VARIABLES
2314 ddec 26 08                        BNE  LB66F          ; BRANCH IF THIS STRING IS NOT AT THE BOTTOM
2315                         *                             ; OF STRING VARIABLES
2316 ddee 34 04                        PSHS B              ; SAVE LENGTH; ACCA WAS CLEARED
2317 ddf0 d3 23                        ADDD STRTAB         ; * ADD THE LENGTH OF THE JUST REMOVED STRING
2318 ddf2 dd 23                        STD  STRTAB         ; * TO THE START OF STRING VARIABLES - THIS WILL
2319                         *                             ; * REMOVE THE STRING FROM THE STRING SPACE
2320 ddf4 35 04                        PULS B              ; RESTORE LENGTH
2321 ddf6 30 01              LB66F     LEAX 1,X            ; ADD ONE TO POINTER
2322 ddf8 39                           RTS
2323 ddf9 ae 02              LB672     LDX  2,X            ; *POINT X TO ADDRESS OF STRING NOT
2324 ddfb 39                           RTS                 ; *ON THE STRING STACK
2325                         * REMOVE STRING FROM STRING STACK. ENTER WITH X
2326                         * POINTING TO A STRING DESCRIPTOR - DELETE THE
2327                         * STRING FROM STACK IF IT IS ON TOP OF THE
2328                         * STACK. IF THE STRING IS DELETED, SET THE ZERO FLAG
2329 ddfc 9c 0d              LB675     CMPX LASTPT         ; *COMPARE TO LAST USED DESCRIPTOR ADDRESS
2330 ddfe 26 07                        BNE  LB680          ; *ON THE STRING STACK, RETURN IF DESCRIPTOR
2331                         *                             ; *ADDRESS NOT ON THE STRING STACK
2332 de00 9f 0b                        STX  TEMPPT         ; SAVE LAST USED DESCRIPTOR AS NEXT AVAILABLE
2333 de02 30 1b                        LEAX -5,X           ; * MOVE LAST USED DESCRIPTOR BACK 5 BYTES
2334 de04 9f 0d                        STX  LASTPT         ; * AND SAVE AS THE LAST USED DESCRIPTOR ADDR
2335 de06 4f                           CLRA                ; SET ZERO FLAG
2336 de07 39                 LB680     RTS
2337                         
2338                         * LEN
2339 de08 8d 03              LEN       BSR  LB686          ; POINT X TO PROPER STRING AND GET LENGTH
2340 de0a 7e dc 7a           LB683     JMP  LB4F3          ; CONVERT ACCB TO FP NUMBER IN FPA0
2341                         * POINT X TO STRING ADDRESS LOAD LENGTH INTO
2342                         * ACCB. ENTER WITH THE STRING DESCRIPTOR IN
2343                         * BOTTOM TWO BYTES OF FPA0
2344 de0d 8d cc              LB686     BSR  LB654          ; GET LENGTH AND ADDRESS OF STRING
2345 de0f 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
2346 de11 5d                           TSTB                ; SET FLAGS ACCORDING TO LENGTH
2347 de12 39                           RTS
2348                         
2349                         * CHR$
2350 de13 bd de 95           CHR       JSR  LB70E          ; CONVERT FPA0 TO AN INTEGER IN ACCD
2351 de16 c6 01              LB68F     LDB  #1             ; * RESERVE ONE BYTE IN
2352 de18 bd dc f4                     JSR  LB56D          ; * THE STRING SPACE
2353 de1b 96 53                        LDA  FPA0+3         ; GET ASCII STRING VALUE
2354 de1d bd dc 98                     JSR  LB511          ; SAVE RESERVED STRING DESCRIPTOR IN TEMP DESCRIPTOR
2355 de20 a7 84                        STA  ,X             ; SAVE THE STRING (IT'S ONLY ONE BYTE)
2356 de22 32 62              LB69B     LEAS 2,S            ; PURGE THE RETURN ADDRESS OFF OF THE STACK
2357 de24 7e dc d3           LB69D     JMP  LB54C          ; PUT TEMP DESCRIPTOR DATA ONTO STRING STACK
2358                         
2359                         
2360 de27 8d 02              ASC       BSR  LB6A4          ; PUT 1ST CHARACTER OF STRING INTO ACCB
2361 de29 20 df                        BRA  LB683          ; CONVERT ACCB INTO FP NUMBER IN FPA0
2362 de2b 8d e0              LB6A4     BSR  LB686          ; POINT X TO STRING DESCRIPTOR
2363 de2d 27 5e                        BEQ  LB706          ; 'FC' ERROR IF NULL STRING
2364 de2f e6 84                        LDB  ,X             ; GET FIRST BYTE OF STRING
2365 de31 39                           RTS
2366                         
2367                         
2368 de32 8d 48              LEFT      BSR  LB6F5          ; GET ARGUMENTS FROM STACK
2369 de34 4f                 LB6AD     CLRA                ; CLEAR STRING POINTER OFFSET - OFFSET = 0 FOR LEFT$
2370 de35 e1 84              LB6AE     CMPB ,X             ; * COMPARE LENGTH PARAMETER TO LENGTH OF
2371 de37 23 03                        BLS  LB6B5          ; * STRING AND BRANCH IF LENGTH OF STRING
2372                         *                             ; >= LENGTH PARAMETER
2373 de39 e6 84                        LDB  ,X             ; USE LENGTH OF STRING OTHERWISE
2374 de3b 4f                           CLRA                ; CLEAR STRING POINTER OFFSET (0 FOR LEFT$)
2375 de3c 34 06              LB6B5     PSHS B,A            ; PUSH PARAMETERS ONTO STACK
2376 de3e bd dc 96                     JSR  LB50F          ; RESERVE ACCB BYTES IN THE STRING SPACE
2377 de41 9e 4d                        LDX  V4D            ; POINT X TO STRING DESCRIPTOR
2378 de43 8d 9b                        BSR  LB659          ; GET ADDRESS OF OLD STRING (X=ADDRESS)
2379 de45 35 04                        PULS B              ; * PULL STRING POINTER OFFSET OFF OF THE STACK
2380 de47 3a                           ABX                 ; * AND ADD IT TO STRING ADDRESS
2381 de48 35 04                        PULS B              ; PULL LENGTH PARAMETER OFF OF THE STACK
2382 de4a bd dd cc                     JSR  LB645          ; MOVE ACCB BYTES FROM (X) TO [FRESPC]
2383 de4d 20 d5                        BRA  LB69D          ; PUT TEMP STRING DESCRIPTOR ONTO THE STRING STACK
2384                         
2385                         * RIGHT$
2386 de4f 8d 2b              RIGHT     BSR  LB6F5          ; GET ARGUMENTS FROM STACK
2387 de51 a0 84                        SUBA ,X             ; ACCA=LENGTH PARAMETER - LENGTH OF OLD STRING
2388 de53 40                           NEGA                ; NOW ACCA = LENGTH OF OLD STRING
2389 de54 20 df                        BRA  LB6AE          ; PUT NEW STRING IN THE STRING SPACE
2390                         
2391                         * MID$
2392 de56 c6 ff              MID       LDB  #$FF           ; * GET DEFAULT VALUE OF LENGTH AND
2393 de58 d7 53                        STB  FPA0+3         ; * SAVE IT IN FPA0
2394 de5a 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
2395 de5c 81 29                        CMPA #')            ; ARGUMENT DELIMITER?
2396 de5e 27 05                        BEQ  LB6DE          ; YES - NO LENGTH PARAMETER GIVEN
2397 de60 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
2398 de63 8d 2d                        BSR  LB70B          ; EVALUATE NUMERIC EXPRESSION (LENGTH)
2399 de65 8d 15              LB6DE     BSR  LB6F5          ; GET ARGUMENTS FROM STACK
2400 de67 27 24                        BEQ  LB706          ; 'FC' ERROR IF NULL STRING
2401 de69 5f                           CLRB                ; CLEAR LENGTH COUNTER (DEFAULT VALUE)
2402 de6a 4a                           DECA                ; *SUOTRACT ONE FROM POSITION PARAMETER (THESE
2403 de6b a1 84                        CMPA ,X             ; *ROUTINES EXPECT 1ST POSITION TO BE ZERO, NOT ONE)
2404                         *                             ; *AND COMPARE IT TO LENGTH OF OLD STRING
2405 de6d 24 cd                        BCC  LB6B5          ; IF POSITION > LENGTH OF OLD STRING, THEN NEW
2406                         *                             ; STRING WILL BE A NULL STRING
2407 de6f 1f 89                        TFR  A,B            ; SAVE ABSOLUTE POSITION PARAMETER IN ACCB
2408 de71 e0 84                        SUBB ,X             ; ACCB=POSITION-LENGTH OF OLD STRING
2409 de73 50                           NEGB                ; NOW ACCB=LENGTH OF OLDSTRING-POSITION
2410 de74 d1 53                        CMPB FPA0+3         ; *IF THE AMOUNT OF OLD STRING TO THE RIGHT OF
2411 de76 23 c4                        BLS  LB6B5          ; *POSITION IS <= THE LENGTH PARAMETER, BRANCH AND
2412                         * USE ALL OF THE STRING TO THE RIGHT OF THE POSITION
2413                         * INSTEAD OF THE LENGTH PARAMETER
2414 de78 d6 53                        LDB  FPA0+3         ; GET LENGTH OF NEW STRING
2415 de7a 20 c0                        BRA  LB6B5          ; PUT NEW STRING IN STRING SPACE
2416                         * DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY CALCULATED NUMERIC
2417                         * ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR OFF OF THE STACK
2418 de7c bd d9 f3           LB6F5     JSR  LB267          ; SYNTAX CHECK FOR A ")"
2419 de7f ee e4                        LDU  ,S             ; LOAD THE RETURN ADDRESS INTO U REGISTER
2420 de81 ae 65                        LDX  5,S            ; * GET ADDRESS OF STRING AND
2421 de83 9f 4d                        STX  V4D            ; * SAVE IT IN V4D
2422 de85 a6 64                        LDA  4,S            ; = PUT LENGTH OF STRING IN
2423 de87 e6 64                        LDB  4,S            ; = BOTH ACCA AND ACCB
2424 de89 32 67                        LEAS 7,S            ; REMOVE DESCRIPTOR AND RETURN ADDRESS FROM STACK
2425 de8b 1f 35                        TFR  U,PC           ; JUMP TO ADDRESS IN U REGISTER
2426 de8d 7e db d1           LB706     JMP  LB44A          ; 'ILLEGAL FUNCTION CALL'
2427                         * EVALUATE AN EXPRESSION - RETURN AN INTEGER IN
2428                         * ACCB - 'FC' ERROR IF EXPRESSION > 255
2429 de90 9d 7c              LB709     JSR  GETNCH         ; GET NEXT BASIC INPUT CHARACTER
2430 de92 bd d8 cd           LB70B     JSR  LB141          ; EVALUATE A NUMERIC EXPRESSION
2431 de95 bd db 70           LB70E     JSR  LB3E9          ; CONVERT FPA0 TO INTEGER IN ACCD
2432 de98 4d                           TSTA                ; TEST MS BYTE OF INTEGER
2433 de99 26 f2                        BNE  LB706          ; 'FC' ERROR IF EXPRESSION > 255
2434 de9b 0e 82                        JMP  GETCCH         ; GET CURRENT INPUT CHARACTER FROM BASIC
2435                         
2436                         * VAL
2437 de9d bd de 0d           VAL       JSR  LB686          ; POINT X TO STRING ADDRESS
2438 dea0 10 27 02 e1                  LBEQ LBA39          ; IF NULL STRING SET FPA0
2439 dea4 de 83                        LDU  CHARAD         ; SAVE INPUT POINTER IN REGISTER U
2440 dea6 9f 83                        STX  CHARAD         ; POINT INPUT POINTER TO ADDRESS OF STRING
2441 dea8 3a                           ABX                 ; MOVE POINTER TO END OF STRING TERMINATOR
2442 dea9 a6 84                        LDA  ,X             ; GET LAST BYTE OF STRING
2443 deab 34 52                        PSHS U,X,A          ; SAVE INPUT POINTER, STRING TERMINATOR
2444                         *         ADDRESS AND CHARACTER
2445 dead 6f 84                        CLR  ,X             ; CLEAR STRING TERMINATOR : FOR ASCII - FP CONVERSION
2446 deaf 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
2447 deb1 bd e4 5e                     JSR  LBD12          ; CONVERT AN ASCII STRING TO FLOATING POINT
2448 deb4 35 52                        PULS A,X,U          ; RESTORE CHARACTERS AND POINTERS
2449 deb6 a7 84                        STA  ,X             ; REPLACE STRING TERMINATOR
2450 deb8 df 83                        STU  CHARAD         ; RESTORE INPUT CHARACTER
2451 deba 39                           RTS
2452                         
2453 debb 8d 07              LB734     BSR  LB73D          ; * EVALUATE AN EXPRESSION, RETURN
2454 debd 9f 2b                        STX  BINVAL         ; * THE VALUE IN X; STORE IT IN BINVAL
2455 debf bd d9 f9           LB738     JSR  LB26D          ; SYNTAX CHECK FOR A COMMA
2456 dec2 20 ce                        BRA  LB70B          ; EVALUATE EXPRESSION IN RANGE 0 <= X < 256
2457                         * EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 'FC' ERROR IF
2458                         
2459 dec4 bd d8 cd           LB73D     JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
2460 dec7 96 54              LB740     LDA  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
2461 dec9 2b c2                        BMI  LB706          ; ILLEGAL FUNCTION CALL' IF NEGATIVE
2462 decb 96 4f                        LDA  FP0EXP         ; GET EXPONENT OF FPA0
2463 decd 81 90                        CMPA #$90           ; COMPARE TO LARGEST POSITIVE INTEGER
2464 decf 22 bc                        BHI  LB706          ; ILLEGAL FUNCTION CALL' IF TOO LARGE
2465 ded1 bd e4 14                     JSR  LBCC8          ; SHIFT BINARY POINT TO EXTREME RIGHT OF FPA0
2466 ded4 9e 52                        LDX  FPA0+2         ; LOAD X WITH LOWER TWO BYTES OF FPA0
2467 ded6 39                           RTS
2468                         
2469                         * PEEK
2470 ded7 8d ee              PEEK      BSR  LB740          ; CONVERT FPA0 TO INTEGER IN REGISTER X
2471 ded9 e6 84                        LDB  ,X             ; GET THE VALUE BEING 'PEEK'ED
2472 dedb 7e dc 7a                     JMP  LB4F3          ; CONVERT ACCB INTO A FP NUMBER
2473                         
2474                         * POKE
2475 dede 8d db              POKE      BSR  LB734          ; EVALUATE 2 EXPRESSIONS
2476 dee0 9e 2b                        LDX  BINVAL         ; GET THE ADDRESS TO BE 'POKE'ED
2477 dee2 e7 84                        STB  ,X             ; STORE THE DATA IN THAT ADDRESS
2478 dee4 39                           RTS
2479                         
2480                         
2481                         * LIST
2482 dee5 34 01              LIST      PSHS CC             ; SAVE ZERO FLAG ON STACK
2483 dee7 bd d7 17                     JSR  LAF67          ; CONVERT DECIMAL LINE NUMBER TO BINARY
2484 deea bd d4 a5                     JSR  LAD01          ; * FIND RAM ADDRESS OF THAT LINE NUMBER AND
2485 deed 9f 66                        STX  LSTTXT         ; * SAVE IT IN LSTTXT
2486 deef 35 01                        PULS CC             ; GET ZERO FLAG FROM STACK
2487 def1 27 12                        BEQ  LB784          ; BRANCH IF END OF LINE
2488 def3 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
2489 def5 27 13                        BEQ  LB789          ; BRANCH IF END OF LINE
2490 def7 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN (IS IT A RANGE OF LINE NUMBERS?)
2491 def9 26 09                        BNE  LB783          ; NO - RETURN
2492 defb 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
2493 defd 27 06                        BEQ  LB784          ; BRANCH IF END OF LINE
2494 deff bd d7 17                     JSR  LAF67          ; GET ENDING LINE NUMBER
2495 df02 27 06                        BEQ  LB789          ; BRANCH IF LEGAL LINE NUMBER
2496 df04 39                 LB783 RTS
2497                         * LIST THE ENTIRE PROGRAM
2498 df05 ce ff ff           LB784     LDU  #$FFFF         ; * SET THE DEFAULT ENDING LINE NUMBER
2499 df08 df 2b                        STU  BINVAL         ; * TO $FFFF
2500 df0a 32 62              LB789     LEAS 2,S            ; PURGE RETURN ADDRESS FROM THE STACK
2501 df0c 9e 66                        LDX  LSTTXT         ; POINT X TO STARTING LINE ADDRESS
2502 df0e bd e0 ac           LB78D     JSR  LB95C          ; MOVE CURSOR TO START OF A NEW LINE
2503 df11 bd d1 9a                     JSR  LA549          ; CHECK FOR A BREAK OR PAUSE
2504 df14 ec 84                        LDD  ,X             ; GET ADDRESS OF NEXT BASIC LINE
2505 df16 26 03                        BNE  LB79F          ; BRANCH IF NOT END OF PROGRAM
2506                         LB797
2507 df18 7e d4 25                     JMP  LAC73          ; RETURN TO BASIC'S MAIN INPUT LOOP
2508 df1b 9f 66              LB79F     STX  LSTTXT         ; SAVE NEW STARTING LINE ADDRESS
2509 df1d ec 02                        LDD  2,X            ; * GET THE LINE NUMBER OF THIS LINE AND
2510 df1f 10 93 2b                     CMPD BINVAL         ; * COMPARE IT TO ENDING LINE NUMBER
2511 df22 22 f4                        BHI  LB797          ; EXIT IF LINE NUMBER > ENDING LINE NUMBER
2512 df24 bd e5 18                     JSR  LBDCC          ; PRINT THE NUMBER IN ACCD ON SCREEN IN DECIMAL
2513 df27 bd e0 f8                     JSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
2514 df2a 9e 66                        LDX  LSTTXT         ; GET RAM ADDRESS OF THIS LINE
2515 df2c 8d 10                        BSR  LB7C2          ; UNCRUNCH A LINE
2516 df2e ae 9f 00 66                  LDX  [LSTTXT]       ; POINT X TO START OF NEXT LINE
2517 df32 ce 00 f4                     LDU  #LINBUF+1      ; POINT U TO BUFFER FULL OF UNCRUNCHED LINE
2518 df35 a6 c0              LB7B9     LDA  ,U+            ; GET A BYTE FROM THE BUFFER
2519 df37 27 d5                        BEQ  LB78D          ; BRANCH IF END OF BUFFER
2520 df39 bd e0 fd                     JSR  LB9B1          ; SEND CHARACTER TO CONSOLE OUT
2521 df3c 20 f7                        BRA  LB7B9          ; GET ANOTHER CHARACTER
2522                         
2523                         * UNCRUNCH A LINE INTO BASIC'S LINE INPUT BUFFER
2524 df3e 30 04              LB7C2     LEAX 4,X            ; MOVE POINTER PAST ADDRESS OF NEXT LINE AND LINE NUMBER
2525 df40 10 8e 00 f4                  LDY  #LINBUF+1      ; UNCRUNCH LINE INTO LINE INPUT BUFFER
2526 df44 a6 80              LB7CB     LDA  ,X+            ; GET A CHARACTER
2527 df46 27 51                        BEQ  LB820          ; BRANCH IF END OF LINE
2528 df48 2b 15                        BMI  LB7E6          ; BRANCH IF IT'S A TOKEN
2529 df4a 81 3a                        CMPA #':            ; CHECK FOR END OF SUB LINE
2530 df4c 26 0d                        BNE  LB7E2          ; BRNCH IF NOT END OF SUB LINE
2531 df4e e6 84                        LDB  ,X             ; GET CHARACTER FOLLOWING COLON
2532 df50 c1 84                        CMPB #TOK_ELSE      ; TOKEN FOR ELSE?
2533 df52 27 f0                        BEQ  LB7CB          ; YES - DON'T PUT IT IN BUFFER
2534 df54 c1 83                        CMPB #TOK_SNGL_Q    ; TOKEN FOR REMARK?
2535 df56 27 ec                        BEQ  LB7CB          ; YES - DON'T PUT IT IN BUFFER
2536 df58 8c                           FCB  SKP2           ; SKIP TWO BYTES
2537 df59 86 21              LB7E0     LDA  #'!            ; EXCLAMATION POINT
2538 df5b 8d 30              LB7E2     BSR  LB814          ; PUT CHARACTER IN BUFFER
2539 df5d 20 e5                        BRA  LB7CB          ; GET ANOTHER CHARACTER
2540                         
2541 df5f ce d0 e7           LB7E6     LDU  #COMVEC-10     ; FIRST DO COMMANDS
2542 df62 81 ff                        CMPA #$FF           ; CHECK FOR SECONDARY TOKEN
2543 df64 26 04                        BNE  LB7F1          ; BRANCH IF NON SECONDARY TOKEN
2544 df66 a6 80                        LDA  ,X+            ; GET SECONDARY TOKEN
2545 df68 33 45                        LEAU 5,U            ; BUMP IT UP TO SECONDARY FUNCTIONS
2546 df6a 84 7f              LB7F1     ANDA #$7F           ; MASK OFF BIT 7 OF TOKEN
2547 df6c 33 4a              LB7F3     LEAU 10,U           ; MOVE TO NEXT COMMAND TABLE
2548 df6e 6d c4                        TST  ,U             ; IS THIS TABLE ENABLED?
2549 df70 27 e7                        BEQ  LB7E0          ; NO - ILLEGAL TOKEN
2550 df72 a0 c4                        SUBA ,U             ; SUBTRACT THE NUMBER OF TOKENS FROM THE CURRENT TOKEN NUMBER
2551 df74 2a f6                        BPL  LB7F3          ; BRANCH IF TOKEN NOT IN THIS TABLE
2552 df76 ab c4                        ADDA ,U             ; RESTORE TOKEN NUMBER RELATIVE TO THIS TABLE
2553 df78 ee 41                        LDU  1,U            ; POINT U TO COMMAND DICTIONARY TABLE
2554 df7a 4a                 LB801     DECA                ; DECREMENT TOKEN NUMBER
2555 df7b 2b 06                        BMI  LB80A          ; BRANCH IF THIS IS THE CORRECT TOKEN
2556                         * SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN
2557 df7d 6d c0              LB804     TST  ,U+            ; GRAB A BYTE
2558 df7f 2a fc                        BPL  LB804          ; BRANCH IF BIT 7 NOT SET
2559 df81 20 f7                        BRA  LB801          ; GO SEE IF THIS IS THE CORRECT TOKEN
2560 df83 a6 c4              LB80A     LDA  ,U             ; GET A CHARACTER FROM DICTIONARY TABLE
2561 df85 8d 06                        BSR  LB814          ; PUT CHARACTER IN BUFFER
2562 df87 6d c0                        TST  ,U+            ; CHECK FOR START OF NEXT TOKEN
2563 df89 2a f8                        BPL  LB80A          ; BRANCH IF NOT DONE WITH THIS TOKEN
2564 df8b 20 b7                        BRA  LB7CB          ; GO GET ANOTHER CHARACTER
2565 df8d 10 8c 01 ed        LB814     CMPY #LINBUF+LBUFMX ; TEST FOR END OF LINE INPUT BUFFER
2566 df91 24 06                        BCC  LB820          ; BRANCH IF AT END OF BUFFER
2567 df93 84 7f                        ANDA #$7F           ; MASK OFF BIT 7
2568 df95 a7 a0                        STA  ,Y+            ; * SAVE CHARACTER IN BUFFER AND
2569 df97 6f a4                        CLR  ,Y             ; * CLEAR NEXT CHARACTER SLOT IN BUFFER
2570 df99 39                 LB820     RTS
2571                         *
2572                         * CRUNCH THE LINE THAT THE INPUT POINTER IS
2573                         * POINTING TO INTO THE LINE INPUT BUFFER
2574                         * RETURN LENGTH OF CRUNCHED LINE IN ACCD
2575                         *
2576 df9a 9e 83              LB821     LDX  CHARAD         ; GET BASIC'S INPUT POINTER ADDRESS
2577 df9c ce 00 f3                     LDU  #LINBUF        ; POINT X TO LINE INPUT BUFFER
2578 df9f 0f 43              LB829     CLR  V43            ; CLEAR ILLEGAL TOKEN FLAG
2579 dfa1 0f 44                        CLR  V44            ; CLEAR DATA FLAG
2580 dfa3 a6 80              LB82D     LDA  ,X+            ; GET INPUT CHAR
2581 dfa5 27 21                        BEQ  LB852          ; BRANCH IF END OF LINE
2582 dfa7 0d 43                        TST  V43            ; * CHECK ILLEGAL TOKEN FLAG & BRANCH IF NOT
2583 dfa9 27 0f                        BEQ  LB844          ; * PROCESSING AN ILLEGAL TOKEN
2584 dfab bd db 29                     JSR  LB3A2          ; SET CARRY IF NOT UPPER CASE ALPHA
2585 dfae 24 18                        BCC  LB852          ; BRANCH IF UPPER CASE ALPHA
2586 dfb0 81 30                        CMPA #'0            ; * DON'T CRUNCH ASCII NUMERIC CHARACTERS
2587 dfb2 25 04                        BLO  LB842          ; * BRANCH IF NOT NUMERIC
2588 dfb4 81 39                        CMPA #'9            ; *
2589 dfb6 23 10                        BLS  LB852          ; * BRANCH IF NUMERIC
2590                         * END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC
2591 dfb8 0f 43              LB842     CLR  V43            ; CLEAR ILLEGAL TOKEN FLAG
2592 dfba 81 20              LB844     CMPA #SPACE         ; SPACE?
2593 dfbc 27 0a                        BEQ  LB852          ; DO NOT REMOVE SPACES
2594 dfbe 97 42                        STA  V42            ; SAVE INPUT CHARACTER AS SCAN DELIMITER
2595 dfc0 81 22                        CMPA #'"            ; CHECK FOR STRING DELIMITER
2596 dfc2 27 38                        BEQ  LB886          ; BRANCH IF STRING
2597 dfc4 0d 44                        TST  V44            ; * CHECK DATA FLAG AND BRANCH IF CLEAR
2598 dfc6 27 19                        BEQ  LB86B          ; * DO NOT CRUNCH DATA
2599 dfc8 a7 c0              LB852     STA  ,U+            ; SAVE CHARACTER IN BUFFER
2600 dfca 27 06                        BEQ  LB85C          ; BRANCH IF END OF LINE
2601 dfcc 81 3a                        CMPA #':            ; * CHECK FOR END OF SUBLINE
2602 dfce 27 cf                        BEQ  LB829          ; * AND RESET FLAGS IF END OF SUBLINE
2603 dfd0 20 d1              LB85A     BRA  LB82D          ; GO GET ANOTHER CHARACTER
2604 dfd2 6f c0              LB85C     CLR  ,U+            ; * DOUBLE ZERO AT END OF LINE
2605 dfd4 6f c0                        CLR  ,U+            ; *
2606 dfd6 1f 30                        TFR  U,D            ; SAVE ADDRESS OF END OF LINE IN ACCD
2607 dfd8 83 00 f1                     SUBD #LINHDR        ; LENGTH OF LINE IN ACCD
2608 dfdb 8e 00 f2                     LDX  #LINBUF-1      ; * SET THE INPUT POINTER TO ONE BEFORE
2609 dfde 9f 83                        STX  CHARAD         ; * THE START OF THE CRUNCHED LINE
2610 dfe0 39                           RTS                 ; EXIT 'CRUNCH'
2611 dfe1 81 3f              LB86B     CMPA #'?            ; CHECK FOR "?" - PRINT ABBREVIATION
2612 dfe3 26 04                        BNE  LB873          ; BRANCH IF NOT PRINT ABBREVIATION
2613 dfe5 86 87                        LDA  #TOK_PRINT     ; * GET THE PRINT TOKEN AND SAVE IT
2614 dfe7 20 df                        BRA  LB852          ; * IN BUFFER
2615 dfe9 81 27              LB873     CMPA #''            ; APOSTROPHE IS SAME AS REM
2616 dfeb 26 13                        BNE  LB88A          ; BRANCH IF NOT REMARK
2617 dfed cc 3a 83                     LDD  #$3A00+TOK_SNGL_Q ; COLON, REM TOKEN
2618 dff0 ed c1                        STD  ,U++           ; SAVE IN BUFFER
2619 dff2 0f 42              LB87C     CLR  V42            ; SET DELIMITER = 0 (END OF LINE)
2620 dff4 a6 80              LB87E     LDA  ,X+            ; SCAN TILL WE MATCH [V42]
2621 dff6 27 d0                        BEQ  LB852          ; BRANCH IF END OF LINE
2622 dff8 91 42                        CMPA V42            ; DELIMITER?
2623 dffa 27 cc                        BEQ  LB852          ; BRANCH OUT IF SO
2624 dffc a7 c0              LB886     STA  ,U+            ; DON'T CRUNCH REMARKS OR STRINGS
2625 dffe 20 f4                        BRA  LB87E          ; GO GET MORE STRING OR REMARK
2626 e000 81 30              LB88A     CMPA #'0            ; * LESS THAN ASCII ZERO?
2627 e002 25 04                        BCS  LB892          ; * BRANCH IF SO
2628 e004 81 3c                        CMPA #';+1          ; = CHECK FOR NUMERIC VALUE, COLON OR SEMICOLON
2629 e006 25 c0                        BCS  LB852          ; = AND INSERT IN BUFFER IF SO
2630 e008 30 1f              LB892     LEAX -1,X           ; MOVE INPUT POINTER BACK ONE
2631 e00a 34 50                        PSHS U,X            ; SAVE POINTERS TO INPUT STRING, OUTPUT STRING
2632 e00c 0f 41                        CLR  V41            ; TOKEN FLAG 0 = COMMAND, FF = SECONDARY
2633 e00e ce d0 e7                     LDU  #COMVEC-10     ; POINT U TO COMMAND INTERPRETATION
2634                         *                             ; TABLE FOR BASIC - 10
2635 e011 0f 42              LB89B     CLR  V42            ; INITIALIZE V42 AS TOKEN COUNTER
2636 e013 33 4a              LB89D     LEAU 10,U           ; MOVE TO NEXT COMMAND INTERPRETATION TABLE
2637 e015 a6 c4                        LDA  ,U             ; GET NUMBER OF COMMANDS
2638 e017 27 31                        BEQ  LB8D4          ; GO DO SECONDARY FUNCTIONS IF NO COMMAND TABLE
2639 e019 10 ae 41                     LDY  1,U            ; POINT Y TO COMMAND DICTIONARY TABLE
2640 e01c ae e4              LB8A6     LDX  ,S             ; GET POINTER TO INPUT STRING
2641 e01e e6 a0              LB8A8     LDB  ,Y+            ; GET A BYTE FROM DICTIONARY TABLE
2642 e020 e0 80                        SUBB ,X+            ; SUBTRACT INPUT CHARACTER
2643 e022 27 fa                        BEQ  LB8A8          ; LOOP IF SAME
2644 e024 c1 80                        CMPB #$80           ; LAST CHAR IN RESERVED WORD TABLE HAD
2645                         *                             ; BIT 7 SET, SO IF WE HAVE $80 HERE
2646                         *                             ; THEN IT IS A GOOD COMPARE
2647 e026 26 38                        BNE  LB8EA          ; BRANCH IF NO MATCH - CHECK ANOTHER COMMAND
2648 e028 32 62                        LEAS 2,S            ; DELETE OLD INPUT POINTER FROM STACK
2649 e02a 35 40                        PULS U              ; GET POINTER TO OUTPUT STRING
2650 e02c da 42                        ORB  V42            ; OR IN THE TABLE POSITION TO MAKE THE TOKEN
2651                         *                             ; - NOTE THAT B ALREADY HAD $80 IN IT -
2652 e02e 96 41                        LDA  V41            ; * CHECK TOKEN FLAG AND BRANCH
2653 e030 26 06                        BNE  LB8C2          ; * IF SECONDARY
2654 e032 c1 84                        CMPB #TOK_ELSE      ; IS IT ELSE TOKEN?
2655 e034 26 06                        BNE  LB8C6          ; NO
2656 e036 86 3a                        LDA  #':            ; PUT A COLON (SUBLINE) BEFORE ELSE TOKEN
2657 e038 ed c1              LB8C2     STD  ,U++           ; SECONDARY TOKENS PRECEEDED BY $FF
2658 e03a 20 94                        BRA  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
2659 e03c e7 c0              LB8C6     STB  ,U+            ; SAVE THIS TOKEN
2660 e03e c1 86                        CMPB #TOK_DATA      ; DATA TOKEN?
2661 e040 26 02                        BNE  LB8CE          ; NO
2662 e042 0c 44                        INC  V44            ; SET DATA FLAG
2663 e044 c1 82              LB8CE     CMPB #TOK_REM       ; REM TOKEN?
2664 e046 27 aa                        BEQ  LB87C          ; YES
2665 e048 20 86              LB8D2     BRA  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
2666                         * CHECK FOR A SECONDARY TOKEN
2667 e04a ce d0 ec           LB8D4     LDU  #COMVEC-5      ; NOW DO SECONDARY FUNCTIONS
2668 e04d 03 41                        COM  V41            ; TOGGLE THE TOKEN FLAG
2669 e04f 26 c0                        BNE  LB89B          ; BRANCH IF NOW CHECKING SECONDARY COMMANDS
2670                         
2671                         * THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CRUNCHED AND SO
2672                         * IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN
2673 e051 35 50                        PULS X,U            ; RESTORE INPUT AND OUTPUT POINTERS
2674 e053 a6 80                        LDA  ,X+            ; * MOVE THE FIRST CHARACTER OF AN
2675 e055 a7 c0                        STA  ,U+            ; * ILLEGAL TOKEN
2676 e057 bd db 29                     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
2677 e05a 25 ec                        BCS  LB8D2          ; BRANCH IF NOT ALPHA
2678 e05c 03 43                        COM  V43            ; SET ILLEGAL TOKEN FLAG IF UPPER CASE ALPHA
2679 e05e 20 e8                        BRA  LB8D2          ; PROCESS MORE INPUT CHARACTERS
2680 e060 0c 42              LB8EA     INC  V42            ; INCREMENT TOKEN COUNTER
2681 e062 4a                           DECA                ; DECR COMMAND COUNTER
2682 e063 27 ae                        BEQ  LB89D          ; GET ANOTHER COMMAND TABLE IF DONE W/THIS ONE
2683 e065 31 3f                        LEAY -1,Y           ; MOVE POINTER BACK ONE
2684 e067 e6 a0              LB8F1     LDB  ,Y+            ; * GET TO NEXT
2685 e069 2a fc                        BPL  LB8F1          ; * RESERVED WORD
2686 e06b 20 af                        BRA  LB8A6          ; GO SEE IF THIS WORD IS A MATCH
2687                         
2688                         * PRINT
2689 e06d 27 39              PRINT     BEQ  LB958          ; BRANCH IF NO ARGUMENT
2690 e06f 8d 01                        BSR  LB8FE          ; CHECK FOR ALL PRINT OPTIONS
2691 e071 39                           RTS
2692                         LB8FE
2693 e072 bd ef d2           LB918     JSR  XVEC9          ; CALL EXTENDED BASIC ADD-IN
2694 e075 27 3e              LB91B     BEQ  LB965          ; RETURN IF END OF LINE
2695 e077 81 9f              LB91D     CMPA #TOK_TAB       ; TOKEN FOR TAB( ?
2696 e079 27 53                        BEQ  LB97E          ; YES
2697 e07b 81 2c                        CMPA #',            ; COMMA?
2698 e07d 27 37                        BEQ  LB966          ; YES - ADVANCE TO NEXT TAB FIELD
2699 e07f 81 3b                        CMPA #';            ; SEMICOLON?
2700 e081 27 60                        BEQ  LB997          ; YES - DO NOT ADVANCE CURSOR
2701 e083 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
2702 e086 96 06                        LDA  VALTYP         ; * GET VARIABLE TYPE AND
2703 e088 34 02                        PSHS A              ; * SAVE IT ON THE STACK
2704 e08a 26 06                        BNE  LB938          ; BRANCH IF STRING VARIABLE
2705 e08c bd e5 25                     JSR  LBDD9          ; CONVERT FP NUMBER TO AN ASCII STRING
2706 e08f bd dc 9d                     JSR  LB516          ; PARSE A STRING FROM (X-1) AND PUT
2707                         *                             ; DESCRIPTOR ON STRING STACK
2708 e092 8d 57              LB938     BSR  LB99F          ; PRINT STRING POINTED TO BY X
2709 e094 35 04                        PULS B              ; GET VARIABLE TYPE BACK
2710 e096 bd d1 33                     JSR  LA35F          ; SET UP TAB WIDTH ZONE, ETC
2711 e099 5d                 LB949     TSTB                ; CHECK CURRENT PRINT POSITION
2712 e09a 26 08                        BNE  LB954          ; BRANCH IF NOT AT START OF LINE
2713 e09c 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
2714 e09e 81 2c                        CMPA #',            ; COMMA?
2715 e0a0 27 14                        BEQ  LB966          ; SKIP TO NEXT TAB FIELD
2716 e0a2 8d 54                        BSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
2717 e0a4 9d 82              LB954     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
2718 e0a6 26 cf                        BNE  LB91D          ; BRANCH IF NOT END OF LINE
2719 e0a8 86 0d              LB958     LDA  #CR            ; * SEND A CR TO
2720 e0aa 20 51                        BRA  LB9B1          ; * CONSOLE OUT
2721 e0ac bd d1 33           LB95C     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
2722 e0af 27 f7                        BEQ  LB958          ; BRANCH IF WIDTH = ZERO
2723 e0b1 96 6c                        LDA  DEVPOS         ; GET PRINT POSITION
2724 e0b3 26 f3                        BNE  LB958          ; BRANCH IF NOT AT START OF LINE
2725 e0b5 39                 LB965     RTS
2726                         * SKIP TO NEXT TAB FIELD
2727 e0b6 bd d1 33           LB966     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
2728 e0b9 27 0a                        BEQ  LB975          ; BRANCH IF LINE WIDTH = 0 (CASSETTE)
2729 e0bb d6 6c                        LDB  DEVPOS         ; GET CURRENT POSITION
2730 e0bd d1 6b                        CMPB DEVLCF         ; COMPARE TO LAST TAB ZONE
2731 e0bf 25 06                        BCS  LB977          ; BRANCH IF < LAST TAB ZONE
2732 e0c1 8d e5                        BSR  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
2733 e0c3 20 1e                        BRA  LB997          ; GET MORE DATA
2734 e0c5 d6 6c              LB975     LDB  DEVPOS         ; *
2735 e0c7 d0 6a              LB977     SUBB DEVCFW         ; * SUBTRACT TAB FIELD WIDTH FROM CURRENT
2736 e0c9 24 fc                        BCC  LB977          ; * POSITION UNTIL CARRY SET - NEGATING THE
2737 e0cb 50                           NEGB                ; * REMAINDER LEAVES THE NUMBER OF SPACES TO NEXT
2738                         *              ; * TAB ZONE IN ACCB
2739 e0cc 20 10                        BRA  LB98E          ; GO ADVANCE TO NEXT TAB ZONE
2740                         
2741                         * PRINT TAB(
2742 e0ce bd de 90           LB97E     JSR  LB709          ; EVALUATE EXPRESSION - RETURN VALUE IN B
2743 e0d1 81 29                        CMPA #')            ; * 'SYNTAX' ERROR IF NOT ')'
2744 e0d3 10 26 f9 2c                  LBNE LB277          ; *
2745 e0d7 bd d1 33                     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
2746 e0da d0 6c                        SUBB DEVPOS         ; GET DIFFERENCE OF PRINT POSITION & TAB POSITION
2747 e0dc 23 05                        BLS  LB997          ; BRANCH IF TAB POSITION < CURRENT POSITION
2748                         LB98E
2749 e0de 8d 18              LB992     BSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
2750 e0e0 5a                           DECB                ; DECREMENT DIFFERENCE COUNT
2751 e0e1 26 fb                        BNE  LB992          ; BRANCH UNTIL CURRENT POSITION = TAB POSITION
2752 e0e3 9d 7c              LB997     JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
2753 e0e5 7e e0 75                     JMP  LB91B          ; LOOK FOR MORE PRINT DATA
2754                         * COPY A STRING FROM (X) TO CONSOLE OUT
2755 e0e8 bd dc 9f           LB99C     JSR  LB518          ; PARSE A STRING FROM X AND PUT
2756                         *         DESCRIPTOR ON STRING STACK
2757 e0eb bd dd de           LB99F     JSR  LB657          ; GET LENGTH OF STRING AND REMOVE
2758                         *         DESCRIPTOR FROM STRING STACK
2759 e0ee 5c                           INCB                ; COMPENSATE FOR DECB BELOW
2760 e0ef 5a                 LB9A3     DECB                ; DECREMENT COUNTER
2761 e0f0 27 c3                        BEQ  LB965          ; EXIT ROUTINE
2762 e0f2 a6 80                        LDA  ,X+            ; GET A CHARACTER FROM X
2763 e0f4 8d 07                        BSR  LB9B1          ; SEND TO CONSOLE OUT
2764 e0f6 20 f7                        BRA  LB9A3          ; KEEP LOOPING
2765 e0f8 86 20              LB9AC     LDA  #SPACE         ; SPACE TO CONSOLE OUT
2766 e0fa 8c                           FCB  SKP2           ; SKIP NEXT TWO BYTES
2767 e0fb 86 3f              LB9AF     LDA  #'?            ; QUESTION MARK TO CONSOLE OUT
2768 e0fd 7e d0 17           LB9B1     JMP  PUTCHR         ; JUMP TO CONSOLE OUT
2769                         
2770                         * FLOATING POINT MATH PACKAGE
2771                         
2772                         * ADD .5 TO FPA0
2773 e100 8e e6 0c           LB9B4     LDX  #LBEC0         ; FLOATING POINT CONSTANT (.5)
2774 e103 20 09                        BRA  LB9C2          ; ADD .5 TO FPA0
2775                         * SUBTRACT FPA0 FROM FP NUMBER POINTED
2776                         * TO BY (X), LEAVE RESULT IN FPA0
2777 e105 bd e2 7b           LB9B9     JSR  LBB2F          ; COPY PACKED FP DATA FROM (X) TO FPA1
2778                         
2779                         * ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 FROM FPA1 (ENTER
2780                         * WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 IN ACCA)
2781 e108 03 54              LB9BC     COM  FP0SGN         ; CHANGE MANTISSA SIGN OF FPA0
2782 e10a 03 62                        COM  RESSGN         ; REVERSE RESULT SIGN FLAG
2783 e10c 20 03                        BRA  LB9C5          ; GO ADD FPA1 AND FPA0
2784                         * ADD FP NUMBER POINTED TO BY
2785                         * (X) TO FPA0 - LEAVE RESULT IN FPA0
2786 e10e bd e2 7b           LB9C2     JSR  LBB2F          ; UNPACK PACKED FP DATA FROM (X) TO
2787                         *         FPA1; RETURN EXPONENT OF FPA1 IN ACCA
2788                         
2789                         * ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO
2790                         
2791 e111 5d                 LB9C5     TSTB                ; CHECK EXPONENT OF FPA0
2792 e112 10 27 02 80                  LBEQ LBC4A          ; COPY FPA1 TO FPA0 IF FPA0 =
2793 e116 8e 00 5c                     LDX  #FP1EXP        ; POINT X TO FPA1
2794 e119 1f 89              LB9CD     TFR  A,B            ; PUT EXPONENT OF FPA1 INTO ACCB
2795 e11b 5d                           TSTB                ; CHECK EXPONENT
2796 e11c 27 6c                        BEQ  LBA3E          ; RETURN IF EXPONENT = 0 (ADDING 0 TO FPA0)
2797 e11e d0 4f                        SUBB FP0EXP         ; SUBTRACT EXPONENT OF FPA0 FROM EXPONENT OF FPA1
2798 e120 27 69                        BEQ  LBA3F          ; BRANCH IF EXPONENTS ARE EQUAL
2799 e122 25 0a                        BCS  LB9E2          ; BRANCH IF EXPONENT FPA0 > FPA1
2800 e124 97 4f                        STA  FP0EXP         ; REPLACE FPA0 EXPONENT WITH FPA1 EXPONENT
2801 e126 96 61                        LDA  FP1SGN         ; * REPLACE FPA0 MANTISSA SIGN
2802 e128 97 54                        STA  FP0SGN         ; * WITH FPA1 MANTISSA SIGN
2803 e12a 8e 00 4f                     LDX  #FP0EXP        ; POINT X TO FPA0
2804 e12d 50                           NEGB                ; NEGATE DIFFERENCE OF EXPONENTS
2805 e12e c1 f8              LB9E2     CMPB #-8            ; TEST DIFFERENCE OF EXPONENTS
2806 e130 2f 59                        BLE  LBA3F          ; BRANCH IF DIFFERENCE OF EXPONENTS <= 8
2807 e132 4f                           CLRA                ; CLEAR OVERFLOW BYTE
2808 e133 64 01                        LSR  1,X            ; SHIFT MS BYTE OF MANTISSA; BIT 7 = 0
2809 e135 bd e2 06                     JSR  LBABA          ; GO SHIFT MANTISSA OF (X) TO THE RIGHT (B) TIMES
2810 e138 d6 62              LB9EC     LDB  RESSGN         ; GET SIGN FLAG
2811 e13a 2a 0b                        BPL  LB9FB          ; BRANCH IF FPA0 AND FPA1 SIGNS ARE THE SAME
2812 e13c 63 01                        COM  1,X            ; * COMPLEMENT MANTISSA POINTED
2813 e13e 63 02                        COM  2,X            ; * TO BY (X) THE
2814 e140 63 03                        COM  3,X            ; * ADCA BELOW WILL
2815 e142 63 04                        COM  4,X            ; * CONVERT THIS OPERATION
2816 e144 43                           COMA                ; * INTO A NEG (MANTISSA)
2817 e145 89 00                        ADCA #0             ; ADD ONE TO ACCA - COMA ALWAYS SETS THE CARRY FLAG
2818                         * THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA
2819                         *
2820                         * ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0
2821 e147 97 63              LB9FB     STA  FPSBYT         ; SAVE FPA SUB BYTE
2822 e149 96 53                        LDA  FPA0+3         ; * ADD LS BYTE
2823 e14b 99 60                        ADCA FPA1+3         ; * OF MANTISSA
2824 e14d 97 53                        STA  FPA0+3         ; SAVE IN FPA0 LSB
2825 e14f 96 52                        LDA  FPA0+2         ; * ADD NEXT BYTE
2826 e151 99 5f                        ADCA FPA1+2         ; * OF MANTISSA
2827 e153 97 52                        STA  FPA0+2         ; SAVE IN FPA0
2828 e155 96 51                        LDA  FPA0+1         ; * ADD NEXT BYTE
2829 e157 99 5e                        ADCA FPA1+1         ; * OF MANTISSA
2830 e159 97 51                        STA  FPA0+1         ; SAVE IN FPA0
2831 e15b 96 50                        LDA  FPA0           ; * ADD MS BYTE
2832 e15d 99 5d                        ADCA FPA1           ; * OF MANTISSA
2833 e15f 97 50                        STA  FPA0           ; SAVE IN FPA0
2834 e161 5d                           TSTB                ; TEST SIGN FLAG
2835 e162 2a 44                        BPL  LBA5C          ; BRANCH IF FPA0 & FPA1 SIGNS WERE ALIKE
2836 e164 25 02              LBA18     BCS  LBA1C          ; BRANCH IF POSITIVE MANTISSA
2837 e166 8d 5d                        BSR  LBA79          ; NEGATE FPA0 MANTISSA
2838                         
2839                         * NORMALIZE FPA0
2840 e168 5f                 LBA1C     CLRB                ; CLEAR TEMPORARY EXPONENT ACCUMULATOR
2841 e169 96 50              LBA1D     LDA  FPA0           ; TEST MSB OF MANTISSA
2842 e16b 26 2e                        BNE  LBA4F          ; BRANCH IF <> 0
2843 e16d 96 51                        LDA  FPA0+1         ; * IF THE MSB IS
2844 e16f 97 50                        STA  FPA0           ; * 0, THEN SHIFT THE
2845 e171 96 52                        LDA  FPA0+2         ; * MANTISSA A WHOLE BYTE
2846 e173 97 51                        STA  FPA0+1         ; * AT A TIME. THIS
2847 e175 96 53                        LDA  FPA0+3         ; * IS FASTER THAN ONE
2848 e177 97 52                        STA  FPA0+2         ; * BIT AT A TIME
2849 e179 96 63                        LDA  FPSBYT         ; * BUT USES MORE MEMORY.
2850 e17b 97 53                        STA  FPA0+3         ; * FPSBYT, THE CARRY IN
2851 e17d 0f 63                        CLR  FPSBYT         ; * BYTE, REPLACES THE MATISSA LSB.
2852 e17f cb 08                        ADDB #8             ; SHIFTING ONE BYTE = 8 BIT SHIFTS; ADD 8 TO EXPONENT
2853 e181 c1 28                        CMPB #5*8           ; CHECK FOR 5 SHIFTS
2854 e183 2d e4                        BLT  LBA1D          ; BRANCH IF < 5 SHIFTS, IF > 5, THEN MANTISSA = 0
2855 e185 4f                 LBA39     CLRA                ; A ZERO EXPONENT = 0 FLOATING POINT
2856 e186 97 4f              LBA3A     STA  FP0EXP         ; ZERO OUT THE EXPONENT
2857 e188 97 54                        STA  FP0SGN         ; ZERO OUT THE MANTISSA SIGN
2858 e18a 39                 LBA3E     RTS
2859 e18b 8d 6d              LBA3F     BSR  LBAAE          ; SHIFT FPA0 MANTISSA TO RIGHT
2860 e18d 5f                           CLRB                ; CLEAR CARRY FLAG
2861 e18e 20 a8                        BRA  LB9EC
2862                         * SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7
2863                         * OF MATISSA MS BYTE = 1
2864 e190 5c                 LBA44     INCB                ; ADD ONE TO EXPONENT ACCUMULATOR
2865 e191 08 63                        ASL  FPSBYT         ; SHIFT SUB BYTE ONE LEFT
2866 e193 09 53                        ROL  FPA0+3         ; SHIFT LS BYTE
2867 e195 09 52                        ROL  FPA0+2         ; SHIFT NS BYTE
2868 e197 09 51                        ROL  FPA0+1         ; SHIFT NS BYTE
2869 e199 09 50                        ROL  FPA0           ; SHIFT MS BYTE
2870 e19b 2a f3              LBA4F     BPL  LBA44          ; BRANCH IF NOT YET NORMALIZED
2871 e19d 96 4f                        LDA  FP0EXP         ; GET CURRENT EXPONENT
2872 e19f 34 04                        PSHS B              ; SAVE EXPONENT MODIFIER CAUSED BY NORMALIZATION
2873 e1a1 a0 e0                        SUBA ,S+            ; SUBTRACT ACCUMULATED EXPONENT MODIFIER
2874 e1a3 97 4f                        STA  FP0EXP         ; SAVE AS NEW EXPONENT
2875 e1a5 23 de                        BLS  LBA39          ; SET FPA0 = 0 IF THE NORMALIZATION CAUSED
2876                         *         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE
2877                         *         SIZE OF THE EXPONENT
2878 e1a7 8c                           FCB  SKP2           ; SKIP 2 BYTES
2879 e1a8 25 08              LBA5C     BCS  LBA66          ; BRANCH IF MANTISSA OVERFLOW
2880 e1aa 08 63                        ASL  FPSBYT         ; SUB BYTE BIT 7 TO CARRY - USE AS ROUND-OFF
2881                         *                             ; FLAG (TRUNCATE THE REST OF SUB BYTE)
2882 e1ac 86 00                        LDA  #0             ; CLRA, BUT DO NOT CHANGE CARRY FLAG
2883 e1ae 97 63                        STA  FPSBYT         ; CLEAR THE SUB BYTE
2884 e1b0 20 0c                        BRA  LBA72          ; GO ROUND-OFF RESULT
2885 e1b2 0c 4f              LBA66     INC  FP0EXP         ; INCREMENT EXPONENT - MULTIPLY BY 2
2886 e1b4 27 28                        BEQ  LBA92          ; OVERFLOW ERROR IF CARRY PAST $FF
2887 e1b6 06 50                        ROR  FPA0           ; * SHIFT MANTISSA
2888 e1b8 06 51                        ROR  FPA0+1         ; * ONE TO
2889 e1ba 06 52                        ROR  FPA0+2         ; * THE RIGHT -
2890 e1bc 06 53                        ROR  FPA0+3         ; * DIVIDE BY TWO
2891 e1be 24 04              LBA72     BCC  LBA78          ; BRANCH IF NO ROUND-OFF NEEDED
2892 e1c0 8d 0d                        BSR  LBA83          ; ADD ONE TO MANTISSA - ROUND OFF
2893 e1c2 27 ee                        BEQ  LBA66          ; BRANCH iF OVERFLOW - MANTISSA = 0
2894 e1c4 39                 LBA78     RTS
2895                         * NEGATE FPA0 MANTISSA
2896 e1c5 03 54              LBA79     COM  FP0SGN         ; TOGGLE SIGN OF MANTISSA
2897 e1c7 03 50              LBA7B     COM  FPA0           ; * COMPLEMENT ALL 4 MANTISSA BYTES
2898 e1c9 03 51                        COM  FPA0+1         ; *
2899 e1cb 03 52                        COM  FPA0+2         ; *
2900 e1cd 03 53                        COM  FPA0+3         ; *
2901                         * ADD ONE TO FPA0 MANTISSA
2902 e1cf 9e 52              LBA83     LDX  FPA0+2         ; * GET BOTTOM 2 MANTISSA
2903 e1d1 30 01                        LEAX 1,X            ; * BYTES, ADD ONE TO
2904 e1d3 9f 52                        STX  FPA0+2         ; * THEM AND SAVE THEM
2905 e1d5 26 06                        BNE  LBA91          ; BRANCH IF NO OVERFLOW
2906 e1d7 9e 50                        LDX  FPA0           ; * IF OVERFLOW ADD ONE
2907 e1d9 30 01                        LEAX 1,X            ; * TO TOP 2 MANTISSA
2908 e1db 9f 50                        STX  FPA0           ; * BYTES AND SAVE THEM
2909 e1dd 39                 LBA91     RTS
2910 e1de c6 0a              LBA92     LDB  #2*5           ; OV' OVERFLOW ERROR
2911 e1e0 7e d4 06                     JMP  LAC46          ; PROCESS AN ERROR
2912 e1e3 8e 00 12           LBA97     LDX  #FPA2-1        ; POINT X TO FPA2
2913                         * SHIFT FPA POINTED TO BY (X) TO
2914                         * THE RIGHT -(B) TIMES. EXIT WITH
2915                         * ACCA CONTAINING DATA SHIFTED OUT
2916                         * TO THE RIGHT (SUB BYTE) AND THE DATA
2917                         * SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY
2918 e1e6 a6 04              LBA9A     LDA  4,X            ; GET LS BYTE OF MANTISSA (X)
2919 e1e8 97 63                        STA  FPSBYT         ; SAVE IN FPA SUB BYTE
2920 e1ea a6 03                        LDA  3,X            ; * SHIFT THE NEXT THREE BYTES OF THE
2921 e1ec a7 04                        STA  4,X            ; * MANTISSA RIGHT ONE COMPLETE BYTE.
2922 e1ee a6 02                        LDA  2,X            ; *
2923 e1f0 a7 03                        STA  3,X            ; *
2924 e1f2 a6 01                        LDA  1,X            ; *
2925 e1f4 a7 02                        STA  2,X            ; *
2926 e1f6 96 5b                        LDA  FPCARY         ; GET THE CARRY IN BYTE
2927 e1f8 a7 01                        STA  1,X            ; STORE AS THE MS MANTISSA BYTE OF (X)
2928 e1fa cb 08              LBAAE     ADDB #8             ; ADD 8 TO DIFFERENCE OF EXPONENTS
2929 e1fc 2f e8                        BLE  LBA9A          ; BRANCH IF EXPONENT DIFFERENCE < -8
2930 e1fe 96 63                        LDA  FPSBYT         ; GET FPA SUB BYTE
2931 e200 c0 08                        SUBB #8             ; CAST OUT THE 8 ADDED IN ABOVE
2932 e202 27 0c                        BEQ  LBAC4          ; BRANCH IF EXPONENT DIFFERENCE = 0
2933                         
2934                         
2935 e204 67 01              LBAB8     ASR  1,X            ; * SHIFT MANTISSA AND SUB BYTE ONE BIT TO THE RIGHT
2936 e206 66 02              LBABA     ROR  2,X            ; *
2937 e208 66 03                        ROR  3,X            ; *
2938 e20a 66 04                        ROR  4,X            ; *
2939 e20c 46                           RORA                ; *
2940 e20d 5c                           INCB                ; ADD ONE TO EXPONENT DIFFERENCE
2941 e20e 26 f4                        BNE  LBAB8          ; BRANCH IF EXPONENTS NOT =
2942 e210 39                 LBAC4     RTS
2943 e211 81 00 00 00 00     LBAC5     FCB  $81,$00,$00,$00,$00 ; FLOATING POINT CONSTANT 1.0
2944                         
2945                         * ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY
2946                         * FPA0 BY (X) - RETURN PRODUCT IN FPA0
2947 e216 8d 63              LBACA     BSR  LBB2F          ; MOVE PACKED FPA FROM (X) TO FPA1
2948 e218 27 60              LBACC     BEQ  LBB2E          ; BRANCH IF EXPONENT OF FPA0 = 0
2949 e21a 8d 78                        BSR  LBB48          ; CALCULATE EXPONENT OF PRODUCT
2950                         * MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE
2951                         * HIGH ORDER BYTES OF PRODUCT IN FPA0. THE
2952                         * LOW ORDER FOUR BYTES OF THE PRODUCT WILL
2953                         * BE STORED IN VAB-VAE.
2954 e21c 86 00              LBAD0     LDA  #0             ; * ZERO OUT MANTISSA OF FPA2
2955 e21e 97 13                        STA  FPA2           ; *
2956 e220 97 14                        STA  FPA2+1         ; *
2957 e222 97 15                        STA  FPA2+2         ; *
2958 e224 97 16                        STA  FPA2+3         ; *
2959 e226 d6 53                        LDB  FPA0+3         ; GET LS BYTE OF FPA0
2960 e228 8d 22                        BSR  LBB00          ; MULTIPLY BY FPA1
2961 e22a d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 4
2962 e22c d7 8b                        STB  VAE            ; *
2963 e22e d6 52                        LDB  FPA0+2         ; GET NUMBER 3 MANTISSA BYTE OF FPA0
2964 e230 8d 1a                        BSR  LBB00          ; MULTIPLY BY FPA1
2965 e232 d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 3
2966 e234 d7 8a                        STB  VAD            ; *
2967 e236 d6 51                        LDB  FPA0+1         ; GET NUMBER 2 MANTISSA BYTE OF FPA0
2968 e238 8d 12                        BSR  LBB00          ; MULTIPLY BY FPA1
2969 e23a d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 2
2970 e23c d7 89                        STB  VAC            ; *
2971 e23e d6 50                        LDB  FPA0           ; GET MS BYTE OF FPA0 MANTISSA
2972 e240 8d 0c                        BSR  LBB02          ; MULTIPLY BY FPA1
2973 e242 d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 1
2974 e244 d7 88                        STB  VAB            ; *
2975 e246 bd e3 57                     JSR  LBC0B          ; COPY MANTISSA FROM FPA2 TO FPA0
2976 e249 7e e1 68                     JMP  LBA1C          ; NORMALIZE FPA0
2977 e24c 27 95              LBB00     BEQ  LBA97          ; SHIFT FPA2 ONE BYTE TO RIGHT
2978 e24e 43                 LBB02     COMA                ; SET CARRY FLAG
2979                         * MULTIPLY FPA1 MANTISSA BY ACCB AND
2980                         * ADD PRODUCT TO FPA2 MANTISSA
2981 e24f 96 13              LBB03     LDA  FPA2           ; GET FPA2 MS BYTE
2982 e251 56                           RORB                ; ROTATE CARRY FLAG INTO SHIFT COUNTER;
2983                         *         DATA BIT INTO CARRY
2984 e252 27 26                        BEQ  LBB2E          ; BRANCH WHEN 8 SHIFTS DONE
2985 e254 24 16                        BCC  LBB20          ; DO NOT ADD FPA1 IF DATA BIT = 0
2986 e256 96 16                        LDA  FPA2+3         ; * ADD MANTISSA LS BYTE
2987 e258 9b 60                        ADDA FPA1+3         ; *
2988 e25a 97 16                        STA  FPA2+3         ; *
2989 e25c 96 15                        LDA  FPA2+2         ; = ADD MANTISSA NUMBER 3 BYTE
2990 e25e 99 5f                        ADCA FPA1+2         ; =
2991 e260 97 15                        STA  FPA2+2         ; =
2992 e262 96 14                        LDA  FPA2+1         ; * ADD MANTISSA NUMBER 2 BYTE
2993 e264 99 5e                        ADCA FPA1+1         ; *
2994 e266 97 14                        STA  FPA2+1         ; *
2995 e268 96 13                        LDA  FPA2           ; = ADD MANTISSA MS BYTE
2996 e26a 99 5d                        ADCA FPA1           ; =
2997 e26c 46                 LBB20     RORA                ; * ROTATE CARRY INTO MS BYTE
2998 e26d 97 13                        STA  FPA2           ; *
2999 e26f 06 14                        ROR  FPA2+1         ; = ROTATE FPA2 ONE BIT TO THE RIGHT
3000 e271 06 15                        ROR  FPA2+2         ; =
3001 e273 06 16                        ROR  FPA2+3         ; =
3002 e275 06 63                        ROR  FPSBYT         ; =
3003 e277 4f                           CLRA                ; CLEAR CARRY FLAG
3004 e278 20 d5                        BRA  LBB03          ; KEEP LOOPING
3005 e27a 39                 LBB2E     RTS
3006                         * UNPACK A FP NUMBER FROM (X) TO FPA1
3007 e27b ec 01              LBB2F     LDD  1,X            ; GET TWO MSB BYTES OF MANTISSA FROM
3008                         *         FPA  POINTED TO BY X
3009 e27d 97 61                        STA  FP1SGN         ; SAVE PACKED MANTISSA SIGN BYTE
3010 e27f 8a 80                        ORA  #$80           ; FORCE BIT 7 OF MSB MANTISSA = 1
3011 e281 dd 5d                        STD  FPA1           ; SAVE 2 MSB BYTES IN FPA1
3012 e283 d6 61                        LDB  FP1SGN         ; * GET PACKED MANTISSA SIGN BYTE. EOR W/FPA0
3013 e285 d8 54                        EORB FP0SGN         ; * SIGN - NEW SIGN POSITION IF BOTH OLD SIGNS ALIKE,
3014 e287 d7 62                        STB  RESSGN         ; * NEG IF BOTH OLD SIGNS DIFF. SAVE ADJUSTED
3015                         *                             ; * MANTISSA SIGN BYTE
3016 e289 ec 03                        LDD  3,X            ; = GET 2 LSB BYTES OF MANTISSA
3017 e28b dd 5f                        STD  FPA1+2         ; = AND PUT IN FPA1
3018 e28d a6 84                        LDA  ,X             ; * GET EXPONENT FROM (X) AND
3019 e28f 97 5c                        STA  FP1EXP         ; * PUT IN EXPONENT OF FPA1
3020 e291 d6 4f                        LDB  FP0EXP         ; GET EXPONENT OF FPA0
3021 e293 39                           RTS
3022                         * CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1
3023                         * ENTER WITH EXPONENT OF FPA1 IN ACCA
3024 e294 4d                 LBB48     TSTA                ; TEST EXPONENT OF FPA1
3025 e295 27 16                        BEQ  LBB61          ; PURGE RETURN ADDRESS & SET FPA0 = 0
3026 e297 9b 4f                        ADDA FP0EXP         ; ADD FPA1 EXPONENT TO FPA0 EXPONENT
3027 e299 46                           RORA                ; ROTATE CARRY INTO BIT 7; BIT 0 INTO CARRY
3028 e29a 49                           ROLA                ; SET OVERFLOW FLAG
3029 e29b 28 10                        BVC  LBB61          ; BRANCH IF EXPONENT TOO LARGE OR SMALL
3030 e29d 8b 80                        ADDA #$80           ; ADD $80 BIAS TO EXPONENT
3031 e29f 97 4f                        STA  FP0EXP         ; SAVE NEW EXPONENT
3032 e2a1 27 0c                        BEQ  LBB63          ; SET FPA0
3033 e2a3 96 62                        LDA  RESSGN         ; GET MANTISSA SIGN
3034 e2a5 97 54                        STA  FP0SGN         ; SAVE AS MANTISSA SIGN OF FPA0
3035 e2a7 39                           RTS
3036                         * IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0
3037                         * = IS NEGATIVE THEN FPA0 = 0
3038 e2a8 96 54              LBB5C     LDA  FP0SGN         ; GET MANTISSA SIGN OF FPA0
3039 e2aa 43                           COMA                ; CHANGE SIGN OF FPA0 MANTISSA
3040 e2ab 20 02                        BRA  LBB63
3041 e2ad 32 62              LBB61     LEAS 2,S            ; PURGE RETURN ADDRESS FROM STACK
3042 e2af 10 2a fe d2        LBB63     LBPL LBA39          ; ZERO FPA0 MANTISSA SIGN & EXPONENT
3043 e2b3 7e e1 de           LBB67     JMP  LBA92          ; 'OV' OVERFLOW ERROR
3044                         * FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0
3045 e2b6 bd e3 ab           LBB6A     JSR  LBC5F          ; TRANSFER FPA0 TO FPA1
3046 e2b9 27 0d                        BEQ  LBB7C          ; BRANCH IF EXPONENT = 0
3047 e2bb 8b 02                        ADDA #2             ; ADD 2 TO EXPONENT (TIMES 4)
3048 e2bd 25 f4                        BCS  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
3049 e2bf 0f 62                        CLR  RESSGN         ; CLEAR RESULT SIGN BYTE
3050 e2c1 bd e1 19                     JSR  LB9CD          ; ADD FPA1 TO FPA0 (TIMES 5)
3051 e2c4 0c 4f                        INC  FP0EXP         ; ADD ONE TO EXPONENT (TIMES 10)
3052 e2c6 27 eb                        BEQ  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
3053 e2c8 39                 LBB7C     RTS
3054 e2c9 84 20 00 00 00     LBB7D     FCB  $84,$20,$00,$00,$00 ; FLOATING POINT CONSTANT 10
3055                         * DIVIDE FPA0 BY 10
3056 e2ce bd e3 ab           LBB82     JSR  LBC5F          ; MOVE FPA0 TO FPA1
3057 e2d1 8e e2 c9                     LDX  #LBB7D         ; POINT TO FLOATING POINT CONSTANT 10
3058 e2d4 5f                           CLRB                ; ZERO MANTISSA SIGN BYTE
3059 e2d5 d7 62              LBB89     STB  RESSGN         ; STORE THE QUOTIENT MANTISSA SIGN BYTE
3060 e2d7 bd e3 60                     JSR  LBC14          ; UNPACK AN FP NUMBER FROM (X) INTO FPA0
3061 e2da 8c                           FCB  SKP2           ; SKIP TWO BYTES
3062                         * DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0
3063 e2db 8d 9e              LBB8F     BSR  LBB2F          ; GET FP NUMBER FROM (X) TO FPA1
3064                         
3065                         * ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY FPA0 (ENTER WITH
3066                         * EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY TSTA)
3067                         
3068                         * DIVIDE FPA1 BY FPA0
3069 e2dd 27 73              LBB91     BEQ  LBC06          ; '/0' DIVIDE BY ZERO ERROR
3070 e2df 00 4f                        NEG  FP0EXP         ; GET EXPONENT OF RECIPROCAL OF DIVISOR
3071 e2e1 8d b1                        BSR  LBB48          ; CALCULATE EXPONENT OF QUOTIENT
3072 e2e3 0c 4f                        INC  FP0EXP         ; INCREMENT EXPONENT
3073 e2e5 27 cc                        BEQ  LBB67          ; 'OV' OVERFLOW ERROR
3074 e2e7 8e 00 13                     LDX  #FPA2          ; POINT X TO MANTISSA OF FPA2 - HOLD
3075                         *                             ; TEMPORARY QUOTIENT IN FPA2
3076 e2ea c6 04                        LDB  #4             ; 5 BYTE DIVIDE
3077 e2ec d7 03                        STB  TMPLOC         ; SAVE BYTE COUNTER
3078 e2ee c6 01                        LDB  #1             ; SHIFT COUNTER-AND TEMPORARY QUOTIENT BYTE
3079                         * COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -
3080                         * SET CARRY FLAG IF FPA1 >= FPA0
3081 e2f0 96 50              LBBA4     LDA  FPA0           ; * COMPARE THE TWO MS BYTES
3082 e2f2 91 5d                        CMPA FPA1           ; * OF FPA0 AND FPA1 AND
3083 e2f4 26 13                        BNE  LBBBD          ; * BRANCH IF <>
3084 e2f6 96 51                        LDA  FPA0+1         ; = COMPARE THE NUMBER 2
3085 e2f8 91 5e                        CMPA FPA1+1         ; = BYTES AND
3086 e2fa 26 0d                        BNE  LBBBD          ; = BRANCH IF <>
3087 e2fc 96 52                        LDA  FPA0+2         ; * COMPARE THE NUMBER 3
3088 e2fe 91 5f                        CMPA FPA1+2         ; * BYTES AND
3089 e300 26 07                        BNE  LBBBD          ; * BRANCH IF <>
3090 e302 96 53                        LDA  FPA0+3         ; = COMPARE THE LS BYTES
3091 e304 91 60                        CMPA FPA1+3         ; = AND BRANCH
3092 e306 26 01                        BNE  LBBBD          ; = IF <>
3093 e308 43                           COMA                ; SET CARRY FLAG IF FPA0 = FPA1
3094 e309 1f a8              LBBBD     TFR  CC,A           ; SAVE CARRY FLAG STATUS IN ACCA; CARRY
3095                         *         CLEAR IF FPA0 > FPA1
3096 e30b 59                           ROLB                ; ROTATE CARRY INTO TEMPORARY QUOTIENT BYTE
3097 e30c 24 0a                        BCC  LBBCC          ; CARRY WILL BE SET AFTER 8 SHIFTS
3098 e30e e7 80                        STB  ,X+            ; SAVE TEMPORARY QUOTIENT
3099 e310 0a 03                        DEC  TMPLOC         ; DECREMENT BYTE COUNTER
3100 e312 2b 34                        BMI  LBBFC          ; BRANCH IF DONE
3101 e314 27 2e                        BEQ  LBBF8          ; BRANCH IF LAST BYTE
3102 e316 c6 01                        LDB  #1             ; RESET SHIFT COUNTER AND TEMPORARY QUOTIENT BYTE
3103 e318 1f 8a              LBBCC     TFR  A,CC           ; RESTORE CARRY FLAG AND
3104 e31a 25 0e                        BCS  LBBDE          ; BRANCH IF FPA0 =< FPA1
3105 e31c 08 60              LBBD0     ASL  FPA1+3         ; * SHIFT FPA1 MANTISSA 1 BIT TO LEFT
3106 e31e 09 5f                        ROL  FPA1+2         ; *
3107 e320 09 5e                        ROL  FPA1+1         ; *
3108 e322 09 5d                        ROL  FPA1           ; *
3109 e324 25 e3                        BCS  LBBBD          ; BRANCH IF CARRY - ADD ONE TO PARTIAL QUOTIENT
3110 e326 2b c8                        BMI  LBBA4          ; IF MSB OF HIGH ORDER MANTISSA BYTE IS
3111                         *         SET, CHECK THE MAGNITUDES OF FPA0, FPA1
3112 e328 20 df                        BRA  LBBBD          ; CARRY IS CLEAR, CHECK ANOTHER BIT
3113                         * SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1
3114 e32a 96 60              LBBDE     LDA  FPA1+3         ; * SUBTRACT THE LS BYTES OF MANTISSA
3115 e32c 90 53                        SUBA FPA0+3         ; *
3116 e32e 97 60                        STA  FPA1+3         ; *
3117 e330 96 5f                        LDA  FPA1+2         ; = THEN THE NEXT BYTE
3118 e332 92 52                        SBCA FPA0+2         ; =
3119 e334 97 5f                        STA  FPA1+2         ; =
3120 e336 96 5e                        LDA  FPA1+1         ; * AND THE NEXT
3121 e338 92 51                        SBCA FPA0+1         ; *
3122 e33a 97 5e                        STA  FPA1+1         ; *
3123 e33c 96 5d                        LDA  FPA1           ; = AND FINALLY, THE MS BYTE OF MANTISSA
3124 e33e 92 50                        SBCA FPA0           ; =
3125 e340 97 5d                        STA  FPA1           ; =
3126 e342 20 d8                        BRA  LBBD0          ; GO SHIFT FPA1
3127 e344 c6 40              LBBF8     LDB  #$40           ; USE ONLY TWO BITS OF THE LAST BYTE (FIFTH)
3128 e346 20 d0                        BRA  LBBCC          ; GO SHIFT THE LAST BYTE
3129 e348 56                 LBBFC     RORB                ; * SHIFT CARRY (ALWAYS SET HERE) INTO
3130 e349 56                           RORB                ; * BIT 5 AND MOVE
3131 e34a 56                           RORB                ; * BITS 1,0 TO BITS 7,6
3132 e34b d7 63                        STB  FPSBYT         ; SAVE SUB BYTE
3133 e34d 8d 08                        BSR  LBC0B          ; MOVE MANTISSA OF FPA2 TO FPA0
3134 e34f 7e e1 68                     JMP  LBA1C          ; NORMALIZE FPA0
3135 e352 c6 14              LBC06     LDB  #2*10          ; /0' ERROR
3136 e354 7e d4 06                     JMP  LAC46          ; PROCESS THE ERROR
3137                         * COPY MANTISSA FROM FPA2 TO FPA0
3138 e357 9e 13              LBC0B     LDX  FPA2           ; * MOVE TOP 2 BYTES
3139 e359 9f 50                        STX  FPA0           ; *
3140 e35b 9e 15                        LDX  FPA2+2         ; = MOVE BOTTOM 2 BYTES
3141 e35d 9f 52                        STX  FPA0+2         ; =
3142 e35f 39                           RTS
3143                         * COPY A PACKED FP NUMBER FROM (X) TO FPA0
3144 e360 34 02              LBC14     PSHS A              ; SAVE ACCA
3145 e362 ec 01                        LDD  1,X            ; GET TOP TWO MANTISSA BYTES
3146 e364 97 54                        STA  FP0SGN         ; SAVE MS BYTE OF MANTISSA AS MANTISSA SIGN
3147 e366 8a 80                        ORA  #$80           ; UNPACK MS BYTE
3148 e368 dd 50                        STD  FPA0           ; SAVE UNPACKED TOP 2 MANTISSA BYTES
3149 e36a 0f 63                        CLR  FPSBYT         ; CLEAR MANTISSA SUB BYTE
3150 e36c e6 84                        LDB  ,X             ; GET EXPONENT TO ACCB
3151 e36e ae 03                        LDX  3,X            ; * MOVE LAST 2
3152 e370 9f 52                        STX  FPA0+2         ; * MANTISSA BYTES
3153 e372 d7 4f                        STB  FP0EXP         ; SAVE EXPONENT
3154 e374 35 82                        PULS A,PC           ; RESTORE ACCA AND RETURN
3155                         
3156 e376 8e 00 45           LBC2A     LDX  #V45           ; POINT X TO MANTISSA OF FPA4
3157 e379 20 06                        BRA  LBC35          ; MOVE FPA0 TO FPA4
3158 e37b 8e 00 40           LBC2F     LDX  #V40           ; POINT X TO MANTISSA OF FPA3
3159 e37e 8c                           FCB  SKP2           ; SKIP TWO BYTES
3160 e37f 9e 3b              LBC33     LDX  VARDES         ; POINT X TO VARIABLE DESCRIPTOR IN VARDES
3161                         * PACK FPA0 AND MOVE IT TO ADDRESS IN X
3162 e381 96 4f              LBC35     LDA  FP0EXP         ; * COPY EXPONENT
3163 e383 a7 84                        STA  ,X             ; *
3164 e385 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN BIT
3165 e387 8a 7f                        ORA  #$7F           ; MASK THE BOTTOM 7 BITS
3166 e389 94 50                        ANDA FPA0           ; AND BIT 7 OF MANTISSA SIGN INTO BIT 7 OF MS BYTE
3167 e38b a7 01                        STA  1,X            ; SAVE MS BYTE
3168 e38d 96 51                        LDA  FPA0+1         ; * MOVE 2ND MANTISSA BYTE
3169 e38f a7 02                        STA  2,X            ; *
3170 e391 de 52                        LDU  FPA0+2         ; = MOVE BOTTOM 2 MANTISSA BYTES
3171 e393 ef 03                        STU  3,X            ; =
3172 e395 39                           RTS
3173                         * MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA
3174 e396 96 61              LBC4A     LDA  FP1SGN         ; * COPY MANTISSA SIGN FROM
3175 e398 97 54              LBC4C     STA  FP0SGN         ; * FPA1 TO FPA0
3176 e39a 9e 5c                        LDX  FP1EXP         ; = COPY EXPONENT + MS BYTE FROM
3177 e39c 9f 4f                        STX  FP0EXP         ; = FPA1 TO FPA0
3178 e39e 0f 63                        CLR  FPSBYT         ; CLEAR MANTISSA SUB BYTE
3179 e3a0 96 5e                        LDA  FPA1+1         ; * COPY 2ND MANTISSA BYTE
3180 e3a2 97 51                        STA  FPA0+1         ; * FROM FPA1 TO FPA0
3181 e3a4 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN
3182 e3a6 9e 5f                        LDX  FPA1+2         ; * COPY 3RD AND 4TH MANTISSA BYTE
3183 e3a8 9f 52                        STX  FPA0+2         ; * FROM FPA1 TO FPA0
3184 e3aa 39                           RTS
3185                         * TRANSFER FPA0 TO FPA1
3186 e3ab dc 4f              LBC5F     LDD  FP0EXP         ; * TRANSFER EXPONENT & MS BYTE
3187 e3ad dd 5c                        STD  FP1EXP         ; *
3188 e3af 9e 51                        LDX  FPA0+1         ; = TRANSFER MIDDLE TWO BYTES
3189 e3b1 9f 5e                        STX  FPA1+1         ; =
3190 e3b3 9e 53                        LDX  FPA0+3         ; * TRANSFER BOTTOM TWO BYTES
3191 e3b5 9f 60                        STX  FPA1+3         ; *
3192 e3b7 4d                           TSTA                ; SET FLAGS ACCORDING TO EXPONENT
3193 e3b8 39                           RTS
3194                         * CHECK FPA0; RETURN ACCB = 0 IF FPA0 = 0,
3195                         * ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = POSITIVE
3196 e3b9 d6 4f              LBC6D     LDB  FP0EXP         ; GET EXPONENT
3197 e3bb 27 08                        BEQ  LBC79          ; BRANCH IF FPA0 = 0
3198 e3bd d6 54              LBC71     LDB  FP0SGN         ; GET SIGN OF MANTISSA
3199 e3bf 59                 LBC73     ROLB                ; BIT 7 TO CARRY
3200 e3c0 c6 ff                        LDB  #$FF           ; NEGATIVE FLAG
3201 e3c2 25 01                        BCS  LBC79          ; BRANCH IF NEGATIVE MANTISSA
3202 e3c4 50                           NEGB                ; ACCB = 1 IF POSITIVE MANTISSA
3203 e3c5 39                 LBC79     RTS
3204                         
3205                         * SGN
3206 e3c6 8d f1              SGN       BSR  LBC6D          ; SET ACCB ACCORDING TO SIGN OF FPA0
3207                         * CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POINT NUMBER
3208 e3c8 d7 50              LBC7C     STB  FPA0           ; SAVE ACCB IN FPA0
3209 e3ca 0f 51                        CLR  FPA0+1         ; CLEAR NUMBER 2 MANTISSA BYTE OF FPA0
3210 e3cc c6 88                        LDB  #$88           ; EXPONENT REQUIRED IF FPA0 IS TO BE AN INTEGER
3211 e3ce 96 50              LBC82     LDA  FPA0           ; GET MS BYTE OF MANTISSA
3212 e3d0 80 80                        SUBA #$80           ; SET CARRY IF POSITIVE MANTISSA
3213 e3d2 d7 4f              LBC86     STB  FP0EXP         ; SAVE EXPONENT
3214 e3d4 dc 74                        LDD  ZERO           ; * ZERO OUT ACCD AND
3215 e3d6 dd 52                        STD  FPA0+2         ; * BOTTOM HALF OF FPA0
3216 e3d8 97 63                        STA  FPSBYT         ; CLEAR SUB BYTE
3217 e3da 97 54                        STA  FP0SGN         ; CLEAR SIGN OF FPA0 MANTISSA
3218 e3dc 7e e1 64                     JMP  LBA18          ; GO NORMALIZE FPA0
3219                         
3220                         * ABS
3221 e3df 0f 54              ABS       CLR  FP0SGN         ; FORCE MANTISSA SIGN OF FPA0 POSITIVE
3222 e3e1 39                           RTS
3223                         * COMPARE A PACKED FLOATING POINT NUMBER POINTED TO
3224                         * BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN
3225                         * ZERO FLAG SET AND ACCB = 0, IF EQUAL; ACCB = 1 IF
3226                         * FPA0 > (X); ACCB = $FF IF FPA0 < (X)
3227 e3e2 e6 84              LBC96     LDB  ,X             ; CHECK EXPONENT OF (X)
3228 e3e4 27 d3                        BEQ  LBC6D          ; BRANCH IF FPA = 0
3229 e3e6 e6 01                        LDB  1,X            ; GET MS BYTE OF MANTISSA OF (X)
3230 e3e8 d8 54                        EORB FP0SGN         ; EOR WITH SIGN OF FPA0
3231 e3ea 2b d1                        BMI  LBC71          ; BRANCH IF SIGNS NOT =
3232                         * COMPARE FPA0 WITH FP NUMBER POINTED TO BY (X).
3233                         * FPA0 IS NORMALIZED, (X) IS PACKED.
3234 e3ec d6 4f              LBCA0     LDB  FP0EXP         ; * GET EXPONENT OF
3235 e3ee e1 84                        CMPB ,X             ; * FPA0, COMPARE TO EXPONENT OF
3236 e3f0 26 1d                        BNE  LBCC3          ; * (X) AND BRANCH IF <>.
3237 e3f2 e6 01                        LDB  1,X            ; * GET MS BYTE OF (X), KEEP ONLY
3238 e3f4 ca 7f                        ORB  #$7F           ; * THE SIGN BIT - 'AND' THE BOTTOM 7
3239 e3f6 d4 50                        ANDB FPA0           ; * BITS OF FPA0 INTO ACCB
3240 e3f8 e1 01                        CMPB 1,X            ; = COMPARE THE BOTTOM 7 BITS OF THE MANTISSA
3241 e3fa 26 13                        BNE  LBCC3          ; = MS BYTE AND BRANCH IF <>
3242 e3fc d6 51                        LDB  FPA0+1         ; * COMPARE 2ND BYTE
3243 e3fe e1 02                        CMPB 2,X            ; * OF MANTISSA,
3244 e400 26 0d                        BNE  LBCC3          ; * BRANCH IF <>
3245 e402 d6 52                        LDB  FPA0+2         ; = COMPARE 3RD BYTE
3246 e404 e1 03                        CMPB 3,X            ; = OF MANTISSA,
3247 e406 26 07                        BNE  LBCC3          ; = BRANCH IF <>
3248 e408 d6 53                        LDB  FPA0+3         ; * SUBTRACT LS BYTE
3249 e40a e0 04                        SUBB 4,X            ; * OF (X) FROM LS BYTE OF
3250 e40c 26 01                        BNE  LBCC3          ; * FPA0, BRANCH IF <>
3251 e40e 39                           RTS                 ; RETURN IF FP (X) = FPA0
3252 e40f 56                 LBCC3     RORB                ; SHIFT CARRY TO BIT 7; CARRY SET IF FPA0 < (X)
3253 e410 d8 54                        EORB FP0SGN         ; TOGGLE SIZE COMPARISON BIT IF FPA0 IS NEGATIVE
3254 e412 20 ab                        BRA  LBC73          ; GO SET ACCB ACCORDING TO COMPARISON
3255                         * DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BINARY POINT IS TO THE RIGHT
3256                         * OF THE LEAST SIGNIFICANT BYTE OF THE MANTISSA
3257 e414 d6 4f              LBCC8     LDB  FP0EXP         ; GET EXPONENT OF FPA0
3258 e416 27 3d                        BEQ  LBD09          ; ZERO MANTISSA IF FPA0 = 0
3259 e418 c0 a0                        SUBB #$A0           ; SUBTRACT $A0 FROM FPA0 EXPONENT T THIS WILL YIELD
3260                         *                             ; THE NUMBER OF SHIFTS REQUIRED TO DENORMALIZE FPA0. WHEN
3261                         *                             ; THE EXPONENT OF FPA0 IS = ZERO, THEN THE BINARY POINT
3262                         *                             ; WILL BE TO THE RIGHT OF THE MANTISSA
3263 e41a 96 54                        LDA  FP0SGN         ; TEST SIGN OF FPA0 MANTISSA
3264 e41c 2a 05                        BPL  LBCD7          ; BRANCH IF POSITIVE
3265 e41e 03 5b                        COM  FPCARY         ; COMPLEMENT CARRY IN BYTE
3266 e420 bd e1 c7                     JSR  LBA7B          ; NEGATE MANTISSA OF FPA0
3267 e423 8e 00 4f           LBCD7     LDX  #FP0EXP        ; POINT X TO FPA0
3268 e426 c1 f8                        CMPB #-8            ; EXPONENT DIFFERENCE < -8?
3269 e428 2e 06                        BGT  LBCE4          ; YES
3270 e42a bd e1 fa                     JSR  LBAAE          ; SHIFT FPA0 RIGHT UNTIL FPA0 EXPONENT = $A0
3271 e42d 0f 5b                        CLR  FPCARY         ; CLEAR CARRY IN BYTE
3272 e42f 39                           RTS
3273 e430 0f 5b              LBCE4     CLR  FPCARY         ; CLEAR CARRY IN BYTE
3274 e432 96 54                        LDA  FP0SGN         ; * GET SIGN OF FPA0 MANTISSA
3275 e434 49                           ROLA                ; * ROTATE IT INTO THE CARRY FLAG
3276 e435 06 50                        ROR  FPA0           ; ROTATE CARRY (MANTISSA SIGN) INTO BIT 7
3277                         *                             ; OF LS BYTE OF MANTISSA
3278 e437 7e e2 06                     JMP  LBABA          ; DE-NORMALIZE FPA0
3279                         
3280                         * INT
3281                         * THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS IT WILL SHIFT THE BINARY POINT
3282                         * TO THE EXTREME RIGHT OF THE MANTISSA TO FORCE ITS EXPONENT TO BE $AO. ONCE
3283                         * THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE FOUR LEAST SIGNIFICANT
3284                         * BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUSION OF THE DE-NORMALIZATION
3285                         * ONLY THE INTEGER PORTION OF FPA0 WILL REMAIN.
3286                         *
3287 e43a d6 4f              INT       LDB  FP0EXP         ; GET EXPONENT OF FPA0
3288 e43c c1 a0                        CMPB #$A0           ; LARGEST POSSIBLE INTEGER EXPONENT
3289 e43e 24 1d                        BCC  LBD11          ; RETURN IF FPA0 >= 32768
3290 e440 8d d2                        BSR  LBCC8          ; SHIFT THE BINARY POINT ONE TO THE RIGHT OF THE
3291                         *                             ; LS BYTE OF THE FPA0 MANTISSA
3292 e442 d7 63                        STB  FPSBYT         ; ACCB = 0: ZERO OUT THE SUB BYTE
3293 e444 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN
3294 e446 d7 54                        STB  FP0SGN         ; FORCE MANTISSA SIGN TO BE POSITIVE
3295 e448 80 80                        SUBA #$80           ; SET CARRY IF MANTISSA
3296 e44a 86 a0                        LDA  #$A0           ; * GET DENORMALIZED EXPONENT AND
3297 e44c 97 4f                        STA  FP0EXP         ; * SAVE IT IN FPA0 EXPONENT
3298 e44e 96 53                        LDA  FPA0+3         ; = GET LS BYTE OF FPA0 AND
3299 e450 97 01                        STA  CHARAC         ; = SAVE IT IN CHARAC
3300 e452 7e e1 64                     JMP  LBA18          ; NORMALIZE FPA0
3301                         
3302 e455 d7 50              LBD09     STB  FPA0           ; * LOAD MANTISSA OF FPA0 WITH CONTENTS OF ACCB
3303 e457 d7 51                        STB  FPA0+1         ; *
3304 e459 d7 52                        STB  FPA0+2         ; *
3305 e45b d7 53                        STB  FPA0+3         ; *
3306 e45d 39                 LBD11     RTS                 ; *
3307                         
3308                         * CONVERT ASCII STRING TO FLOATING POINT
3309 e45e 9e 74              LBD12     LDX  ZERO           ; (X) = 0
3310 e460 9f 54                        STX  FP0SGN         ; * ZERO OUT FPA0 & THE SIGN FLAG (COEFCT)
3311 e462 9f 4f                        STX  FP0EXP         ; *
3312 e464 9f 51                        STX  FPA0+1         ; *
3313 e466 9f 52                        STX  FPA0+2         ; *
3314 e468 9f 47                        STX  V47            ; INITIALIZE EXPONENT & EXPONENT SIGN FLAG TO ZERO
3315 e46a 9f 45                        STX  V45            ; INITIALIZE RIGHT DECIMAL CTR & DECIMAL PT FLAG TO 0
3316 e46c 25 64                        BCS  LBD86          ; IF CARRY SET (NUMERIC CHARACTER), ASSUME ACCA CONTAINS FIRST
3317                         *         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE RAM HOOK
3318 e46e bd eb 9b                     JSR  XVEC19         ; CALL EXTENDED BASIC ADD-IN
3319 e471 81 2d              LBD25     CMPA #'-            ; * CHECK FOR A LEADING MINUS SIGN AND BRANCH
3320 e473 26 04                        BNE  LBD2D          ; * IF NO MINUS SIGN
3321 e475 03 55                        COM  COEFCT         ; TOGGLE SIGN; 0 = +; FF = -
3322 e477 20 04                        BRA  LBD31          ; INTERPRET THE REST OF THE STRING
3323 e479 81 2b              LBD2D     CMPA #'+            ; * CHECK FOR LEADING PLUS SlGN AND BRANCH
3324 e47b 26 04                        BNE  LBD35          ; * IF NOT A PLUS SIGN
3325 e47d 9d 7c              LBD31     JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
3326 e47f 25 51                        BCS  LBD86          ; BRANCH IF NUMERIC CHARACTER
3327 e481 81 2e              LBD35     CMPA #'.            ; DECIMAL POlNT?
3328 e483 27 28                        BEQ  LBD61          ; YES
3329 e485 81 45                        CMPA #'E            ; "E" SHORTHAND FORM (SCIENTIFIC NOTATION)?
3330 e487 26 28                        BNE  LBD65          ; NO
3331                         * EVALUATE EXPONENT OF EXPONENTIAL FORMAT
3332 e489 9d 7c                        JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
3333 e48b 25 64                        BCS  LBDA5          ; BRANCH IF NUMERIC
3334 e48d 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN?
3335 e48f 27 0e                        BEQ  LBD53          ; YES
3336 e491 81 2d                        CMPA #'-            ; ASCII MINUS?
3337 e493 27 0a                        BEQ  LBD53          ; YES
3338 e495 81 a6                        CMPA #TOK_PLUS      ; PLUS TOKEN?
3339 e497 27 08                        BEQ  LBD55          ; YES
3340 e499 81 2b                        CMPA #'+            ; ASCII PLUS?
3341 e49b 27 04                        BEQ  LBD55          ; YES
3342 e49d 20 06                        BRA  LBD59          ; BRANCH IF NO SIGN FOUND
3343 e49f 03 48              LBD53     COM  V48            ; SET EXPONENT SIGN FLAG TO NEGATIVE
3344                         * STRIP A DECIMAL NUMBER FROM BASIC LINE, CONVERT IT TO BINARY IN V47
3345 e4a1 9d 7c              LBD55     JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
3346 e4a3 25 4c                        BCS  LBDA5          ; IF NUMERIC CHARACTER, CONVERT TO BINARY
3347 e4a5 0d 48              LBD59     TST  V48            ; * CHECK EXPONENT SIGN FLAG
3348 e4a7 27 08                        BEQ  LBD65          ; * AND BRANCH IF POSITIVE
3349 e4a9 00 47                        NEG  V47            ; NEGATE VALUE OF EXPONENT
3350 e4ab 20 04                        BRA  LBD65
3351 e4ad 03 46              LBD61     COM  V46            ; *TOGGLE DECIMAL PT FLAG AND INTERPRET ANOTHER
3352 e4af 26 cc                        BNE  LBD31          ; *CHARACTER IF <> 0 - TERMINATE INTERPRETATION
3353                         *         IF   SECOND DECIMAL POINT
3354                         * ADJUST FPA0 FOR THE DECIMAL EXPONENT IN V47
3355 e4b1 96 47              LBD65     LDA  V47            ; * GET EXPONENT, SUBTRACT THE NUMBER OF
3356 e4b3 90 45                        SUBA V45            ; * PLACES TO THE RIGHT OF DECIMAL POINT
3357 e4b5 97 47                        STA  V47            ; * AND RESAVE IT.
3358 e4b7 27 12                        BEQ  LBD7F          ; EXIT ROUTINE IF ADJUSTED EXPONENT = ZERO
3359 e4b9 2a 09                        BPL  LBD78          ; BRANCH IF POSITIVE EXPONENT
3360 e4bb bd e2 ce           LBD6F     JSR  LBB82          ; DIVIDE FPA0 BY 10
3361 e4be 0c 47                        INC  V47            ; INCREMENT EXPONENT COUNTER (MULTIPLY BY 10)
3362 e4c0 26 f9                        BNE  LBD6F          ; KEEP MULTIPLYING
3363 e4c2 20 07                        BRA  LBD7F          ; EXIT ROUTINE
3364 e4c4 bd e2 b6           LBD78     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
3365 e4c7 0a 47                        DEC  V47            ; DECREMENT EXPONENT COUNTER (DIVIDE BY 10)
3366 e4c9 26 f9                        BNE  LBD78          ; KEEP MULTIPLYING
3367 e4cb 96 55              LBD7F     LDA  COEFCT         ; GET THE SIGN FLAG
3368 e4cd 2a 8e                        BPL  LBD11          ; RETURN IF POSITIVE
3369 e4cf 7e e6 35                     JMP  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0, IF NEGATIVE
3370                         *MULTIPLY FPA0 BY TEN AND ADD ACCA TO THE RESULT
3371 e4d2 d6 45              LBD86     LDB  V45            ; *GET THE RIGHT DECIMAL COUNTER AND SUBTRACT
3372 e4d4 d0 46                        SUBB V46            ; *THE DECIMAL POINT FLAG FROM IT. IF DECIMAL POINT
3373 e4d6 d7 45                        STB  V45            ; *FLAG=0, NOTHING HAPPENS. IF DECIMAL POINT FLAG IS
3374                         *                             -1, THEN RIGHT DECIMAL COUNTER IS INCREMENTED BY ONE
3375 e4d8 34 02                        PSHS A              ; SAVE NEW DIGIT ON STACK
3376 e4da bd e2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
3377 e4dd 35 04                        PULS B              ; GET NEW DIGIT BACK
3378 e4df c0 30                        SUBB #'0            ; MASK OFF ASCII
3379 e4e1 8d 02                        BSR  LBD99          ; ADD ACCB TO FPA0
3380 e4e3 20 98                        BRA  LBD31          ; GET ANOTHER CHARACTER FROM BASIC
3381 e4e5 bd e3 7b           LBD99     JSR  LBC2F          ; PACK FPA0 AND SAVE IT IN FPA3
3382 e4e8 bd e3 c8                     JSR  LBC7C          ; CONVERT ACCB TO FP NUMBER IN FPA0
3383 e4eb 8e 00 40                     LDX  #V40           ; * ADD FPA0 TO
3384 e4ee 7e e1 0e                     JMP  LB9C2          ; * FPA3
3385                         
3386                         
3387 e4f1 d6 47              LBDA5     LDB  V47
3388 e4f3 58                           ASLB                ; TIMES 2
3389 e4f4 58                           ASLB                ; TIMES 4
3390 e4f5 db 47                        ADDB V47            ; ADD 1 = TIMES 5
3391 e4f7 58                           ASLB                ; TIMES 10
3392 e4f8 80 30                        SUBA #'0            ; *MASK OFF ASCII FROM ACCA, PUSH
3393 e4fa 34 04                        PSHS B              ; *RESULT ONTO THE STACK AND
3394 e4fc ab e0                        ADDA ,S+            ; ADD lT TO ACCB
3395 e4fe 97 47                        STA  V47            ; SAVE IN V47
3396 e500 20 9f                        BRA  LBD55          ; INTERPRET ANOTHER CHARACTER
3397                         *
3398 e502 9b 3e bc 1f fd     LBDB6     FCB  $9B,$3E,$BC,$1F,$FD ; * 99999999.9
3399 e507 9e 6e 6b 27 fd     LBDBB     FCB  $9E,$6E,$6B,$27,$FD ; * 999999999
3400 e50c 9e 6e 6b 28 00     LBDC0     FCB  $9E,$6E,$6B,$28,$00 ; * 1E + 09
3401                         *
3402 e511 8e d3 a7           LBDC5     LDX  #LABE8-1       ; POINT X TO " IN " MESSAGE
3403 e514 8d 0c                        BSR  LBDD6          ; COPY A STRING FROM (X) TO CONSOLE OUT
3404 e516 dc 68                        LDD  CURLIN         ; GET CURRENT BASIC LINE NUMBER TO ACCD
3405                         * CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER
3406                         * AND PRINT IT TO CONSOLE OUT
3407 e518 dd 50              LBDCC     STD  FPA0           ; SAVE ACCD IN TOP HALF OF FPA0
3408 e51a c6 90                        LDB  #$90           ; REQ'D EXPONENT IF TOP HALF OF ACCD = INTEGER
3409 e51c 43                           COMA                ; SET CARRY FLAG - FORCE POSITIVE MANTISSA
3410 e51d bd e3 d2                     JSR  LBC86          ; ZERO BOTTOM HALF AND SIGN OF FPA0, THEN
3411                         *         SAVE EXPONENT AND NORMALIZE IT
3412 e520 8d 03                        BSR  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
3413 e522 7e e0 e8           LBDD6     JMP  LB99C          ; COPY A STRING FROM (X) TO CONSOLE OUT
3414                         
3415                         * CONVERT FP NUMBER TO ASCII STRING
3416 e525 ce 01 f1           LBDD9     LDU  #STRBUF+3      ; POINT U TO BUFFER WHICH WILL NOT CAUSE
3417                         *                             ; THE STRING TO BE STORED IN STRING SPACE
3418 e528 86 20              LBDDC     LDA  #SPACE         ; SPACE = DEFAULT SIGN FOR POSITIVE #
3419 e52a d6 54                        LDB  FP0SGN         ; GET SIGN OF FPA0
3420 e52c 2a 02                        BPL  LBDE4          ; BRANCH IF POSITIVE
3421 e52e 86 2d                        LDA  #'-            ; ASCII MINUS SIGN
3422 e530 a7 c0              LBDE4     STA  ,U+            ; STORE SIGN OF NUMBER
3423 e532 df 64                        STU  COEFPT         ; SAVE BUFFER POINTER
3424 e534 97 54                        STA  FP0SGN         ; SAVE SIGN (IN ASCII)
3425 e536 86 30                        LDA  #'0            ; ASCII ZERO IF EXPONENT = 0
3426 e538 d6 4f                        LDB  FP0EXP         ; GET FPA0 EXPONENT
3427 e53a 10 27 00 c6                  LBEQ LBEB8          ; BRANCH IF FPA0 = 0
3428 e53e 4f                           CLRA                ; BASE 10 EXPONENT=0 FOR FP NUMBER > 1
3429 e53f c1 80                        CMPB #$80           ; CHECK EXPONENT
3430 e541 22 08                        BHI  LBDFF          ; BRANCH IF FP NUMBER > 1
3431                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE CONVERSION PROCESS
3432 e543 8e e5 0c                     LDX  #LBDC0         ; POINT X TO FP 1E+09
3433 e546 bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY (X)
3434 e549 86 f7                        LDA  #-9            ; BASE 10 EXPONENT = -9
3435 e54b 97 45              LBDFF     STA  V45            ; BASE 10 EXPONENT
3436                         * PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE RANGE
3437                         * OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST
3438                         * NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE
3439                         * SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING
3440                         * SCIENTIFIC NOTATION
3441 e54d 8e e5 07           LBE01     LDX  #LBDBB         ; POINT X TO FP 999,999,999
3442 e550 bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO 999,999,999
3443 e553 2e 0f                        BGT  LBE18          ; BRANCH IF > 999,999,999
3444 e555 8e e5 02           LBE09     LDX  #LBDB6         ; POINT X TO FP 99,999,999.9
3445 e558 bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO 99,999,999.9
3446 e55b 2e 0e                        BGT  LBE1F          ; BRANCH IF > 99,999,999.9 (IN RANGE)
3447 e55d bd e2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
3448 e560 0a 45                        DEC  V45            ; SUBTRACT ONE FROM DECIMAL OFFSET
3449 e562 20 f1                        BRA  LBE09          ; PSEUDO - NORMALIZE SOME MORE
3450 e564 bd e2 ce           LBE18     JSR  LBB82          ; DIVIDE FPA0 BY 10
3451 e567 0c 45                        INC  V45            ; ADD ONE TO BASE 10 EXPONENT
3452 e569 20 e2                        BRA  LBE01          ; PSEUDO - NORMALIZE SOME MORE
3453 e56b bd e1 00           LBE1F     JSR  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
3454 e56e bd e4 14                     JSR  LBCC8          ; CONVERT FPA0 TO AN INTEGER
3455 e571 c6 01                        LDB  #1             ; DEFAULT DECIMAL POINT FLAG (FORCE IMMED DECIMAL PT)
3456 e573 96 45                        LDA  V45            ; * GET BASE 10 EXPONENT AND ADD TEN TO IT
3457 e575 8b 0a                        ADDA #9+1           ; * (NUMBER 'NORMALIZED' TO 9 PLACES & DECIMAL PT)
3458 e577 2b 09                        BMI  LBE36          ; BRANCH IF NUMBER < 1.0
3459 e579 81 0b                        CMPA #9+2           ; NINE PLACES MAY BE DISPLAYED WITHOUT
3460                         *         USING SCIENTIFIC NOTATION
3461 e57b 24 05                        BCC  LBE36          ; BRANCH IF SCIENTIFIC NOTATION REQUIRED
3462 e57d 4a                           DECA                ; * SUBTRACT 1 FROM MODIFIED BASE 10 EXPONENT CTR
3463 e57e 1f 89                        TFR  A,B            ; * AND SAVE IT IN ACCB (DECiMAL POINT FLAG)
3464 e580 86 02                        LDA  #2             ; FORCE EXPONENT = 0 - DON'T USE SCIENTIFIC NOTATION
3465 e582 4a                 LBE36     DECA                ; * SUBTRACT TWO (WITHOUT AFFECTING CARRY)
3466 e583 4a                           DECA                ; * FROM BASE 10 EXPONENT
3467 e584 97 47                        STA  V47            ; SAVE EXPONENT - ZERO EXPONENT = DO NOT DISPLAY
3468                         *         IN   SCIENTIFIC NOTATION
3469 e586 d7 45                        STB  V45            ; DECIMAL POINT FLAG - NUMBER OF PLACES TO
3470                         *         LEFT OF DECIMAL POINT
3471 e588 2e 0d                        BGT  LBE4B          ; BRANCH IF >= 1
3472 e58a de 64                        LDU  COEFPT         ; POINT U TO THE STRING BUFFER
3473 e58c 86 2e                        LDA  #'.            ; * STORE A PERIOD
3474 e58e a7 c0                        STA  ,U+            ; * IN THE BUFFER
3475 e590 5d                           TSTB                ; CHECK DECIMAL POINT FLAG
3476 e591 27 04                        BEQ  LBE4B          ; BRANCH IF NOTHING TO LEFT OF DECIMAL POINT
3477 e593 86 30                        LDA  #'0            ; * STORE A ZERO
3478 e595 a7 c0                        STA  ,U+            ; * IN THE BUFFER
3479                         
3480                         * CONVERT FPA0 INTO A STRING OF ASCII DIGITS
3481 e597 8e e6 11           LBE4B     LDX  #LBEC5         ; POINT X TO FP POWER OF 10 MANTISSA
3482 e59a c6 80                        LDB  #0+$80         ; INITIALIZE DIGIT COUNTER TO 0+$80
3483                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
3484                         * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
3485                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB IS HOW
3486                         * THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.
3487 e59c 96 53              LBE50     LDA  FPA0+3         ; * ADD MANTISSA LS
3488 e59e ab 03                        ADDA 3,X            ; * BYTE OF FPA0
3489 e5a0 97 53                        STA  FPA0+3         ; * AND (X)
3490 e5a2 96 52                        LDA  FPA0+2         ; = ADD MANTISSA
3491 e5a4 a9 02                        ADCA 2,X            ; = NUMBER 3 BYTE OF
3492 e5a6 97 52                        STA  FPA0+2         ; = FPA0 AND (X)
3493 e5a8 96 51                        LDA  FPA0+1         ; * ADD MANTISSA
3494 e5aa a9 01                        ADCA 1,X            ; * NUMBER 2 BYTE OF
3495 e5ac 97 51                        STA  FPA0+1         ; * FPA0 AND (X)
3496 e5ae 96 50                        LDA  FPA0           ; = ADD MANTISSA
3497 e5b0 a9 84                        ADCA ,X             ; = MS BYTE OF
3498 e5b2 97 50                        STA  FPA0           ; = FPA0 AND (X)
3499 e5b4 5c                           INCB                ; ADD ONE TO DIGIT COUNTER
3500 e5b5 56                           RORB                ; ROTATE CARRY INTO BIT 7
3501 e5b6 59                           ROLB                ; *SET OVERFLOW FLAG AND BRANCH IF CARRY = 1 AND
3502 e5b7 28 e3                        BVC  LBE50          ; *POSITIVE MANTISSA OR CARRY = 0 AND NEG MANTISSA
3503 e5b9 24 03                        BCC  LBE72          ; BRANCH IF NEGATIVE MANTISSA
3504 e5bb c0 0b                        SUBB #10+1          ; * TAKE THE 9'S COMPLEMENT IF
3505 e5bd 50                           NEGB                ; * ADDING MANTISSA
3506 e5be cb 2f              LBE72     ADDB #'0-1          ; ADD ASCII OFFSET TO DIGIT
3507 e5c0 30 04                        LEAX 4,X            ; MOVE TO NEXT POWER OF 10 MANTISSA
3508 e5c2 1f 98                        TFR  B,A            ; SAVE DIGIT IN ACCA
3509 e5c4 84 7f                        ANDA #$7F           ; MASK OFF BIT 7 (ADD/SUBTRACT FLAG)
3510 e5c6 a7 c0                        STA  ,U+            ; STORE DIGIT IN STRING BUFFER
3511 e5c8 0a 45                        DEC  V45            ; DECREMENT DECIMAL POINT FLAG
3512 e5ca 26 04                        BNE  LBE84          ; BRANCH IF NOT TIME FOR DECIMAL POINT
3513 e5cc 86 2e                        LDA  #'.            ; * STORE DECIMAL POINT IN
3514 e5ce a7 c0                        STA  ,U+            ; * STRING BUFFER
3515 e5d0 53                 LBE84     COMB                ; TOGGLE BIT 7 (ADD/SUBTRACT FLAG)
3516 e5d1 c4 80                        ANDB #$80           ; MASK OFF ALL BUT ADD/SUBTRACT FLAG
3517 e5d3 8c e6 35                     CMPX #LBEC5+36      ; COMPARE X TO END OF MANTISSA TABLE
3518 e5d6 26 c4                        BNE  LBE50          ; BRANCH IF NOT AT END OF TABLE
3519                         * BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY
3520 e5d8 a6 c2              LBE8C     LDA  ,-U            ; GET THE LAST CHARACTER; MOVE POINTER BACK
3521 e5da 81 30                        CMPA #'0            ; WAS IT A ZERO?
3522 e5dc 27 fa                        BEQ  LBE8C          ; IGNORE TRAILING ZEROS IF SO
3523 e5de 81 2e                        CMPA #'.            ; CHECK FOR DECIMAL POINT
3524 e5e0 26 02                        BNE  LBE98          ; BRANCH IF NOT DECIMAL POINT
3525 e5e2 33 5f                        LEAU -1,U           ; STEP OVER THE DECIMAL POINT
3526 e5e4 86 2b              LBE98     LDA  #'+            ; ASCII PLUS SIGN
3527 e5e6 d6 47                        LDB  V47            ; GET SCIENTIFIC NOTATION EXPONENT
3528 e5e8 27 1c                        BEQ  LBEBA          ; BRANCH IF NOT SCIENTIFIC NOTATION
3529 e5ea 2a 03                        BPL  LBEA3          ; BRANCH IF POSITIVE EXPONENT
3530 e5ec 86 2d                        LDA  #'-            ; ASCII MINUS SIGN
3531 e5ee 50                           NEGB                ; NEGATE EXPONENT IF NEGATIVE
3532 e5ef a7 42              LBEA3     STA  2,U            ; STORE EXPONENT SIGN IN STRING
3533 e5f1 86 45                        LDA  #'E            ; * GET ASCII 'E' (SCIENTIFIC NOTATION
3534 e5f3 a7 41                        STA  1,U            ; * FLAG) AND SAVE IT IN THE STRING
3535 e5f5 86 2f                        LDA  #'0-1          ; INITIALIZE ACCA TO ASCII ZERO
3536                         
3537                         
3538 e5f7 4c                 LBEAB     INCA                ; ADD ONE TO 10'S DIGIT OF EXPONENT
3539 e5f8 c0 0a                        SUBB #10            ; SUBTRACT 10 FROM ACCB
3540 e5fa 24 fb                        BCC  LBEAB          ; ADD 1 TO 10'S DIGIT IF NO CARRY
3541 e5fc cb 3a                        ADDB #'9+1          ; CONVERT UNITS DIGIT TO ASCII
3542 e5fe ed 43                        STD  3,U            ; SAVE EXPONENT IN STRING
3543 e600 6f 45                        CLR  5,U            ; CLEAR LAST BYTE (TERMINATOR)
3544 e602 20 04                        BRA  LBEBC          ; GO RESET POINTER
3545 e604 a7 c4              LBEB8     STA  ,U             ; STORE LAST CHARACTER
3546 e606 6f 41              LBEBA     CLR  1,U            ; CLEAR LAST BYTE (TERMINATOR - REQUIRED BY
3547                         *         PRINT SUBROUTINES)
3548 e608 8e 01 f1           LBEBC     LDX  #STRBUF+3      ; RESET POINTER TO START OF BUFFER
3549 e60b 39                           RTS
3550                         *
3551 e60c 80 00 00 00 00     LBEC0     FCB  $80,$00,$00,$00,$00 ; FLOATING POINT .5
3552                         *
3553                         *** TABLE OF UNNORMALIZED POWERS OF 10
3554 e611 fa 0a 1f 00        LBEC5     FCB  $FA,$0A,$1F,$00 ; -100000000
3555 e615 00 98 96 80        LBEC9     FCB  $00,$98,$96,$80 ; 10000000
3556 e619 ff f0 bd c0        LBECD     FCB  $FF,$F0,$BD,$C0 ; -1000000
3557 e61d 00 01 86 a0        LBED1     FCB  $00,$01,$86,$A0 ; 100000
3558 e621 ff ff d8 f0        LBED5     FCB  $FF,$FF,$D8,$F0 ; -10000
3559 e625 00 00 03 e8        LBED9     FCB  $00,$00,$03,$E8 ; 1000
3560 e629 ff ff ff 9c        LBEDD     FCB  $FF,$FF,$FF,$9C ; -100
3561 e62d 00 00 00 0a        LBEE1     FCB  $00,$00,$00,$0A ; 10
3562 e631 ff ff ff ff        LBEE5     FCB  $FF,$FF,$FF,$FF ; -1
3563                         *
3564                         *
3565 e635 96 4f              LBEE9     LDA  FP0EXP         ; GET EXPONENT OF FPA0
3566 e637 27 02                        BEQ  LBEEF          ; BRANCH IF FPA0 = 0
3567 e639 03 54                        COM  FP0SGN         ; TOGGLE MANTISSA SIGN OF FPA0
3568 e63b 39                 LBEEF     RTS
3569                         * EXPAND A POLYNOMIAL OF THE FORM
3570                         * AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0
3571                         * AND THE X REGISTER POINTS TO A TABLE OF
3572                         * COEFFICIENTS A,B,C,D....
3573 e63c 9f 64              LBEF0     STX  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
3574 e63e bd e3 7b                     JSR  LBC2F          ; MOVE FPA0 TO FPA3
3575 e641 8d 05                        BSR  LBEFC          ; MULTIPLY FPA3 BY FPA0
3576 e643 8d 08                        BSR  LBF01          ; EXPAND POLYNOMIAL
3577 e645 8e 00 40                     LDX  #V40           ; POINT X TO FPA3
3578 e648 7e e2 16           LBEFC     JMP  LBACA          ; MULTIPLY (X) BY FPA0
3579                         
3580                         * CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL
3581                         * EXPRESSION. ENTER WITH (X) POINTING TO A TABLE
3582                         * OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE
3583                         * NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER
3584                         * OF PACKED FLOATING POINT NUMBERS. THE
3585                         * POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =
3586                         * (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0...YN)
3587 e64b 9f 64              LBEFF     STX  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
3588 e64d bd e3 76           LBF01     JSR  LBC2A          ; MOVE FPA0 TO FPA4
3589 e650 9e 64                        LDX  COEFPT         ; GET THE COEFFICIENT POINTER
3590 e652 e6 80                        LDB  ,X+            ; GET THE TOP OF COEFFICIENT TABLE TO
3591 e654 d7 55                        STB  COEFCT         ; * USE AND STORE IT IN TEMPORARY COUNTER
3592 e656 9f 64                        STX  COEFPT         ; SAVE NEW COEFFICIENT POINTER
3593 e658 8d ee              LBF0C     BSR  LBEFC          ; MULTIPLY (X) BY FPA0
3594 e65a 9e 64                        LDX  COEFPT         ; *GET COEFFICIENT POINTER
3595 e65c 30 05                        LEAX 5,X            ; *MOVE TO NEXT FP NUMBER
3596 e65e 9f 64                        STX  COEFPT         ; *SAVE NEW COEFFICIENT POINTER
3597 e660 bd e1 0e                     JSR  LB9C2          ; ADD (X) AND FPA0
3598 e663 8e 00 45                     LDX  #V45           ; POINT (X) TO FPA4
3599 e666 0a 55                        DEC  COEFCT         ; DECREMENT TEMP COUNTER
3600 e668 26 ee                        BNE  LBF0C          ; BRANCH IF MORE COEFFICIENTS LEFT
3601 e66a 39                           RTS
3602                         
3603                         * RND
3604 e66b bd e3 b9           RND       JSR  LBC6D          ; TEST FPA0
3605 e66e 2b 1f                        BMI  LBF45          ; BRANCH IF FPA0 = NEGATIVE
3606 e670 27 15                        BEQ  LBF3B          ; BRANCH IF FPA0 = 0
3607 e672 8d 10                        BSR  LBF38          ; CONVERT FPA0 TO AN INTEGER
3608 e674 bd e3 7b                     JSR  LBC2F          ; PACK FPA0 TO FPA3
3609 e677 8d 0e                        BSR  LBF3B          ; GET A RANDOM NUMBER: FPA0 < 1.0
3610 e679 8e 00 40                     LDX  #V40           ; POINT (X) TO FPA3
3611 e67c 8d ca                        BSR  LBEFC          ; MULTIPLY (X) BY FPA0
3612 e67e 8e e2 11                     LDX  #LBAC5         ; POINT (X) TO FP VALUE OF 1.0
3613 e681 bd e1 0e                     JSR  LB9C2          ; ADD 1.0 TO FPA0
3614 e684 7e e4 3a           LBF38     JMP  INT            ; CONVERT FPA0 TO AN INTEGER
3615                         * CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.0
3616 e687 9e b1              LBF3B     LDX  RVSEED+1       ; * MOVE VARIABLE
3617 e689 9f 50                        STX  FPA0           ; * RANDOM NUMBER
3618 e68b 9e b3                        LDX  RVSEED+3       ; * SEED TO
3619 e68d 9f 52                        STX  FPA0+2         ; * FPA0
3620 e68f be e6 bc           LBF45     LDX  RSEED          ; = MOVE FIXED
3621 e692 9f 5d                        STX  FPA1           ; = RANDOM NUMBER
3622 e694 be e6 be                     LDX  RSEED+2        ; = SEED TO
3623 e697 9f 5f                        STX  FPA1+2         ; = MANTISSA OF FPA0
3624 e699 bd e2 1c                     JSR  LBAD0          ; MULTIPLY FPA0 X FPA1
3625 e69c dc 8a                        LDD  VAD            ; GET THE TWO LOWEST ORDER PRODUCT BYTES
3626 e69e c3 65 8b                     ADDD #$658B         ; ADD A CONSTANT
3627 e6a1 dd b3                        STD  RVSEED+3       ; SAVE NEW LOW ORDER VARIABLE RANDOM # SEED
3628 e6a3 dd 52                        STD  FPA0+2         ; SAVE NEW LOW ORDER BYTES OF FPA0 MANTISSA
3629 e6a5 dc 88                        LDD  VAB            ; GET 2 MORE LOW ORDER PRODUCT BYTES
3630 e6a7 c9 b0                        ADCB #$B0           ; ADD A CONSTANT
3631 e6a9 89 05                        ADCA #5             ; ADD A CONSTANT
3632 e6ab dd b1                        STD  RVSEED+1       ; SAVE NEW HIGH ORDER VARIABLE RANDOM # SEED
3633 e6ad dd 50                        STD  FPA0           ; SAVE NEW HIGH ORDER FPA0 MANTISSA
3634 e6af 0f 54                        CLR  FP0SGN         ; FORCE FPA0 MANTISSA = POSITIVE
3635 e6b1 86 80                        LDA  #$80           ; * SET FPA0 BIASED EXPONENT
3636 e6b3 97 4f                        STA  FP0EXP         ; * TO 0 1 < FPA0 < 0
3637 e6b5 96 15                        LDA  FPA2+2         ; GET A BYTE FROM FPA2 (MORE RANDOMNESS)
3638 e6b7 97 63                        STA  FPSBYT         ; SAVE AS SUB BYTE
3639 e6b9 7e e1 68                     JMP  LBA1C          ; NORMALIZE FPA0
3640                         *
3641 e6bc 40 e6              RSEED     FDB  $40E6          ; *CONSTANT RANDOM NUMBER GENERATOR SEED
3642 e6be 4d ab                        FDB  $4DAB          ; *
3643                         
3644                         * SIN
3645                         * THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND WILL REPEAT ITSELF EVERY
3646                         * 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ONLY THE FRACTIONAL PART IS
3647                         * RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, THE COEFFICIENTS MUST BE
3648                         * MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.
3649                         
3650                         * SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES BELOW:
3651                         * SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)
3652 e6c0 bd e3 ab           SIN       JSR  LBC5F          ; COPY FPA0 TO FPA1
3653 e6c3 8e e7 05                     LDX  #LBFBD         ; POINT (X) TO 2*PI
3654 e6c6 d6 61                        LDB  FP1SGN         ; *GET MANTISSA SIGN OF FPA1
3655 e6c8 bd e2 d5                     JSR  LBB89          ; *AND DIVIDE FPA0 BY 2*PI
3656 e6cb bd e3 ab                     JSR  LBC5F          ; COPY FPA0 TO FPA1
3657 e6ce 8d b4                        BSR  LBF38          ; CONVERT FPA0 TO AN INTEGER
3658 e6d0 0f 62                        CLR  RESSGN         ; SET RESULT SIGN = POSITIVE
3659 e6d2 96 5c                        LDA  FP1EXP         ; *GET EXPONENT OF FPA1
3660 e6d4 d6 4f                        LDB  FP0EXP         ; *GET EXPONENT OF FPA0
3661 e6d6 bd e1 08                     JSR  LB9BC          ; *SUBTRACT FPA0 FROM FPA1
3662                         * NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUMENT/2*PI
3663 e6d9 8e e7 0a                     LDX  #LBFC2         ; POINT X TO FP (.25)
3664 e6dc bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM .25 (PI/2)
3665 e6df 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN OF FPA0
3666 e6e1 34 02                        PSHS A              ; SAVE IT ON STACK
3667 e6e3 2a 09                        BPL  LBFA6          ; BRANCH IF MANTISSA POSITIVE
3668 e6e5 bd e1 00                     JSR  LB9B4          ; ADD .5 (PI) TO FPA0
3669 e6e8 96 54                        LDA  FP0SGN         ; GET SIGN OF FPA0
3670 e6ea 2b 05                        BMI  LBFA9          ; BRANCH IF NEGATIVE
3671 e6ec 03 0a                        COM  RELFLG         ; COM IF +(3*PI)/2 >= ARGUMENT >+ PI/2 (QUADRANT FLAG)
3672 e6ee bd e6 35           LBFA6     JSR  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0
3673 e6f1 8e e7 0a           LBFA9     LDX  #LBFC2         ; POINT X TO FP (.25)
3674 e6f4 bd e1 0e                     JSR  LB9C2          ; ADD .25 (PI/2) TO FPA0
3675 e6f7 35 02                        PULS A              ; GET OLD MANTISSA SIGN
3676 e6f9 4d                           TSTA                ; * BRANCH IF OLD
3677 e6fa 2a 03                        BPL  LBFB7          ; * SIGN WAS POSITIVE
3678 e6fc bd e6 35                     JSR  LBEE9          ; TOGGLE MANTISSA SIGN
3679 e6ff 8e e7 0f           LBFB7     LDX  #LBFC7         ; POINT X TO TABLE OF COEFFICIENTS
3680 e702 7e e6 3c                     JMP  LBEF0          ; GO CALCULATE POLYNOMIAL VALUE
3681                         
3682 e705 83 49 0f da a2     LBFBD     FCB  $83,$49,$0F,$DA,$A2 ; 6.28318531 (2*PI)
3683 e70a 7f 00 00 00 00     LBFC2     FCB  $7F,$00,$00,$00,$00 ; .25
3684                         
3685                         
3686 e70f 05                 LBFC7     FCB  6-1            ; SIX COEFFICIENTS
3687 e710 84 e6 1a 2d 1b     LBFC8     FCB  $84,$E6,$1A,$2D,$1B ; * -((2*PI)**11)/11!
3688 e715 86 28 07 fb f8     LBFCD     FCB  $86,$28,$07,$FB,$F8 ; * ((2*PI)**9)/9!
3689 e71a 87 99 68 89 01     LBFD2     FCB  $87,$99,$68,$89,$01 ; * -((2*PI)**7)/7!
3690 e71f 87 23 35 df e1     LBFD7     FCB  $87,$23,$35,$DF,$E1 ; * ((2*PI)**5)/5!
3691 e724 86 a5 5d e7 28     LBFDC     FCB  $86,$A5,$5D,$E7,$28 ; * -((2*PI)**3)/3!
3692 e729 83 49 0f da a2     LBFE1     FCB  $83,$49,$0F,$DA,$A2 ; *
3693                         
3694 e72e a1 54 46 8f 13               FCB  $A1,$54,$46,$8F,$13 ; UNUSED GARBAGE BYTES
3695 e733 8f 52 43 89 cd               FCB  $8F,$52,$43,$89,$CD ; UNUSED GARBAGE BYTES
3696                         * EXTENDED BASIC
3697                         
3698                         * COS
3699                         * THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTITY COS(X)=SIN((PI/2)+X)
3700 e738 8e e7 6b           COS       LDX  #L83AB         ; POINT X TO FP CONSTANT (P1/2)
3701 e73b bd e1 0e                     JSR  LB9C2          ; ADD FPA0 TO (X)
3702 e73e 7e e6 c0           L837E     JMP  SIN            ; JUMP TO SIN ROUTINE
3703                         
3704                         * TAN
3705                         * THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTITY TAN(X)=SIN(X)/COS(X)
3706 e741 bd e3 7b           TAN       JSR  LBC2F          ; PACK FPA0 AND MOVE IT TO FPA3
3707 e744 0f 0a                        CLR  RELFLG         ; RESET QUADRANT FLAG
3708 e746 8d f6                        BSR  L837E          ; CALCULATE SIN OF ARGUMENT
3709 e748 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5
3710 e74b bd e3 81                     JSR  LBC35          ; PACK FPA0 AND MOVE IT TO FPA5
3711 e74e 8e 00 40                     LDX  #V40           ; POINT X TO FPA3
3712 e751 bd e3 60                     JSR  LBC14          ; MOVE FPA3 TO FPA0
3713 e754 0f 54                        CLR  FP0SGN         ; FORCE FPA0 MANTISSA TO BE POSITIVE
3714 e756 96 0a                        LDA  RELFLG         ; GET THE QUADRANT FLAG - COS NEGATIVE IN QUADS 2,3
3715 e758 8d 0c                        BSR  L83A6          ; CALCULATE VALUE OF COS(FPA0)
3716 e75a 0d 4f                        TST  FP0EXP         ; CHECK EXPONENT OF FPA0
3717 e75c 10 27 fa 7e                  LBEQ LBA92          ; ''OV' ERROR IF COS(X)=0
3718 e760 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5
3719 e763 7e e2 db           L83A3     JMP  LBB8F          ; DIVIDE (X) BY FPA0 - SIN(X)/COS(X)
3720 e766 34 02              L83A6     PSHS A              ; SAVE SIGN FLAG ON STACK
3721 e768 7e e6 ee                     JMP  LBFA6          ; EXPAND POLYNOMIAL
3722                         
3723 e76b 81 49 0f da a2     L83AB     FCB  $81,$49,$0F,$DA,$A2 ; 1.57079633 (PI/2)
3724                         
3725                         * ATN
3726                         * A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE
3727                         * ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED
3728                         * TO EVALUATE THE EXPRESSION DEPENDING UPON
3729                         * WHETHER OR NOT THE ARGUMENT SQUARED IS > OR < 1.0
3730                         
3731                         * IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .
3732                         * IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5)*5)-. . .)
3733                         
3734 e770 96 54              ATN       LDA  FP0SGN         ; * GET THE SIGN OF THE MANTISSA AND
3735 e772 34 02                        PSHS A              ; * SAVE IT ON THE STACK
3736 e774 2a 02                        BPL  L83B8          ; BRANCH IF POSITIVE MANTISSA
3737 e776 8d 24                        BSR  L83DC          ; CHANGE SIGN OF FPA0
3738 e778 96 4f              L83B8     LDA  FP0EXP         ; * GET EXPONENT OF FPA0 AND
3739 e77a 34 02                        PSHS A              ; * SAVE IT ON THE STACK
3740 e77c 81 81                        CMPA #$81           ; IS FPAO < 1.0?
3741 e77e 25 05                        BLO  L83C5          ; YES
3742 e780 8e e2 11                     LDX  #LBAC5         ; POINT X TO FP CONSTANT 1.0
3743 e783 8d de                        BSR  L83A3          ; GET RECIPROCAL OF FPA0
3744 e785 8e e7 a0           L83C5     LDX  #L83E0         ; POINT (X) TO TAYLOR SERIES COEFFICIENTS
3745 e788 bd e6 3c                     JSR  LBEF0          ; EXPAND POLYNOMIAL
3746 e78b 35 02                        PULS A              ; GET EXPONENT OF ARGUMENT
3747 e78d 81 81                        CMPA #$81           ; WAS ARGUMENT < 1.0?
3748 e78f 25 06                        BLO  L83D7          ; YES
3749 e791 8e e7 6b                     LDX  #L83AB         ; POINT (X) TO FP NUMBER (PI/2)
3750 e794 bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (PI/2)
3751 e797 35 02              L83D7     PULS A              ; * GET SIGN OF INITIAL ARGUMENT MANTISSA
3752 e799 4d                           TSTA                ; * AND SET FLAGS ACCORDING TO IT
3753 e79a 2a 03                        BPL  L83DF          ; RETURN IF ARGUMENT WAS POSITIVE
3754 e79c 7e e6 35           L83DC     JMP  LBEE9          ; CHANGE MANTISSA SIGN OF FPA0
3755 e79f 39                 L83DF     RTS
3756                         *
3757                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR ARCTANGENT
3758 e7a0 0b                 L83E0     FCB  $0B            ; TWELVE COEFFICIENTS
3759 e7a1 76 b3 83 bd d3     L83E1     FCB  $76,$B3,$83,$BD,$D3 ; -6.84793912E-04 1/23
3760 e7a6 79 1e f4 a6 f5     L83E6     FCB  $79,$1E,$F4,$A6,$F5 ; +4.85094216E-03 1/21
3761 e7ab 7b 83 fc b0 10     L83EB     FCB  $7B,$83,$FC,$B0,$10 ; -0.0161117018
3762 e7b0 7c 0c 1f 67 ca     L83F0     FCB  $7C,$0C,$1F,$67,$CA ; 0.0342096381
3763 e7b5 7c de 53 cb c1     L83F5     FCB  $7C,$DE,$53,$CB,$C1 ; -0.0542791328
3764 e7ba 7d 14 64 70 4c     L83FA     FCB  $7D,$14,$64,$70,$4C ; 0.0724571965
3765 e7bf 7d b7 ea 51 7a     L83FF     FCB  $7D,$B7,$EA,$51,$7A ; -0.0898023954
3766 e7c4 7d 63 30 88 7e     L8404     FCB  $7D,$63,$30,$88,$7E ; 0.110932413
3767 e7c9 7e 92 44 99 3a     L8409     FCB  $7E,$92,$44,$99,$3A ; -0.142839808
3768 e7ce 7e 4c cc 91 c7     L840E     FCB  $7E,$4C,$CC,$91,$C7 ; 0.199999121
3769 e7d3 7f aa aa aa 13     L8413     FCB  $7F,$AA,$AA,$AA,$13 ; -0.333333316
3770 e7d8 81 00 00 00 00     L8418     FCB  $81,$00,$00,$00,$00 ; 1
3771                         *
3772                         *** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR LN(X)
3773                         *
3774 e7dd 03                 L841D     FCB  3              ; FOUR COEFFICIENTS
3775 e7de 7f 5e 56 cb 79     L841E     FCB  $7F,$5E,$56,$CB,$79 ; 0.434255942
3776 e7e3 80 13 9b 0b 64     L8423     FCB  $80,$13,$9B,$0B,$64 ; 0.576584541
3777 e7e8 80 76 38 93 16     L8428     FCB  $80,$76,$38,$93,$16 ; 0.961800759
3778 e7ed 82 38 aa 3b 20     L842D     FCB  $82,$38,$AA,$3B,$20 ; 2.88539007
3779                         
3780 e7f2 80 35 04 f3 34     L8432     FCB  $80,$35,$04,$F3,$34 ; 1/SQR(2)
3781                         
3782 e7f7 81 35 04 f3 34     L8437     FCB  $81,$35,$04,$F3,$34 ; SQR(2)
3783                         
3784 e7fc 80 80 00 00 00     L843C     FCB  $80,$80,$00,$00,$00 ; -0.5
3785                         
3786 e801 80 31 72 17 f8     L8441     FCB  $80,$31,$72,$17,$F8 ; LN(2)
3787                         *
3788                         * LOG - NATURAL LOGARITHM (LN)
3789                         
3790                         * THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USING
3791                         * MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*(2**B) (SCIENTIFIC
3792                         * NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE VALUE OF
3793                         * LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WILL EXPAND THIS
3794                         * TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)*LN(2). ALL OF
3795                         * THE TERMS OF THE LATTER EXPRESSION ARE CONSTANTS EXCEPT FOR THE
3796                         * LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLOR SERIES EXPANSION
3797 e806 bd e3 b9           LOG       JSR  LBC6D          ; CHECK STATUS OF FPA0
3798 e809 10 2f f3 c4                  LBLE LB44A          ; 'FC' ERROR IF NEGATIVE OR ZERO
3799 e80d 8e e7 f2                     LDX  #L8432         ; POINT (X) TO FP NUMBER (1/SQR(2))
3800 e810 96 4f                        LDA  FP0EXP         ; *GET EXPONENT OF ARGUMENT
3801 e812 80 80                        SUBA #$80           ; *SUBTRACT OFF THE BIAS AND
3802 e814 34 02                        PSHS A              ; *SAVE IT ON THE STACK
3803 e816 86 80                        LDA  #$80
3804 e818 97 4f                        STA  FP0EXP
3805 e81a bd e1 0e                     JSR  LB9C2          ; ADD FPA0 TO (X)
3806 e81d 8e e7 f7                     LDX  #L8437         ; POINT X TO SQR(2)
3807 e820 bd e2 db                     JSR  LBB8F          ; DIVIDE SQR(2) BY FPA0
3808 e823 8e e2 11                     LDX  #LBAC5         ; POINT X TO FP VALUE OF 1.00
3809 e826 bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (X)
3810                         *         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE X IS ARGUMENT
3811 e829 8e e7 dd                     LDX  #L841D         ; POINT X TO TABLE OF COEFFICIENTS
3812 e82c bd e6 3c                     JSR  LBEF0          ; EXPAND POLYNOMIAL
3813 e82f 8e e7 fc                     LDX  #L843C         ; POINT X TO FP VALUE OF (-.5)
3814 e832 bd e1 0e                     JSR  LB9C2          ; ADD FPA0 TO X
3815 e835 35 04                        PULS B              ; GET EXPONENT OF ARGUMENT BACK (WITHOUT BIAS)
3816 e837 bd e4 e5                     JSR  LBD99          ; ADD ACCB TO FPA0
3817 e83a 8e e8 01                     LDX  #L8441         ; POINT X TO LN(2)
3818 e83d 7e e2 16                     JMP  LBACA          ; MULTIPLY FPA0 * LN(2)
3819                         
3820                         * SQR
3821 e840 bd e3 ab           SQR       JSR  LBC5F          ; MOVE FPA0 TO FPA1
3822 e843 8e e6 0c                     LDX  #LBEC0         ; POINT (X) TO FP NUMBER (.5)
3823 e846 bd e3 60                     JSR  LBC14          ; COPY A PACKED NUMBER FROM (X) TO FPA0
3824                         
3825                         * ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS
3826                         * HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION
3827                         * IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.7182818
3828 e849 27 67              L8489     BEQ  EXP            ; DO A NATURAL EXPONENTIATION IF EXPONENT = 0
3829 e84b 4d                           TSTA                ; *CHECK VALUE BEING EXPONENTIATED
3830 e84c 26 03                        BNE  L8491          ; *AND BRANCH IF IT IS <> 0
3831 e84e 7e e1 86                     JMP  LBA3A          ; FPA0=0 IF RAISING ZERO TO A POWER
3832 e851 8e 00 4a           L8491     LDX  #V4A           ; * PACK FPA0 AND SAVE
3833 e854 bd e3 81                     JSR  LBC35          ; * IT IN FPA5 (ARGUMENT'S EXPONENT)
3834 e857 5f                           CLRB                ; ACCB=DEFAULT RESULT SIGN FLAG; 0=POSITIVE
3835 e858 96 61                        LDA  FP1SGN         ; *CHECK THE SIGN OF ARGUMENT
3836 e85a 2a 10                        BPL  L84AC          ; *BRANCH IF POSITIVE
3837 e85c bd e4 3a                     JSR  INT            ; CONVERT EXPONENT INTO AN INTEGER
3838 e85f 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5 (ORIGINAL EXPONENT)
3839 e862 96 61                        LDA  FP1SGN         ; GET MANTISSA SIGN OF FPA1 (ARGUMENT)
3840 e864 bd e3 ec                     JSR  LBCA0          ; *COMPARE FPA0 TO (X) AND
3841 e867 26 03                        BNE  L84AC          ; *BRANCH IF NOT EQUAL
3842 e869 43                           COMA                ; TOGGLE FPA1 MANTISSA SIGN - FORCE POSITIVE
3843 e86a d6 01                        LDB  CHARAC         ; GET LS BYTE OF INTEGER VALUE OF EXPONENT (RESULT SIGN FLAG)
3844 e86c bd e3 98           L84AC     JSR  LBC4C          ; COPY FPA1 TO FPA0; ACCA = MANTISSA SIGN
3845 e86f 34 04                        PSHS B              ; PUT RESULT SIGN FLAG ON THE STACK
3846 e871 bd e8 06                     JSR  LOG
3847 e874 8e 00 4a                     LDX  #V4A           ; POINT (X) TO FPA5
3848 e877 bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY FPA5
3849 e87a 8d 36                        BSR  EXP            ; CALCULATE E**(FPA0)
3850 e87c 35 02                        PULS A              ; * GET RESULT SIGN FLAG FROM THE STACK
3851 e87e 46                           RORA                ; * AND BRANCH IF NEGATIVE
3852 e87f 10 25 fd b2                  LBCS LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
3853 e883 39                           RTS
3854                         
3855                         * CORRECTION FACTOR FOR EXPONENTIAL FUNCTION
3856 e884 81 38 aa 3b 29     L84C4     FCB  $81,$38,$AA,$3B,$29 ; 1.44269504 ( CF )
3857                         *
3858                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E**X
3859                         *
3860 e889 07                 L84C9     FCB  7              ; EIGHT COEFFICIENTS
3861 e88a 71 34 58 3e 56     L84CA     FCB  $71,$34,$58,$3E,$56 ; 2.14987637E-05: 1/(7!*(CF**7))
3862 e88f 74 16 7e b3 1b     L84CF     FCB  $74,$16,$7E,$B3,$1B ; 1.4352314E-04 : 1/(6!*(CF**6))
3863 e894 77 2f ee e3 85     L84D4     FCB  $77,$2F,$EE,$E3,$85 ; 1.34226348E-03: 1/(5!*(CF**5))
3864 e899 7a 1d 84 1c 2a     L84D9     FCB  $7A,$1D,$84,$1C,$2A ; 9.61401701E-03: 1/(4!*(CF**4))
3865 e89e 7c 63 59 58 0a     L84DE     FCB  $7C,$63,$59,$58,$0A ; 0.0555051269
3866 e8a3 7e 75 fd e7 c6     L84E3     FCB  $7E,$75,$FD,$E7,$C6 ; 0.240226385
3867 e8a8 80 31 72 18 10     L84E8     FCB  $80,$31,$72,$18,$10 ; 0.693147186
3868 e8ad 81 00 00 00 00     L84ED     FCB  $81,$00,$00,$00,$00 ; 1
3869                         *
3870                         * EXP ( E**X)
3871                         * THE EXPONENTIAL FUNCTION IS EVALUATED BY FIRST MULTIPLYING THE
3872                         * ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS DONE, AN
3873                         * ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFLOW) FOR A
3874                         * NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A POSITIVE
3875                         * ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED TO REFLECT
3876                         * THE CF MULTIPLICATION AT THE START OF THE EVALUATION PROCESS.
3877                         
3878 e8b2 8e e8 84           EXP       LDX  #L84C4         ; POINT X TO THE CORRECTION FACTOR
3879 e8b5 bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY (X)
3880 e8b8 bd e3 7b                     JSR  LBC2F          ; PACK FPA0 AND STORE IT IN FPA3
3881 e8bb 96 4f                        LDA  FP0EXP         ; *GET EXPONENT OF FPA0 AND
3882 e8bd 81 88                        CMPA #$88           ; *COMPARE TO THE MAXIMUM VALUE
3883 e8bf 25 03                        BLO  L8504          ; BRANCH IF FPA0 < 128
3884 e8c1 7e e2 a8           L8501     JMP  LBB5C          ; SET FPA0 = 0 OR 'OV' ERROR
3885 e8c4 bd e4 3a           L8504     JSR  INT            ; CONVERT FPA0 TO INTEGER
3886 e8c7 96 01                        LDA  CHARAC         ; GET LS BYTE OF INTEGER
3887 e8c9 8b 81                        ADDA #$81           ; * WAS THE ARGUMENT =127, IF SO
3888 e8cb 27 f4                        BEQ  L8501          ; * THEN 'OV' ERROR; THIS WILL ALSO ADD THE $80 BIAS
3889                         *              ; * REQUIRED WHEN THE NEW EXPONENT IS CALCULATED BELOW
3890 e8cd 4a                           DECA                ; DECREMENT ONE FROM THE EXPONENT, BECAUSE $81, NOT $80 WAS USED ABOVE
3891 e8ce 34 02                        PSHS A              ; SAVE EXPONENT OF INTEGER PORTION ON STACK
3892 e8d0 8e 00 40                     LDX  #V40           ; POINT (X) TO FPA3
3893 e8d3 bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (X) - GET FRACTIONAL PART OF ARGUMENT
3894 e8d6 8e e8 89                     LDX  #L84C9         ; POINT X TO COEFFICIENTS
3895 e8d9 bd e6 4b                     JSR  LBEFF          ; EVALUATE POLYNOMIAL FOR FRACTIONAL PART
3896 e8dc 0f 62                        CLR  RESSGN         ; FORCE THE MANTISSA TO BE POSITIVE
3897 e8de 35 02                        PULS A              ; GET INTEGER EXPONENT FROM STACK
3898 e8e0 bd e2 94                     JSR  LBB48          ; * CALCULATE EXPONENT OF NEW FPA0 BY ADDING THE EXPONENTS OF THE
3899                         *              ; * INTEGER AND FRACTIONAL PARTS
3900 e8e3 39                           RTS
3901                         
3902                         * FIX
3903 e8e4 bd e3 b9           FIX       JSR  LBC6D          ; CHECK STATUS OF FPA0
3904 e8e7 2b 03                        BMI  L852C          ; BRANCH IF FPA0 = NEGATIVE
3905 e8e9 7e e4 3a           L8529     JMP  INT            ; CONVERT FPA0 TO INTEGER
3906 e8ec 03 54              L852C     COM  FP0SGN         ; TOGGLE SIGN OF FPA0 MANTISSA
3907 e8ee 8d f9                        BSR  L8529          ; CONVERT FPA0 TO INTEGER
3908 e8f0 7e e6 35                     JMP  LBEE9          ; TOGGLE SIGN OF FPA0
3909                         
3910                         * EDIT
3911 e8f3 bd ed 21           EDIT      JSR  L89AE          ; GET LINE NUMBER FROM BASIC
3912 e8f6 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF THE STACK
3913 e8f8 86 01              L8538     LDA  #$01           ; 'LIST' FLAG
3914 e8fa 97 98                        STA  VD8            ; SET FLAG TO LIST LINE
3915 e8fc bd d4 a5                     JSR  LAD01          ; GO FIND THE LINE NUMBER IN PROGRAM
3916 e8ff 10 25 ed 7f                  LBCS LAED2          ; ERROR #7 'UNDEFINED LINE #'
3917 e903 bd df 3e                     JSR  LB7C2          ; GO UNCRUNCH LINE INTO BUFFER AT LINBUF+1
3918 e906 1f 20                        TFR  Y,D            ; PUT ABSOLUTE ADDRESS OF END OF LINE TO ACCD
3919 e908 83 00 f5                     SUBD #LINBUF+2      ; SUBTRACT OUT THE START OF LINE
3920 e90b d7 97                        STB  VD7            ; SAVE LENGTH OF LINE
3921 e90d dc 2b              L854D     LDD  BINVAL         ; GET THE HEX VALUE OF LINE NUMBER
3922 e90f bd e5 18                     JSR  LBDCC          ; LIST THE LINE NUMBER ON THE SCREEN
3923 e912 bd e0 f8                     JSR  LB9AC          ; PRINT A SPACE
3924 e915 8e 00 f4                     LDX  #LINBUF+1      ; POINT X TO BUFFER
3925 e918 d6 98                        LDB  VD8            ; * CHECK TO SEE IF LINE IS TO BE
3926 e91a 26 25                        BNE  L8581          ; * LISTED TO SCREEN - BRANCH IF IT IS
3927 e91c 5f                 L855C     CLRB                ; RESET DIGIT ACCUMULATOR - DEFAULT VALUE
3928 e91d bd ea 47           L855D     JSR  L8687          ; GET KEY STROKE
3929 e920 bd f1 ec                     JSR  L90AA          ; SET CARRY IF NOT NUMERIC
3930 e923 25 0b                        BLO  L8570          ; BRANCH IF NOT NUMERIC
3931 e925 80 30                        SUBA #'0            ; MASK OFF ASCII
3932 e927 34 02                        PSHS A              ; SAVE IT ON STACK
3933 e929 86 0a                        LDA  #10            ; NUMBER BEING CONVERTED IS BASE 10
3934 e92b 3d                           MUL                 ; MULTIPLY ACCUMULATED VALUE BY BASE (10)
3935 e92c eb e0                        ADDB ,S+            ; ADD DIGIT TO ACCUMULATED VALUE
3936 e92e 20 ed                        BRA  L855D          ; CHECK FOR ANOTHER DIGIT
3937 e930 c0 01              L8570     SUBB #$01           ; * REPEAT PARAMETER IN ACCB; IF IT
3938 e932 c9 01                        ADCB #$01           ; *IS 0, THEN MAKE IT '1'
3939 e934 81 41                        CMPA #'A            ; ABORT?
3940 e936 26 05                        BNE  L857D          ; NO
3941 e938 bd e0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
3942 e93b 20 bb                        BRA  L8538          ; RESTART EDIT PROCESS - CANCEL ALL CHANGES
3943 e93d 81 4c              L857D     CMPA #'L            ; LIST?
3944 e93f 26 0b                        BNE  L858C          ; NO
3945 e941 8d 31              L8581     BSR  L85B4          ; LIST THE LINE
3946 e943 0f 98                        CLR  VD8            ; RESET THE LIST FLAG TO 'NO LIST'
3947 e945 bd e0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN
3948 e948 20 c3                        BRA  L854D          ; GO INTERPRET ANOTHER EDIT COMMAND
3949 e94a 32 62              L858A     LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF THE STACK
3950 e94c 81 0d              L858C     CMPA #CR            ; ENTER KEY?
3951 e94e 26 0d                        BNE  L859D          ; NO
3952 e950 8d 22                        BSR  L85B4          ; ECHO THE LINE TO THE SCREEN
3953 e952 bd e0 a8           L8592     JSR  LB958          ; PRINT CARRIAGE RETURN
3954 e955 8e 00 f4                     LDX  #LINBUF+1      ; * RESET BASIC'S INPUT POINTER
3955 e958 9f 83                        STX  CHARAD         ; * TO THE LINE INPUT BUFFER
3956 e95a 7e d4 4e                     JMP  LACA8          ; GO PUT LINE BACK IN PROGRAM
3957 e95d 81 45              L859D     CMPA #'E            ; EXIT?
3958 e95f 27 f1                        BEQ  L8592          ; YES - SAME AS ENTER EXCEPT NO ECHO
3959 e961 81 51                        CMPA #'Q            ; QUIT?
3960 e963 26 06                        BNE  L85AB          ; NO
3961 e965 bd e0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
3962 e968 7e d4 25                     JMP  LAC73          ; GO TO COMMAND LEVEL - MAKE NO CHANGES
3963 e96b 8d 02              L85AB     BSR  L85AF          ; INTERPRET THE REMAINING COMMANDS AS SUBROUTINES
3964 e96d 20 ad                        BRA  L855C          ; GO INTERPRET ANOTHER EDIT COMMAND
3965 e96f 81 20              L85AF     CMPA #SPACE         ; SPACE BAR?
3966 e971 26 10                        BNE  L85C3          ; NO
3967 e973 8c                 L85B3     FCB  SKP2           ; SKIP TWO BYTES
3968                         * DISPLAY THE NEXT ACCB BYTES OF THE LINE IN THE BUFFER TO THE SCREEN
3969                         *
3970 e974 c6 f9              L85B4     LDB  #LBUFMX-1      ; 250 BYTES MAX IN BUFFER
3971 e976 a6 84              L85B6     LDA  ,X             ; GET A CHARACTER FROM BUFFER
3972 e978 27 08                        BEQ  L85C2          ; EXIT IF IT'S A 0
3973 e97a bd d0 17                     JSR  PUTCHR         ; SEND CHAR TO CONSOLE OUT
3974 e97d 30 01                        LEAX $01,X          ; MOVE POINTER UP ONE
3975 e97f 5a                           DECB                ; DECREMENT CHARACTER COUNTER
3976 e980 26 f4                        BNE  L85B6          ; LOOP IF NOT DONE
3977 e982 39                 L85C2     RTS
3978 e983 81 44              L85C3     CMPA #'D            ; DELETE?
3979 e985 26 48                        BNE  L860F          ; NO
3980 e987 6d 84              L85C7     TST  ,X             ; * CHECK FOR END OF LINE
3981 e989 27 f7                        BEQ  L85C2          ; * AND BRANCH IF SO
3982 e98b 8d 04                        BSR  L85D1          ; REMOVE A CHARACTER
3983 e98d 5a                           DECB                ; DECREMENT REPEAT PARAMETER
3984 e98e 26 f7                        BNE  L85C7          ; BRANCH IF NOT DONE
3985 e990 39                           RTS
3986                         * REMOVE ONE CHARACTER FROM BUFFER
3987 e991 0a 97              L85D1     DEC  VD7            ; DECREMENT LENGTH OF BUFFER
3988 e993 31 1f                        LEAY -1,X           ; POINT Y TO ONE BEFORE CURRENT BUFFER POINTER
3989 e995 31 21              L85D5     LEAY $01,Y          ; INCREMENT TEMPORARY BUFFER POINTER
3990 e997 a6 21                        LDA  $01,Y          ; GET NEXT CHARACTER
3991 e999 a7 a4                        STA  ,Y             ; PUT IT IN CURRENT POSITION
3992 e99b 26 f8                        BNE  L85D5          ; BRANCH IF NOT END OF LINE
3993 e99d 39                           RTS
3994 e99e 81 49              L85DE     CMPA #'I            ;  INSERT?
3995 e9a0 27 13                        BEQ  L85F5          ; YES
3996 e9a2 81 58                        CMPA #'X            ; EXTEND?
3997 e9a4 27 0d                        BEQ  L85F3          ; YES
3998 e9a6 81 48                        CMPA #'H            ; HACK?
3999 e9a8 26 5c                        BNE  L8646          ; NO
4000 e9aa 6f 84                        CLR  ,X             ; TURN CURRENT BUFFER POINTER INTO END OF LINE FLAG
4001 e9ac 1f 10                        TFR  X,D            ; PUT CURRENT BUFFER POINTER IN ACCD
4002 e9ae 83 00 f5                     SUBD #LINBUF+2      ; SUBTRACT INITIAL POINTER POSITION
4003 e9b1 d7 97                        STB  VD7            ; SAVE NEW BUFFER LENGTH
4004 e9b3 8d bf              L85F3     BSR  L85B4          ; DISPLAY THE LINE ON THE SCREEN
4005 e9b5 bd ea 47           L85F5     JSR  L8687          ; GET A KEYSTROKE
4006 e9b8 81 0d                        CMPA #CR            ; ENTER KEY?
4007 e9ba 27 8e                        BEQ  L858A          ; YES - INTERPRET ANOTHER COMMAND - PRINT LINE
4008 e9bc 81 1b                        CMPA #ESC           ; ESCAPE?
4009 e9be 27 25                        BEQ  L8625          ; YES - RETURN TO COMMAND LEVEL - DON'T PRINT LINE
4010 e9c0 81 08                        CMPA #BS            ; BACK SPACE?
4011 e9c2 26 22                        BNE  L8626          ; NO
4012 e9c4 8c 00 f4                     CMPX #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
4013 e9c7 27 ec                        BEQ  L85F5          ; DO NOT ALLOW BS IF AT START
4014 e9c9 8d 45                        BSR  L8650          ; MOVE POINTER BACK ONE, BS TO SCREEN
4015 e9cb 8d c4                        BSR  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
4016 e9cd 20 e6                        BRA  L85F5          ; GET INSERT SUB COMMAND
4017 e9cf 81 43              L860F     CMPA #'C            ; CHANGE?
4018 e9d1 26 cb                        BNE  L85DE          ; NO
4019 e9d3 6d 84              L8613     TST  ,X             ; CHECK CURRENT BUFFER CHARACTER
4020 e9d5 27 0e                        BEQ  L8625          ; BRANCH IF END OF LINE
4021 e9d7 bd ea 47                     JSR  L8687          ; GET A KEYSTROKE
4022 e9da 25 02                        BLO  L861E          ; BRANCH IF LEGITIMATE KEY
4023 e9dc 20 f5                        BRA  L8613          ; TRY AGAIN IF ILLEGAL KEY
4024 e9de a7 80              L861E     STA  ,X+            ; INSERT NEW CHARACTER INTO BUFFER
4025 e9e0 8d 37                        BSR  L8659          ; SEND NEW CHARACTER TO SCREEN
4026 e9e2 5a                           DECB                ; DECREMENT REPEAT PARAMETER
4027 e9e3 26 ee                        BNE  L8613          ; BRANCH IF NOT DONE
4028 e9e5 39                 L8625     RTS
4029 e9e6 d6 97              L8626     LDB  VD7            ; GET LENGTH OF LINE
4030 e9e8 c1 f9                        CMPB #LBUFMX-1      ; COMPARE TO MAXIMUM LENGTH
4031 e9ea 26 02                        BNE  L862E          ; BRANCH IF NOT AT MAXIMUM
4032 e9ec 20 c7                        BRA  L85F5          ; IGNORE INPUT IF LINE AT MAXIMUM LENGTH
4033 e9ee 34 10              L862E     PSHS X              ; SAVE CURRENT BUFFER POINTER
4034 e9f0 6d 80              L8630     TST  ,X+            ; * SCAN THE LINE UNTIL END OF
4035 e9f2 26 fc                        BNE  L8630          ; * LINE (0) IS FOUND
4036 e9f4 e6 82              L8634     LDB  ,-X            ; DECR TEMP LINE POINTER AND GET A CHARACTER
4037 e9f6 e7 01                        STB  $01,X          ; PUT CHARACTER BACK DOWN ONE SPOT
4038 e9f8 ac e4                        CMPX ,S             ; HAVE WE REACHED STARTING POINT?
4039 e9fa 26 f8                        BNE  L8634          ; NO - KEEP GOING
4040 e9fc 32 62                        LEAS $02,S          ; PURGE BUFFER POINTER FROM STACK
4041 e9fe a7 80                        STA  ,X+            ; INSERT NEW CHARACTER INTO THE LINE
4042 ea00 8d 17                        BSR  L8659          ; SEND A CHARACTER TO CONSOLE OUT
4043 ea02 0c 97                        INC  VD7            ; ADD ONE TO BUFFER LENGTH
4044 ea04 20 af                        BRA  L85F5          ; GET INSERT SUB COMMAND
4045 ea06 81 08              L8646     CMPA #BS            ; BACKSPACE?
4046 ea08 26 12                        BNE  L865C          ; NO
4047 ea0a 8d 04              L864A     BSR  L8650          ; MOVE POINTER BACK 1, SEND BS TO SCREEN
4048 ea0c 5a                           DECB                ; DECREMENT REPEAT PARAMETER
4049 ea0d 26 fb                        BNE  L864A          ; LOOP UNTIL DONE
4050 ea0f 39                           RTS
4051 ea10 8c 00 f4           L8650     CMPX #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
4052 ea13 27 d0                        BEQ  L8625          ; DO NOT ALLOW BS IF AT START
4053 ea15 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
4054 ea17 86 08                        LDA  #BS            ; BACK SPACE
4055 ea19 7e d0 17           L8659     JMP  PUTCHR         ; SEND TO CONSOLE OUT
4056 ea1c 81 4b              L865C     CMPA #'K            ; KILL?
4057 ea1e 27 05                        BEQ  L8665          ; YES
4058 ea20 80 53                        SUBA #'S            ; SEARCH?
4059 ea22 27 01                        BEQ  L8665          ; YES
4060 ea24 39                           RTS
4061 ea25 34 02              L8665     PSHS A              ; SAVE KILL/SEARCH FLAG ON STACK
4062 ea27 8d 1e                        BSR  L8687          ; * GET A KEYSTROKE (TARGET CHARACTER)
4063 ea29 34 02                        PSHS A              ; * AND SAVE IT ON STACK
4064 ea2b a6 84              L866B     LDA  ,X             ; GET CURRENT BUFFER CHARACTER
4065 ea2d 27 16                        BEQ  L8685          ; AND RETURN IF END OF LINE
4066 ea2f 6d 61                        TST  $01,S          ; CHECK KILL/SEARCH FLAG
4067 ea31 26 06                        BNE  L8679          ; BRANCH IF KILL
4068 ea33 8d e4                        BSR  L8659          ; SEND A CHARACTER TO CONSOLE OUT
4069 ea35 30 01                        LEAX $01,X          ; INCREMENT BUFFER POINTER
4070 ea37 20 03                        BRA  L867C          ; CHECK NEXT INPUT CHARACTER
4071 ea39 bd e9 91           L8679     JSR  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
4072 ea3c a6 84              L867C     LDA  ,X             ; GET CURRENT INPUT CHARACTER
4073 ea3e a1 e4                        CMPA ,S             ; COMPARE TO TARGET CHARACTER
4074 ea40 26 e9                        BNE  L866B          ; BRANCH IF NO MATCH
4075 ea42 5a                           DECB                ; DECREMENT REPEAT PARAMETER
4076 ea43 26 e6                        BNE  L866B          ; BRANCH IF NOT DONE
4077 ea45 35 a0              L8685     PULS Y,PC           ; THE Y PULL WILL CLEAN UP THE STACK FOR THE 2 PSHS A
4078                         *
4079                         * GET A KEYSTRKE
4080 ea47 bd d0 03           L8687     JSR  LA171          ; CALL CONSOLE IN : DEV NBR=SCREEN
4081 ea4a 81 7f                        CMPA #$7F           ; GRAPHIC CHARACTER?
4082 ea4c 24 f9                        BCC  L8687          ; YES - GET ANOTHER CHAR
4083 ea4e 81 5f                        CMPA #$5F           ; SHIFT UP ARROW (QUIT INSERT)
4084 ea50 26 02                        BNE  L8694          ; NO
4085 ea52 86 1b                        LDA  #ESC           ; REPLACE W/ESCAPE CODE
4086 ea54 81 0d              L8694     CMPA #CR            ; ENTER KEY
4087 ea56 27 0e                        BEQ  L86A6          ; YES
4088 ea58 81 1b                        CMPA #ESC           ; ESCAPE?
4089 ea5a 27 0a                        BEQ  L86A6          ; YES
4090 ea5c 81 08                        CMPA #BS            ; BACKSPACE?
4091 ea5e 27 06                        BEQ  L86A6          ; YES
4092 ea60 81 20                        CMPA #SPACE         ; SPACE
4093 ea62 25 e3                        BLO  L8687          ; GET ANOTHER CHAR IF CONTROL CHAR
4094 ea64 1a 01                        ORCC #$01           ; SET CARRY
4095 ea66 39                 L86A6     RTS
4096                         
4097                         * TRON
4098 ea67 86                 TRON      FCB  SKP1LD         ; SKIP ONE BYTE AND LDA #$4F
4099                         
4100                         * TROFF
4101 ea68 4f                 TROFF     CLRA                ; TROFF FLAG
4102 ea69 97 8c                        STA  TRCFLG         ; TRON/TROFF FLAG:0=TROFF, <> 0=TRON
4103 ea6b 39                           RTS
4104                         
4105                         * POS
4106                         
4107 ea6c 86 00              POS       LDA  #0             ; GET DEVICE NUMBER
4108 ea6e d6 79                        LDB  LPTPOS         ; GET PRINT POSITION
4109 ea70 1d                 LA5E8     SEX                 ; CONVERT ACCB TO 2 DIGIT SIGNED INTEGER
4110 ea71 7e dc 7b                     JMP  GIVABF         ; CONVERT ACCD TO FLOATING POINT
4111                         
4112                         
4113                         * VARPTR
4114 ea74 bd d9 f6           VARPT     JSR  LB26A          ; SYNTAX CHECK FOR '('
4115 ea77 dc 1f                        LDD  ARYEND         ; GET ADDR OF END OF ARRAYS
4116 ea79 34 06                        PSHS B,A            ; SAVE IT ON STACK
4117 ea7b bd da de                     JSR  LB357          ; GET VARIABLE DESCRIPTOR
4118 ea7e bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4119 ea81 35 06                        PULS A,B            ; GET END OF ARRAYS ADDR BACK
4120 ea83 1e 10                        EXG  X,D            ; SWAP END OF ARRAYS AND VARIABLE DESCRIPTOR
4121 ea85 9c 1f                        CMPX ARYEND         ; COMPARE TO NEW END OF ARRAYS
4122 ea87 26 51                        BNE  L8724          ; 'FC' ERROR IF VARIABLE WAS NOT DEFINED PRIOR TO CALLING VARPTR
4123 ea89 7e dc 7b                     JMP  GIVABF         ; CONVERT VARIABLE DESCRIPTOR INTO A FP NUMBER
4124                         
4125                         * MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT
4126 ea8c 9d 7c              L86D6     JSR  GETNCH         ; GET INPUT CHAR FROM BASIC
4127 ea8e bd d9 f6                     JSR  LB26A          ; SYNTAX CHECK FOR '('
4128 ea91 bd da de                     JSR  LB357          ; * GET VARIABLE DESCRIPTOR ADDRESS AND
4129 ea94 34 10                        PSHS X              ; * SAVE IT ON THE STACK
4130 ea96 ec 02                        LDD  $02,X          ; POINT ACCD TO START OF OLDSTRING
4131 ea98 10 93 21                     CMPD FRETOP         ; COMPARE TO START OF CLEARED SPACE
4132 ea9b 23 04                        BLS  L86EB          ; BRANCH IF <=
4133 ea9d 93 27                        SUBD MEMSIZ         ; SUBTRACT OUT TOP OF CLEARED SPACE
4134 ea9f 23 12                        BLS  L86FD          ; BRANCH IF STRING IN STRING SPACE
4135 eaa1 e6 84              L86EB     LDB  ,X             ; GET LENGTH OF OLDSTRING
4136 eaa3 bd dc f4                     JSR  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
4137 eaa6 34 10                        PSHS X              ; SAVE RESERVED SPACE STRING ADDRESS ON STACK
4138 eaa8 ae 62                        LDX  $02,S          ; POINT X TO OLDSTRING DESCRIPTOR
4139 eaaa bd dd ca                     JSR  LB643          ; MOVE OLDSTRING INTO STRING SPACE
4140 eaad 35 50                        PULS X,U            ; * GET OLDSTRING DESCRIPTOR ADDRESS AND RESERVED STRING
4141 eaaf af 42                        STX  $02,U          ; * ADDRESS AND SAVE RESERVED ADDRESS AS OLDSTRING ADDRESS
4142 eab1 34 40                        PSHS U              ; SAVE OLDSTRING DESCRIPTOR ADDRESS
4143 eab3 bd de bf           L86FD     JSR  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
4144 eab6 34 04                        PSHS B              ; SAVE POSITION PARAMETER ON STACK
4145 eab8 5d                           TSTB                ; * CHECK POSITION PARAMETER AND BRANCH
4146 eab9 27 1f                        BEQ  L8724          ; * IF START OF STRING
4147 eabb c6 ff                        LDB  #$FF           ; DEFAULT REPLACEMENT LENGTH = $FF
4148 eabd 81 29                        CMPA #')            ; * CHECK FOR END OF MID$ STATEMENT AND
4149 eabf 27 03                        BEQ  L870E          ; * BRANCH IF AT END OF STATEMENT
4150 eac1 bd de bf                     JSR  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
4151 eac4 34 04              L870E     PSHS B              ; SAVE LENGTH PARAMETER ON STACK
4152 eac6 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4153 eac9 c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR =
4154 eacb bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR '='
4155 eace 8d 2e                        BSR  L8748          ; EVALUATE REPLACEMENT STRING
4156 ead0 1f 13                        TFR  X,U            ; SAVE REPLACEMENT STRING ADDRESS IN U
4157 ead2 ae 62                        LDX  $02,S          ; POINT X TO OLOSTRING DESCRIPTOR ADDRESS
4158 ead4 a6 84                        LDA  ,X             ; GET LENGTH OF OLDSTRING
4159 ead6 a0 61                        SUBA $01,S          ; SUBTRACT POSITION PARAMETER
4160 ead8 24 03                        BCC  L8727          ; INSERT REPLACEMENT STRING INTO OLDSTRING
4161 eada 7e db d1           L8724     JMP  LB44A          ; 'FC' ERROR IF POSITION > LENGTH OF OLDSTRING
4162 eadd 4c                 L8727     INCA                ; * NOW ACCA = NUMBER OF CHARACTERS TO THE RIGHT
4163                         *                             ; * (INCLUSIVE) OF THE POSITION PARAMETER
4164 eade a1 e4                        CMPA ,S
4165 eae0 24 02                        BCC  L872E          ; BRANCH IF NEW STRING WILL FIT IN OLDSTRING
4166 eae2 a7 e4                        STA  ,S             ; IF NOT, USE AS MUCH OF LENGTH PARAMETER AS WILL FIT
4167 eae4 a6 61              L872E     LDA  $01,S          ; GET POSITION PARAMETER
4168 eae6 1e 89                        EXG  A,B            ; ACCA=LENGTH OF REPL STRING, ACCB=POSITION PARAMETER
4169 eae8 ae 02                        LDX  $02,X          ; POINT X TO OLDSTRING ADDRESS
4170 eaea 5a                           DECB                ; * BASIC'S POSITION PARAMETER STARTS AT 1; THIS ROUTINE
4171                         *                             ; * WANTS IT TO START AT ZERO
4172 eaeb 3a                           ABX                 ; POINT X TO POSITION IN OLDSTRING WHERE THE REPLACEMENT WILL GO
4173 eaec 4d                           TSTA                ; * IF THE LENGTH OF THE REPLACEMENT STRING IS ZERO
4174 eaed 27 0d                        BEQ  L8746          ; * THEN RETURN
4175 eaef a1 e4                        CMPA ,S
4176 eaf1 23 02                        BLS  L873F          ; ADJUSTED LENGTH PARAMETER, THEN BRANCH
4177 eaf3 a6 e4                        LDA  ,S             ; OTHERWISE USE AS MUCH ROOM AS IS AVAILABLE
4178 eaf5 1f 89              L873F     TFR  A,B            ; SAVE NUMBER OF BYTES TO MOVE IN ACCB
4179 eaf7 1e 31                        EXG  U,X            ; SWAP SOURCE AND DESTINATION POINTERS
4180 eaf9 bd d1 b1                     JSR  LA59A          ; MOVE (B) BYTES FROM (X) TO (U)
4181 eafc 35 96              L8746     PULS A,B,X,PC
4182 eafe bd d8 e2           L8748     JSR  LB156          ; EVALUATE EXPRESSION
4183 eb01 7e dd db                     JMP  LB654          ; *'TM' ERROR IF NUMERIC; RETURN WITH X POINTING
4184                         *                             ; *TO STRING, ACCB = LENGTH
4185                         
4186                         * STRING
4187 eb04 bd d9 f6           STRING    JSR  LB26A          ; SYNTAX CHECK FOR '('
4188 eb07 bd de 92                     JSR  LB70B          ; EVALUATE EXPRESSION; ERROR IF > 255
4189 eb0a 34 04                        PSHS B              ; SAVE LENGTH OF STRING
4190 eb0c bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4191 eb0f bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
4192 eb12 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4193 eb15 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
4194 eb17 26 05                        BNE  L8768          ; BRANCH IF STRING
4195 eb19 bd de 95                     JSR  LB70E          ; CONVERT FPA0 INTO AN INTEGER IN ACCB
4196 eb1c 20 03                        BRA  L876B          ; SAVE THE STRING IN STRING SPACE
4197 eb1e bd de 2b           L8768     JSR  LB6A4          ; GET FIRST BYTE OF STRING
4198 eb21 34 04              L876B     PSHS B              ; SAVE FIRST BYTE OF EXPRESSION
4199 eb23 e6 61                        LDB  $01,S          ; GET LENGTH OF STRING
4200 eb25 bd dc 96                     JSR  LB50F          ; RESERVE ACCB BYTES IN STRING SPACE
4201 eb28 35 06                        PULS A,B            ; GET LENGTH OF STRING AND CHARACTER
4202 eb2a 27 05                        BEQ  L877B          ; BRANCH IF NULL STRING
4203 eb2c a7 80              L8776     STA  ,X+            ; SAVE A CHARACTER IN STRING SPACE
4204 eb2e 5a                           DECB                ; DECREMENT LENGTH
4205 eb2f 26 fb                        BNE  L8776          ; BRANCH IF NOT DONE
4206 eb31 7e de 22           L877B     JMP  LB69B          ; PUT STRING DESCRIPTOR ONTO STRING STACK
4207                         
4208                         * INSTR
4209 eb34 bd d9 f6           INSTR     JSR  LB26A          ; SYNTAX CHECK FOR '('
4210 eb37 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
4211 eb3a c6 01                        LDB  #$01           ; DEFAULT POSITION = 1 (SEARCH START)
4212 eb3c 34 04                        PSHS B              ; SAVE START
4213 eb3e 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
4214 eb40 26 10                        BNE  L879C          ; BRANCH IF STRING
4215 eb42 bd de 95                     JSR  LB70E          ; CONVERT FPA0 TO INTEGER IN ACCB
4216 eb45 e7 e4                        STB  ,S             ; SAVE START SEARCH VALUE
4217 eb47 27 91                        BEQ  L8724          ; BRANCH IF START SEARCH AT ZERO
4218 eb49 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4219 eb4c bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION - SEARCH STRING
4220 eb4f bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC
4221 eb52 9e 52              L879C     LDX  FPA0+2         ; SEARCH STRING DESCRIPTOR ADDRESS
4222 eb54 34 10                        PSHS X              ; SAVE ON THE STACK
4223 eb56 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4224 eb59 bd ea fe                     JSR  L8748          ; EVALUATE TARGET STRING EXPRESSION
4225 eb5c 34 14                        PSHS X,B            ; SAVE ADDRESS AND LENGTH ON STACK
4226 eb5e bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4227 eb61 ae 63                        LDX  $03,S          ; * LOAD X WITH SEARCH STRING DESCRIPTOR ADDRESS
4228 eb63 bd dd e0                     JSR  LB659          ; * AND GET THE LENGTH ANDADDRESS OF SEARCH STRING
4229 eb66 34 04                        PSHS B              ; SAVE LENGTH ON STACK
4230                         *
4231                         * AT THIS POINT THE STACK HAS THE FOLLOWING INFORMATION
4232                         * ON IT: 0,S-SEARCH LENGTH; 1,S-TARGET LENGTH; 2 3,S-TARGET
4233                         * ADDRESS; 4 5,S-SEARCH DESCRIPTOR ADDRESS; 6,S-SEARCH POSITION
4234 eb68 e1 66                        CMPB $06,S          ; COMPARE LENGTH OF SEARCH STRING TO START
4235 eb6a 25 23                        BLO  L87D9          ; POSITION; RETURN 0 IF LENGTH < START
4236 eb6c a6 61                        LDA  $01,S          ; GET LENGTH OF TARGET STRING
4237 eb6e 27 1c                        BEQ  L87D6          ; BRANCH IF TARGET STRING = NULL
4238 eb70 e6 66                        LDB  $06,S          ; GET START POSITION
4239 eb72 5a                           DECB                ; MOVE BACK ONE
4240 eb73 3a                           ABX                 ; POINT X TO POSITION IN SEARCH STRING WHERE SEARCHING WILL START
4241 eb74 31 84              L87BE     LEAY ,X             ; POINT Y TO SEARCH POSITION
4242 eb76 ee 62                        LDU  $02,S          ; POINT U TO START OF TARGET
4243 eb78 e6 61                        LDB  $01,S          ; LOAD ACCB WITH LENGTH OF TARGET
4244 eb7a a6 e4                        LDA  ,S             ; LOAD ACCA WITH LENGTH OF SEARCH
4245 eb7c a0 66                        SUBA $06,S          ; SUBTRACT SEARCH POSITION FROM SEARCH LENGTH
4246 eb7e 4c                           INCA                ; ADD ONE
4247 eb7f a1 61                        CMPA $01,S          ; COMPARE TO TARGET LENGTH
4248 eb81 25 0c                        BLO  L87D9          ; RETURN 0 IF TARGET LENGTH > WHAT'S LEFT OF SEARCH STRING
4249 eb83 a6 80              L87CD     LDA  ,X+            ; GET A CHARACTER FROM SEARCH STRING
4250 eb85 a1 c0                        CMPA ,U+            ; COMPARE IT TO TARGET STRING
4251 eb87 26 0c                        BNE  L87DF          ; BRANCH IF NO MATCH
4252 eb89 5a                           DECB                ; DECREMENT TARGET LENGTH
4253 eb8a 26 f7                        BNE  L87CD          ; CHECK ANOTHER CHARACTER
4254 eb8c e6 66              L87D6     LDB  $06,S          ; GET MATCH POSITION
4255 eb8e 21                 L87D8     FCB  SKP1           ; SKIP NEXT BYTE
4256 eb8f 5f                 L87D9     CLRB                ; MATCH ADDRESS = 0
4257 eb90 32 67                        LEAS $07,S          ; CLEAN UP THE STACK
4258 eb92 7e dc 7a                     JMP  LB4F3          ; CONVERT ACCB TO FP NUMBER
4259 eb95 6c 66              L87DF     INC  $06,S          ; INCREMENT SEARCH POSITION
4260 eb97 30 21                        LEAX $01,Y          ; MOVE X TO NEXT SEARCH POSITION
4261 eb99 20 d9                        BRA  L87BE          ; KEEP LOOKING FOR A MATCH
4262                         
4263                         * EXTENDED BASIC RVEC19 HOOK CODE
4264 eb9b 81 26              XVEC19    CMPA #'&            ; *
4265 eb9d 26 5c                        BNE  L8845          ; * RETURN IF NOT HEX OR OCTAL VARIABLE
4266 eb9f 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS FROM STACK
4267                         * PROCESS A VARIABLE PRECEEDED BY A '&' (&H,&O)
4268 eba1 0f 52              L87EB     CLR  FPA0+2         ; * CLEAR BOTTOM TWO
4269 eba3 0f 53                        CLR  FPA0+3         ; * BYTES OF FPA0
4270 eba5 8e 00 52                     LDX  #FPA0+2        ; BYTES 2,3 OF FPA0 = (TEMPORARY ACCUMULATOR)
4271 eba8 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4272 ebaa 81 4f                        CMPA #'O
4273 ebac 27 12                        BEQ  L880A          ; YES
4274 ebae 81 48                        CMPA #'H
4275 ebb0 27 23                        BEQ  L881F          ; YES
4276 ebb2 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4277 ebb4 20 0c                        BRA  L880C          ; DEFAULT TO OCTAL (&O)
4278 ebb6 81 38              L8800     CMPA #'8
4279 ebb8 10 22 ee 47                  LBHI LB277
4280 ebbc c6 03                        LDB  #$03           ; BASE 8 MULTIPLIER
4281 ebbe 8d 2a                        BSR  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
4282                         * EVALUATE AN &O VARIABLE
4283 ebc0 9d 7c              L880A     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4284 ebc2 25 f2              L880C     BLO  L8800          ; BRANCH IF NUMERIC
4285 ebc4 0f 50              L880E     CLR  FPA0           ; * CLEAR 2 HIGH ORDER
4286 ebc6 0f 51                        CLR  FPA0+1         ; * BYTES OF FPA0
4287 ebc8 0f 06                        CLR  VALTYP         ; SET VARXABLE TYPE TO NUMERIC
4288 ebca 0f 63                        CLR  FPSBYT         ; ZERO OUT SUB BYTE OF FPA0
4289 ebcc 0f 54                        CLR  FP0SGN         ; ZERO OUT MANTISSA SIGN OF FPA0
4290 ebce c6 a0                        LDB  #$A0           ; * SET EXPONENT OF FPA0
4291 ebd0 d7 4f                        STB  FP0EXP         ; *
4292 ebd2 7e e1 68                     JMP  LBA1C          ; GO NORMALIZE FPA0
4293                         * EVALUATE AN &H VARIABLE
4294 ebd5 9d 7c              L881F     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4295 ebd7 25 0b                        BLO  L882E          ; BRANCH IF NUMERIC
4296 ebd9 bd db 29                     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
4297 ebdc 25 e6                        BLO  L880E          ; BRANCH IF NOT ALPHA OR NUMERIC
4298 ebde 81 47                        CMPA #'G            ; CHECK FOR LETTERS A-F
4299 ebe0 24 e2                        BCC  L880E          ; BRANCH IF >= G (ILLEGAL HEX LETTER)
4300 ebe2 80 07                        SUBA #7             ; SUBTRACT ASCII DIFFERENCE BETWEEN A AND 9
4301 ebe4 c6 04              L882E     LDB  #$04           ; BASE 16 DIGIT MULTIPLIER = 2**4
4302 ebe6 8d 02                        BSR  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
4303 ebe8 20 eb                        BRA  L881F          ; KEEP EVALUATING VARIABLE
4304 ebea 68 01              L8834     ASL  $01,X          ; * MULTIPLY TEMPORARY
4305 ebec 69 84                        ROL  ,X             ; * ACCUMULATOR BY TWO
4306 ebee 10 25 f5 ec                  LBCS LBA92          ; 'OV' OVERFLOW ERROR
4307 ebf2 5a                           DECB                ; DECREMENT SHIFT COUNTER
4308 ebf3 26 f5                        BNE  L8834          ; MULTIPLY TEMPORARY ACCUMULATOR AGAIN
4309 ebf5 80 30                        SUBA #'0            ; MASK OFF ASCII
4310 ebf7 ab 01                        ADDA $01,X          ; * ADD DIGIT TO TEMPORARY
4311 ebf9 a7 01                        STA  $01,X          ; * ACCUMULATOR AND SAVE IT
4312 ebfb 39                 L8845     RTS
4313                         
4314 ebfc 35 40              XVEC15    PULS U              ; PULL RETURN ADDRESS AND SAVE IN U REGISTER
4315 ebfe 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
4316 ec00 9e 83                        LDX  CHARAD         ; CURRENT INPUT POINTER TO X
4317 ec02 9d 7c                        JSR  GETNCH         ; GET CHARACTER FROM BASIC
4318 ec04 81 26                        CMPA #'&            ; HEX AND OCTAL VARIABLES ARE PRECEEDED BY &
4319 ec06 27 99                        BEQ  L87EB          ; PROCESS A '&' VARIABLE
4320 ec08 81 b0                        CMPA #TOK_FN        ; TOKEN FOR FN
4321 ec0a 27 5e                        BEQ  L88B4          ; PROCESS FN CALL
4322 ec0c 81 ff                        CMPA #$FF           ; CHECK FOR SECONDARY TOKEN
4323 ec0e 26 08                        BNE  L8862          ; NOT SECONDARY
4324 ec10 9d 7c                        JSR  GETNCH         ; GET CHARACTER FROM BASIC
4325 ec12 81 83                        CMPA #TOK_USR       ; TOKEN FOR USR
4326 ec14 10 27 00 ab                  LBEQ L892C          ; PROCESS USR CALL
4327 ec18 9f 83              L8862     STX  CHARAD         ; RESTORE BASIC'S INPUT POINTER
4328 ec1a 6e c4                        JMP  ,U             ; RETURN TO CALLING ROUTINE
4329 ec1c 9e 68              L8866     LDX  CURLIN         ; GET CURRENT LINE NUMBER
4330 ec1e 30 01                        LEAX $01,X          ; IN DIRECT MODE?
4331 ec20 26 d9                        BNE  L8845          ; RETURN IF NOT IN DIRECT MODE
4332 ec22 c6 16                        LDB  #2*11          ; 'ILLEGAL DIRECT STATEMENT' ERROR
4333 ec24 7e d4 06           L886E     JMP  LAC46          ; PROCESS ERROR
4334                         
4335 ec27 ae 9f 00 83        DEF       LDX  [CHARAD]       ; GET TWO INPUT CHARS
4336 ec2b 8c ff 83                     CMPX #TOK_FF_USR    ; TOKEN FOR USR
4337 ec2e 10 27 00 74                  LBEQ L890F          ; BRANCH IF DEF USR
4338 ec32 8d 23                        BSR  L88A1          ; GET DESCRIPTOR ADDRESS FOR FN VARIABLE NAME
4339 ec34 8d e6                        BSR  L8866          ; DON'T ALLOW DEF FN IF IN DIRECT MODE
4340 ec36 bd d9 f6                     JSR  LB26A          ; SYNTAX CHECK FOR '('
4341 ec39 c6 80                        LDB  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE
4342 ec3b d7 08                        STB  ARYDIS         ; * AND SAVE IT IN THE ARRAY DISABLE FLAG
4343 ec3d bd da de                     JSR  LB357          ; GET VARIABLE DESCRIPTOR
4344 ec40 8d 25                        BSR  L88B1          ; 'TM' ERROR IF STRING
4345 ec42 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4346 ec45 c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR '='
4347 ec47 bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR =
4348 ec4a 9e 4b                        LDX  V4B            ; GET THE ADDRESS OF THE FN NAME DESCRIPTOR
4349 ec4c dc 83                        LDD  CHARAD         ; * GET THE CURRENT INPUT POINTER ADDRESS AND
4350 ec4e ed 84                        STD  ,X             ; * SAVE IT IN FIRST 2 BYTES OF THE DESCRIPTOR
4351 ec50 dc 39                        LDD  VARPTR         ; = GET THE DESCRIPTOR ADDRESS OF THE ARGUMENT
4352 ec52 ed 02                        STD  $02,X          ; = VARIABLE AND SAVE IT IN THE DESCRIPTOR OF THE FN NAME
4353 ec54 7e d6 90                     JMP  DATA           ; MOVE INPUT POINTER TO END OF LINE OR SUBLINE
4354 ec57 c6 b0              L88A1     LDB  #TOK_FN        ; TOKEN FOR FN
4355 ec59 bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR FN
4356 ec5c c6 80                        LDB  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE FLAG
4357 ec5e d7 08                        STB  ARYDIS         ; * AND SAVE IT IN ARRAY VARIABLE FLAG
4358 ec60 8a 80                        ORA  #$80           ; SET BIT 7 OF CURRENT INPUT CHARACTER TO INDICATE AN FN VARIABLE
4359 ec62 bd da e3                     JSR  LB35C          ; * GET THE DESCRIPTOR ADDRESS OF THIS
4360 ec65 9f 4b                        STX  V4B            ; * VARIABLE AND SAVE IT IN V4B
4361 ec67 7e d8 cf           L88B1     JMP  LB143          ; 'TM' ERROR IF STRING VARIABLE
4362                         * EVALUATE AN FN CALL
4363 ec6a 8d eb              L88B4     BSR  L88A1          ; * GET THE DESCRIPTOR OF THE FN NAME
4364 ec6c 34 10                        PSHS X              ; * VARIABLE AND SAVE IT ON THE STACK
4365 ec6e bd d9 ee                     JSR  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
4366 ec71 8d f4                        BSR  L88B1          ; 'TM' ERROR IF STRING VARIABLE
4367 ec73 35 40                        PULS U              ; POINT U TO FN NAME DESCRIPTOR
4368 ec75 c6 32                        LDB  #2*25          ; 'UNDEFINED FUNCTION CALL' ERROR
4369 ec77 ae 42                        LDX  $02,U          ; POINT X TO ARGUMENT VARIABLE DESCRIPTOR
4370 ec79 27 a9                        BEQ  L886E          ; BRANCH TO ERROR HANDLER
4371 ec7b 10 9e 83                     LDY  CHARAD         ; SAVE CURRENT INPUT POINTER IN Y
4372 ec7e ee c4                        LDU  ,U             ; * POINT U TO START OF FN FORMULA AND
4373 ec80 df 83                        STU  CHARAD         ; * SAVE IT IN INPUT POINTER
4374 ec82 a6 04                        LDA  $04,X          ; = GET FP VALUE OF
4375 ec84 34 02                        PSHS A              ; = ARGUMENT VARIABLE, CURRENT INPUT
4376 ec86 ec 84                        LDD  ,X             ; = POINTER, AND ADDRESS OF START
4377 ec88 ee 02                        LDU  $02,X          ; = OF FN FORMULA AND SAVE
4378 ec8a 34 76                        PSHS U,Y,X,B,A      ; = THEM ON THE STACK
4379 ec8c bd e3 81                     JSR  LBC35          ; PACK FPA0 AND SAVE IT IN (X)
4380 ec8f bd d8 cd           L88D9     JSR  LB141          ; EVALUATE FN EXPRESSION
4381 ec92 35 76                        PULS A,B,X,Y,U      ; RESTORE REGISTERS
4382 ec94 ed 84                        STD  ,X             ; * GET THE FP
4383 ec96 ef 02                        STU  $02,X          ; * VALUE OF THE ARGUMENT
4384 ec98 35 02                        PULS A              ; * VARIABLE OFF OF THE
4385 ec9a a7 04                        STA  $04,X          ; * STACK AND RE-SAVE IT
4386 ec9c 9d 82                        JSR  GETCCH         ; GET FINAL CHARACTER OF THE FN FORMULA
4387 ec9e 10 26 ed 61                  LBNE LB277          ; 'SYNTAX' ERROR IF NOT END OF LINE
4388 eca2 10 9f 83                     STY  CHARAD         ; RESTORE INPUT POINTER
4389 eca5 39                 L88EF     RTS
4390                         
4391                         
4392                         
4393                         * DEF USR
4394 eca6 9d 7c              L890F     JSR  GETNCH         ; SKIP PAST SECOND BYTE OF DEF USR TOKEN
4395 eca8 8d 09                        BSR  L891C          ; GET FN NUMBER
4396 ecaa 34 10                        PSHS X              ; SAVE FN EXEC ADDRESS STORAGE LOC
4397 ecac 8d 2d                        BSR  L8944          ; CALCULATE EXEC ADDRESS
4398 ecae 35 40                        PULS U              ; GET FN EXEC ADDRESS STORAGE LOC
4399 ecb0 af c4                        STX  ,U             ; SAVE EXEC ADDRESS
4400 ecb2 39                           RTS
4401 ecb3 5f                 L891C     CLRB                ; DEFAULT TO USR0 IF NO ARGUMENT
4402 ecb4 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4403 ecb6 24 06                        BCC  L8927          ; BRANCH IF NOT NUMERIC
4404 ecb8 80 30                        SUBA #'0            ; MASK OFF ASCII
4405 ecba 1f 89                        TFR  A,B            ; SAVE USR NUMBER IN ACCB
4406 ecbc 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4407 ecbe 9e 8d              L8927     LDX  USRADR         ; GET ADDRESS OF STORAGE LOCs FOR USR ADDRESS
4408 ecc0 58                           ASLB                ; X2 - 2 BYTES/USR ADDRESS
4409 ecc1 3a                           ABX                 ; ADD OFFSET TO START ADDRESS OF STORAGE LOCs
4410 ecc2 39                           RTS
4411                         * PROCESS A USR CALL
4412 ecc3 8d ee              L892C     BSR  L891C          ; GET STORAGE LOC OF EXEC ADDRESS FOR USR N
4413 ecc5 ae 84                        LDX  ,X             ; * GET EXEC ADDRESS AND
4414 ecc7 34 10                        PSHS X              ; * PUSH IT ONTO STACK
4415 ecc9 bd d9 ee                     JSR  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
4416 eccc 8e 00 4f                     LDX  #FP0EXP        ; POINT X TO FPA0
4417 eccf 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
4418 ecd1 27 07                        BEQ  L8943          ; BRANCH IF NUMERIC, STRING IF <> 0
4419 ecd3 bd dd de                     JSR  LB657          ; GET LENGTH & ADDRESS OF STRING VARIABLE
4420 ecd6 9e 52                        LDX  FPA0+2         ; GET POINTER TO STRING DESCRIPTOR
4421 ecd8 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
4422 ecda 39                 L8943     RTS                 ; JUMP TO USR ROUTINE (PSHS X ABOVE)
4423 ecdb c6 ae              L8944     LDB  #TOK_EQUALS    ; TOKEN FOR '='
4424 ecdd bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR =
4425 ece0 7e de c4                     JMP  LB73D          ; EVALUATE EXPRESSION, RETURN VALUE IN X
4426                         
4427                         
4428                         
4429                         * DEL
4430 ece3 10 27 ee ea        DEL       LBEQ LB44A          ; 'FC' ERROR IF NO ARGUMENT
4431 ece7 bd d7 17                     JSR  LAF67          ; CONVERT A DECIMAL BASiC NUMBER TO BINARY
4432 ecea bd d4 a5                     JSR  LAD01          ; FIND RAM ADDRESS OF START OF A BASIC LINE
4433 eced 9f 93                        STX  VD3            ; SAVE RAM ADDRESS OF STARTING LINE NUMBER
4434 ecef 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4435 ecf1 27 10                        BEQ  L8990          ; BRANCH IF END OF LINE
4436 ecf3 81 a7                        CMPA #TOK_MINUS     ; TOKEN FOR '-'
4437 ecf5 26 3b                        BNE  L89BF          ; TERMINATE COMMAND IF LINE NUMBER NOT FOLLOWED BY '-'
4438 ecf7 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4439 ecf9 27 04                        BEQ  L898C          ; IF END OF LINE, USE DEFAULT ENDING LINE NUMBER
4440 ecfb 8d 24                        BSR  L89AE          ; * CONVERT ENDING LINE NUMBER TO BINARY
4441 ecfd 20 04                        BRA  L8990          ; * AND SAVE IT IN BINVAL
4442 ecff 86 ff              L898C     LDA  #$FF           ; = USE $FFXX AS DEFAULT ENDING
4443 ed01 97 2b                        STA  BINVAL         ; = LINE NUMBER - SAVE IT IN BINVAL
4444 ed03 de 93              L8990     LDU  VD3            ; POINT U TO STARTING LINE NUMBER ADDRESS
4445 ed05 8c                 L8992     FCB  SKP2           ; SKIP TWO BYTES
4446 ed06 ee c4              L8993     LDU  ,U             ; POINT U TO START OF NEXT LINE
4447 ed08 ec c4                        LDD  ,U             ; CHECK FOR END OF PROGRAM
4448 ed0a 27 06                        BEQ  L899F          ; BRANCH IF END OF PROGRAM
4449 ed0c ec 42                        LDD  $02,U          ; LOAD ACCD WITH THIS LINE'S NUMBER
4450 ed0e 93 2b                        SUBD BINVAL         ; SUBTRACT ENDING LINE NUMBER ADDRESS
4451 ed10 23 f4                        BLS  L8993          ; BRANCH IF = < ENDING LINE NUMBER
4452 ed12 9e 93              L899F     LDX  VD3            ; GET STARTING LINE NUMBER
4453 ed14 8d 15                        BSR  L89B8          ; MOVE (U) TO (X) UNTIL END OF PROGRAM
4454 ed16 bd d4 c5                     JSR  LAD21          ; RESET BASIC'S INPUT POINTER AND ERASE VARIABLES
4455 ed19 9e 93                        LDX  VD3            ; GET STARTING LINE NUMBER ADDRESS
4456 ed1b bd d4 95                     JSR  LACF1          ; RECOMPUTE START OF NEXT LINE ADDRESSES
4457 ed1e 7e d4 25                     JMP  LAC73          ; JUMP TO BASIC'S MAIN COMMAND LOOP
4458 ed21 bd d7 17           L89AE     JSR  LAF67          ; GO GET LINE NUMBER CONVERTED TO BINARY
4459 ed24 7e d1 ba                     JMP  LA5C7          ; MAKE SURE THERE'S NO MORE ON THIS LINE
4460 ed27 a6 c0              L89B4     LDA  ,U+            ; GET A BYTE FROM (U)
4461 ed29 a7 80                        STA  ,X+            ; MOVE THE BYTE TO (X)
4462 ed2b 11 93 1b           L89B8     CMPU VARTAB         ; COMPARE TO END OF BASIC
4463 ed2e 26 f7                        BNE  L89B4          ; BRANCH IF NOT AT END
4464 ed30 9f 1b                        STX  VARTAB         ; SAVE (X) AS NEW END OF BASIC
4465 ed32 39                 L89BF     RTS
4466                         
4467                         
4468 ed33 bd ec 1c           L89C0     JSR  L8866          ; 'BS' ERROR IF IN DIRECT MODE
4469 ed36 9d 7c                        JSR  GETNCH         ; GET A CHAR FROM BASIC
4470 ed38 81 22              L89D2     CMPA #'"            ; CHECK FOR PROMPT STRING
4471 ed3a 26 0b                        BNE  L89E1          ; BRANCH IF NO PROMPT STRING
4472 ed3c bd d9 d0                     JSR  LB244          ; STRIP OFF PROMPT STRING & PUT IT ON STRING STACK
4473 ed3f c6 3b                        LDB  #';            ; *
4474 ed41 bd d9 fb                     JSR  LB26F          ; * DO A SYNTAX CHECK FOR;
4475 ed44 bd e0 eb                     JSR  LB99F          ; REMOVE PROMPT STRING FROM STRING STACK & SEND TO CONSOLE OUT
4476 ed47 32 7e              L89E1     LEAS -2,S           ; RESERVE TWO STORAGE SLOTS ON STACK
4477 ed49 bd d7 cc                     JSR  LB035          ; INPUT A LINE FROM CURRENT INPUT DEVICE
4478 ed4c 32 62                        LEAS $02,S          ; CLEAN UP THE STACK
4479 ed4e bd da de                     JSR  LB357          ; SEARCH FOR A VARIABLE
4480 ed51 9f 3b                        STX  VARDES         ; SAVE POINTER TO VARIABLE DESCRIPTOR
4481 ed53 bd d8 d2                     JSR  LB146          ; ''TM' ERROR IF VARIABLE TYPE = NUMERIC
4482 ed56 8e 00 f3                     LDX  #LINBUF        ; POINT X TO THE STRING BUFFER WHERE THE INPUT STRING WAS STORED
4483 ed59 4f                           CLRA                ; TERMINATOR CHARACTER 0 (END OF LINE)
4484 ed5a bd dc a3                     JSR  LB51A          ; PARSE THE INPUT STRING AND STORE IT IN THE STRING SPACE
4485 ed5d 7e d7 54                     JMP  LAFA4          ; REMOVE DESCRIPTOR FROM STRING STACK
4486 ed60 bd d7 17           L89FC     JSR  LAF67          ; STRIP A DECIMAL NUMBER FROM BASIC INPUT LINE
4487 ed63 9e 2b                        LDX  BINVAL         ; GET BINARY VALUE
4488 ed65 39                           RTS
4489 ed66 9e 91              L8A02     LDX  VD1            ; GET CURRENT OLD NUMBER BEING RENUMBERED
4490 ed68 9f 2b              L8A04     STX  BINVAL         ; SAVE THE LINE NUMBER BEING SEARCHED FOR
4491 ed6a 7e d4 a5                     JMP  LAD01          ; GO FIND THE LINE NUMBER IN BASIC PROGRAM
4492                         
4493                         * RENUM
4494 ed6d bd d4 ca           RENUM     JSR  LAD26          ; ERASE VARIABLES
4495 ed70 cc 00 0a                     LDD  #10            ; DEFAULT LINE NUMBER INTERVAL
4496 ed73 dd 95                        STD  VD5            ; SAVE DEFAULT RENUMBER START LINE NUMBER
4497 ed75 dd 8f                        STD  VCF            ; SAVE DEFAULT INTERVAL
4498 ed77 5f                           CLRB                ; NOW ACCD = 0
4499 ed78 dd 91                        STD  VD1            ; DEFAULT LINE NUMBER OF WHERE TO START RENUMBERING
4500 ed7a 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4501 ed7c 24 06                        BCC  L8A20          ; BRANCH IF NOT NUMERIC
4502 ed7e 8d e0                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4503 ed80 9f 95                        STX  VD5            ; SAVE LINE NUMBER WHERE RENUMBERING STARTS
4504 ed82 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4505 ed84 27 1b              L8A20     BEQ  L8A3D          ; BRANCH IF END OF LINE
4506 ed86 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4507 ed89 24 06                        BCC  L8A2D          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
4508 ed8b 8d d3                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4509 ed8d 9f 91                        STX  VD1            ; SAVE NEW RENUMBER LINE
4510 ed8f 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4511 ed91 27 0e              L8A2D     BEQ  L8A3D          ; BRANCH IF END OF LINE
4512 ed93 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4513 ed96 24 06                        BCC  L8A3A          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
4514 ed98 8d c6                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4515 ed9a 9f 8f                        STX  VCF            ; SAVE NEW INTERVAL
4516 ed9c 27 49                        BEQ  L8A83          ; 'FC' ERROR
4517 ed9e bd d1 ba           L8A3A     JSR  LA5C7          ; CHECK FOR MORE CHARACTERS ON LINE - 'SYNTAX' ERROR IF ANY
4518 eda1 8d c3              L8A3D     BSR  L8A02          ; GO GET ADDRESS OF OLD NUMBER BEING RENUMBERED
4519 eda3 9f 93                        STX  VD3            ; SAVE ADDRESS
4520 eda5 9e 95                        LDX  VD5            ; GET NEXT RENUMBERED LINE NUMBER TO USE
4521 eda7 8d bf                        BSR  L8A04          ; FIND THE LINE NUMBER IN THE BASIC PROGRAM
4522 eda9 9c 93                        CMPX VD3            ; COMPARE TO ADDRESS OF OLD LINE NUMBER
4523 edab 25 3a                        BLO  L8A83          ; 'FC' ERROR IF NEW ADDRESS < OLD ADDRESS
4524 edad 8d 1c                        BSR  L8A67          ; MAKE SURE RENUMBERED LINE NUMBERS WILL BE IN RANGE
4525 edaf bd ee 41                     JSR  L8ADD          ; CONVERT ASCII LINE NUMBERS TO 'EXPANDED' BINARY
4526 edb2 bd d4 93                     JSR  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESSES
4527 edb5 8d af                        BSR  L8A02          ; GET RAM ADDRESS OF FIRST LINE TO BE RENUMBERED
4528 edb7 9f 93                        STX  VD3            ; SAVE IT
4529 edb9 8d 3a                        BSR  L8A91          ; MAKE SURE LINE NUMBERS EXIST
4530 edbb 8d 0f                        BSR  L8A68          ; INSERT NEW LINE NUMBERS IN LINE HEADERS
4531 edbd 8d 36                        BSR  L8A91          ; INSERT NEW LINE NUMBERS IN PROGRAM STATEMENTS
4532 edbf bd ee dc                     JSR  L8B7B          ; CONVERT PACKED BINARY LINE NUMBERS TO ASCII
4533 edc2 bd d4 ca                     JSR  LAD26          ; ERASE VARIABLES
4534 edc5 bd d4 93                     JSR  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESS
4535 edc8 7e d4 25                     JMP  LAC73          ; GO BACK TO BASIC'S MAIN LOOP
4536 edcb 86                 L8A67     FCB  SKP1LD         ; SKIP ONE BYTE - LDA #$4F
4537 edcc 4f                 L8A68     CLRA                ; NEW LINE NUMBER FLAG - 0; INSERT NEW LINE NUMBERS
4538 edcd 97 98                        STA  VD8            ; SAVE NEW LINE NUMBER FLAG; 0 = INSERT NEW NUMBERS
4539 edcf 9e 93                        LDX  VD3            ; GET ADDRESS OF OLD LINE NUMBER BEING RENUMBERED
4540 edd1 dc 95                        LDD  VD5            ; GET THE CURRENT RENUMBERED LINE NUMBER
4541 edd3 8d 15                        BSR  L8A86          ; RETURN IF END OF PROGRAM
4542 edd5 0d 98              L8A71     TST  VD8            ; CHECK NEW LINE NUMBER FLAG
4543 edd7 26 02                        BNE  L8A77          ; BRANCH IF NOT INSERTING NEW LINE NUMBERS
4544 edd9 ed 02                        STD  $02,X          ; STORE THE NEW LINE NUMBER IN THE BASIC PROGRAM
4545 eddb ae 84              L8A77     LDX  ,X             ; POINT X TO THE NEXT LINE IN BASIC
4546 eddd 8d 0b                        BSR  L8A86          ; RETURN IF END OF PROGRAM
4547 eddf d3 8f                        ADDD VCF            ; ADD INTERVAL TO CURRENT RENUMBERED LINE NUMBER
4548 ede1 25 04                        BLO  L8A83          ; 'FC' ERROR IF LINE NUMBER > $FFFF
4549 ede3 81 fa                        CMPA #MAXLIN        ; LARGEST LINE NUMBER = $F9FF
4550 ede5 25 ee                        BLO  L8A71          ; BRANCH IF LEGAL LINE NUMBER
4551 ede7 7e db d1           L8A83     JMP  LB44A          ; 'FC' ERROR IF LINE NUMBER MS BYTE > $F9
4552                         * TEST THE TWO BYTES POINTED TO BY (X).
4553                         * NORMAL RETURN IF <> 0. IF = 0 (END OF
4554                         * PROGRAM) RETURN IS PULLED OFF STACK AND
4555                         * YOU RETURN TO PREVIOUS SUBROUTINE CALL.
4556 edea 34 06              L8A86     PSHS B,A            ; SAVE ACCD
4557 edec ec 84                        LDD  ,X             ; TEST THE 2 BYTES POINTED TO BY X
4558 edee 35 06                        PULS A,B            ; RESTORE ACCD
4559 edf0 26 02                        BNE  L8A90          ; BRANCH IF NOT END OF PROGRAM
4560 edf2 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS FROM STACK
4561 edf4 39                 L8A90     RTS
4562 edf5 9e 19              L8A91     LDX  TXTTAB         ; GET START OF BASIC PROGRAM
4563 edf7 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
4564 edf9 30 01              L8A95     LEAX $01,X          ; MOVE POINTER UP ONE
4565 edfb 8d ed                        BSR  L8A86          ; RETURN IF END OF PROGRAM
4566 edfd 30 03              L8A99     LEAX $03,X          ; SKIP OVER NEXT LINE ADDRESS AND LINE NUMBER
4567 edff 30 01              L8A9B     LEAX $01,X          ; MOVE POINTER TO NEXT CHARACTER
4568 ee01 a6 84                        LDA  ,X             ; CHECK CURRENT CHARACTER
4569 ee03 27 f4                        BEQ  L8A95          ; BRANCH IF END OF LINE
4570 ee05 9f 0f                        STX  TEMPTR         ; SAVE CURRENT POINTER
4571 ee07 4a                           DECA                ; =
4572 ee08 27 0c                        BEQ  L8AB2          ; =BRANCH IF START OF PACKED NUMERIC LINE
4573 ee0a 4a                           DECA                ; *
4574 ee0b 27 2a                        BEQ  L8AD3          ; *BRANCH IF LINE NUMBER EXISTS
4575 ee0d 4a                           DECA                ; =
4576 ee0e 26 ef                        BNE  L8A9B          ; =MOVE TO NEXT CHARACTER IF > 3
4577 ee10 86 03              L8AAC     LDA  #$03           ; * SET 1ST BYTE = 3 TO INDICATE LINE
4578 ee12 a7 80                        STA  ,X+            ; * NUMBER DOESN'T CURRENTLY EXIST
4579 ee14 20 e7                        BRA  L8A99          ; GO GET ANOTHER CHARACTER
4580 ee16 ec 01              L8AB2     LDD  $01,X          ; GET MS BYTE OF LINE NUMBER
4581 ee18 6a 02                        DEC  $02,X          ; DECREMENT ZERO CHECK BYTE
4582 ee1a 27 01                        BEQ  L8AB9          ; BRANCH IF MS BYTE <> 0
4583 ee1c 4f                           CLRA                ; CLEAR MS BYTE
4584 ee1d e6 03              L8AB9     LDB  $03,X          ; GET LS BYTE OF LINE NUMBER
4585 ee1f 6a 04                        DEC  $04,X          ; DECREMENT ZERO CHECK FLAG
4586 ee21 27 01                        BEQ  L8AC0          ; BRANCH IF IS BYTE <> 0
4587 ee23 5f                           CLRB                ; CLEAR LS BYTE
4588 ee24 ed 01              L8AC0     STD  $01,X          ; SAVE BINARY LINE NUMBER
4589 ee26 dd 2b                        STD  BINVAL         ; SAVE TRIAL LINE NUMBER
4590 ee28 bd d4 a5                     JSR  LAD01          ; FIND RAM ADDRESS OF A BASIC LINE NUMBER
4591 ee2b 9e 0f              L8AC7     LDX  TEMPTR         ; GET BACK POINTER TO START OF PACKED LINE NUMBER
4592 ee2d 25 e1                        BLO  L8AAC          ; BRANCH IF NO LINE NUMBER MATCH FOUND
4593 ee2f dc 47                        LDD  V47            ; GET START ADDRESS OF LINE NUMBER
4594 ee31 6c 80                        INC  ,X+            ; * SET 1ST BYTE = 2, TO INDICATE LINE NUMBER EXISTS IF CHECKING FOR
4595                         *              ; * EXISTENCE OF LINE NUMBER, SET IT = 1 IF INSERTING LINE NUMBERS
4596                         
4597 ee33 ed 84                        STD  ,X             ; SAVE RAM ADDRESS OF CORRECT LINE NUMBER
4598 ee35 20 c6                        BRA  L8A99          ; GO GET ANOTHER CHARACTER
4599 ee37 6f 84              L8AD3     CLR  ,X             ; CLEAR CARRY FLAG AND 1ST BYTE
4600 ee39 ae 01                        LDX  $01,X          ; POINT X TO RAM ADDRESS OF CORRECT LINE NUMBER
4601 ee3b ae 02                        LDX  $02,X          ; PUT CORRECT LINE NUMBER INTO (X)
4602 ee3d 9f 47                        STX  V47            ; SAVE IT TEMPORARILY
4603 ee3f 20 ea                        BRA  L8AC7          ; GO INSERT IT INTO BASIC LINE
4604 ee41 9e 19              L8ADD     LDX  TXTTAB         ; GET BEGINNING OF BASIC PROGRAM
4605 ee43 20 04                        BRA  L8AE5
4606 ee45 9e 83              L8AE1     LDX  CHARAD         ; *GET CURRENT INPUT POINTER
4607 ee47 30 01                        LEAX $01,X          ; *AND BUMP IT ONE
4608 ee49 8d 9f              L8AE5     BSR  L8A86          ; RETURN IF END OF PROGRAM
4609 ee4b 30 02                        LEAX $02,X          ; SKIP PAST NEXT LINE ADDRESS
4610 ee4d 30 01              L8AE9     LEAX $01,X          ; ADVANCE POINTER BY ONE
4611 ee4f 9f 83              L8AEB     STX  CHARAD         ; SAVE NEW BASIC INPUT POINTER
4612 ee51 9d 7c              L8AED     JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
4613 ee53 4d                 L8AEF     TSTA                ; CHECK THE CHARACTER
4614 ee54 27 ef                        BEQ  L8AE1          ; BRANCH IF END OF LINE
4615 ee56 2a f9                        BPL  L8AED          ; BRANCH IF NOT A TOKEN
4616 ee58 9e 83                        LDX  CHARAD         ; GET CURRENT INPUT POINTER
4617 ee5a 81 ff                        CMPA #$FF           ; IS THIS A SECONDARY TOKEN?
4618 ee5c 27 ef                        BEQ  L8AE9          ; YES - IGNORE IT
4619 ee5e 81 a2                        CMPA #TOK_THEN      ; TOKEN FOR THEN?
4620 ee60 27 12                        BEQ  L8B13          ; YES
4621 ee62 81 84                        CMPA #TOK_ELSE      ; TOKEN FOR ELSE?
4622 ee64 27 0e                        BEQ  L8B13          ; YES
4623 ee66 81 81                        CMPA #TOK_GO        ; TOKEN FOR GO?
4624 ee68 26 e7                        BNE  L8AED          ; NO
4625 ee6a 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4626 ee6c 81 a0                        CMPA #TOK_TO        ; TOKEN FOR TO?
4627 ee6e 27 04                        BEQ  L8B13          ; YES
4628 ee70 81 a1                        CMPA #TOK_SUB       ; TOKEN FOR SUB?
4629 ee72 26 db                        BNE  L8AEB          ; NO
4630 ee74 9d 7c              L8B13     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4631 ee76 25 04                        BLO  L8B1B          ; BRANCH IF NUMERIC
4632 ee78 9d 82              L8B17     JSR  GETCCH         ; GET CURRENT BASIC INPUT CHARRACTER
4633 ee7a 20 d7                        BRA  L8AEF          ; KEEP CHECKING THE LINE
4634 ee7c 9e 83              L8B1B     LDX  CHARAD         ; GET CURRENT INPUT ADDRESS
4635 ee7e 34 10                        PSHS X              ; SAVE IT ON THE STACK
4636 ee80 bd d7 17                     JSR  LAF67          ; CONVERT DECIMAL BASIC NUMBER TO BINARY
4637 ee83 9e 83                        LDX  CHARAD         ; GET CURRENT INPUT POINTER
4638 ee85 a6 82              L8B24     LDA  ,-X            ; GET PREVIOUS INPUT CHARACTER
4639 ee87 bd f1 ec                     JSR  L90AA          ; CLEAR CARRY IF NUMERIC INPUT VALUE
4640 ee8a 25 f9                        BLO  L8B24          ; BRANCH IF NON-NUMERIC
4641 ee8c 30 01                        LEAX $01,X          ; MOVE POINTER UP ONE
4642 ee8e 1f 10                        TFR  X,D            ; NOW ACCD POINTS TO ONE PAST END OF LINE NUMBER
4643 ee90 e0 61                        SUBB $01,S          ; SUBTRACT PRE-NUMERIC POINTER LS BYTE
4644 ee92 c0 05                        SUBB #$05           ; MAKE SURE THERE ARE AT LEAST 5 CHARACTERS IN THE NUMERIC LINE
4645                         *
4646 ee94 27 20                        BEQ  L8B55          ; BRANCH IF EXACTLY 5
4647 ee96 25 0a                        BLO  L8B41          ; BRANCH IF < 5
4648 ee98 33 84                        LEAU ,X             ; TRANSFER X TO U
4649 ee9a 50                           NEGB                ; NEGATE B
4650 ee9b 30 85                        LEAX B,X            ; MOVE X BACK B BYTES
4651 ee9d bd ed 2b                     JSR  L89B8          ; *MOVE BYTES FROM (U) TO (X) UNTIL
4652                         *         *U   = END OF BASIC; (I) = NEW END OF BASIC
4653 eea0 20 14                        BRA  L8B55
4654                         * FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER
4655 eea2 9f 47              L8B41     STX  V47            ; SAVE END OF NUMERIC VALUE
4656 eea4 9e 1b                        LDX  VARTAB         ; GET END OF BASIC PROGRAM
4657 eea6 9f 43                        STX  V43            ; SAVE IT
4658 eea8 50                           NEGB                ; NEGATE B
4659 eea9 30 85                        LEAX B,X            ; ADD IT TO END OF NUMERIC POiNTER
4660 eeab 9f 41                        STX  V41            ; SAVE POINTER
4661 eead 9f 1b                        STX  VARTAB         ; STORE END OF BASIC PROGRAM
4662 eeaf bd d3 de                     JSR  LAC1E          ; ACCD = TOP OF ARRAYS - CHECK FOR ENOUGH ROOM
4663 eeb2 9e 45                        LDX  V45            ; * GET AND SAVE THE
4664 eeb4 9f 83                        STX  CHARAD         ; * NEW CURRENT INPUT POINTER
4665 eeb6 35 10              L8B55     PULS X              ; RESTORE POINTER TO START OF NUMERIC VALUE
4666 eeb8 86 01                        LDA  #$01           ; NEW LINE NUMBER FLAG
4667 eeba a7 84                        STA  ,X             ; * SAVE NEW LINE FLAG
4668 eebc a7 02                        STA  $02,X          ; *
4669 eebe a7 04                        STA  $04,X          ; *
4670 eec0 d6 2b                        LDB  BINVAL         ; GET MS BYTE OF BINARY LINE NUMBER
4671 eec2 26 04                        BNE  L8B67          ; BRANCH IF IT IS NOT ZERO
4672 eec4 c6 01                        LDB  #$01           ; ; SAVE A 1 IF BYTE IS 0; OTHERWISE, BASIC WILL
4673                         *              ; THINK IT IS THE END OF A LINE
4674 eec6 6c 02                        INC  $02,X          ; IF 2,X = 2, THEN PREVIOUS BYTE WAS A ZERO
4675 eec8 e7 01              L8B67     STB  $01,X          ; SAVE MS BYTE OF BINARY LINE NUMBER
4676 eeca d6 2c                        LDB  BINVAL+1       ; GET IS BYTE OF BINARY LINE NUMBER
4677 eecc 26 04                        BNE  L8B71          ; BRANCH IF NOT A ZERO BYTE
4678 eece c6 01                        LDB  #$01           ; SAVE A 1 IF BYTE IS A 0
4679 eed0 6c 04                        INC  $04,X          ; IF 4,X = 2, THEN PREVIOUS BYTE WAS A 0
4680 eed2 e7 03              L8B71     STB  $03,X          ; SAVE LS BYTE OF BINARY LINE NUMBER
4681 eed4 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4682 eed6 81 2c                        CMPA #',            ; IS IT A COMMA?
4683 eed8 27 9a                        BEQ  L8B13          ; YES - PROCESS ANOTHER NUMERIC VALUE
4684 eeda 20 9c                        BRA  L8B17          ; NO - GO GET AND PROCESS AN INPUT CHARACTER
4685 eedc 9e 19              L8B7B     LDX  TXTTAB         ; POINT X TO START OF BASIC PROGRAM
4686 eede 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
4687 eee0 30 01              L8B7F     LEAX $01,X          ; MOVE POINTER UP ONE
4688 eee2 ec 02                        LDD  $02,X          ; GET ADDRESS OF NEXT LINE
4689 eee4 dd 68                        STD  CURLIN         ; SAVE IT IN CURLIN
4690 eee6 bd ed ea                     JSR  L8A86          ; RETURN IF END OF PROGRAM
4691 eee9 30 03                        LEAX $03,X          ; SKIP OVER ADDRESS OF NEXT LINE AND 1ST BYTE OF LINE NUMBER
4692 eeeb 30 01              L8B8A     LEAX $01,X          ; MOVE POINTER UP ONE
4693 eeed a6 84              L8B8C     LDA  ,X             ; GET CURRENT CHARACTER
4694 eeef 27 ef                        BEQ  L8B7F          ; BRANCH IF END OF LINE
4695 eef1 4a                           DECA                ; INPUT CHARACTER = 1? - VALID LINE NUMBER
4696 eef2 27 1b                        BEQ  L8BAE          ; YES
4697 eef4 80 02                        SUBA #$02           ; INPUT CHARACTER 3? - UL LINE NUMBER
4698 eef6 26 f3                        BNE  L8B8A          ; NO
4699 eef8 34 10                        PSHS X              ; SAVE CURRENT POSITION OF INPUT POINTER
4700 eefa 8e ef 39                     LDX  #L8BD9-1       ; POINT X TO 'UL' MESSAGE
4701 eefd bd e0 e8                     JSR  LB99C          ; PRINT STRING TO THE SCREEN
4702 ef00 ae e4                        LDX  ,S             ; GET INPUT POINTER
4703 ef02 ec 01                        LDD  $01,X          ; GET THE UNDEFINED LINE NUMBER
4704 ef04 bd e5 18                     JSR  LBDCC          ; CONVERT NUMBER IN ACCD TO DECIMAL AND DISPLAY IT
4705 ef07 bd e5 11                     JSR  LBDC5          ; PRINT 'IN XXXX' XXXX = CURRENT LINE NUMBER
4706 ef0a bd e0 a8                     JSR  LB958          ; SEND A CR TO CONSOLE OUT
4707 ef0d 35 10                        PULS X              ; GET INPUT POINTER BACK
4708 ef0f 34 10              L8BAE     PSHS X              ; SAVE CURRENT POSITION OF INPUT POINTER
4709 ef11 ec 01                        LDD  $01,X          ; LOAD ACCD WITH BINARY VALUE OF LINE NUMBER
4710 ef13 dd 52                        STD  FPA0+2         ; SAVE IN BOTTOM 2 BYTES OF FPA0
4711 ef15 bd eb c4                     JSR  L880E          ; ADJUST REST OF FPA0 AS AN INTEGER
4712 ef18 bd e5 25                     JSR  LBDD9          ; CONVERT FPA0 TO ASCII, STORE IN LINE NUMBER
4713 ef1b 35 40                        PULS U              ; LOAD U WITH PREVIOUS ADDRESS OF INPUT POINTER
4714 ef1d c6 05                        LDB  #$05           ; EACH EXPANDED LINE NUMBER USES 5 BYTES
4715 ef1f 30 01              L8BBE     LEAX $01,X          ; MOVE POINTER FORWARD ONE
4716 ef21 a6 84                        LDA  ,X             ; GET AN ASCII BYTE
4717 ef23 27 05                        BEQ  L8BC9          ; BRANCH IF END OF NUMBER
4718 ef25 5a                           DECB                ; DECREMENT BYTE COUNTER
4719 ef26 a7 c0                        STA  ,U+            ; STORE ASCII NUMBER IN BASIC LINE
4720 ef28 20 f5                        BRA  L8BBE          ; CHECK FOR ANOTHER DIGIT
4721 ef2a 30 c4              L8BC9     LEAX ,U             ; TRANSFER NEW LINE POINTER TO (X)
4722 ef2c 5d                           TSTB                ; DOES THE NEW LINE NUMBER REQUIRE 5 BYTES?
4723 ef2d 27 be                        BEQ  L8B8C          ; YES - GO GET ANOTHER INPUT CHARACTER
4724 ef2f 31 c4                        LEAY ,U             ; SAVE NEW LINE POINTER IN Y
4725 ef31 33 c5                        LEAU B,U            ; POINT U TO END OF 5 BYTE PACKED LINE NUMBER BLOCK
4726 ef33 bd ed 2b                     JSR  L89B8          ; MOVE BYTES FROM (U) TO (X) UNTIL END OF PROGRAM
4727 ef36 30 a4                        LEAX ,Y             ; LOAD (X) WITH NEW LINE POINTER
4728 ef38 20 b3                        BRA  L8B8C          ; GO GET ANOTHER INPUT CHARACTER
4729                         
4730 ef3a 55 4c 20           L8BD9     FCC  "UL "          ; UNKNOWN LINE NUMBER MESSAGE
4731 ef3d 00                           FCB  0
4732                         
4733                         
4734 ef3e bd de c7           HEXDOL    JSR  LB740          ; CONVERT FPA0 INTO A POSITIVE 2 BYTE INTEGER
4735 ef41 8e 01 f0                     LDX  #STRBUF+2      ; POINT TO TEMPORARY BUFFER
4736 ef44 c6 04                        LDB  #$04           ; CONVERT 4 NIBBLES
4737 ef46 34 04              L8BE5     PSHS B              ; SAVE NIBBLE COUNTER
4738 ef48 5f                           CLRB                ; CLEAR CARRY FLAG
4739 ef49 86 04                        LDA  #$04           ; 4 SHIFTS
4740 ef4b 08 53              L8BEA     ASL  FPA0+3         ; * SHIFT BOTTOM TWO BYTES OF
4741 ef4d 09 52                        ROL  FPA0+2         ; * FPA0 LEFT ONE BIT (X2)
4742 ef4f 59                           ROLB                ; IF OVERFLOW, ACCB <> 0
4743 ef50 4a                           DECA                ; * DECREMENT SHIFT COUNTER AND
4744 ef51 26 f8                        BNE  L8BEA          ; * BRANCH IF NOT DONE
4745 ef53 5d                           TSTB                ; CHECK FOR OVERFLOW
4746 ef54 26 0a                        BNE  L8BFF          ; BRANCH IF OVERFLOW
4747 ef56 a6 e4                        LDA  ,S             ; * GET NIBBLE COUNTER,
4748 ef58 4a                           DECA                ; * DECREMENT IT AND
4749 ef59 27 05                        BEQ  L8BFF          ; * BRANCH IF DONE
4750 ef5b 8c 01 f0                     CMPX #STRBUF+2      ; DO NOT DO A CONVERSION UNTIL A NON-ZERO
4751 ef5e 27 0c                        BEQ  L8C0B          ; BYTE IS FOUND - LEADING ZERO SUPPRESSION
4752 ef60 cb 30              L8BFF     ADDB #'0            ; ADD IN ASCII ZERO
4753 ef62 c1 39                        CMPB #'9            ; COMPARE TO ASCII 9
4754 ef64 23 02                        BLS  L8C07          ; BRANCH IF < 9
4755 ef66 cb 07                        ADDB #7             ; ADD ASCII OFFSET IF HEX LETTER
4756 ef68 e7 80              L8C07     STB  ,X+            ; STORE HEX VALUE AND ADVANCE POINTER
4757 ef6a 6f 84                        CLR  ,X             ; CLEAR NEXT BYTE - END OF STRING FLAG
4758 ef6c 35 04              L8C0B     PULS B              ; * GET NIBBLE COUNTER,
4759 ef6e 5a                           DECB                ; * DECREMENT IT AND
4760 ef6f 26 d5                        BNE  L8BE5          ; * BRANCH IF NOT DONE
4761 ef71 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF STACK
4762 ef73 8e 01 ef                     LDX  #STRBUF+1      ; RESET POINTER
4763 ef76 7e dc 9f                     JMP  LB518          ; SAVE STRING ON STRING STACK
4764                         * PROCESS EXCLAMATION POINT
4765 ef79 86 01              L8E37     LDA  #$01           ; * SET SPACES
4766 ef7b 97 99                        STA  VD9            ; * COUNTER = 1
4767                         * PROCESS STRING ITEM - LIST
4768 ef7d 5a                 L8E3B     DECB                ; DECREMENT FORMAT STRING LENGTH COUNTER
4769 ef7e bd f1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <>0
4770 ef81 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4771 ef83 10 27 00 93                  LBEQ L8ED8          ; EXIT PRINT USING IF END OF LINE
4772 ef87 d7 93                        STB  VD3            ; SAVE REMAINDER FORMAT STRING LENGTH
4773 ef89 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
4774 ef8c bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
4775 ef8f 9e 52                        LDX  FPA0+2         ; * GET ITEM - LIST DESCRIPTOR ADDRESS
4776 ef91 9f 4d                        STX  V4D            ; * AND SAVE IT IN V4D
4777 ef93 d6 99                        LDB  VD9            ; GET SPACES COUNTER
4778 ef95 bd de 34                     JSR  LB6AD          ; PUT ACCB BYTES INTO STRING SPACE & PUT DESCRIPTOR ON STRING STACK
4779 ef98 bd e0 eb                     JSR  LB99F          ; PRINT THE FORMATTED STRING TO CONSOLE OUT
4780                         * PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING < FORMAT STRING LENGTH
4781 ef9b 9e 52                        LDX  FPA0+2         ; POINT X TO FORMATTED STRING DESCRIPTOR ADDRESS
4782 ef9d d6 99                        LDB  VD9            ; GET SPACES COUNTER
4783 ef9f e0 84                        SUBB ,X             ; SUBTRACT LENGTH OF FORMATTED STRING
4784 efa1 5a                 L8E5F     DECB                ; DECREMENT DIFFERENCE
4785 efa2 10 2b 01 4f                  LBMI L8FB3          ; GO INTERPRET ANOTHER ITEM - LIST
4786 efa6 bd e0 f8                     JSR  LB9AC          ; PAD FORMAT STRING WITH A SPACE
4787 efa9 20 f6                        BRA  L8E5F          ; KEEP PADDING
4788                         * PERCENT SIGN - PROCESS A %SPACES% COMMAND
4789 efab d7 93              L8E69     STB  VD3            ; * SAVE THE CURRENT FORMAT STRING
4790 efad 9f 0f                        STX  TEMPTR         ; * COUNTER AND POINTER
4791 efaf 86 02                        LDA  #$02           ; INITIAL SPACES COUNTER = 2
4792 efb1 97 99                        STA  VD9            ; SAVE IN SPACES COUNTER
4793 efb3 a6 84              L8E71     LDA  ,X             ; GET A CHARACTER FROM FORMAT STRING
4794 efb5 81 25                        CMPA #'%            ; COMPARE TO TERMINATOR CHARACTER
4795 efb7 27 c4                        BEQ  L8E3B          ; BRANCH IF END OF SPACES COMMAND
4796 efb9 81 20                        CMPA #'             ; BLANK
4797 efbb 26 07                        BNE  L8E82          ; BRANCH IF ILLEGAL CHARACTER
4798 efbd 0c 99                        INC  VD9            ; ADD ONE TO SPACES COUNTER
4799 efbf 30 01                        LEAX $01,X          ; MOVE FORMAT POINTER UP ONE
4800 efc1 5a                           DECB                ; DECREMENT LENGTH COUNTER
4801 efc2 26 ef                        BNE  L8E71          ; BRANCH IF NOT END OF FORMAT STRING
4802 efc4 9e 0f              L8E82     LDX  TEMPTR         ; * RESTORE CURRENT FORMAT STRING COUNTER
4803 efc6 d6 93                        LDB  VD3            ; * AND POINTER TO POSITION BEFORE SPACES COMMAND
4804 efc8 86 25                        LDA  #'%            ; SEND A '%' TO CONSOLE OUT AS A DEBUGGING AID
4805                         * ERROR PROCESSOR - ILLEGAL CHARACTER OR BAD SYNTAX IN FORMAT STRING
4806 efca bd f1 1a           L8E88     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
4807 efcd bd d0 17                     JSR  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
4808 efd0 20 29                        BRA  L8EB9          ; GET NEXT CHARACTER IN FORMAT STRING
4809                         
4810                         * PRINT RAM HOOK
4811 efd2 81 b1              XVEC9     CMPA #TOK_USING     ; USING TOKEN
4812 efd4 27 01                        BEQ  L8E95          ; BRANCH IF PRINT USING
4813 efd6 39                           RTS
4814                         
4815                         * PRINT USING
4816                         * VDA IS USED AS A STATUS BYTE: BIT 6 = COMMA FORCE
4817                         * BIT 5=LEADING ASTERISK FORCE; BIT 4 = FLOATING $ FORCE
4818                         * BIT 3 = PRE SIGN FORCE; BIT 2 = POST SIGN FORCE; BIT 0 = EXPONENTIAL FORCE
4819 efd7 32 62              L8E95     LEAS $02,S          ; PURGE RETURN ADDRESS OFF THE STACK
4820 efd9 bd d8 e4                     JSR  LB158          ; EVALUATE FORMAT STRING
4821 efdc bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
4822 efdf c6 3b                        LDB  #';            ; CHECK FOR ITEM LIST SEPARATOR
4823 efe1 bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR ;
4824 efe4 9e 52                        LDX  FPA0+2         ; * GET FORMAT STRING DESCRIPTOR ADDRESS
4825 efe6 9f 95                        STX  VD5            ; * AND SAVE IT IN VD5
4826 efe8 20 06                        BRA  L8EAE          ; GO PROCESS FORMAT STRING
4827 efea 96 97              L8EA8     LDA  VD7            ; *CHECK NEXT PRINT ITEM FLAG AND
4828 efec 27 08                        BEQ  L8EB4          ; *'FC' ERROR IF NO FURTHER PRINT ITEMS
4829 efee 9e 95                        LDX  VD5            ; RESET FORMAT STRING POINTER TO START OF STRING
4830 eff0 0f 97              L8EAE     CLR  VD7            ; RESET NEXT PRINT ITEM FLAG
4831 eff2 e6 84                        LDB  ,X             ; GET LENGTH OF FORMAT STRING
4832 eff4 26 03                        BNE  L8EB7          ; INTERPRET FORMAT STRING IF LENGTH > 0
4833 eff6 7e db d1           L8EB4     JMP  LB44A          ; 'FC' ERROR IF FORMAT STRING = NULL
4834 eff9 ae 02              L8EB7     LDX  $02,X          ; POINT X TO START OF FORMAT STRING
4835                         * INTERPRET THE FORMAT STRING
4836 effb 0f 9a              L8EB9     CLR  VDA            ; CLEAR THE STATUS BYTE
4837 effd 0f 99              L8EBB     CLR  VD9            ; CLEAR LEFT DIGIT COUNTER
4838 efff a6 80                        LDA  ,X+            ; GET A CHARACTER FROM FORMAT STRING
4839 f001 81 21                        CMPA #'!            ; EXCLAMATION POINT?
4840 f003 10 27 ff 72                  LBEQ L8E37          ; YES - STRING TYPE FORMAT
4841 f007 81 23                        CMPA #'#            ; NUMBER SIGN? (DIGIT LOCATOR)
4842 f009 27 5b                        BEQ  L8F24          ; YES - NUMERIC TYPE FORMAT
4843 f00b 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH
4844 f00c 26 16                        BNE  L8EE2          ; BRANCH IF NOT DONE
4845 f00e bd f1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
4846 f011 bd d0 17                     JSR  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
4847 f014 9d 82              L8ED2     JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
4848 f016 26 d2                        BNE  L8EA8          ; BRANCH IF NOT END OF LINE
4849 f018 96 97                        LDA  VD7            ; GET NEXT PRINT ITEM FLAG
4850 f01a 26 03              L8ED8     BNE  L8EDD          ; BRANCH IF MORE PRINT ITEMS
4851 f01c bd e0 a8                     JSR  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
4852 f01f 9e 95              L8EDD     LDX  VD5            ; POINT X TO FORMAT STRING DESCRIPTOR
4853 f021 7e dd e0                     JMP  LB659          ; RETURN ADDRESS AND LENGTH OF FORMAT STRING - EXIT PRINT USING
4854 f024 81 2b              L8EE2     CMPA #'+            ; CHECK FOR '+' (PRE-SIGN FORCE)
4855 f026 26 09                        BNE  L8EEF          ; NO PLUS
4856 f028 bd f1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
4857 f02b 86 08                        LDA  #$08           ; * LOAD THE STATUS BYTE WITH 8;
4858 f02d 97 9a                        STA  VDA            ; * PRE-SIGN FORCE FLAG
4859 f02f 20 cc                        BRA  L8EBB          ; INTERPRET THE REST OF THE FORMAT STRING
4860 f031 81 2e              L8EEF     CMPA #'.            ; DECIMAL POINT?
4861 f033 27 4e                        BEQ  L8F41          ; YES
4862 f035 81 25                        CMPA #'%            ; PERCENT SIGN?
4863 f037 10 27 ff 70                  LBEQ L8E69          ; YES
4864 f03b a1 84                        CMPA ,X             ; COMPARE THE PRESENT FORMAT STRING INPUT
4865                         *              ; CHARACTER TO THE NEXT ONE IN THE STRING
4866 f03d 26 8b              L8EFB     BNE  L8E88          ; NO MATCH - ILLEGAL CHARACTER
4867                         * TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING
4868 f03f 81 24                        CMPA #'$            ; DOLLAR SIGN?
4869 f041 27 19                        BEQ  L8F1A          ; YES - MAKE THE DOLLAR SIGN FLOAT
4870 f043 81 2a                        CMPA #'*            ; ASTERISK?
4871 f045 26 f6                        BNE  L8EFB          ; NO - ILLEGAL CHARACTER
4872 f047 96 9a                        LDA  VDA            ; * GRAB THE STATUS BYTE AND BET BIT 5
4873 f049 8a 20                        ORA  #$20           ; * TO INDICATE THAT THE OUTPUT WILL
4874 f04b 97 9a                        STA  VDA            ; * BE LEFT PADDED WITH ASTERISKS
4875 f04d c1 02                        CMPB #2             ; * CHECK TO SEE IF THE $$ ARE THE LAST TWO
4876 f04f 25 11                        BLO  L8F20          ; * CHARACTERS IN THE FORMAT STRING AND BRANCH IF SO
4877 f051 a6 01                        LDA  $01,X          ; GET THE NEXT CHARACTER AFTER **
4878 f053 81 24                        CMPA #'$            ; CHECK FOR **$
4879 f055 26 0b                        BNE  L8F20          ; CHECK FOR MORE CHARACTERS
4880 f057 5a                           DECB                ; DECREMENT STRING LENGTH COUNTER
4881 f058 30 01                        LEAX $01,X          ; MOVE FORMAT STRING POINTER UP ONE
4882 f05a 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER - FOR ASTERISK PAD AND
4883                         *              ; FLOATING DOLLAR SIGN COMBINATION
4884 f05c 96 9a              L8F1A     LDA  VDA            ; * GET THE STATUS BYTE AND SET
4885 f05e 8a 10                        ORA  #$10           ; * BIT 4 TO INDICATE A
4886 f060 97 9a                        STA  VDA            ; * FLOATING DOLLAR SIGN
4887 f062 30 01              L8F20     LEAX $01,X          ; MOVE FORMAT STRING POINTER UP ONE
4888 f064 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT (FLOATING $ OR ASTERISK PAD)
4889                         * PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT IN THE FORMAT STRING
4890 f066 0f 98              L8F24     CLR  VD8            ; CLEAR THE RIGHT DIGIT COUNTER
4891 f068 0c 99              L8F26     INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER
4892 f06a 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH COUNTER
4893 f06b 27 49                        BEQ  L8F74          ; BRANCH IF END OF FORMAT STRING
4894 f06d a6 80                        LDA  ,X+            ; GET THE NEXT FORMAT CHARACTER
4895 f06f 81 2e                        CMPA #'.            ; DECIMAL POINT?
4896 f071 27 1e                        BEQ  L8F4F          ; YES
4897 f073 81 23                        CMPA #'#            ; NUMBER SIGN?
4898 f075 27 f1                        BEQ  L8F26          ; YES
4899 f077 81 2c                        CMPA #',            ; COMMA?
4900 f079 26 21                        BNE  L8F5A          ; NO
4901 f07b 96 9a                        LDA  VDA            ; * GET THE STATUS BYTE
4902 f07d 8a 40                        ORA  #$40           ; * AND SET BIT 6 WHICH IS THE
4903 f07f 97 9a                        STA  VDA            ; * COMMA SEPARATOR FLAG
4904 f081 20 e5                        BRA  L8F26          ; PROCESS MORE CHARACTERS TO LEFT OF DECIMAL POINT
4905                         * PROCESS DECIMAL POINT IF NO DIGITS TO LEFT OF IT
4906 f083 a6 84              L8F41     LDA  ,X             ; GET NEXT FORMAT CHARACTER
4907 f085 81 23                        CMPA #'#            ; IS IT A NUMBER SIGN?
4908 f087 10 26 ff 3f                  LBNE L8E88          ; NO
4909 f08b 86 01                        LDA  #1             ; * SET THE RIGHT DIGIT COUNTER TO 1 -
4910 f08d 97 98                        STA  VD8            ; * ALLOW ONE SPOT FOR DECIMAL POINT
4911 f08f 30 01                        LEAX $01,X          ; MOVE FORMAT POINTER UP ONE
4912                         * PROCESS DIGITS TO RIGHT OF DECIMAL POINT
4913 f091 0c 98              L8F4F     INC  VD8            ; ADD ONE TO RIGHT DIGIT COUNTER
4914 f093 5a                           DECB                ; DECREMENT FORMAT LENGTH COUNTER
4915 f094 27 20                        BEQ  L8F74          ; BRANCH IF END OF FORMAT STRING
4916 f096 a6 80                        LDA  ,X+            ; GET A CHARACTER FROM FORMAT STRING
4917 f098 81 23                        CMPA #'#            ; IS IT NUMBER SIGN?
4918 f09a 27 f5                        BEQ  L8F4F          ; YES - KEEP CHECKING
4919                         * CHECK FOR EXPONENTIAL FORCE
4920 f09c 81 5e              L8F5A     CMPA #$5E           ; CHECK FOR UP ARROW
4921 f09e 26 16                        BNE  L8F74          ; NO UP ARROW
4922 f0a0 a1 84                        CMPA ,X             ; IS THE NEXT CHARACTER AN UP ARROW?
4923 f0a2 26 12                        BNE  L8F74          ; NO
4924 f0a4 a1 01                        CMPA $01,X          ; AND THE NEXT CHARACTER?
4925 f0a6 26 0e                        BNE  L8F74          ; NO
4926 f0a8 a1 02                        CMPA $02,X          ; HOW ABOUT THE 4TH CHARACTER?
4927 f0aa 26 0a                        BNE  L8F74          ; NO, ALSO
4928 f0ac c1 04                        CMPB #4             ; * CHECK TO SEE IF THE 4 UP ARROWS ARE IN THE
4929 f0ae 25 06                        BLO  L8F74          ; * FORMAT STRING AND BRANCH IF NOT
4930 f0b0 c0 04                        SUBB #4             ; * MOVE POINTER UP 4 AND SUBTRACT
4931 f0b2 30 04                        LEAX $04,X          ; * FOUR FROM LENGTH
4932 f0b4 0c 9a                        INC  VDA            ; INCREMENT STATUS BYTE - EXPONENTIAL FORM
4933                         
4934                         * CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMAT STRING
4935 f0b6 30 1f              L8F74     LEAX -1,X           ; MOVE POINTER BACK ONE
4936 f0b8 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER FOR PRE-SIGN FORCE
4937 f0ba 96 9a                        LDA  VDA            ; * PRE-SIGN
4938 f0bc 85 08                        BITA #$08           ; * FORCE AND
4939 f0be 26 18                        BNE  L8F96          ; * BRANCH IF SET
4940 f0c0 0a 99                        DEC  VD9            ; DECREMENT LEFT DIGIT - NO PRE-SIGN FORCE
4941 f0c2 5d                           TSTB                ; * CHECK LENGTH COUNTER AND BRANCH
4942 f0c3 27 13                        BEQ  L8F96          ; * IF END OF FORMAT STRING
4943 f0c5 a6 84                        LDA  ,X             ; GET NEXT FORMAT STRING CHARACTER
4944 f0c7 80 2d                        SUBA #'-            ; CHECK FOR MINUS SIGN
4945 f0c9 27 06                        BEQ  L8F8F          ; BRANCH IF MINUS SIGN
4946 f0cb 81 fe                        CMPA #$FE           ; * WAS CMPA #('+')-('-')
4947 f0cd 26 09                        BNE  L8F96          ; BRANCH IF NO PLUS SIGN
4948 f0cf 86 08                        LDA  #$08           ; GET THE PRE-SIGN FORCE FLAG
4949 f0d1 8a 04              L8F8F     ORA  #$04           ; 'OR' IN POST-SIGN FORCE FLAG
4950 f0d3 9a 9a                        ORA  VDA            ; 'OR' IN THE STATUS BYTE
4951 f0d5 97 9a                        STA  VDA            ; SAVE THE STATUS BYTE
4952 f0d7 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH
4953                         
4954                         * EVALUATE NUMERIC ITEM-LIST
4955 f0d8 9d 82              L8F96     JSR  GETCCH         ; GET CURRENT CHARACTER
4956 f0da 10 27 ff 3c                  LBEQ L8ED8          ; BRANCH IF END OF LINE
4957 f0de d7 93                        STB  VD3            ; SAVE FORMAT STRING LENGTH WHEN FORMAT EVALUATION ENDED
4958 f0e0 bd d8 cd                     JSR  LB141          ; EVALUATE EXPRESSION
4959 f0e3 96 99                        LDA  VD9            ; GET THE LEFT DIGIT COUNTER
4960 f0e5 9b 98                        ADDA VD8            ; ADD IT TO THE RIGHT DIGIT COUNTER
4961 f0e7 81 11                        CMPA #17            ; *
4962 f0e9 10 22 ea e4                  LBHI LB44A          ; *'FC' ERROR IF MORE THAN 16 DIGITS AND DECIMAL POiNT
4963 f0ed bd f1 27                     JSR  L8FE5          ; CONVERT ITEM-LIST TO FORMATTED ASCII STRING
4964 f0f0 30 1f                        LEAX -1,X           ; MOVE BUFFER POINTER BACK ONE
4965 f0f2 bd e0 e8                     JSR  LB99C          ; DISPLAY THE FORMATTED STRING TO CONSOLE OUT
4966 f0f5 0f 97              L8FB3     CLR  VD7            ; RESET NEXT PRINT ITEM FLAG
4967 f0f7 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4968 f0f9 27 0d                        BEQ  L8FC6          ; BRANCH IF END OF LINE
4969 f0fb 97 97                        STA  VD7            ; SAVE CURRENT CHARACTER (<>0) IN NEXT PRINT ITEM FLAG
4970 f0fd 81 3b                        CMPA #';            ; * CHECK FOR ; - ITEM-LIST SEPARATOR AND
4971 f0ff 27 05                        BEQ  L8FC4          ; * BRANCH IF SEMICOLON
4972 f101 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4973 f104 20 02                        BRA  L8FC6          ; PROCESS NEXT PRINT ITEM
4974 f106 9d 7c              L8FC4     JSR  GETNCH         ; GET NEXT INPUT CHARACTER
4975 f108 9e 95              L8FC6     LDX  VD5            ; GET FORMAT STRING DESCRIPTOR ADDRESS
4976 f10a e6 84                        LDB  ,X             ; GET LENGTH OF FORMAT STRING
4977 f10c d0 93                        SUBB VD3            ; SUBTRACT AMOUNT OF FORMAT STRING LEFT AFTER LAST PRINT ITEM
4978 f10e ae 02                        LDX  $02,X          ; *GET FORMAT STRING START ADDRESS AND ADVANCE
4979 f110 3a                           ABX                 ; *POINTER TO START OF UNUSED FORMAT STRING
4980 f111 d6 93                        LDB  VD3            ; * GET AMOUNT OF UNUSED FORMAT STRING
4981 f113 10 26 fe e4                  LBNE L8EB9          ; * REINTERPRET FORMAT STRING FROM THAT POINT
4982 f117 7e f0 14                     JMP  L8ED2          ; REINTERPRET FORMAT STRING FROM THE START IF ENTIRELY
4983                         *         USED ON LAST PRINT ITEM
4984                         
4985                         * PRINT A '+' TO CONSOLE OUT IF THE STATUS BYTE <> 0
4986 f11a 34 02              L8FD8     PSHS A              ; RESTORE ACCA AND RETURN
4987 f11c 86 2b                        LDA  #'+            ; GET ASCII PLUS SIGN
4988 f11e 0d 9a                        TST  VDA            ; * CHECK THE STATUS BYTE AND
4989 f120 27 03                        BEQ  L8FE3          ; * RETURN IF = 0
4990 f122 bd d0 17                     JSR  PUTCHR         ; SEND A CHARACTER TO CONSOLE OUT
4991 f125 35 82              L8FE3     PULS A,PC           ; RETURN ACCA AND RETURN
4992                         
4993                         * CONVERT ITEM-LIST TO DECIMAL ASCII STRING
4994 f127 ce 01 f2           L8FE5     LDU  #STRBUF+4      ; POINT U TO STRING BUFFER
4995 f12a c6 20                        LDB  #SPACE         ; BLANK
4996 f12c 96 9a                        LDA  VDA            ; * GET THE STATUS FLAG AND
4997 f12e 85 08                        BITA #$08           ; * CHECK FOR A PRE-SIGN FORCE
4998 f130 27 02                        BEQ  L8FF2          ; * BRANCH IF NO PRE-SIGN FORCE
4999 f132 c6 2b                        LDB  #'+            ; PLUS SIGN
5000 f134 0d 54              L8FF2     TST  FP0SGN         ; CHECK THE SIGN OF FPA0
5001 f136 2a 04                        BPL  L8FFA          ; BRANCH IF POSITIVE
5002 f138 0f 54                        CLR  FP0SGN         ; FORCE FPA0 SIGN TO BE POSITIVE
5003 f13a c6 2d                        LDB  #'-            ; MINUS SIGN
5004 f13c e7 c0              L8FFA     STB  ,U+            ; SAVE THE SIGN IN BUFFER
5005 f13e c6 30                        LDB  #'0            ; * PUT A ZERO INTO THE BUFFER
5006 f140 e7 c0                        STB  ,U+            ; *
5007 f142 84 01                        ANDA #$01           ; * CHECK THE EXPONENTIAL FORCE FLAG IN
5008 f144 10 26 01 07                  LBNE L910D          ; * THE STATUS BYTE - BRANCH IF ACTIVE
5009 f148 8e e5 0c                     LDX  #LBDC0         ; POINT X TO FLOATING POINT 1E + 09
5010 f14b bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO (X)
5011 f14e 2b 15                        BMI  L9023          ; BRANCH IF FPA0 < 1E+09
5012 f150 bd e5 25                     JSR  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
5013 f153 a6 80              L9011     LDA  ,X+            ; * ADVANCE POINTER TO END OF
5014 f155 26 fc                        BNE  L9011          ; * ASCII STRING (ZERO BYTE)
5015 f157 a6 82              L9015     LDA  ,-X            ; MOVE THE
5016 f159 a7 01                        STA  $01,X          ; ENTIRE STRING
5017 f15b 8c 01 f1                     CMPX #STRBUF+3      ; UP ONE
5018 f15e 26 f7                        BNE  L9015          ; BYTE
5019 f160 86 25                        LDA  #'%            ; * INSERT A % SIGN AT START OF
5020 f162 a7 84                        STA  ,X             ; * STRING - OVERFLOW ERROR
5021 f164 39                           RTS
5022                         
5023 f165 96 4f              L9023     LDA  FP0EXP         ; GET EXPONENT OF FPA0
5024 f167 97 47                        STA  V47            ; AND SAVE IT IN V74
5025 f169 27 03                        BEQ  L902C          ; BRANCH IF FPA0 = 0
5026 f16b bd f3 0f                     JSR  L91CD          ; CONVERT FPA0 TO NUMBER WITH 9 SIGNIFICANT
5027                         *              ; PLACES TO LEFT OF DECIMAL POINT
5028 f16e 96 47              L902C     LDA  V47            ; GET BASE 10 EXPONENT OFFSET
5029 f170 10 2b 00 81                  LBMI L90B3          ; BRANCH IF FPA0 < 100,000,000
5030 f174 40                           NEGA                ; * CALCULATE THE NUMBER OF LEADING ZEROES TO INSERT -
5031 f175 9b 99                        ADDA VD9            ; * SUBTRACT BASE 10 EXPONENT OFFSET AND 9 (FPA0 HAS
5032 f177 80 09                        SUBA #$09           ; * 9 PLACES TO LEFT OF EXPONENT) FROM LEFT DIGIT COUNTER
5033 f179 bd f2 2c                     JSR  L90EA          ; PUT ACCA ZEROES IN STRING BUFFER
5034 f17c bd f3 a5                     JSR  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
5035 f17f bd f3 44                     JSR  L9202          ; CONVERT FPA0 TO DECIMAL ASCII IN THE STRING BUFFER
5036 f182 96 47                        LDA  V47            ; * GET BASE 10 EXPONENT AND PUT THAT MANY
5037 f184 bd f3 c3                     JSR  L9281          ; * ZEROES IN STRING BUFFER - STOP AT DECIMAL POINT
5038 f187 96 47                        LDA  V47            ; WASTED INSTRUCTION - SERVES NO PURPOSE
5039 f189 bd f3 8b                     JSR  L9249          ; CHECK FOR DECIMAL POINT
5040 f18c 96 98                        LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
5041 f18e 26 02                        BNE  L9050          ; BRANCH IF RIGHT DIGlT COUNTER <> 0
5042 f190 33 5f                        LEAU -1,U           ; * MOVE BUFFER POINTER BACK ONE - DELETE
5043                         *                             ; * DECIMAL POINT IF NO RIGHT DIGITS SPECiFIED
5044 f192 4a                 L9050     DECA                ; SUBTRACT ONE (DECIMAL POINT)
5045 f193 bd f2 2c                     JSR  L90EA          ; PUT ACCA ZEROES INTO BUFFER (TRAILING ZEROES)
5046 f196 bd f2 c7           L9054     JSR  L9185          ; INSERT ASTERISK PADDING, FLOATING $, AND POST-SIGN
5047 f199 4d                           TSTA                ; WAS THERE A POST-SIGN?
5048 f19a 27 06                        BEQ  L9060          ; NO
5049 f19c c1 2a                        CMPB #'*            ; IS THE FIRST CHARACTER AN $?
5050 f19e 27 02                        BEQ  L9060          ; YES
5051 f1a0 e7 c0                        STB  ,U+            ; STORE THE POST-SIGN
5052 f1a2 6f c4              L9060     CLR  ,U             ; CLEAR THE LAST CHARACTER IN THE BUFFER
5053                         *
5054                         * REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE
5055                         * STRING BUFFER TO THE LEFT OF THE DECIMAL POINT
5056 f1a4 8e 01 f1                     LDX  #STRBUF+3      ; POINT X TO THE START OF THE BUFFER
5057 f1a7 30 01              L9065     LEAX $01,X          ; MOVE BUFFER POINTER UP ONE
5058 f1a9 9f 0f                        STX  TEMPTR         ; SAVE BUFFER POINTER IN TEMPTR
5059 f1ab 96 3a                        LDA  VARPTR+1       ; * GET ADDRESS OF DECIMAL POINT IN BUFFER, SUBTRACT
5060 f1ad 90 10                        SUBA TEMPTR+1       ; * CURRENT POSITION AND SUBTRACT LEFT DIGIT COUNTER -
5061 f1af 90 99                        SUBA VD9            ; * THE RESULT WILL BE ZERO WHEN TEMPTR+1 IS POINTING
5062                         *              ; * TO THE FIRST DIGIT OF THE FORMAT STRING
5063 f1b1 27 38                        BEQ  L90A9          ; RETURN IF NO DIGITS TO LEFT OF THE DECiMAL POINT
5064 f1b3 a6 84                        LDA  ,X             ; GET THE CURRENT BUFFER CHARACTER
5065 f1b5 81 20                        CMPA #SPACE         ; SPACE?
5066 f1b7 27 ee                        BEQ  L9065          ; YES - ADVANCE POINTER
5067 f1b9 81 2a                        CMPA #'*            ; ASTERISK?
5068 f1bb 27 ea                        BEQ  L9065          ; YES - ADVANCE POINTER
5069 f1bd 4f                           CLRA                ; A ZERO ON THE STACK IS END OF DATA POINTER
5070 f1be 34 02              L907C     PSHS A              ; PUSH A CHARACTER ONTO THE STACK
5071 f1c0 a6 80                        LDA  ,X+            ; GET NEXT CHARACTER FROM BUFFER
5072 f1c2 81 2d                        CMPA #'-            ; MINUS SIGN?
5073 f1c4 27 f8                        BEQ  L907C          ; YES
5074 f1c6 81 2b                        CMPA #'+            ; PLUS SIGN?
5075 f1c8 27 f4                        BEQ  L907C          ; YES
5076 f1ca 81 24                        CMPA #'$            ; DOLLAR SIGN?
5077 f1cc 27 f0                        BEQ  L907C          ; YES
5078 f1ce 81 30                        CMPA #'0            ; ZERO?
5079 f1d0 26 0e                        BNE  L909E          ; NO - ERROR
5080 f1d2 a6 01                        LDA  $01,X          ; GET CHARACTER FOLLOWING ZERO
5081 f1d4 8d 16                        BSR  L90AA          ; CLEAR CARRY IF NUMERIC
5082 f1d6 25 08                        BLO  L909E          ; BRANCH IF NOT A NUMERIC CHARACTER - ERROR
5083 f1d8 35 02              L9096     PULS A              ; * PULL A CHARACTER OFF OF THE STACK
5084 f1da a7 82                        STA  ,-X            ; * AND PUT IT BACK IN THE STRING BUFFER
5085 f1dc 26 fa                        BNE  L9096          ; * KEEP GOING UNTIL ZERO FLAG
5086 f1de 20 c7                        BRA  L9065          ; KEEP CLEANING UP THE INPUT BUFFER
5087 f1e0 35 02              L909E     PULS A              ;
5088 f1e2 4d                           TSTA                ; * THE STACK AND EXIT WHEN
5089 f1e3 26 fb                        BNE  L909E          ; * ZERO FLAG FOUND
5090 f1e5 9e 0f                        LDX  TEMPTR         ; GET THE STRING BUFFER START POINTER
5091 f1e7 86 25                        LDA  #'%            ; * PUT A % SIGN BEFORE THE ERROR POSITION TO
5092 f1e9 a7 82                        STA  ,-X            ; * INDICATE AN ERROR
5093 f1eb 39                 L90A9     RTS
5094                         *
5095                         * CLEAR CARRY IF NUMERIC
5096 f1ec 81 30              L90AA     CMPA #'0            ; ASCII ZERO
5097 f1ee 25 04                        BLO  L90B2          ; RETURN IF ACCA < ASCII 0
5098 f1f0 80 3a                        SUBA #$3A           ; *  #'9'+1
5099 f1f2 80 c6                        SUBA #$C6           ; * #-('9'+1)  CARRY CLEAR IF NUMERIC
5100 f1f4 39                 L90B2     RTS
5101                         *
5102                         * PROCESS AN ITEM-LIST WHICH IS < 100,000,000
5103 f1f5 96 98              L90B3     LDA  VD8            ; GET RIGHT DIGIT COUNTER
5104 f1f7 27 01                        BEQ  L90B8          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT OF DECIMAL PT
5105 f1f9 4a                           DECA                ; SUBTRACT ONE FOR DECIMAL POINT
5106 f1fa 9b 47              L90B8     ADDA V47            ; *ADD THE BASE 10 EXPONENT OFFSET - ACCA CONTAINS THE
5107                         *         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO THE SPECIFIED
5108                         *         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMAL POINT
5109 f1fc 2b 01                        BMI  L90BD          ; IF ACCA >= 0 THEN NO SHIFTS ARE REQUIRED
5110 f1fe 4f                           CLRA                ; FORCE SHIFT COUNTER = 0
5111 f1ff 34 02              L90BD     PSHS A              ; SAVE INITIAL SHIFT COUNTER ON THE STACK
5112 f201 2a 0a              L90BF     BPL  L90CB          ; EXIT ROUTINE IF POSITIVE
5113 f203 34 02                        PSHS A              ; SAVE SHIFT COUNTER ON STACK
5114 f205 bd e2 ce                     JSR  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT ONE DIGIT TO RIGHT
5115 f208 35 02                        PULS A              ; GET SHIFT COUNTER FROM THE STACK
5116 f20a 4c                           INCA                ; BUMP SHIFT COUNTER UP BY ONE
5117 f20b 20 f4                        BRA  L90BF          ; CHECK FOR FURTHER DIVISION
5118 f20d 96 47              L90CB     LDA  V47            ; * GET BASE 10 EXPONENT OFFSET, ADD INITIAL SHIFT COUNTER
5119 f20f a0 e0                        SUBA ,S+            ; * AND SAVE NEW BASE 10 EXPONENT OFFSET - BECAUSE
5120 f211 97 47                        STA  V47            ; * FPA0 WAS SHIFTED ABOVE
5121 f213 8b 09                        ADDA #$09           ; * ADD NINE (SIGNIFICANT PLACES) AND BRANCH IF THERE ARE NO
5122 f215 2b 19                        BMI  L90EE          ; * ZEROES TO THE LEFT OF THE DECIMAL POINT IN THIS PRINT ITEM
5123 f217 96 99                        LDA  VD9            ; *DETERMINE HOW MANY FILLER ZEROES TO THE LEFT OF THE DECIMAL
5124 f219 80 09                        SUBA #$09           ; *POINT. GET THE NUMBER OF FORMAT PLACES TO LEFT OF DECIMAL
5125 f21b 90 47                        SUBA V47            ; *POINT, SUBTRACT THE BASE 10 EXPONENT OFFSET AND THE CONSTANT 9
5126 f21d 8d 0d                        BSR  L90EA          ; *(UNNORMALIZATION)-THEN OUTPUT THAT MANY ZEROES TO THE BUFFER
5127 f21f bd f3 a5                     JSR  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
5128 f222 20 1d                        BRA  L90FF          ; PROCESS THE REMAINDER OF THE PRINT ITEM
5129                         *
5130                         * PUT (ACCA+1) ASCII ZEROES IN BUFFER
5131 f224 34 02              L90E2     PSHS A              ; SAVE ZERO COUNTER
5132 f226 86 30                        LDA  #'0            ; * INSERT A ZERO INTO
5133 f228 a7 c0                        STA  ,U+            ; * THE BUFFER
5134 f22a 35 02                        PULS A              ; RESTORE ZERO COUNTER
5135                         
5136                         * PUT ACCA ASCII ZEROES INTO THE BUFFER
5137 f22c 4a                 L90EA     DECA                ; DECREMENT ZERO COUNTER
5138 f22d 2a f5                        BPL  L90E2          ; BRANCH IF NOT DONE
5139 f22f 39                           RTS
5140                         
5141 f230 96 99              L90EE     LDA  VD9            ; * GET THE LEFT DIGIT COUNTER AND PUT
5142 f232 8d f8                        BSR  L90EA          ; * THAT MANY ZEROES IN THE STRiNG BUFFER
5143 f234 bd f3 8f                     JSR  L924D          ; PUT THE DECIMAL POINT IN THE STRING BUFFER
5144 f237 86 f7                        LDA  #-9            ; *DETERMINE HOW MANY FILLER ZEROES BETWEEN THE DECIMAL POINT
5145 f239 90 47                        SUBA V47            ; *AND SIGNIFICANT DATA. SUBTRACT BASE 10 EXPONENT FROM -9
5146 f23b 8d ef                        BSR  L90EA          ; *(UNNORMALIZATION) AND OUTPUT THAT MANY ZEROES TO BUFFER
5147 f23d 0f 45                        CLR  V45            ; CLEAR THE DECIMAL POINT COUNTER - SUPPRESS THE DECIMAL POINT
5148 f23f 0f 97                        CLR  VD7            ; CLEAR THE COMMA COUNTER - SUPPRESS COMMAS
5149 f241 bd f3 44           L90FF     JSR  L9202          ; DECODE FPA0 INTO A DECIMAL ASCII STRING
5150 f244 96 98                        LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
5151 f246 26 02                        BNE  L9108          ; BRANCH IF RIGHT DIGIT COUNTER <> 0
5152 f248 de 39                        LDU  VARPTR         ; RESET BUFFER PTR TO THE DECIMAL POINT IF NO DIGITS TO RIGHT
5153 f24a 9b 47              L9108     ADDA V47            ; *ADD BASE 10 EXPONENT - A POSITIVE ACCA WILL CAUSE THAT MANY
5154                         * *FILLER ZEROES TO BE OUTPUT ; TO THE RIGHT OF LAST SIGNIFICANT DATA
5155                         *         *SIGNIFICANT DATA
5156 f24c 16 ff 43                     LBRA L9050          ; INSERT LEADING ASTERISKS, FLOATING DOLLAR SIGN, ETC
5157                         *
5158                         * FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FORMAT
5159 f24f 96 4f              L910D     LDA  FP0EXP         ; * GET EXPONENT OF FPA0 AND
5160 f251 34 02                        PSHS A              ; * SAVE IT ON THE STACK
5161 f253 27 03                        BEQ  L9116          ; BRANCH IF FPA0 = 0
5162 f255 bd f3 0f                     JSR  L91CD          ; *CONVERT FPA0 INTO A NUMBER WITH 9 SIGNIFICANT
5163                         *         *DIGITS TO THE LEFT OF THE DECIMAL POINT
5164 f258 96 98              L9116     LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
5165 f25a 27 01                        BEQ  L911B          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT
5166 f25c 4a                           DECA                ; SUBTRACT ONE FOR THE DECIMAL POINT
5167 f25d 9b 99              L911B     ADDA VD9            ; ADD TO THE LEFT DIGIT COUNTER
5168 f25f 7f 01 f1                     CLR  STRBUF+3       ; CLEAR BUFFER BYTE AS TEMPORARY STORAGE LOCATION
5169 f262 d6 9a                        LDB  VDA            ; * GET THE STATUS BYTE FOR A
5170 f264 c4 04                        ANDB #$04           ; * POST-BYTE FORCE; BRANCH IF
5171 f266 26 03                        BNE  L9129          ; * A POST-BYTE FORCE
5172 f268 73 01 f1                     COM  STRBUF+3       ; TOGGLE BUFFER BYTE TO -1 IF NO POST-BYTE FORCE
5173 f26b bb 01 f1           L9129     ADDA STRBUF+3       ; SUBTRACT 1 IF NO POST BYTE FORCE
5174 f26e 80 09                        SUBA #$09           ; *SUBTRACT 9 (DUE TO THE CONVERSION TO 9
5175                         *         *SIGNIFICANT DIGITS TO LEFT OF DECIMAL POINT)
5176 f270 34 02                        PSHS A              ; * SAVE SHIFT COUNTER ON THE STACK - ACCA CONTAINS THE NUMBER
5177                         *         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE NUMBER OF
5178                         *         FORMATTED PLACES TO THE RIGHT OF THE DECIMAL POINT.
5179 f272 2a 0a              L9130     BPL  L913C          ; NO MORE SHIFTS WHEN ACCA >= 0
5180 f274 34 02                        PSHS A              ; SAVE SHIFT COUNTER
5181 f276 bd e2 ce                     JSR  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT TO RIGHT ONE
5182 f279 35 02                        PULS A              ; RESTORE THE SHIFT COUNTER
5183 f27b 4c                           INCA                ; ADD 1 TO SHIFT COUNTER
5184 f27c 20 f4                        BRA  L9130          ; CHECK FOR FURTHER SHIFTING (DIVISION)
5185 f27e a6 e4              L913C     LDA  ,S             ; *GET THE INITIAL VALUE OF THE SHIFT COUNTER
5186 f280 2b 01                        BMI  L9141          ; *AND BRANCH IF SHIFTING HAS TAKEN PLACE
5187 f282 4f                           CLRA                ; RESET ACCA IF NO SHIFTING HAS TAKEN PLACE
5188 f283 40                 L9141     NEGA                ; *CALCULATE THE POSITION OF THE DECIMAL POINT BY
5189 f284 9b 99                        ADDA VD9            ; *NEGATING SHIFT COUNTER, ADDING THE LEFT DIGIT COUNTER
5190 f286 4c                           INCA                ; *PLUS ONE AND THE POST-BYTE POSlTION, IF USED
5191 f287 bb 01 f1                     ADDA STRBUF+3       ; *
5192 f28a 97 45                        STA  V45            ; SAVE DECIMAL POINT COUNTER
5193 f28c 0f 97                        CLR  VD7            ; CLEAR COMMA COUNTER - NO COMMAS INSERTED
5194 f28e bd f3 44                     JSR  L9202          ; CONVERT FPA0 INTO ASCII DECIMAL STRING
5195 f291 35 02                        PULS A              ; * GET THE INITIAL VALUE OF SHIFT COUNTER AND
5196 f293 bd f3 c3                     JSR  L9281          ; * INSERT THAT MANY ZEROES INTO THE BUFFER
5197 f296 96 98                        LDA  VD8            ; *GET THE RIGHT DIGIT COUNTER AND BRANCH
5198 f298 26 02                        BNE  L915A          ; *IF NOT ZERO
5199 f29a 33 5f                        LEAU -1,U           ; MOVE BUFFER POINTER BACK ONE
5200                         
5201                         * CALCULATE VALUE OF EXPONENT AND PUT IN STRING BUFFER
5202 f29c e6 e0              L915A     LDB  ,S+            ; GET ORIGINAL EXPONENT OF FPA0
5203 f29e 27 09                        BEQ  L9167          ; BRANCH IF EXPONENT = 0
5204 f2a0 d6 47                        LDB  V47            ; GET BASE 10 EXPONENT
5205 f2a2 cb 09                        ADDB #$09           ; ADD 9 FOR 9 SIGNIFICANT DIGIT CONVERSION
5206 f2a4 d0 99                        SUBB VD9            ; SUBTRACT LEFT DIGIT COUNTER
5207 f2a6 f0 01 f1                     SUBB STRBUF+3       ; ADD ONE TO EXPONENT IF POST-SIGN FORCE
5208 f2a9 86 2b              L9167     LDA  #'+            ; PLUS SIGN
5209 f2ab 5d                           TSTB                ; TEST EXPONENT
5210 f2ac 2a 03                        BPL  L916F          ; BRANCH IF POSITIVE EXPONENT
5211 f2ae 86 2d                        LDA  #'-            ; MINUS SIGN
5212 f2b0 50                           NEGB                ; CONVERT EXPONENT TO POSITIVE NUMBER
5213 f2b1 a7 41              L916F     STA  $01,U          ; PUT SIGN OF EXPONENT IN STRING BUFFER
5214 f2b3 86 45                        LDA  #'E            ; * PUT AN 'E' (EXPONENTIATION FLAG) IN
5215 f2b5 a7 c1                        STA  ,U++           ; * BUFFER AND SKIP OVER THE SIGN
5216 f2b7 86 2f                        LDA  #$2F           ; * WAS LDA #'0'-1
5217                         *CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACCA
5218 f2b9 4c                 L9177     INCA                ; ADD ONE TO TENS DIGIT COUNTER
5219 f2ba c0 0a                        SUBB #10            ; *SUBTRACT 10 FROM EXPONENT AND ADD ONE TO TENS
5220 f2bc 24 fb                        BCC  L9177          ; * DIGIT IF NO CARRY. TENS DIGIT DONE IF THERE IS A CARRY
5221 f2be cb 3a                        ADDB #$3A           ; WAS ADDB #'9'+1
5222 f2c0 ed c1                        STD  ,U++           ; SAVE EXPONENT IN BUFFER
5223 f2c2 6f c4                        CLR  ,U             ; CLEAR FINAL BYTE IN BUFFER - PRINT TERMINATOR
5224 f2c4 7e f1 96                     JMP  L9054          ; INSERT ASTERISK PADDING, FLOATING DOLLAR SIGN, ETC.
5225                         
5226                         * INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN
5227 f2c7 8e 01 f2           L9185     LDX  #STRBUF+4      ; POINT X TO START OF PRINT ITEM BUFFER
5228 f2ca e6 84                        LDB  ,X             ; * GET SIGN BYTE OF ITEM-LIST BUFFER
5229 f2cc 34 04                        PSHS B              ; * AND SAVE IT ON THE STACK
5230 f2ce 86 20                        LDA  #SPACE         ; DEFAULT PAD WITH BLANKS
5231 f2d0 d6 9a                        LDB  VDA            ; * GET STATUS BYTE AND CHECK FOR
5232 f2d2 c5 20                        BITB #$20           ; * ASTERISK LEFT PADDING
5233 f2d4 35 04                        PULS B              ; GET SIGN BYTE AGAIN
5234 f2d6 27 08                        BEQ  L919E          ; BRANCH IF NO PADDING
5235 f2d8 86 2a                        LDA  #'*            ; PAD WITH ASTERISK
5236 f2da c1 20                        CMPB #SPACE         ; WAS THE FIRST BYTE A BLANK (POSITIVE)?
5237 f2dc 26 02                        BNE  L919E          ; NO
5238 f2de 1f 89                        TFR  A,B            ; TRANSFER PAD CHARACTER TO ACCB
5239 f2e0 34 04              L919E     PSHS B              ; SAVE FIRST CHARACTER ON STACK
5240 f2e2 a7 80              L91A0     STA  ,X+            ; STORE PAD CHARACTER IN BUFFER
5241 f2e4 e6 84                        LDB  ,X             ; GET NEXT CHARACTER IN BUFFER
5242 f2e6 27 10                        BEQ  L91B6          ; INSERT A ZERO IF END OF BUFFER
5243 f2e8 c1 45                        CMPB #'E            ; * CHECK FOR AN 'E' AND
5244 f2ea 27 0c                        BEQ  L91B6          ; * PUT A ZERO BEFORE IT
5245 f2ec c1 30                        CMPB #'0            ; * REPLACE LEADING ZEROES WITH
5246 f2ee 27 f2                        BEQ  L91A0          ; * PAD CHARACTERS
5247 f2f0 c1 2c                        CMPB #',            ; * REPLACE LEADING COMMAS
5248 f2f2 27 ee                        BEQ  L91A0          ; * WITH PAD CHARACTERS
5249 f2f4 c1 2e                        CMPB #'.            ; * CHECK FOR DECIMAL POINT
5250 f2f6 26 04                        BNE  L91BA          ; * AND DON'T PUT A ZERO BEFORE IT
5251 f2f8 86 30              L91B6     LDA  #'0            ; * REPLACE PREVIOUS CHARACTER
5252 f2fa a7 82                        STA  ,-X            ; * WITH A ZERO
5253 f2fc 96 9a              L91BA     LDA  VDA            ; * GET STATUS BYTE, CHECK
5254 f2fe 85 10                        BITA #$10           ; * FOR FLOATING $
5255 f300 27 04                        BEQ  L91C4          ; * BRANCH IF NO FLOATING $
5256 f302 c6 24                        LDB  #'$            ; * STORE A $ IN
5257 f304 e7 82                        STB  ,-X            ; * BUFFER
5258 f306 84 04              L91C4     ANDA #$04           ; CHECK PRE-SIGN FLAG
5259 f308 35 04                        PULS B              ; GET SIGN CHARACTER
5260 f30a 26 02                        BNE  L91CC          ; RETURN IF POST-SIGN REQUIRED
5261 f30c e7 82                        STB  ,-X            ; STORE FIRST CHARACTER
5262 f30e 39                 L91CC     RTS
5263                         *
5264                         * CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN X 10**M.
5265                         * THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPONENT).
5266 f30f 34 40              L91CD     PSHS U              ; SAVE BUFFER POINTER
5267 f311 4f                           CLRA                ; INITIAL EXPONENT OFFSET = 0
5268 f312 97 47              L91D0     STA  V47            ; SAVE EXPONENT OFFSET
5269 f314 d6 4f                        LDB  FP0EXP         ; GET EXPONENT OF FPA0
5270 f316 c1 80                        CMPB #$80           ; * COMPARE TO EXPONENT OF .5
5271 f318 22 11                        BHI  L91E9          ; * AND BRANCH IF FPA0 > = 1.0
5272                         
5273                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1
5274 f31a 8e e5 0c                     LDX  #LBDC0         ; POINT X TO FP NUMBER (1E+09)
5275 f31d bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY 1E+09
5276 f320 96 47                        LDA  V47            ; GET EXPONENT OFFSET
5277 f322 80 09                        SUBA #$09           ; SUBTRACT 9 (BECAUSE WE MULTIPLIED BY 1E+09 ABOVE)
5278 f324 20 ec                        BRA  L91D0          ; CHECK TO SEE IF > 1.0
5279 f326 bd e2 ce           L91E4     JSR  LBB82          ; DIVIDE FPA0 BY 10
5280 f329 0c 47                        INC  V47            ; INCREMENT EXPONENT OFFSET
5281 f32b 8e e5 07           L91E9     LDX  #LBDBB         ; POINT X TO FP NUMBER (999,999,999)
5282 f32e bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO X
5283 f331 2e f3                        BGT  L91E4          ; BRANCH IF FPA0 > 999,999,999
5284 f333 8e e5 02           L91F1     LDX  #LBDB6         ; POINT X TO FP NUMBER (99,999,999.9)
5285 f336 bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO X
5286 f339 2e 07                        BGT  L9200          ; RETURN IF 999,999,999 > FPA0 > 99,999,999.9
5287 f33b bd e2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
5288 f33e 0a 47                        DEC  V47            ; DECREMENT EXPONENT OFFSET
5289 f340 20 f1                        BRA  L91F1          ; KEEP UNNORMALIZING
5290 f342 35 c0              L9200     PULS U,PC           ; RESTORE BUFFER POINTER AND RETURN
5291                         *
5292                         * CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT
5293                         * INTO A DECIMAL ASCII STRING IN THE BUFFER
5294 f344 34 40              L9202     PSHS U              ; SAVE BUFFER POINTER
5295 f346 bd e1 00                     JSR  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
5296 f349 bd e4 14                     JSR  LBCC8          ; CONVERT FPA0 TO INTEGER FORMAT
5297 f34c 35 40                        PULS U              ; RESTORE BUFFER POINTER
5298                         *
5299                         * CONVERT FPA0 INTO A DECIMAL ASCII STRING
5300 f34e 8e e6 11                     LDX  #LBEC5         ; POINT X TO UNNORMALIZED POWERS OF 10
5301 f351 c6 80                        LDB  #$80           ; INITIALIZE DIGIT COUNTER TO 0 + $80.
5302                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
5303                         * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
5304                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB
5305                         * IS HOW THIS ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURRING.
5306 f353 8d 36              L9211     BSR  L9249          ; CHECK FOR COMMA INSERTION
5307 f355 96 53              L9213     LDA  FPA0+3         ; * 'ADD' A POWER OF 10 MANTISSA TO FPA0.
5308 f357 ab 03                        ADDA $03,X          ; * IF THE MANTISSA IS NEGATIVE, A SUBTRACTION
5309 f359 97 53                        STA  FPA0+3         ; * WILL BE WHAT REALLY TAKES PLACE.
5310 f35b 96 52                        LDA  FPA0+2         ; *
5311 f35d a9 02                        ADCA $02,X          ; *
5312 f35f 97 52                        STA  FPA0+2         ; *
5313 f361 96 51                        LDA  FPA0+1         ; *
5314 f363 a9 01                        ADCA $01,X          ; *
5315 f365 97 51                        STA  FPA0+1         ; *
5316 f367 96 50                        LDA  FPA0           ; *
5317 f369 a9 84                        ADCA ,X             ; *
5318 f36b 97 50                        STA  FPA0           ; *
5319 f36d 5c                           INCB                ; ADD ONE TO DIGIT COUNTER
5320 f36e 56                           RORB                ; ROTATE CARRY INTO BIT 7
5321 f36f 59                           ROLB                ; * SET OVERFLOW FLAG - BRANCH IF CARRY SET AND
5322 f370 28 e3                        BVC  L9213          ; * ADDING MANTISSA OR CARRY CLEAR AND SUBTRACTING MANTISSA
5323 f372 24 03                        BCC  L9235          ; BRANCH IF SUBTRACTING MANTISSA
5324 f374 c0 0b                        SUBB #10+1          ; WAS SUBB #10+1
5325 f376 50                           NEGB                ; * IF ADDING MANTISSA
5326 f377 cb 2f              L9235     ADDB #$2F           ; WAS ADDB #'0'-1
5327 f379 30 04                        LEAX $04,X          ; MOVE TO NEXT POWER OF 10 MANTISSA
5328 f37b 1f 98                        TFR  B,A            ; SAVE DIGIT IN ACCA
5329 f37d 84 7f                        ANDA #$7F           ; MASK OFF ADD/SUBTRACT FLAG (BIT 7)
5330 f37f a7 c0                        STA  ,U+            ; STORE DIGIT IN BUFFER
5331 f381 53                           COMB                ; TOGGLE ADD/SUBTRACT FLAG
5332 f382 c4 80                        ANDB #$80           ; MASK OFF EVERYTHING BUT ADD/SUB FLAG
5333 f384 8c e6 35                     CMPX #LBEE9         ; COMPARE TO END OF UNNORMALIZED POWERS OF 10
5334 f387 26 ca                        BNE  L9211          ; BRANCH IF NOT DONE
5335 f389 6f c4                        CLR  ,U             ; PUT A ZERO AT END OF INTEGER
5336                         
5337                         * DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA INSERTION
5338 f38b 0a 45              L9249     DEC  V45            ; DECREMENT DECIMAL POINT COUNTER
5339 f38d 26 09                        BNE  L9256          ; NOT TIME FOR DECIMAL POINT
5340 f38f df 39              L924D     STU  VARPTR         ; SAVE BUFFER POINTER-POSITION OF THE DECIMAL POINT
5341 f391 86 2e                        LDA  #'.            ; * STORE A DECIMAL
5342 f393 a7 c0                        STA  ,U+            ; * POINT IN THE OUTPUT BUFFER
5343 f395 0f 97                        CLR  VD7            ; * CLEAR COMMA COUNTER - NOW IT WILL TAKE 255
5344                         *                             ; * DECREMENTS BEFORE ANOTHER COMMA WILL BE INSERTED
5345 f397 39                           RTS
5346 f398 0a 97              L9256     DEC  VD7            ; DECREMENT COMMA COUNTER
5347 f39a 26 08                        BNE  L9262          ; RETURN IF NOT TIME FOR COMMA
5348 f39c 86 03                        LDA  #$03           ; * RESET COMMA COUNTER TO 3; THREE
5349 f39e 97 97                        STA  VD7            ; * DIGITS BETWEEN COMMAS
5350 f3a0 86 2c                        LDA  #',            ; * PUT A COMMA INTO
5351 f3a2 a7 c0                        STA  ,U+            ; * THE BUFFER
5352 f3a4 39                 L9262     RTS
5353                         
5354                         * INITIALIZE DECIMAL POINT AND COMMA COUNTERS
5355 f3a5 96 47              L9263     LDA  V47            ; GET THE BASE 10 EXPONENT OFFSET
5356 f3a7 8b 0a                        ADDA #10            ; * ADD 10 (FPA0 WAS 'NORMALIZED' TO 9 PLACES LEFT
5357 f3a9 97 45                        STA  V45            ; * OF DECIMAL POINT) - SAVE IN DECIMAL POINT COUNTER
5358 f3ab 4c                           INCA                ; ADD ONE FOR THE DECIMAL POINT
5359 f3ac 80 03              L926A     SUBA #$03           ; * DIVIDE DECIMAL POINT COUNTER BY 3; LEAVE
5360 f3ae 24 fc                        BCC  L926A          ; * THE REMAINDER IN ACCA
5361 f3b0 8b 05                        ADDA #$05           ; CONVERT REMAINDER INTO A NUMBER FROM 1-3
5362 f3b2 97 97                        STA  VD7            ; SAVE COMMA COUNTER
5363 f3b4 96 9a                        LDA  VDA            ; GET STATUS BYTE
5364 f3b6 84 40                        ANDA #$40           ; CHECK FOR COMMA FLAG
5365 f3b8 26 02                        BNE  L927A          ; BRANCH IF COMMA FLAG ACTIVE
5366 f3ba 97 97                        STA  VD7            ; CLEAR COMMA COUNTER - 255 DIGITS OUTPUT BEFORE A COMMA
5367 f3bc 39                 L927A     RTS
5368                         *
5369                         * INSERT ACCA ZEROES INTO THE BUFFER
5370 f3bd 34 02              L927B     PSHS A              ; SAVE ZEROES COUNTER
5371 f3bf 8d ca                        BSR  L9249          ; CHECK FOR DECIMAL POINT
5372 f3c1 35 02                        PULS A              ; RESTORE ZEROES COUNTER
5373 f3c3 4a                 L9281     DECA                ; * DECREMENT ZEROES COUNTER AND
5374 f3c4 2b 0a                        BMI  L928E          ; * RETURN IF < 0
5375 f3c6 34 02                        PSHS A              ; SAVE ZEROES COUNTER
5376 f3c8 86 30                        LDA  #'0            ; * PUT A ZERO INTO
5377 f3ca a7 c0                        STA  ,U+            ; * THE BUFFER
5378 f3cc a6 e0                        LDA  ,S+            ; RESTORE THE ZEROES COUNTER
5379 f3ce 26 ed                        BNE  L927B          ; BRANCH IF NOT DONE
5380 f3d0 39                 L928E     RTS
5381                         
5382                         
5383                         * LINE
5384 f3d1 81 89              LINE      CMPA #TOK_INPUT     ; 'INPUT' TOKEN
5385 f3d3 10 27 f9 5c                  LBEQ L89C0          ; GO DO 'LINE INPUT' COMMAND
5386 f3d7 7e da 03                     JMP  LB277          ; 'SYNTAX ERROR' IF NOT "LINE INPUT"
5387                         
5388                         * END OF EXTENDED BASIC
5389                         
5390 f3da ff ff ff ff ff ff          FILL    $FF, $F800-*   ; Fill ROM with FFs until start of ASSIST09
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff
5391                         
5392                         *************************************
5393                         * COPYRIGHT (C) MOTOROLA, INC. 1979 *
5394                         *************************************
5395                         
5396                         *************************************
5397                         * THIS IS THE BASE ASSIST09 ROM.
5398                         * IT MAY RUN WITH OR WITHOUT THE
5399                         * EXTENSION ROM WHICH
5400                         * WHEN PRESENT WILL BE AUTOMATICALLY
5401                         * INCORPORATED BY THE BLDVTR
5402                         * SUBROUTINE.
5403                         *************************************
5404                         
5405                         *********************************************
5406                         * GLOBAL MODULE EQUATES
5407                         ********************************************
5408 f800                    ROMBEG  EQU     $F800           ; ROM START ASSEMBLY ADDRESS
5409 ffff6800                    RAMOFS  EQU     -$9800          ; ROM OFFSET TO RAM WORK PAGE
5410 0800                    ROMSIZ  EQU     2048            ; ROM SIZE
5411 f000                    ROM2OF  EQU     ROMBEG-ROMSIZ   ; START OF EXTENSION ROM
5412 a000                    ACIA    EQU     $A000           ; DEFAULT ACIA ADDRESS
5413 0000                    PTM     EQU     $0000           ; DEFAULT PTM ADDRESS
5414 0000                    DFTCHP  EQU     0               ; DEFAULT CHARACTER PAD COUNT
5415 0005                    DFTNLP  EQU     5               ; DEFAULT NEW LINE PAD COUNT
5416 003e                    PROMPT  EQU     '>              ; PROMPT CHARACTER
5417 0008                    NUMBKP  EQU     8               ; NUMBER OF BREAKPOINTS
5418                         *********************************************
5419                         
5420                         *********************************************
5421                         * MISCELANEOUS EQUATES
5422                         *********************************************
5423 0004                    EOT     EQU     $04             ; END OF TRANSMISSION
5424 0007                    BELL    EQU     $07             ; BELL CHARACTER
5425 000a                    LF      EQU     $0A             ; LINE FEED
5426                         *CR     EQU     $0D             ; CARRIAGE RETURN
5427 0010                    DLE     EQU     $10             ; DATA LINK ESCAPE
5428 0018                    CAN     EQU     $18             ; CANCEL (CTL-X)
5429                         
5430                         * PTM ACCESS DEFINITIONS
5431 0001                    PTMSTA  EQU     PTM+1           ; READ STATUS REGISTER
5432 0000                    PTMC13  EQU     PTM             ; CONTROL REGISTERS 1 AND 3
5433 0001                    PTMC2   EQU     PTM+1           ; CONTROL REGISTER 2
5434 0002                    PTMTM1  EQU     PTM+2           ; LATCH 1
5435 0004                    PTMTM2  EQU     PTM+4           ; LATCH 2
5436 0006                    PTMTM3  EQU     PTM+6           ; LATCH 3
5437 008c                    SKIP2   EQU     $8C             ; "CMPX #" OPCODE - SKIPS TWO BYTES
5438                         
5439                         *******************************************
5440                         * ASSIST09 MONITOR SWI FUNCTIONS
5441                         * THE FOLLOWING EQUATES DEFINE FUNCTIONS PROVIDED
5442                         * BY THE ASSIST09 MONITOR VIA THE SWI INSTRUCTION.
5443                         ******************************************
5444 0000                    INCHNP  EQU     0               ; INPUT CHAR IN A REG - NO PARITY
5445 0001                    OUTCH   EQU     1               ; OUTPUT CHAR FROM A REG
5446 0002                    PDATA1  EQU     2               ; OUTPUT STRING
5447 0003                    PDATA   EQU     3               ; OUTPUT CR/LF THEN STRING
5448 0004                    OUT2HS  EQU     4               ; OUTPUT TWO HEX AND SPACE
5449 0005                    OUT4HS  EQU     5               ; OUTPUT FOUR HEX AND SPACE
5450 0006                    PCRLF   EQU     6               ; OUTPUT CR/LF
5451 0007                    SPACEF  EQU     7               ; OUTPUT A SPACE
5452 0008                    MONITR  EQU     8               ; ENTER ASSIST09 MONITOR
5453 0009                    VCTRSW  EQU     9               ; VECTOR EXAMINE/SWITCH
5454 000a                    BRKPT   EQU     10              ; USER PROGRAM BREAKPOINT
5455 000b                    PAUSE   EQU     11              ; TASK PAUSE FUNCTION
5456 000b                    NUMFUN  EQU     11              ; NUMBER OF AVAILABLE FUNCTIONS
5457                         
5458                         * NEXT SUB-CODES FOR ACCESSING THE VECTOR TABLE.
5459                         * THEY ARE EQUIVALENT TO OFFSETS IN THE TABLE.
5460                         * RELATIVE POSITIONING MUST BE MAINTAINED
5461                         
5462 0000                    .AVTBL  EQU     0               ; ADDRESS OF VECTOR TABLE
5463 0002                    .CMDL1  EQU     2               ; FIRST COMMAND LIST
5464 0004                    .RSVD   EQU     4               ; RESERVED HARDWARE VECTOR
5465 0006                    .SWI3   EQU     6               ; SWI3 ROUTINE
5466 0008                    .SWI2   EQU     8               ; SWI2 ROUTINE
5467 000a                    .FIRQ   EQU     10              ; FIRQ ROUTINE
5468 000c                    .IRQ    EQU     12              ; IRQ ROUTINE
5469 000e                    .SWI    EQU     14              ; SWI ROUTINE
5470 0010                    .NMI    EQU     16              ; NMI ROUTINE
5471 0012                    .RESET  EQU     18              ; RESET ROUTINE
5472 0014                    .CION   EQU     20              ; CONSOLE ON
5473 0016                    .CIDTA  EQU     22              ; CONSOLE INPUT DATA
5474 0018                    .CIOFF  EQU     24              ; CONSOLE INPUT OFF
5475 001a                    .COON   EQU     26              ; CONSOLE OUTPUT ON
5476 001c                    .CODTA  EQU     28              ; CONSOLE OUTPUT DATA
5477 001e                    .COOFF  EQU     30              ; CONSOLE OUTPUT OFF
5478 0020                    .HSDTA  EQU     32              ; HIGH SPEED PRINTDATA
5479 0022                    .BSON   EQU     34              ; PUNCH/LOAD ON
5480 0024                    .BSDTA  EQU     36              ; PUNCH/LOAD DATA
5481 0026                    .BSOFF  EQU     38              ; PUNCH/LOAD OFF
5482 0028                    .PAUSE  EQU     40              ; TASK PAUSE ROUTINE
5483 002a                    .EXPAN  EQU     42              ; EXPRESSION ANALYZER
5484 002c                    .CMDL2  EQU     44              ; SECOND COMMAND LIST
5485 002e                    .ACIA   EQU     46              ; ACIA ADDRESS
5486 0030                    .PAD    EQU     48              ; CHARACTER PAD AND NEW LINE PAD
5487 0032                    .ECHO   EQU     50              ; ECHO/LOAD AND NULL BKPT FLAG
5488 0034                    .PTM    EQU     52              ; PTM ADDRESS
5489 001b                    NUMVTR  EQU     52/2+1          ; NUMBER OF VECTORS
5490 0034                    HIVTR   EQU     52              ; HIGHEST VECTOR OFFSET
5491                         
5492                         ******************************************
5493                         *           WORK AREA
5494                         * THIS WORK AREA IS ASSIGNED TO THE PAGE ADDRESSED BY
5495                         * -$1800,PCR FROM THE BASE ADDRESS OF THE ASSIST09
5496                         * ROM. THE DIRECT PAGE REGISTER DURING MOST ROUTINE
5497                         * OPERATIONS WILL POINT TO THIS WORK AREA. THE STACK
5498                         * INITIALLY STARTS UNDER THE RESERVED WORK AREAS AS
5499                         * DEFINED HEREIN.
5500                         ******************************************
5501 6000                    WORKPG  EQU     ROMBEG+RAMOFS   ; SETUP DIRECT PAGE ADDRESS
5502                         *       SETDP   =WORKPG         ; NOTIFY ASSEMBLER
5503 6100                            ORG     WORKPG+256      ; READY PAGE DEFINITIONS
5504                         
5505                         * THE FOLLOWING THRU BKPTOP MUST RESIDE IN THIS ORDER
5506                         * FOR PROPER INITIALIZATION
5507 60fc                            ORG     *-4
5508 60fc                    PAUSER  EQU     *               ; PAUSE ROUTINE
5509 60fb                            ORG     *-1
5510 60fb                    SWIBFL  EQU     *               ; BYPASS SWI AS BREAKPOINT FLAG
5511 60fa                            ORG     *-1
5512 60fa                    BKPTCT  EQU     *               ; BREAKPOINT COUNT
5513 60f8                            ORG     *-2             ; SLEVEL EQU
5514 60f8                    SLEVEL  EQU     *               ; STACK TRACE LEVEL
5515 60c2                            ORG     -NUMVTR*2+*
5516 60c2                    VECTAB  EQU     *               ; VECTOR TABLE
5517 60b2                            ORG     -2*NUMBKP+*
5518 60b2                    BKPTBL  EQU     *               ; BREAKPOINT TABLE
5519 60a2                            ORG     -2*NUMBKP+*
5520 60a2                    BKPTOP  EQU     *               ; BREAKPOINT OPCODE TABLE
5521 60a0                            ORG     *-2
5522 60a0                    WINDOW  EQU     *               ; WINDOW
5523 609e                            ORG     *-2
5524 609e                    ADDR    EQU     *               ; ADDRESS POINTER VALUE
5525 609d                            ORG     *-1
5526 609d                    BASEPG  EQU     *               ; BASE PAGE VALUE
5527 609b                            ORG     *-2
5528 609b                    NUMBER  EQU     *               ; BINARY BUILD AREA
5529 6099                            ORG     *-2
5530 6099                    LASTOP  EQU     *               ; LAST OPCODE TRACED
5531 6097                            ORG     *-2
5532 6097                    RSTACK  EQU     *               ; RESET STACK POINTER
5533 6095                            ORG     *-2
5534 6095                    PSTACK  EQU     *               ; COMMAND RECOVERY STACK
5535 6093                            ORG     *-2
5536 6093                    PCNTER  EQU     *               ; LAST PROGRAM COUNTER
5537 6091                            ORG     *-2
5538 6091                    TRACEC  EQU     *               ; TRACE COUNT
5539 6090                            ORG     *-1
5540 6090                    SWICNT  EQU     *               ; TRACE "SWI" NEST LEVEL COUNT
5541 608f                            ORG     *-1             ; (MISFLG MUST FOLLOW SWICNT)
5542 608f                    MISFLG  EQU     *               ; LOAD CMD/THRU BREAKPOINT FLAG
5543 608e                            ORG     *-1
5544 608e                    DELIM   EQU     *               ; EXPRESSION DELIMITER/WORK BYTE
5545 6066                            ORG     *-40
5546 6066                    ROM2WK  EQU     *               ; EXTENSION ROM RESERVED AREA
5547 6051                            ORG     *-21
5548 6051                    TSTACK  EQU     *               ; TEMPORARY STACK HOLD
5549 6051                    STACK   EQU     *               ; START OF INITIAL STACK
5550                         
5551                         ******************************************
5552                         * DEFAULT THE ROM BEGINNING ADDRESS TO 'ROMBEG'
5553                         * ASSIST09 IS POSITION ADDRESS INDEPENDENT, HOWEVER
5554                         * WE ASSEMBLE ASSUMING CONTROL OF THE HARDWARE VECTORS.
5555                         * NOTE THAT THE WORK RAM PAGE MUST BE 'RAMOFS'
5556                         * FROM THE ROM BEGINNING ADDRESS.
5557                         ********************************************
5558 f800                            ORG     ROMBEG          ; ROM ASSEMBLY/DEFAULT ADDRESS
5559                         
5560                         *****************************************************
5561                         * BLDVTR - BUILD ASSIST09 VECTOR TABLE
5562                         * HARDWARE RESET CALLS THIS SUBROUTINE TO BUILD THE
5563                         * ASSIST09 VECTOR TABLE. THIS SUBROUTINE RESIDES AT
5564                         * THE FIRST BYTE OF THE ASSIST09 ROM, AND CAN BE
5565                         * CALLED VIA EXTERNAL CONTROL CODE FOR REMOTE
5566                         * ASSIST09 EXECUTION.
5567                         * INPUT: S->VALID STACK RAM
5568                         * OUTPUT: U->VECTOR TABLE ADDRESS
5569                         * DPR->ASSIST09 WORK AREA PAGE
5570                         * THE VECTOR TABLE AND DEFAULTS ARE INITIALIZED
5571                         * ALL REGISTERS VOLATILE
5572                         *************************************************
5573 f800 30 8d 68 be        BLDVTR  LEAX    VECTAB,PCR      ; ADDRESS VECTOR TABLE
5574 f804 1f 10                      TFR     X,D             ; OBTAIN BASE PAGE ADDRESS
5575 f806 1f 8b                      TFR     A,DP            ; SETUP DPR
5576 f808 97 9d                      STA     <BASEPG         ; STORE FOR QUICK REFERENCE
5577 f80a 33 84                      LEAU    ,X              ; RETURN TABLE TO CALLER
5578 f80c 31 8c 35                   LEAY    <INITVT,PCR     ; LOAD FROM ADDR
5579 f80f ef 81                      STU     ,X++            ; INIT VECTOR TABLE ADDRESS
5580 f811 c6 16                      LDB     #NUMVTR-5       ; NUMBER RELOCATABLE VECTORS
5581 f813 34 04                      PSHS    B               ; STORE INDEX ON STACK
5582 f815 1f 20              BLD2    TFR     Y,D             ; PREPARE ADDRESS RESOLVE
5583 f817 e3 a1                      ADDD    ,Y++            ; TO ABSOLUTE ADDRESS
5584 f819 ed 81                      STD     ,X++            ; INTO VECTOR TABLE
5585 f81b 6a e4                      DEC     ,S              ; COUNT DOWN
5586 f81d 26 f6                      BNE     BLD2            ; BRANCH IF MORE TO INSERT
5587 f81f c6 0d                      LDB     #INTVE-INTVS    ; STATIC VALUE INIT LENGTH
5588 f821 a6 a0              BLD3    LDA     ,Y+             ; LOAD NEXT BYTE
5589 f823 a7 80                      STA     ,X+             ; STORE INTO POSITION
5590 f825 5a                         DECB                    ; COUNT DOWN
5591 f826 26 f9                      BNE     BLD3            ; LOOP UNTIL DONE
5592 f828 31 8d f7 d4                LEAY    ROM2OF,PCR      ; TEST POSSIBLE EXTENSION ROM
5593 f82c 8e 20 fe                   LDX     #$20FE          ; LOAD "BRA *" FLAG PATTERN
5594 f82f ac a1                      CMPX    ,Y++            ; ? EXTENDED ROM HERE
5595 f831 26 02                      BNE     BLDRTN          ; BRANCH NOT OUR ROM TO RETURN
5596 f833 ad a4                      JSR     ,Y              ; CALL EXTENDED ROM INITIALIZE
5597 f835 35 84              BLDRTN  PULS    PC,B            ; RETURN TO INITIALIZER
5598                         
5599                         *****************************************************
5600                         *                RESET ENTRY POINT
5601                         * HARDWARE RESET ENTERS HERE IF ASSIST09 IS ENABLED
5602                         * TO RECEIVE THE MC6809 HARDWARE VECTORS. WE CALL
5603                         * THE BLDVTR SUBROUTINE TO INITIALIZE THE VECTOR
5604                         * TABLE, STACK, AND THEN FIREUP THE MONITOR VIA SWI
5605                         * CALL.
5606                         *******************************************************
5607 f837 32 8d 68 16        RESET   LEAS    STACK,PCR       ; SETUP INITIAL STACK
5608 f83b 8d c3                      BSR     BLDVTR          ; BUILD VECTOR TABLE
5609 f83d 4f                 RESET2  CLRA                    ; ISSUE STARTUP MESSAGE
5610 f83e 1f 8b                      TFR     A,DP            ; DEFAULT TO PAGE ZERO
5611 f840 3f                         SWI                     ; PERFORM MONITOR FIREUP
5612 f841 08                         FCB     MONITR          ; TO ENTER COMMAND PROCESSING
5613 f842 20 f9                      BRA     RESET2          ; REENTER MONITOR IF 'CONTINUE'
5614                         
5615                         ******************************************************
5616                         *        INITVT - INITIAL VECTOR TABLE
5617                         * THIS TABLE IS RELOCATED TO RAM AND REPRESENTS THE
5618                         * INITIAL STATE OF THE VECTOR TABLE. ALL ADDRESSES
5619                         * ARE CONVERTED TO ABSOLUTE FORM. THIS TABLE STARTS
5620                         * WITH THE SECOND ENTRY, ENDS WITH STATIC CONSTANT
5621                         * INITIALIZATION DATA WHICH CARRIES BEYOND THE TABLE.
5622                         ************************************************
5623 f844 01 58              INITVT  FDB     CMDTBL-*        ; DEFAULT FIRST COMMAND TABLE
5624 f846 02 92                      FDB     RSRVDR-*        ; DEFAULT UNDEFINED HARDWARE VECTOR
5625 f848 02 90                      FDB     SWI3R-*         ; DEFAULT SWI3
5626 f84a 02 8e                      FDB     SWI2R-*         ; DEFAULT SWI2
5627 f84c 02 70                      FDB     FIRQR-*         ; DEFAULT FIRQ
5628 f84e 02 8a                      FDB     IRQR-*          ; DEFAULT IRQ ROUTINE
5629 f850 00 45                      FDB     SWIR-*          ; DEFAULT SWI ROUTINE
5630 f852 02 2b                      FDB     NMIR-*          ; DEFAULT NMI ROUTINE
5631 f854 ff e3                      FDB     RESET-*         ; RESTART VECTOR
5632 f856 02 90                      FDB     CION-*          ; DEFAULT CION
5633 f858 02 84                      FDB     CIDTA-*         ; DEFAULT CIDTA
5634 f85a 02 96                      FDB     CIOFF-*         ; DEFAULT CIOFF
5635 f85c 02 8a                      FDB     COON-*          ; DEFAULT COON
5636 f85e 02 93                      FDB     CODTA-*         ; DEFAULT CODTA
5637 f860 02 90                      FDB     COOFF-*         ; DEFAULT COOFF
5638 f862 03 9a                      FDB     HSDTA-*         ; DEFAULT HSDTA
5639 f864 02 b7                      FDB     BSON-*          ; DEFAULT BSON
5640 f866 02 d2                      FDB     BSDTA-*         ; DEFAULT BSDTA
5641 f868 02 bf                      FDB     BSOFF-*         ; DEFAULT BSOFF
5642 f86a 68 92                      FDB     PAUSER-*        ; DEFAULT PAUSE ROUTINE
5643 f86c 04 7d                      FDB     EXP1-*          ; DEFAULT EXPRESSION ANALYZER
5644 f86e 01 2d                      FDB     CMDTB2-*        ; DEFAULT SECOND COMMAND TABLE
5645                         * CONSTANTS
5646 f870 a0 00              INTVS   FDB     ACIA            ; DEFAULT ACIA
5647 f872 00 05                      FCB     DFTCHP,DFTNLP   ; DEFAULT NULL PADDS
5648 f874 00 00                      FDB     0               ; DEFAULT ECHO
5649 f876 00 00                      FDB     PTM             ; DEFAULT PTM
5650 f878 00 00                      FDB     0               ; INITIAL STACK TRACE LEVEL
5651 f87a 00                         FCB     0               ; INITIAL BREAKPOINT COUNT
5652 f87b 00                         FCB     0               ; SWI BREAKPOINT LEVEL
5653 f87c 39                         FCB     $39             ; DEFAULT PAUSE ROUTINE (RTS)
5654 f87d                    INTVE   EQU     *
5655                         *B
5656                         ***********************************************
5657                         *            ASSIST09 SWI HANDLER
5658                         * THE SWI HANDLER PROVIDES ALL INTERFACING NECESSARY
5659                         * FOR A USER PROGRAM. A FUNCTION BYTE IS ASSUMED TO
5660                         * FOLLOW THE SWI INSTRUCTION. IT IS BOUND CHECKED
5661                         * AND THE PROPER ROUTINE IS GIVEN CONTROL. THIS
5662                         * INVOCATION MAY ALSO BE A BREAKPOINT INTERRUPT.
5663                         * IF SO, THE BREAKPOINT HANDLER IS ENTERED.
5664                         * INPUT: MACHINE STATE DEFINED FOR SWI
5665                         * OUTPUT: VARIES ACCORDING TO FUNCTION CALLED. PC ON
5666                         * CALLERS STACK INCREMENTED BY ONE IF VALID CALL.
5667                         * VOLATILE REGISTERS: SEE FUNCTIONS CALLED
5668                         * STATE: RUNS DISABLED UNLESS FUNCTION CLEARS I FLAG.
5669                         ************************************************
5670                         * SWI FUNCTION VECTOR TABLE
5671 f87d 01 94              SWIVTB  FDB     ZINCH-SWIVTB    ; INCHNP
5672 f87f 01 b1                      FDB     ZOTCH1-SWIVTB   ; OUTCH
5673 f881 01 cb                      FDB     ZPDTA1-SWIVTB   ; PDATA1
5674 f883 01 c3                      FDB     ZPDATA-SWIVTB   ; PDATA
5675 f885 01 75                      FDB     ZOT2HS-SWIVTB   ; OUT2HS
5676 f887 01 73                      FDB     ZOT4HS-SWIVTB   ; OUT4HS
5677 f889 01 c0                      FDB     ZPCRLF-SWIVTB   ; PCRLF
5678 f88b 01 79                      FDB     ZSPACE-SWIVTB   ; SPACE
5679 f88d 00 55                      FDB     ZMONTR-SWIVTB   ; MONITR
5680 f88f 01 7d                      FDB     ZVSWTH-SWIVTB   ; VCTRSW
5681 f891 02 56                      FDB     ZBKPNT-SWIVTB   ; BREAKPOINT
5682 f893 01 d1                      FDB     ZPAUSE-SWIVTB   ; TASK PAUSE
5683                         
5684 f895 6a 8d 67 f7        SWIR    DEC     SWICNT,PCR      ; UP "SWI" LEVEL FOR TRACE
5685 f899 17 02 25                   LBSR    LDDP            ; SETUP PAGE AND VERIFY STACK
5686                         * CHECK FOR BREAKPOINT TRAP
5687 f89c ee 6a                      LDU     10,S            ; LOAD PROGRAM COUNTER
5688 f89e 33 5f                      LEAU    -1,U            ; BACK TO SWI ADDRESS
5689 f8a0 0d fb                      TST     <SWIBFL         ; ? THIS "SWI" BREAKPOINT
5690 f8a2 26 11                      BNE     SWIDNE          ; BRANCH IF SO TO LET THROUGH
5691 f8a4 17 06 9b                   LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
5692 f8a7 50                         NEGB                    ; OBTAIN POSITIVE COUNT
5693 f8a8 5a                 SWILP   DECB                    ; COUNT DOWN
5694 f8a9 2b 0a                      BMI     SWIDNE          ; BRANCH WHEN DONE
5695 f8ab 11 a3 a1                   CMPU    ,Y++            ; ? WAS THIS A BREAKPOINT
5696 f8ae 26 f8                      BNE     SWILP           ; BRANCH IF NOT
5697 f8b0 ef 6a                      STU     10,S            ; SET PROGRAM COUNTER BACK
5698 f8b2 16 02 1e                   LBRA    ZBKPNT          ; GO DO BREAKPOINT
5699 f8b5 0f fb              SWIDNE  CLR     <SWIBFL         ; CLEAR IN CASE SET
5700 f8b7 37 06                      PULU    D               ; OBTAIN FUNCTION BYTE, UP PC
5701 f8b9 c1 0b                      CMPB    #NUMFUN         ; ? TOO HIGH
5702 f8bb 10 22 02 0f                LBHI    ERROR           ; YES, DO BREAKPOINT
5703 f8bf ef 6a                      STU     10,S            ; BUMP PROGRAM COUNTER PAST SWI
5704 f8c1 58                         ASLB                    ; FUNCTION CODE TIMES TWO
5705 f8c2 33 8c b8                   LEAU    SWIVTB,PCR      ; OBTAIN VECTOR BRANCH ADDRESS
5706 f8c5 ec c5                      LDD     B,U             ; LOAD OFFSET
5707 f8c7 6e cb                      JMP     D,U             ; JUMP TO ROUTINE
5708                         
5709                         **********************************************
5710                         * REGISTERS TO FUNCTION ROUTINES:
5711                         *  DP-> WORK AREA PAGE
5712                         *  D,Y,U=UNRELIABLE           X=AS CALLED FROM USER
5713                         *  S=AS FROM SWI INTERRUPT
5714                         *********************************************
5715                         
5716                         **************************************************
5717                         *            [SWI FUNCTION 8]
5718                         *              MONITOR ENTRY
5719                         *  FIREUP THE ASSIST09 MONITOR.
5720                         *  THE STACK WITH ITS VALUES FOR THE DIRECT PAGE
5721                         *  REGISTER AND CONDITION CODE FLAGS ARE USED AS IS.
5722                         *   1) INITIALIZE CONSOLE I/O
5723                         *   2) OPTIONALLY PRINT SIGNON
5724                         *   3) INITIALIZE PTM FOR SINGLE STEPPING
5725                         *   4) ENTER COMMAND PROCESSOR
5726                         * INPUT: A=0 INIT CONSOLE AND PRINT STARTUP MESSAGE
5727                         *        A#0 OMIT CONSOLE INIT AND STARTUP MESSAGE
5728                         *************************************************
5729                         
5730 f8c9 41 53 53 49 53 54  SIGNON  FCC     /ASSIST09/      ; SIGNON EYE-CATCHER
     30 39
5731 f8d1 04                         FCB     EOT
5732 f8d2 10 df 97           ZMONTR  STS     <RSTACK         ; SAVE FOR BAD STACK RECOVERY
5733 f8d5 6d 61                      TST     1,S             ; ? INIT CONSOLE AND SEND MSG
5734 f8d7 26 0d                      BNE     ZMONT2          ; BRANCH IF NOT
5735 f8d9 ad 9d 67 f9                JSR     [VECTAB+.CION,PCR] ; READY CONSOLE INPUT
5736 f8dd ad 9d 67 fb                JSR     [VECTAB+.COON,PCR] ; READY CONSOLE OUTPUT
5737 f8e1 30 8c e5                   LEAX    SIGNON,PCR         ; READY SIGNON EYE-CATCHER
5738 f8e4 3f                         SWI                     ; PERFORM
5739 f8e5 03                         FCB     PDATA           ; PRINT STRING
5740 f8e6 9e f6              ZMONT2  LDX     <VECTAB+.PTM    ; LOAD PTM ADDRESS
5741 f8e8 27 0d                      BEQ     CMD             ; BRANCH IF NOT TO USE A PTM
5742 f8ea 6f 02                      CLR     PTMTM1-PTM,X    ; SET LATCH TO CLEAR RESET
5743 f8ec 6f 03                      CLR     PTMTM1+1-PTM,X  ; AND SET GATE HIGH
5744 f8ee cc 01 a6                   LDD     #$01A6          ; SETUP TIMER 1 MODE
5745 f8f1 a7 01                      STA     PTMC2-PTM,X     ; SETUP FOR CONTROL REGISTER1
5746 f8f3 e7 84                      STB     PTMC13-PTM,X    ; SET OUTPUT ENABLED/
5747                         * SINGLE SHOT/ DUAL 8 BIT/INTERNAL MODE/OPERATE
5748 f8f5 6f 01                      CLR     PTMC2-PTM,X     ; SET CR2 BACK TO RESET FORM
5749                         * FALL INTO COMMAND PROCESSOR
5750                         
5751                         ***************************************************
5752                         *          COMMAND HANDLER
5753                         *  BREAKPOINTS ARE REMOVED AT THIS TIME.
5754                         *  PROMPT FOR A COMMAND, AND STORE ALL CHARACTERS
5755                         *  UNTIL A SEPARATOR ON THE STACK.
5756                         *  SEARCH FOR FIRST MATCHING COMMAND SUBSET,
5757                         *  CALL IT OR GIVE '?' RESPONSE.
5758                         *  DURING COMMAND SEARCH:
5759                         *      B=OFFSET TO NEXT ENTRY ON X
5760                         *      U=SAVED S
5761                         *      U-1=ENTRY SIZE+2
5762                         *      U-2=VALID NUMBER FLAG (>=0 VALID)/COMPARE CNT
5763                         *      U-3=CARRIAGE RETURN FLAG (0=CR HAS BEEN DONE)
5764                         *      U-4=START OF COMMAND STORE
5765                         *      S+0=END OF COMMAND STORE
5766                         ***********************************************
5767                         
5768 f8f7 3f                 CMD     SWI                     ; TO NEW LINE
5769 f8f8 06                         FCB     PCRLF           ; FUNCTION
5770                         * DISARM THE BREAKPOINTS
5771 f8f9 17 06 46           CMDNEP  LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
5772 f8fc 2a 0c                      BPL     CMDNOL          ; BRANCH IF NOT ARMED OR NONE
5773 f8fe 50                         NEGB                    ; MAKE POSITIVE
5774 f8ff d7 fa                      STB     <BKPTCT         ; FLAG AS DISARMED
5775 f901 5a                 CMDDDL  DECB                    ; ? FINISHED
5776 f902 2b 06                      BMI     CMDNOL          ; BRANCH IF SO
5777 f904 a6 30                      LDA     -NUMBKP*2,Y     ; LOAD OPCODE STORED
5778 f906 a7 b1                      STA     [,Y++]          ; STORE BACK OVER "SWI"
5779 f908 20 f7                      BRA     CMDDDL          ; LOOP UNTIL DONE
5780 f90a ae 6a              CMDNOL  LDX     10,S            ; LOAD USERS PROGRAM COUNTER
5781 f90c 9f 93                      STX     <PCNTER         ; SAVE FOR EXPRESSION ANALYZER
5782 f90e 86 3e                      LDA     #PROMPT         ; LOAD PROMPT CHARACTER
5783 f910 3f                         SWI                     ; SEND TO OUTPUT HANDLER
5784 f911 01                         FCB     OUTCH           ; FUNCTION
5785 f912 33 e4                      LEAU    ,S              ; REMEMBER STACK RESTORE ADDRESS
5786 f914 df 95                      STU     <PSTACK         ; REMEMBER STACK FOR ERROR USE
5787 f916 4f                         CLRA                    ; PREPARE ZERO
5788 f917 5f                         CLRB                    ; PREPARE ZERO
5789 f918 dd 9b                      STD     <NUMBER         ; CLEAR NUMBER BUILD AREA
5790 f91a dd 8f                      STD     <MISFLG         ; CLEAR MISCEL. AND SWICNT FLAGS
5791 f91c dd 91                      STD     <TRACEC         ; CLEAR TRACE COUNT
5792 f91e c6 02                      LDB     #2              ; SET D TO TWO
5793 f920 34 07                      PSHS    D,CC            ; PLACE DEFAULTS ONTO STACK
5794                         * CHECK FOR "QUICK" COMMANDS.
5795 f922 17 04 54                   LBSR    READC           ; OBTAIN FIRST CHARACTER
5796 f925 30 8d 05 81                LEAX    CDOT+2,PCR      ; PRESET FOR SINGLE TRACE
5797 f929 81 2e                      CMPA    #'.             ; ? QUICK TRACE
5798 f92b 27 5a                      BEQ     CMDXQT          ; BRANCH EQUAL FOR TRACE ONE
5799 f92d 30 8d 04 e9                LEAX    CMPADP+2,PCR    ; READY MEMORY ENTRY POINT
5800 f931 81 2f                      CMPA    #'/             ; ? OPEN LAST USED MEMORY
5801 f933 27 52                      BEQ     CMDXQT          ; BRANCH TO DO IT IF SO
5802                         * PROCESS NEXT CHARACTER
5803 f935 81 20              CMD2    CMPA    #'              ; ? BLANK OR DELIMITER
5804 f937 23 14                      BLS    CMDGOT           ; BRANCH YES, WE HAVE IT
5805 f939 34 02                      PSHS   A                ; BUILD ONTO STACK
5806 f93b 6c 5f                      INC    -1,U             ; COUNT THIS CHARACTER
5807 f93d 81 2f                      CMPA   #'/              ; ? MEMORY COMMAND
5808 f93f 27 4f                      BEQ    CMDMEM           ; BRANCH IF SO
5809 f941 17 04 0b                   LBSR   BLDHXC           ; TREAT AS HEX VALUE
5810 f944 27 02                      BEQ    CMD3             ; BRANCH IF STILL VALID NUMBER
5811 f946 6a 5e                      DEC    -2,U             ; FLAG AS INVALID NUMBER
5812 f948 17 04 2e           CMD3    LBSR   READC            ; OBTAIN NEXT CHARACTER
5813 f94b 20 e8                      BRA    CMD2             ; TEST NEXT CHARACTER
5814                         * GOT COMMAND, NOW SEARCH TABLES
5815 f94d 80 0d              CMDGOT  SUBA   #CR              ; SET ZERO IF CARRIAGE RETURN
5816 f94f a7 5d                      STA    -3,U             ; SETUP FLAG
5817 f951 9e c4                      LDX    <VECTAB+.CMDL1   ; START WITH FIRST CMD LIST
5818 f953 e6 80              CMDSCH  LDB    ,X+              ; LOAD ENTRY LENGTH
5819 f955 2a 10                      BPL    CMDSME           ; BRANCH IF NOT LIST END
5820 f957 9e ee                      LDX    <VECTAB+.CMDL2   ; NOW TO SECOND CMD LITS
5821 f959 5c                         INCB                    ; ? TO CONTINUE TO DEFAULT LIST
5822 f95a 27 f7                      BEQ     CMDSCH          ; BRANCH IF SO
5823 f95c 10 de 95           CMDBAD  LDS     <PSTACK         ; RESTORE STACK
5824 f95f 30 8d 01 5a                LEAX    ERRMSG,PCR      ; POINT TO ERROR STRING
5825 f963 3f                         SWI                     ; SEND OUT
5826 f964 02                         FCB     PDATA1          ; TO CONSOLE
5827 f965 20 90                      BRA     CMD             ; AND TRY AGAIN
5828                         * SEARCH NEXT ENTRY
5829 f967 5a                 CMDSME  DECB                    ; TAKE ACCOUNT OF LENGTH BYTE
5830 f968 e1 5f                      CMPB    -1,U            ; ? ENTERED LONGER THAN ENTRY
5831 f96a 24 03                      BHS     CMDSIZ          ; BRANCH IF NOT TOO LONG
5832 f96c 3a                 CMDFLS  ABX                     ; SKIP TO NEXT ENTRY
5833 f96d 20 e4                      BRA     CMDSCH          ; AND TRY NEXT
5834 f96f 31 5d              CMDSIZ  LEAY    -3,U            ; PREPARE TO COMPARE
5835 f971 a6 5f                      LDA     -1,U            ; LOAD SIZE+2
5836 f973 80 02                      SUBA    #2              ; TO ACTUAL SIZE ENTERED
5837 f975 a7 5e                      STA     -2,U            ; SAVE SIZE FOR COUNTDOWN
5838 f977 5a                 CMDCMP  DECB                    ; DOWN ONE BYTE
5839 f978 a6 80                      LDA     ,X+             ; NEXT COMMAND CHARACTER
5840 f97a a1 a2                      CMPA    ,-Y             ; ? SAME AS THAT ENTERED
5841 f97c 26 ee                      BNE     CMDFLS          ; BRANCH TO FLUSH IF NOT
5842 f97e 6a 5e                      DEC     -2,U            ; COUNT DOWN LENGTH OF ENTRY
5843 f980 26 f5                      BNE     CMDCMP          ; BRANCH IF MORE TO TEST
5844 f982 3a                         ABX                     ; TO NEXT ENTRY
5845 f983 ec 1e                      LDD     -2,X            ; LOAD OFFSET
5846 f985 30 8b                      LEAX    D,X             ; COMPUTE ROUTINE ADDRESS+2
5847 f987 6d 5d              CMDXQT  TST     -3,U            ; SET CC FOR CARRIAGE RETURN TEST
5848 f989 32 c4                      LEAS    ,U              ; DELETE STACK WORK AREA
5849 f98b ad 1e                      JSR     -2,X            ; CALL COMMAND
5850 f98d 16 ff 7a                   LBRA    CMDNOL          ; GO GET NEXT COMMAND
5851 f990 6d 5e              CMDMEM  TST     -2,U            ; ? VALID HEX NUMBER ENTERED
5852 f992 2b c8                      BMI     CMDBAD          ; BRANCH ERROR IF NOT
5853 f994 30 88 ae                   LEAX    <CMEMN-CMPADP,X ; TO DIFFERENT ENTRY
5854 f997 dc 9b                      LDD     <NUMBER         ; LOAD NUMBER ENTERED
5855 f999 20 ec                      BRA     CMDXQT          ; AND ENTER MEMORY COMMAND
5856                         
5857                         ** COMMANDS ARE ENTERED AS A SUBROUTINE WITH:
5858                         **    DPR->ASSIST09 DIRECT PAGE WORK AREA
5859                         **    Z=1 CARRIAGE RETURN ENTERED
5860                         **    Z=0 NON CARRIAGE RETURN DELIMITER
5861                         **    S=NORMAL RETURN ADDRESS
5862                         ** THE LABEL "CMDBAD" MAY BE ENTERED TO ISSUE AN
5863                         ** AN ERROR FLAG (*).
5864                         **************************************************
5865                         *       ASSIST09 COMMAND TABLES
5866                         * THESE ARE THE DEFAULT COMMAND TABLES. EXTERNAL
5867                         * TABLES OF THE SAME FORMAT MAY EXTEND/REPLACE
5868                         * THESE BY USING THE VECTOR SWAP FUNCTION.
5869                         *
5870                         * ENTRY FORMAT:
5871                         *    +0...TOTAL SIZE OF ENTRY (INCLUDING THIS BYTE)
5872                         *    +1...COMMAND STRING
5873                         *    +N...TWO BYTE OFFSET TO COMMAND (ENTRYADDR-*)
5874                         *
5875                         * THE TABLES TERMINATE WITH A ONE BYTE -1 OR -2.
5876                         * THE -1 CONTINUES THE COMMAND SEARCH WITH THE
5877                         *        SECOND COMMAND TABLE.
5878                         * THE -2 TERMINATES COMMAND SEARCHES.
5879                         *****************************************************
5880                         
5881                         * THIS IS THE DEFAULT LIST FOR THE SECOND COMMAND
5882                         * LIST ENTRY.
5883                         
5884 f99b fe                 CMDTB2  FCB     -2              ; STOP COMMAND SEARCHES
5885                         
5886                         * THIS IS THE DEFAULT LIST FOR THE FIRST COMMAND
5887                         * LIST ENTRY.
5888                         
5889 f99c                    CMDTBL  EQU     *               ; MONITOR COMMAND TABLE
5890 f99c 04                         FCB     4
5891 f99d 42                         FCC     /B/             ; 'BREAKPOINT' COMMAND
5892 f99e 05 4d                      FDB     CBKPT-*
5893 f9a0 04                         FCB     4
5894 f9a1 43                         FCC     /C/             ; 'CALL' COMMAND
5895 f9a2 04 17                      FDB     CCALL-*
5896 f9a4 04                         FCB     4
5897 f9a5 44                         FCC     /D/             ; 'DISPLAY' COMMAND
5898 f9a6 04 9d                      FDB     CDISP-*
5899 f9a8 04                         FCB     4
5900 f9a9 45                         FCC     /E/             ; 'ENCODE' COMMAND
5901 f9aa 05 9f                      FDB     CENCDE-*
5902 f9ac 04                         FCB     4
5903 f9ad 47                         FCC     /G/             ; 'GO' COMMAND
5904 f9ae 03 d2                      FDB     CGO-*
5905 f9b0 04                         FCB     4
5906 f9b1 4c                         FCC     /L/             ; 'LOAD' COMMAND
5907 f9b2 04 dd                      FDB     CLOAD-*
5908 f9b4 04                         FCB     4
5909 f9b5 4d                         FCC     /M/             ; 'MEMORY' COMMAND
5910 f9b6 04 0d                      FDB     CMEM-*
5911 f9b8 04                         FCB     4
5912 f9b9 4e                         FCC     /N/             ; 'NULLS' COMMAND
5913 f9ba 04 fd                      FDB     CNULLS-*
5914 f9bc 04                         FCB     4
5915 f9bd 4f                         FCC     /O/             ; 'OFFSET' COMMAND
5916 f9be 05 0a                      FDB     COFFS-*
5917 f9c0 04                         FCB     4
5918 f9c1 50                         FCC     /P/             ; 'PUNCH' COMMAND
5919 f9c2 04 af                      FDB     CPUNCH-*
5920 f9c4 04                         FCB     4
5921 f9c5 52                         FCC     /R/             ; 'REGISTERS' COMMAND
5922 f9c6 02 84                      FDB     CREG-*
5923 f9c8 04                         FCB     4
5924 f9c9 53                         FCC     /S/             ; 'STLEVEL' COMMAND
5925 f9ca 04 f2                      FDB     CSTLEV-*
5926 f9cc 04                         FCB     4
5927 f9cd 54                         FCC     /T/             ; 'TRACE' COMMAND
5928 f9ce 04 d6                      FDB     CTRACE-*
5929 f9d0 04                         FCB     4
5930 f9d1 56                         FCC     /V/             ; 'VERIFY' COMMAND
5931 f9d2 04 cf                      FDB     CVER-*
5932 f9d4 04                         FCB     4
5933 f9d5 57                         FCC     /W/             ; 'WINDOW' COMMAND
5934 f9d6 04 68                      FDB     CWINDO-*
5935 f9d8 ff                         FCB     -1              ; END, CONTINUE WITH THE SECOND
5936                         
5937                         *************************************************
5938                         *             [SWI FUNCTIONS 4 AND 5]
5939                         *      4 - OUT2HS - DECODE BYTE TO HEX AND ADD SPACE
5940                         *      5 - OUT4HS - DECODE WORD TO HEX AND ADD SPACE
5941                         * INPUT: X->BYTE OR WORD TO DECODE
5942                         * OUTPUT: CHARACTERS SENT TO OUTPUT HANDLER
5943                         *         X->NEXT BYTE OR WORD
5944                         *************************************************
5945 f9d9 a6 80              ZOUT2H  LDA     ,X+             ; LOAD NEXT BYTE
5946 f9db 34 06                      PSHS    D               ; SAVE - DO NOT REREAD
5947 f9dd c6 10                      LDB     #16             ; SHIFT BY 4 BITS
5948 f9df 3d                         MUL                     ; WITH MULTIPLY
5949 f9e0 8d 04                      BSR     ZOUTHX          ; SEND OUT AS HEX
5950 f9e2 35 06                      PULS    D               ; RESTORE BYTES
5951 f9e4 84 0f                      ANDA    #$0F            ; ISOLATE RIGHT HEX
5952 f9e6 8b 90              ZOUTHX  ADDA    #$90            ; PREPARE A-F ADJUST
5953 f9e8 19                         DAA                     ; ADJUST
5954 f9e9 89 40                      ADCA    #$40            ; PREPARE CHARACTER BITS
5955 f9eb 19                         DAA                     ; ADJUST
5956 f9ec 6e 9d 66 ee        SEND    JMP     [VECTAB+.CODTA,PCR] ; SEND TO OUT HANDLER
5957                         
5958 f9f0 8d e7              ZOT4HS  BSR     ZOUT2H          ; CONVERT FIRST BYTE
5959 f9f2 8d e5              ZOT2HS  BSR     ZOUT2H          ; CONVERT BYTE TO HEX
5960 f9f4 af 64                      STX     4,S             ; UPDATE USERS X REGISTER
5961                         * FALL INTO SPACE ROUTINE
5962                         
5963                         *************************************************
5964                         *            [SWI FUNCTION 7]
5965                         *         SPACE - SEND BLANK TO OUTPUT HANDLER
5966                         * INPUT: NONE
5967                         * OUTPUT: BLANK SEND TO CONSOLE HANDLER
5968                         *************************************************
5969 f9f6 86 20              ZSPACE  LDA     #'              ; LOAD BLANK
5970 f9f8 20 3d                      BRA     ZOTCH2          ; SEND AND RETURN
5971                         
5972                         ***********************************************
5973                         *             [SWI FUNCTION 9]
5974                         *          SWAP VECTOR TABLE ENTRY
5975                         * INPUT: A=VECTOR TABLE CODE (OFFSET)
5976                         * X=0 OR REPLACEMENT VALUE
5977                         * OUTPUT: X=PREVIOUS VALUE
5978                         ***********************************************
5979 f9fa a6 61              ZVSWTH  LDA     1,S             ; LOAD REQUESTERS A
5980 f9fc 81 34                      CMPA    #HIVTR          ; ? SUB-CODE TOO HIGH
5981 f9fe 22 39                      BHI     ZOTCH3          ; IGNORE CALL IF SO
5982 fa00 10 9e c2                   LDY     <VECTAB+.AVTBL  ; LOAD VECTOR TABLE ADDRESS
5983 fa03 ee a6                      LDU     A,Y             ; U=OLD ENTRY
5984 fa05 ef 64                      STU     4,S             ; RETURN OLD VALUE TO CALLERS X
5985 fa07 af 7e                      STX     -2,S            ; ? X=0
5986 fa09 27 2e                      BEQ     ZOTCH3          ; YES, DO NOT CHANGE ENTRY
5987 fa0b af a6                      STX     A,Y             ; REPLACE ENTRY
5988 fa0d 20 2a                      BRA     ZOTCH3          ; RETURN FROM SWI
5989                         *D
5990                         
5991                         ************************************************
5992                         *               [SWI FUNCTION 0]
5993                         *  INCHNP - OBTAIN INPUT CHAR IN A (NO PARITY)
5994                         * NULLS AND RUBOUTS ARE IGNORED.
5995                         * AUTOMATIC LINE FEED IS SENT UPON RECEIVING A
5996                         * CARRIAGE RETURN.
5997                         * UNLESS WE ARE LOADING FROM TAPE.
5998                         ************************************************
5999 fa0f 8d 5d              ZINCHP  BSR     XQPAUS          ; RELEASE PROCESSOR
6000 fa11 8d 5f              ZINCH   BSR     XQCIDT          ; CALL INPUT DATA APPENDAGE
6001 fa13 24 fa                      BCC     ZINCHP          ; LOOP IF NONE AVAILABLE
6002 fa15 4d                         TSTA                    ; ? TEST FOR NULL
6003 fa16 27 f9                      BEQ     ZINCH           ; IGNORE NULL
6004 fa18 81 7f                      CMPA    #$7F            ; ? RUBOUT
6005 fa1a 27 f5                      BEQ     ZINCH           ; BRANCH YES TO IGNORE
6006 fa1c a7 61                      STA     1,S             ; STORE INTO CALLERS A
6007 fa1e 0d 8f                      TST     <MISFLG         ; ? LOAD IN PROGRESS
6008 fa20 26 17                      BNE     ZOTCH3          ; BRANCH IF SO TO NOT ECHO
6009 fa22 81 0d                      CMPA    #CR             ; ? CARRIAGE RETURN
6010 fa24 26 04                      BNE     ZIN2            ; NO, TEST ECHO BYTE
6011 fa26 86 0a                      LDA     #LF             ; LOAD LINE FEED
6012 fa28 8d c2                      BSR     SEND            ; ALWAYS ECHO LINE FEED
6013 fa2a 0d f4              ZIN2    TST     <VECTAB+.ECHO   ; ? ECHO DESIRED
6014 fa2c 26 0b                      BNE     ZOTCH3          ; NO, RETURN
6015                         * FALL THROUGH TO OUTCH
6016                         ************************************************
6017                         *            [SWI FUNCTION 1]
6018                         *        OUTCH - OUTPUT CHARACTER FROM A
6019                         * INPUT: NONE
6020                         * OUTPUT: IF LINEFEED IS THE OUTPUT CHARACTER THEN
6021                         * C=0 NO CTL-X RECEIVED, C=1 CTL-X RECEIVED
6022                         ************************************************
6023 fa2e a6 61              ZOTCH1  LDA     1,S             ; LOAD CHARACTER TO SEND
6024 fa30 30 8c 09                   LEAX    <ZPCRLS,PCR     ; DEFAULT FOR LINE FEED
6025 fa33 81 0a                      CMPA    #LF             ; ? LINE FEED
6026 fa35 27 0f                      BEQ     ZPDTLP          ; BRANCH TO CHECK PAUSE IF SO
6027 fa37 8d b3              ZOTCH2  BSR     SEND            ; SEND TO OUTPUT ROUTINE
6028 fa39 0c 90              ZOTCH3  INC     <SWICNT         ; BUMP UP "SWI" TRACE NEST LEVEL
6029 fa3b 3b                         RTI                     ; RETURN FROM "SWI" FUNCTION
6030                         
6031                         **************************************************
6032                         * [SWI FUNCTION 6]
6033                         * PCRLF - SEND CR/LF TO CONSOLE HANDLER
6034                         * INPUT: NONE
6035                         * OUTPUT: CR AND LF SENT TO HANDLER
6036                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
6037                         **************************************************
6038 fa3c 04                 ZPCRLS  FCB     EOT             ; NULL STRING
6039 fa3d 30 8c fc           ZPCRLF LEAX     ZPCRLS,PCR      ; READY CR,LF STRING
6040                         * FALL INTO CR/LF CODE
6041                         
6042                         **************************************************
6043                         * [SWI FUNCTION 3]
6044                         * PDATA - OUTPUT CR/LF AND STRING
6045                         * INPUT: X->STRING
6046                         * OUTPUT: CR/LF AND STRING SENT TO OUTPUT CONSOLE
6047                         * HANDLER.
6048                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
6049                         * NOTE: LINE FEED MUST FOLLOW CARRIAGE RETURN FOR
6050                         * PROPER PUNCH DATA.
6051                         **************************************************
6052                         
6053 fa40 86 0d              ZPDATA  LDA     #CR             ; LOAD CARRIAGE RETURN
6054 fa42 8d a8                      BSR     SEND            ; SEND IT
6055 fa44 86 0a                      LDA     #LF             ; LOAD LINE FEED
6056                         * FALL INTO PDATA1
6057                         
6058                         *************************************************
6059                         * [SWI FUNCTION 2]
6060                         * PDATA1 - OUTPUT STRING TILL EOT ($04)
6061                         * THIS ROUTINE PAUSES IF AN INPUT BYTE BECOMES
6062                         * AVAILABLE DURING OUTPUT TRANSMISSION UNTIL A
6063                         * SECOND IS RECEIVED.
6064                         * INPUT: X->STRING
6065                         * OUTPUT: STRING SENT TO OUTPUT CONSOLE DRIVER
6066                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
6067                         *************************************************
6068                         
6069 fa46 8d a4              ZPDTLP  BSR     SEND            ; SEND CHARACTER TO DRIVER
6070 fa48 a6 80              ZPDTA1  LDA     ,X+             ; LOAD NEXT CHARACTER
6071 fa4a 81 04                      CMPA    #EOT            ; ? EOT
6072 fa4c 26 f8                      BNE     ZPDTLP          ; LOOP IF NOT
6073                         * FALL INTO PAUSE CHECK FUNCTION
6074                         
6075                         ********************************************
6076                         * [SWI FUNCTION 12]
6077                         * PAUSE - RETURN TO TASK DISPATCHING AND CHECK
6078                         * FOR FREEZE CONDITION OR CTL-X BREAK
6079                         * THIS FUNCTION ENTERS THE TASK PAUSE HANDLER SO
6080                         * OPTIONALLY OTHER 6809 PROCESSES MAY GAIN CONTROL.
6081                         * UPON RETURN, CHECK FOR A 'FREEZE' CONDITION
6082                         * WITH A RESULTING WAIT LOOP, OR CONDITION CODE
6083                         * RETURN IF A CONTROL-X IS ENTERED FROM THE INPUT
6084                         * HANDLER.
6085                         * OUTPUT: C=1 IF CTL-X HAS ENTERED, C=0 OTHERWISE
6086                         ******************************************
6087                         
6088 fa4e 8d 1e              ZPAUSE  BSR     XQPAUS          ; RELEASE CONTROL AT EVERY LINE
6089 fa50 8d 06                      BSR     CHKABT          ; CHECK FOR FREEZE OR ABORT
6090 fa52 1f a9                      TFR     CC,B            ; PREPARE TO REPLACE CC
6091 fa54 e7 e4                      STB     ,S              ; OVERLAY OLD ONE ON STACK
6092 fa56 20 e1                      BRA     ZOTCH3          ; RETURN FROM "SWI"
6093                         
6094                         * CHKABT - SCAN FOR INPUT PAUSE/ABORT DURING OUTPUT
6095                         * OUTPUT: C=0 OK, C=1 ABORT (CTL-X ISSUED)
6096                         * VOLATILE: U,X,D
6097 fa58 8d 18              CHKABT  BSR     XQCIDT          ; ATTEMPT INPUT
6098 fa5a 24 05                      BCC     CHKRTN          ; BRANCH NO TO RETURN
6099 fa5c 81 18                      CMPA    #CAN            ; ? CTL-X FOR ABORT
6100 fa5e 26 02                      BNE     CHKWT           ; BRANCH NO TO PAUSE
6101 fa60 53                 CHKSEC  COMB                    ; SET CARRY
6102 fa61 39                 CHKRTN  RTS                     ; RETURN TO CALLER WITH CC SET
6103 fa62 8d 0a              CHKWT   BSR     XQPAUS          ; PAUSE FOR A MOMENT
6104 fa64 8d 0c                      BSR     XQCIDT          ; ? KEY FOR START
6105 fa66 24 fa                      BCC     CHKWT           ; LOOP UNTIL RECEIVED
6106 fa68 81 18                      CMPA    #CAN            ; ? ABORT SIGNALED FROM WAIT
6107 fa6a 27 f4                      BEQ     CHKSEC          ; BRANCH YES
6108 fa6c 4f                         CLRA                    ; SET C=0 FOR NO ABORT
6109 fa6d 39                         RTS                     ; AND RETURN
6110                         
6111                         * SAVE MEMORY WITH JUMPS
6112 fa6e 6e 9d 66 78        XQPAUS  JMP   [VECTAB+.PAUSE,PCR] ; TO PAUSE ROUTINE
6113 fa72 ad 9d 66 62        XQCIDT  JSR   [VECTAB+.CIDTA,PCR] ; TO INPUT ROUTINE
6114 fa76 84 7f                      ANDA  #$7F              ; STRIP PARITY
6115 fa78 39                         RTS                     ; RETURN TO CALLER
6116                         
6117                         ********************************************
6118                         * NMI DEFAULT INTERRUPT HANDLER
6119                         * THE NMI HANDLER IS USED FOR TRACING INSTRUCTIONS.
6120                         * TRACE PRINTOUTS OCCUR ONLY AS LONG AS THE STACK
6121                         * TRACE LEVEL IS NOT BREACHED BY FALLING BELOW IT.
6122                         * TRACING CONTINUES UNTIL THE COUNT TURNS ZERO OR
6123                         * A CTL-X IS ENTERED FROM THE INPUT CONSOLE DEVICE.
6124                         *********************************************
6125                         
6126 fa79 4f 50 2d 04        MSHOWP  FCB     'O,'P,'-,EOT    ; OPCODE PREP
6127                         
6128 fa7d 8d 42              NMIR    BSR     LDDP            ; LOAD PAGE AND VERIFY STACK
6129 fa7f 0d 8f                      TST     <MISFLG         ; ? THRU A BREAKPOINT
6130 fa81 26 34                      BNE     NMICON          ; BRANCH IF SO TO CONTINUE
6131 fa83 0d 90                      TST     <SWICNT         ; ? INHIBIT "SWI" DURING TRACE
6132 fa85 2b 29                      BMI     NMITRC          ; BRANCH YES
6133 fa87 30 6c                      LEAX    12,S            ; OBTAIN USERS STACK POINTER
6134 fa89 9c f8                      CMPX    <SLEVEL         ; ? TO TRACE HERE
6135 fa8b 25 23                      BLO     NMITRC          ; BRANCH IF TOO LOW TO DISPLAY
6136 fa8d 30 8c e9                   LEAX    MSHOWP,PCR      ; LOAD OP PREP
6137 fa90 3f                         SWI                     ; SEND TO CONSOLE
6138 fa91 02                         FCB     PDATA1          ; FUNCTION
6139 fa92 09 8e                      ROL     <DELIM          ; SAVE CARRY BIT
6140 fa94 30 8d 66 01                LEAX    LASTOP,PCR      ; POINT TO LAST OP
6141 fa98 3f                         SWI                     ; SEND OUT AS HEX
6142 fa99 05                         FCB     OUT4HS          ; FUNCTION
6143 fa9a 8d 17                      BSR     REGPRS          ; FOLLOW MEMORY WITH REGISTERS
6144 fa9c 25 37                      BCS     ZBKCMD          ; BRANCH IF "CANCEL"
6145 fa9e 06 8e                      ROR     <DELIM          ; RESTORE CARRY BIT
6146 faa0 25 33                      BCS     ZBKCMD          ; BRANCH IF "CANCEL"
6147 faa2 9e 91                      LDX     <TRACEC         ; LOAD TRACE COUNT
6148 faa4 27 2f                      BEQ     ZBKCMD          ; IF ZERO TO COMMAND HANDLER
6149 faa6 30 1f                      LEAX    -1,X            ; MINUS ONE
6150 faa8 9f 91                      STX     <TRACEC         ; REFRESH
6151 faaa 27 29                      BEQ     ZBKCMD          ; STOP TRACE WHEN ZERO
6152 faac 8d aa                      BSR     CHKABT          ; ? ABORT THE TRACE
6153 faae 25 25                      BCS     ZBKCMD          ; BRANCH YES TO COMMAND HANDLER
6154 fab0 16 03 f7           NMITRC  LBRA    CTRCE3          ; NO, TRACE ANOTHER INSTRUCTION
6155                         
6156 fab3 17 01 b9           REGPRS  LBSR    REGPRT          ; PRINT REGISTERS AS FROM COMMAND
6157 fab6 39                         RTS                     ; RETURN TO CALLER
6158                         
6159                         * JUST EXECUTED THRU A BRKPNT. NOW CONTINUE NORMALLY
6160                         
6161 fab7 0f 8f              NMICON  CLR     <MISFLG        ; CLEAR THRU FLAG
6162 fab9 17 02 eb                   LBSR    ARMBK2         ; ARM BREAKPOINTS
6163 fabc 3b                 RTI     RTI                    ; AND CONTINUE USERS PROGRAM
6164                         
6165                         * LDDP - SETUP DIRECT PAGE REGISTER, VERIFY STACK.
6166                         * AN INVALID STACK CAUSES A RETURN TO THE COMMAND
6167                         * HANDLER.
6168                         * INPUT: FULLY STACKED REGISTERS FROM AN INTERRUPT
6169                         * OUTPUT: DPR LOADED TO WORK PAGE
6170                         
6171 fabd 3f 07 20 04        ERRMSG  FCB     '?,BELL,$20,EOT ; ERROR RESPONSE
6172                         
6173 fac1 e6 8d 65 d8        LDDP    LDB     BASEPG,PCR      ; LOAD DIRECT PAGE HIGH BYTE
6174 fac5 1f 9b                      TFR     B,DP            ; SETUP DIRECT PAGE REGISTER
6175 fac7 a1 63                      CMPA    3,S             ; ? IS STACK VALID
6176 fac9 27 25                      BEQ     RTS             ; YES, RETURN
6177 facb 10 de 97                   LDS     <RSTACK         ; RESET TO INITIAL STACK POINTER
6178 face 30 8c ec           ERROR   LEAX    ERRMSG,PCR      ; LOAD ERROR REPORT
6179 fad1 3f                         SWI                     ; SEND OUT BEFORE REGISTERS
6180 fad2 03                         FCB     PDATA           ; ON NEXT LINE
6181                         * FALL INTO BREAKPOINT HANDLER
6182                         
6183                         **********************************************
6184                         * [SWI FUNCTION 10]
6185                         * BREAKPOINT PROGRAM FUNCTION
6186                         * PRINT REGISTERS AND GO TO COMMAND HANLER
6187                         ***********************************************
6188                         
6189 fad3 8d de              ZBKPNT  BSR     REGPRS          ; PRINT OUT REGISTERS
6190 fad5 16 fe 21           ZBKCMD  LBRA    CMDNEP          ; NOW ENTER COMMAND HANDLER
6191                         
6192                         ********************************************
6193                         * IRQ, RESERVED, SWI2 AND SWI3 INTERRUPT HANDLERS
6194                         * THE DEFAULT HANDLING IS TO CAUSE A BREAKPOINT.
6195                         ********************************************
6196 fad8                    SWI2R   EQU     *               ; SWI2 ENTRY
6197 fad8                    SWI3R   EQU     *               ; SWI3 ENTRY
6198 fad8                    IRQR    EQU     *               ; IRQ ENTRY
6199 fad8 8d e7              RSRVDR  BSR     LDDP            ; SET BASE PAGE, VALIDATE STACK
6200 fada 20 f7                      BRA     ZBKPNT          ; FORCE A BREAKPOINT
6201                         
6202                         ******************************************
6203                         * FIRQ HANDLER
6204                         * JUST RETURN FOR THE FIRQ INTERRUPT
6205                         ******************************************
6206 fabc                    FIRQR   EQU     RTI             ; IMMEDIATE RETURN
6207                         
6208                         **************************************************
6209                         * DEFAULT I/O DRIVERS
6210                         **************************************************
6211                         * CIDTA - RETURN CONSOLE INPUT CHARACTER
6212                         * OUTPUT: C=0 IF NO DATA READY, C=1 A=CHARACTER
6213                         * U VOLATILE
6214                         
6215 fadc de f0              CIDTA   LDU     <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
6216 fade a6 c4                      LDA     ,U              ; LOAD STATUS REGISTER
6217 fae0 44                         LSRA                    ; TEST RECEIVER REGISTER FLAG
6218 fae1 24 02                      BCC     CIRTN           ; RETURN IF NOTHING
6219 fae3 a6 41                      LDA     1,U             ; LOAD DATA BYTE
6220 fae5 39                 CIRTN   RTS                     ; RETURN TO CALLER
6221                         
6222                         * CION - INPUT CONSOLE INITIALIZATION
6223                         * COON - OUTPUT CONSOLE INITIALIZATION
6224                         * A,X VOLATILE
6225 fae6                    CION   EQU      *
6226 fae6 86 13              COON   LDA      #$13            ; RESET ACIA CODE
6227 fae8 9e f0                     LDX      <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
6228 faea a7 84                     STA      ,X              ; STORE INTO STATUS REGISTER
6229 faec 86 15                     LDA      #$15            ; SET CONTROL
6230 faee a7 84                     STA      ,X              ; REGISTER UP
6231 faf0 39                 RTS    RTS                      ; RETURN TO CALLER
6232                         
6233                         * THE FOLLOWING HAVE NO DUTIES TO PERFORM
6234 faf0                    CIOFF EQU       RTS             ; CONSOLE INPUT OFF
6235 faf0                    COOFF EQU       RTS             ; CONSOLE OUTPUT OFF
6236                         
6237                         * CODTA - OUTPUT CHARACTER TO CONSOLE DEVICE
6238                         * INPUT: A=CHARACTER TO SEND
6239                         * OUTPUT: CHAR SENT TO TERMINAL WITH PROPER PADDING
6240                         * ALL REGISTERS TRANSPARENT
6241                         
6242 faf1 34 47              CODTA   PSHS    U,D,CC          ; SAVE REGISTERS,WORK BYTE
6243 faf3 de f0                      LDU     <VECTAB+.ACIA   ; ADDRESS ACIA
6244 faf5 8d 1b                      BSR     CODTAO          ; CALL OUTPUT CHAR SUBROUTINE
6245 faf7 81 10                      CMPA    #DLE            ; ? DATA LINE ESCAPE
6246 faf9 27 12                      BEQ     CODTRT          ; YES, RETURN
6247 fafb d6 f2                      LDB     <VECTAB+.PAD    ; DEFAULT TO CHAR PAD COUNT
6248 fafd 81 0d                      CMPA    #CR             ; ? CR
6249 faff 26 02                      BNE     CODTPD          ; BRANCH NO
6250 fb01 d6 f3                      LDB     <VECTAB+.PAD+1  ; LOAD NEW LINE PAD COUNT
6251 fb03 4f                 CODTPD  CLRA                    ; CREATE NULL
6252 fb04 e7 e4                      STB     ,S              ; SAVE COUNT
6253 fb06 8c                         FCB     SKIP2           ; ENTER LOOP
6254 fb07 8d 09              CODTLP  BSR     CODTAO          ; SEND NULL
6255 fb09 6a e4                      DEC     ,S              ; ? FINISHED
6256 fb0b 2a fa                      BPL     CODTLP          ; NO, CONTINUE WITH MORE
6257 fb0d 35 c7              CODTRT  PULS    PC,U,D,CC       ; RESTORE REGISTERS AND RETURN
6258                         
6259 fb0f 17 ff 5c           CODTAD  LBSR    XQPAUS          ; TEMPORARY GIVE UP CONTROL
6260 fb12 e6 c4              CODTAO  LDB     ,U              ; LOAD ACIA CONTROL REGISTER
6261 fb14 c5 02                      BITB    #$02            ; ? TX REGISTER CLEAR >LSAB FIXME
6262 fb16 27 f7                      BEQ     CODTAD          ; RELEASE CONTROL IF NOT
6263 fb18 a7 41                      STA     1,U             ; STORE INTO DATA REGISTER
6264 fb1a 39                         RTS                     ; RETURN TO CALLER
6265                         *E
6266                         
6267                         * BSON - TURN ON READ/VERIFY/PUNCH MECHANISM
6268                         * A IS VOLATILE
6269                         
6270 fb1b 86 11              BSON    LDA     #$11            ; SET READ CODE
6271 fb1d 6d 66                      TST     6,S             ; ? READ OR VERIFY
6272 fb1f 26 01                      BNE     BSON2           ; BRANCH YES
6273 fb21 4c                         INCA                    ; SET TO WRITE
6274 fb22 3f                 BSON2   SWI                     ; PERFORM OUTPUT
6275 fb23 01                         FCB     OUTCH           ; FUNCTION
6276 fb24 0c 8f                      INC     <MISFLG         ; SET LOAD IN PROGRESS FLAG
6277 fb26 39                         RTS                     ; RETURN TO CALLER
6278                         
6279                         * BSOFF - TURN OFF READ/VERIFY/PUNCH MECHANISM
6280                         * A,X VOLATILE
6281                         
6282 fb27 86 14              BSOFF   LDA     #$14            ; TO DC4 - STOP
6283 fb29 3f                         SWI                     ; SEND OUT
6284 fb2a 01                         FCB     OUTCH           ; FUNCTION
6285 fb2b 4a                         DECA                    ; CHANGE TO DC3 (X-OFF)
6286 fb2c 3f                         SWI                     ; SEND OUT
6287 fb2d 01                         FCB     OUTCH           ; FUNCTION
6288 fb2e 0a 8f                      DEC     <MISFLG         ; CLEAR LOAD IN PROGRESS FLAG
6289 fb30 8e 61 a8                   LDX     #25000          ; DELAY 1 SECOND (2MHZ CLOCK)
6290 fb33 30 1f              BSOFLP  LEAX    -1,X            ; COUNT DOWN
6291 fb35 26 fc                      BNE     BSOFLP          ; LOOP TILL DONE
6292 fb37 39                         RTS                     ; RETURN TO CALLER
6293                         
6294                         * BSDTA - READ/VERIFY/PUNCH HANDLER
6295                         * INPUT: S+6=CODE BYTE, VERIFY(-1),PUNCH(0),LOAD(1)
6296                         * S+4=START ADDRESS
6297                         * S+2=STOP ADDRESS
6298                         * S+0=RETURN ADDRESS
6299                         * OUTPUT: Z=1 NORMAL COMPLETION, Z=0 INVALID LOAD/VER
6300                         * REGISTERS ARE VOLATILE
6301 fb38 ee 62              BSDTA   LDU     2,S             ; U=TO ADDRESS OR OFFSET
6302 fb3a 6d 66                      TST     6,S             ; ? PUNCH
6303 fb3c 27 54                      BEQ     BSDPUN          ; BRANCH YES
6304                         
6305                         * DURING READ/VERIFY: S+2=MSB ADDRESS SAVE BYTE
6306                         * S+1=BYTE COUNTER
6307                         * S+0=CHECKSUM
6308                         * U HOLDS OFFSET
6309 fb3e 32 7d                      LEAS    -3,S            ; ROOM FOR WORK/COUNTER/CHECKSUM
6310 fb40 3f                 BSDLD1  SWI                     ; GET NEXT CHARACTER
6311 fb41 00                         FCB     INCHNP          ; FUNCTION
6312 fb42 81 53              BSDLD2  CMPA    #'S             ; ? START OF S1/S9
6313 fb44 26 fa                      BNE     BSDLD1          ; BRANCH NOT
6314 fb46 3f                         SWI                     ; GET NEXT CHARACTER
6315 fb47 00                         FCB     INCHNP          ; FUNCTION
6316 fb48 81 39                      CMPA    #'9             ; ? HAVE S9
6317 fb4a 27 22                      BEQ     BSDSRT          ; YES, RETURN GOOD CODE
6318 fb4c 81 31                      CMPA    #'1             ; ? HAVE NEW RECORD
6319 fb4e 26 f2                      BNE     BSDLD2          ; BRANCH IF NOT
6320 fb50 6f e4                      CLR     ,S              ; CLEAR CHECKSUM
6321 fb52 8d 21                      BSR     BYTE            ; OBTAIN BYTE COUNT
6322 fb54 e7 61                      STB     1,S             ; SAVE FOR DECREMENT
6323                         
6324                         * READ ADDRESS
6325 fb56 8d 1d                      BSR     BYTE            ; OBTAIN HIGH VALUE
6326 fb58 e7 62                      STB     2,S             ; SAVE IT
6327 fb5a 8d 19                      BSR     BYTE            ; OBTAIN LOW VALUE
6328 fb5c a6 62                      LDA     2,S             ; MAKE D=VALUE
6329 fb5e 31 cb                      LEAY    D,U             ; Y=ADDRESS+OFFSET
6330                         * STORE TEXT
6331 fb60 8d 13              BSDNXT  BSR     BYTE            ; NEXT BYTE
6332 fb62 27 0c                      BEQ     BSDEOL          ; BRANCH IF CHECKSUM
6333 fb64 6d 69                      TST     9,S             ; ? VERIFY ONLY
6334 fb66 2b 02                      BMI     BSDCMP          ; YES, ONLY COMPARE
6335 fb68 e7 a4                      STB     ,Y              ; STORE INTO MEMORY
6336 fb6a e1 a0              BSDCMP  CMPB    ,Y+             ; ? VALID RAM
6337 fb6c 27 f2                      BEQ     BSDNXT          ; YES, CONTINUE READING
6338 fb6e 35 92              BSDSRT  PULS    PC,X,A          ; RETURN WITH Z SET PROPER
6339 fb70 4c                 BSDEOL  INCA                    ; ? VALID CHECKSUM
6340 fb71 27 cd                      BEQ     BSDLD1          ; BRANCH YES
6341 fb73 20 f9                      BRA     BSDSRT          ; RETURN Z=0 INVALID
6342                         
6343                         * BYTE BUILDS 8 BIT VALUE FROM TWO HEX DIGITS IN
6344 fb75 8d 12              BYTE    BSR     BYTHEX         ; OBTAIN FIRST HEX
6345 fb77 c6 10                      LDB     #16            ; PREPARE SHIFT
6346 fb79 3d                         MUL                    ; OVER TO A
6347 fb7a 8d 0d                      BSR     BYTHEX         ; OBTAIN SECOND HEX
6348 fb7c 34 04                      PSHS    B              ; SAVE HIGH HEX
6349 fb7e ab e0                      ADDA    ,S+            ; COMBINE BOTH SIDES
6350 fb80 1f 89                      TFR     A,B            ; SEND BACK IN B
6351 fb82 ab 62                      ADDA    2,S            ; COMPUTE NEW CHECKSUM
6352 fb84 a7 62                      STA     2,S            ; STORE BACK
6353 fb86 6a 63                      DEC     3,S            ; DECREMENT BYTE COUNT
6354 fb88 39                 BYTRTS  RTS                    ; RETURN TO CALLER
6355                         
6356 fb89 3f                 BYTHEX  SWI                    ; GET NEXT HEX
6357 fb8a 00                         FCB     INCHNP         ; CHARACTER
6358 fb8b 17 01 d4                   LBSR    CNVHEX         ; CONVERT TO HEX
6359 fb8e 27 f8                      BEQ     BYTRTS         ; RETURN IF VALID HEX
6360 fb90 35 f2                      PULS    PC,U,Y,X,A     ; RETURN TO CALLER WITH Z=0
6361                         
6362                         * PUNCH STACK USE: S+8=TO ADDRESS
6363                         *                  S+6=RETURN ADDRESS
6364                         *                  S+4=SAVED PADDING VALUES
6365                         *                  S+2 FROM ADDRESS
6366                         *                  S+1=FRAME COUNT/CHECKSUM
6367                         *                  S+0=BYTE COUNT
6368                         
6369 fb92 de f2              BSDPUN  LDU     <VECTAB+.PAD    ; LOAD PADDING VALUES
6370 fb94 ae 64                      LDX     4,S             ; X=FROM ADDRESS
6371 fb96 34 56                      PSHS    U,X,D           ; CREATE STACK WORK AREA
6372 fb98 cc 00 18                   LDD     #24             ; SET A=0, B=24
6373 fb9b d7 f2                      STB     <VECTAB+.PAD    ; SETUP 24 CHARACTER PADS
6374 fb9d 3f                         SWI                     ; SEND NULLS OUT
6375 fb9e 01                         FCB     OUTCH           ; FUNCTION
6376 fb9f c6 04                      LDB     #4              ; SETUP NEW LINE PAD TO 4
6377 fba1 dd f2                      STD     <VECTAB+.PAD    ; SETUP PUNCH PADDING
6378                         * CALCULATE SIZE
6379 fba3 ec 68              BSPGO   LDD     8,S             ; LOAD TO
6380 fba5 a3 62                      SUBD    2,S             ; MINUS FROM=LENGTH
6381 fba7 10 83 00 18                CMPD    #24             ; ? MORE THAN 23
6382 fbab 25 02                      BLO     BSPOK           ; NO, OK
6383 fbad c6 17                      LDB     #23             ; FORCE TO 23 MAX
6384 fbaf 5c                 BSPOK   INCB                    ; PREPARE COUNTER
6385 fbb0 e7 e4                      STB     ,S              ; STORE BYTE COUNT
6386 fbb2 cb 03                      ADDB    #3              ; ADJUST TO FRAME COUNT
6387 fbb4 e7 61                      STB     1,S             ; SAVE
6388                         
6389                         *PUNCH CR,LF,NULS,S,1
6390 fbb6 30 8c 33                  LEAX     <BSPSTR,PCR     ; LOAD START RECORD HEADER
6391 fbb9 3f                        SWI                      ; SEND OUT
6392 fbba 03                        FCB      PDATA           ; FUNCTION
6393                         * SEND FRAME COUNT
6394 fbbb 5f                        CLRB                     ; INITIALIZE CHECKSUM
6395 fbbc 30 61                     LEAX     1,S             ; POINT TO FRAME COUNT AND ADDR
6396 fbbe 8d 27                     BSR      BSPUN2          ; SEND FRAME COUNT
6397                         *DATA ADDRESS
6398 fbc0 8d 25                    BSR       BSPUN2          ; SEND ADDRESS HI
6399 fbc2 8d 23                    BSR       BSPUN2          ; SEND ADDRESS LOW
6400                         *PUNCH DATA
6401 fbc4 ae 62                     LDX      2,S             ; LOAD START DATA ADDRESS
6402 fbc6 8d 1f              BSPMRE BSR      BSPUN2          ; SEND OUT NEXT BYTE
6403 fbc8 6a e4                     DEC      ,S              ; ? FINAL BYTE
6404 fbca 26 fa                     BNE      BSPMRE          ; LOOP IF NOT DONE
6405 fbcc af 62                     STX      2,S             ; UPDATE FROM ADDRESS VALUE
6406                         *PUNCH CHECKSUM
6407 fbce 53                        COMB                     ; COMPLEMENT
6408 fbcf e7 61                     STB      1,S             ; STORE FOR SENDOUT
6409 fbd1 30 61                     LEAX     1,S             ; POINT TO IT
6410 fbd3 8d 14                     BSR      BSPUNC          ; SEND OUT AS HEX
6411 fbd5 ae 68                     LDX      8,S             ; LOAD TOP ADDRESS
6412 fbd7 ac 62                     CMPX     2,S             ; ? DONE
6413 fbd9 24 c8                     BHS      BSPGO           ; BRANCH NOT
6414 fbdb 30 8c 11                  LEAX     <BSPEOF,PCR     ; PREPARE END OF FILE
6415 fbde 3f                        SWI                      ; SEND OUT STRING
6416 fbdf 03                        FCB      PDATA           ; FUNCTION
6417 fbe0 ec 64                     LDD      4,S             ; RECOVER PAD COUNTS
6418 fbe2 dd f2                     STD      <VECTAB+.PAD    ; RESTORE
6419 fbe4 4f                        CLRA                     ; SET Z=1 FOR OK RETURN
6420 fbe5 35 d6                     PULS     PC,U,X,D        ; RETURN WITH OK CODE
6421 fbe7 eb 84              BSPUN2 ADDB     ,X              ; ADD TO CHECKSUM
6422 fbe9 16 fd ed           BSPUNC LBRA     ZOUT2H          ; SEND OUT AS HEX AND RETURN
6423                         
6424 fbec 53 01 04           BSPSTR FCB      'S,1,EOT        ; CR,LF,NULLS,S,1
6425 fbef 53 39 30 33 30 30  BSPEOF FCC      /S9030000FC/         ; EOF STRING
     30 30 46 43
6426 fbf9 0d 0a 04                  FCB      CR,LF,EOT
6427                         
6428                         * HSDTA - HIGH SPEED PRINT MEMORY
6429                         * INPUT: S+4=START ADDRESS
6430                         * S+2=STOP ADDRESS
6431                         * S+0=RETURN ADDRESS
6432                         * X,D VOLATILE
6433                         
6434                         * SEND TITLE
6435                         
6436 fbfc 3f                 HSDTA   SWI                     ; SEND NEW LINE
6437 fbfd 06                         FCB     PCRLF           ; FUNCTION
6438 fbfe c6 06                      LDB     #6              ; PREPARE 6 SPACES
6439 fc00 3f                 HSBLNK  SWI                     ; SEND BLANK
6440 fc01 07                         FCB     SPACEF          ; FUNCTION
6441 fc02 5a                         DECB                    ; COUNT DOWN
6442 fc03 26 fb                      BNE     HSBLNK          ; LOOP IF MORE
6443 fc05 5f                         CLRB                    ; SETUP BYTE COUNT
6444 fc06 1f 98              HSHTTL  TFR     B,A             ; PREPARE FOR CONVERT
6445 fc08 17 fd db                   LBSR    ZOUTHX          ; CONVERT TO A HEX DIGIT
6446 fc0b 3f                         SWI                     ; SEND BLANK
6447 fc0c 07                         FCB     SPACEF          ; FUNCTION
6448 fc0d 3f                         SWI                     ; SEND ANOTHER
6449 fc0e 07                         FCB     SPACEF          ; BLANK
6450 fc0f 5c                         INCB                    ; UP ANOTHER
6451 fc10 c1 10                      CMPB    #$10            ; ? PAST 'F'
6452 fc12 25 f2                      BLO     HSHTTL          ; LOOP UNTIL SO
6453 fc14 3f                 HSHLNE  SWI                     ; TO NEXT LINE
6454 fc15 06                         FCB     PCRLF           ; FUNCTION
6455 fc16 25 2f                      BCS     HSDRTN          ; RETURN IF USER ENTERED CTL-X
6456 fc18 30 64                      LEAX    4,S             ; POINT AT ADDRESS TO CONVERT
6457 fc1a 3f                         SWI                     ; PRINT OUT ADDRESS
6458 fc1b 05                         FCB     OUT4HS          ; FUNCTION
6459 fc1c ae 64                      LDX     4,S             ; LOAD ADDRESS PROPER
6460 fc1e c6 10                      LDB     #16             ; NEXT SIXTEEN
6461 fc20 3f                 HSHNXT  SWI                     ; CONVERT BYTE TO HEX AND SEND
6462 fc21 04                         FCB     OUT2HS          ; FUNCTION
6463 fc22 5a                         DECB                    ; COUNT DOWN
6464 fc23 26 fb                      BNE     HSHNXT          ; LOOP IF NOT SIXTEENTH
6465 fc25 3f                         SWI                     ; SEND BLANK
6466 fc26 07                         FCB     SPACEF          ; FUNCTION
6467 fc27 ae 64                      LDX     4,S             ; RELOAD FROM ADDRESS
6468 fc29 c6 10                      LDB     #16             ; COUNT
6469 fc2b a6 80              HSHCHR  LDA     ,X+             ; NEXT BYTE
6470 fc2d 2b 04                      BMI     HSHDOT          ; TOO LARGE, TO A DOT
6471 fc2f 81 20                      CMPA    #'              ; ? LOWER THAN A BLANK
6472 fc31 24 02                      BHS     HSHCOK          ; NO, BRANCH OK
6473 fc33 86 2e              HSHDOT  LDA     #'.             ; CONVERT INVALID TO A BLANK
6474 fc35 3f                 HSHCOK  SWI                     ; SEND CHARACTER
6475 fc36 01                         FCB     OUTCH           ; FUNCTION
6476 fc37 5a                         DECB                    ; ? DONE
6477 fc38 26 f1                      BNE     HSHCHR          ; BRANCH NO
6478 fc3a ac 62                      CPX     2,S             ; ? PAST LAST ADDRESS
6479 fc3c 24 09                      BHS     HSDRTN          ; QUIT IF SO
6480 fc3e af 64                      STX     4,S             ; UPDATE FROM ADDRESS
6481 fc40 a6 65                      LDA     5,S             ; LOAD LOW BYTE ADDRESS
6482 fc42 48                         ASLA                    ; ? TO SECTION BOUNDARY
6483 fc43 26 cf                      BNE     HSHLNE          ; BRANCH IF NOT
6484 fc45 20 b5                      BRA     HSDTA           ; BRANCH IF SO
6485 fc47 3f                 HSDRTN  SWI                     ; SEND NEW LINE
6486 fc48 06                         FCB     PCRLF           ; FUNCTION
6487 fc49 39                         RTS                     ; RETURN TO CALLER
6488                         *F
6489                         
6490                         ***********************************************
6491                         *     A S S I S T 0 9    C O M M A N D S
6492                         ***********************************************
6493                         
6494                         *************REGISTERS - DISPLAY AND CHANGE REGISTERS
6495 fc4a 8d 23              CREG    BSR     REGPRT          ; PRINT REGISTERS
6496 fc4c 4c                         INCA                    ; SET FOR CHANGE FUNCTION
6497 fc4d 8d 21                      BSR     REGCHG          ; GO CHANGE, DISPLAY REGISTERS
6498 fc4f 39                         RTS                     ; RETURN TO COMMAND PROCESSOR
6499                         
6500                         ********************************************
6501                         * REGPRT - PRINT/CHANGE REGISTERS SUBROUTINE
6502                         * WILL ABORT TO 'CMDBAD' IF OVERFLOW DETECTED DURING
6503                         * A CHANGE OPERATION. CHANGE DISPLAYS REGISTERS WHEN
6504                         * DONE.
6505                         
6506                         * REGISTER MASK LIST CONSISTS OF:
6507                         * A) CHARACTERS DENOTING REGISTER
6508                         * B) ZERO FOR ONE BYTE, -1 FOR TWO
6509                         * C) OFFSET ON STACK TO REGISTER POSITION
6510                         * INPUT: SP+4=STACKED REGISTERS
6511                         * A=0 PRINT, A#0 PRINT AND CHANGE
6512                         * OUTPUT: (ONLY FOR REGISTER DISPLAY)
6513                         * C=1 CONTROL-X ENTERED, C=0 OTHERWISE
6514                         * VOLATILE: D,X (CHANGE)
6515                         * B,X (DISPLAY)
6516                         *******************************************
6517                         
6518 fc50 50 43 ff 13        REGMSK  FCB     'P,'C,-1,19     ; PC REG
6519 fc54 41 00 0a                   FCB     'A,0,10         ; A REG
6520 fc57 42 00 0b                   FCB     'B,0,11         ; B REG
6521 fc5a 58 ff 0d                   FCB     'X,-1,13        ; X REG
6522 fc5d 59 ff 0f                   FCB     'Y,-1,15        ; Y REG
6523 fc60 55 ff 11                   FCB     'U,-1,17        ; U REG
6524 fc63 53 ff 01                   FCB     'S,-1,1         ; S REG
6525 fc66 43 43 00 09                FCB     'C,'C,0,9       ; CC REG
6526 fc6a 44 50 00 0c                FCB     'D,'P,0,12      ; DP REG
6527 fc6e 00                         FCB     0               ; END OF LIST
6528                         
6529 fc6f 4f                 REGPRT  CLRA                    ; SETUP PRINT ONLY FLAG
6530 fc70 30 e8 10           REGCHG  LEAX    4+12,S          ; READY STACK VALUE
6531 fc73 34 32                      PSHS    Y,X,A           ; SAVE ON STACK WITH OPTION
6532 fc75 31 8c d8                   LEAY    REGMSK,PCR      ; LOAD REGISTER MASK
6533 fc78 ec a0              REGP1   LDD     ,Y+             ; LOAD NEXT CHAR OR <=0
6534 fc7a 4d                         TSTA                    ; ? END OF CHARACTERS
6535 fc7b 2f 04                      BLE     REGP2           ; BRANCH NOT CHARACTER
6536 fc7d 3f                         SWI                     ; SEND TO CONSOLE
6537 fc7e 01                         FCB     OUTCH           ; FUNCTION BYTE
6538 fc7f 20 f7                      BRA     REGP1           ; CHECK NEXT
6539 fc81 86 2d              REGP2   LDA     #'-             ; READY '-'
6540 fc83 3f                         SWI                     ; SEND OUT
6541 fc84 01                         FCB     OUTCH           ; WITH OUTCH
6542 fc85 30 e5                      LEAX    B,S             ; X->REGISTER TO PRINT
6543 fc87 6d e4                      TST     ,S              ; ? CHANGE OPTION
6544 fc89 26 12                      BNE     REGCNG          ; BRANCH YES
6545 fc8b 6d 3f                      TST     -1,Y            ; ? ONE OR TWO BYTES
6546 fc8d 27 03                      BEQ     REGP3           ; BRANCH ZERO MEANS ONE
6547 fc8f 3f                         SWI                     ; PERFORM WORD HEX
6548 fc90 05                         FCB     OUT4HS          ; FUNCTION
6549 fc91 8c                         FCB     SKIP2           ; SKIP BYTE PRINT
6550 fc92 3f                 REGP3   SWI                     ; PERFORM BYTE HEX
6551 fc93 04                         FCB     OUT2HS          ; FUNCTION
6552 fc94 ec a0              REG4    LDD     ,Y+             ; TO FRONT OF NEXT ENTRY
6553 fc96 5d                         TSTB                    ; ? END OF ENTRIES
6554 fc97 26 df                      BNE     REGP1           ; LOOP IF MORE
6555 fc99 3f                         SWI                     ; FORCE NEW LINE
6556 fc9a 06                         FCB     PCRLF           ; FUNCTION
6557 fc9b 35 b2              REGRTN  PULS    PC,Y,X,A        ; RESTORE STACK AND RETURN
6558                         
6559 fc9d 8d 40              REGCNG  BSR     BLDNNB          ; INPUT BINARY NUMBER
6560 fc9f 27 10                      BEQ     REGNXC          ; IF CHANGE THEN JUMP
6561 fca1 81 0d                      CMPA    #CR             ; ? NO MORE DESIRED
6562 fca3 27 1e                      BEQ     REGAGN          ; BRANCH NOPE
6563 fca5 e6 3f                      LDB     -1,Y            ; LOAD SIZE FLAG
6564 fca7 5a                         DECB                    ; MINUS ONE
6565 fca8 50                         NEGB                    ; MAKE POSITIVE
6566 fca9 58                         ASLB                    ; TIMES TWO (=2 OR =4)
6567 fcaa 3f                 REGSKP  SWI                     ; PERFORM SPACES
6568 fcab 07                         FCB     SPACEF          ; FUNCTION
6569 fcac 5a                         DECB
6570 fcad 26 fb                      BNE     REGSKP          ; LOOP IF MORE
6571 fcaf 20 e3                      BRA     REG4            ; CONTINUE WITH NEXT REGISTER
6572 fcb1 a7 e4              REGNXC  STA     ,S              ; SAVE DELIMITER IN OPTION
6573                         *                               ; (ALWAYS > 0)
6574 fcb3 dc 9b                      LDD     <NUMBER         ; OBTAIN BINARY RESULT
6575 fcb5 6d 3f                      TST     -1,Y            ; ? TWO BYTES WORTH
6576 fcb7 26 02                      BNE     REGTWO          ; BRANCH YES
6577 fcb9 a6 82                      LDA     ,-X             ; SETUP FOR TWO
6578 fcbb ed 84              REGTWO  STD     ,X              ; STORE IN NEW VALUE
6579 fcbd a6 e4                      LDA     ,S              ; RECOVER DELIMITER
6580 fcbf 81 0d                      CMPA    #CR             ; ? END OF CHANGES
6581 fcc1 26 d1                      BNE     REG4            ; NO, KEEP ON TRUCK'N
6582                         * MOVE STACKED DATA TO NEW STACK IN CASE STACK
6583                         * POINTER HAS CHANGED
6584 fcc3 30 8d 63 8a        REGAGN  LEAX    TSTACK,PCR      ; LOAD TEMP AREA
6585 fcc7 c6 15                      LDB     #21             ; LOAD COUNT
6586 fcc9 35 02              REGTF1  PULS    A               ; NEXT BYTE
6587 fccb a7 80                      STA     ,X+             ; STORE INTO TEMP
6588 fccd 5a                         DECB                    ; COUNT DOWN
6589 fcce 26 f9                      BNE     REGTF1          ; LOOP IF MORE
6590 fcd0 10 ee 88 ec                LDS     -20,X           ; LOAD NEW STACK POINTER
6591 fcd4 c6 15                      LDB     #21             ; LOAD COUNT AGAIN
6592 fcd6 a6 82              REGTF2 LDA      ,-X             ; NEXT TO STORE
6593 fcd8 34 02                     PSHS     A               ; BACK ONTO NEW STACK
6594 fcda 5a                        DECB                     ; COUNT DOWN
6595 fcdb 26 f9                     BNE      REGTF2          ; LOOP IF MORE
6596 fcdd 20 bc                     BRA      REGRTN          ; GO RESTART COMMAND
6597                         
6598                         *********************************************
6599                         * BLDNUM - BUILDS BINARY VALUE FROM INPUT HEX
6600                         * THE ACTIVE EXPRESSION HANDLER IS USED.
6601                         * INPUT: S=RETURN ADDRESS
6602                         * OUTPUT: A=DELIMITER WHICH TERMINATED VALUE
6603                         * (IF DELM NOT ZERO)
6604                         * "NUMBER"=WORD BINARY RESULT
6605                         * Z=1 IF INPUT RECEIVED, Z=0 IF NO HEX RECEIVED
6606                         * REGISTERS ARE TRANSPARENT
6607                         **********************************************
6608                         * EXECUTE SINGLE OR EXTENDED ROM EXPRESSION HANDLER
6609                         *
6610                         * THE FLAG "DELIM" IS USED AS FOLLOWS:
6611                         * DELIM=0 NO LEADING BLANKS, NO FORCED TERMINATOR
6612                         * DELIM=CHR ACCEPT LEADING 'CHR'S, FORCED TERMINATOR
6613 fcdf 4f                 BLDNNB  CLRA                    ; NO DYNAMIC DELIMITER
6614 fce0 8c                         FCB     SKIP2           ; SKIP NEXT INSTRUCTION
6615                         * BUILD WITH LEADING BLANKS
6616 fce1 86 20              BLDNUM  LDA     #'              ; ALLOW LEADING BLANKS
6617 fce3 97 8e                      STA     <DELIM          ; STORE AS DELIMITER
6618 fce5 6e 9d 64 03                JMP     [VECTAB+.EXPAN,PCR]   ; TO EXP ANALYZER
6619                         * THIS IS THE DEFAULT SINGLE ROM ANALYZER. WE ACCEPT:
6620                         * 1) HEX INPUT
6621                         * 2) 'M' FOR LAST MEMORY EXAMINE ADDRESS
6622                         * 3) 'P' FOR PROGRAM COUNTER ADDRESS
6623                         * 4) 'W' FOR WINDOW VALUE
6624                         * 5) '@' FOR INDIRECT VALUE
6625                         
6626 fce9 34 14              EXP1    PSHS    X,B             ; SAVE REGISTERS
6627 fceb 8d 5c              EXPDLM  BSR     BLDHXI          ; CLEAR NUMBER, CHECK FIRST CHAR
6628 fced 27 18                      BEQ     EXP2            ; IF HEX DIGIT CONTINUE BUILDING
6629                         * SKIP BLANKS IF DESIRED
6630 fcef 91 8e                      CMPA    <DELIM          ; ? CORRECT DELIMITER
6631 fcf1 27 f8                      BEQ     EXPDLM          ; YES, IGNORE IT
6632                         * TEST FOR M OR P
6633 fcf3 9e 9e                      LDX     <ADDR           ; DEFAULT FOR 'M'
6634 fcf5 81 4d                      CMPA    #'M             ; ? MEMORY EXAMINE ADDR WANTED
6635 fcf7 27 16                      BEQ     EXPTDL          ; BRANCH IF SO
6636 fcf9 9e 93                      LDX     <PCNTER         ; DEFAULT FOR 'P'
6637 fcfb 81 50                      CMPA    #'P             ; ? LAST PROGRAM COUNTER WANTED
6638 fcfd 27 10                      BEQ     EXPTDL          ; BRANCH IF SO
6639 fcff 9e a0                      LDX     <WINDOW         ; DEFAULT TO WINDOW
6640 fd01 81 57                      CMPA    #'W             ; ? WINDOW WANTED
6641 fd03 27 0a                      BEQ     EXPTDL
6642                         
6643 fd05 35 94              EXPRTN  PULS    PC,X,B          ; RETURN AND RESTORE REGISTERS
6644                         * GOT HEX, NOW CONTINUE BUILDING
6645 fd07 8d 44              EXP2    BSR     BLDHEX          ; COMPUTE NEXT DIGIT
6646 fd09 27 fc                      BEQ     EXP2            ; CONTINUE IF MORE
6647 fd0b 20 0a                      BRA     EXPCDL          ; SEARCH FOR +/-
6648                         * STORE VALUE AND CHECK IF NEED DELIMITER
6649 fd0d ae 84              EXPTDI  LDX     ,X              ; INDIRECTION DESIRED
6650 fd0f 9f 9b              EXPTDL  STX     <NUMBER         ; STORE RESULT
6651 fd11 0d 8e                      TST     <DELIM          ; ? TO FORCE A DELIMITER
6652 fd13 27 f0                      BEQ     EXPRTN          ; RETURN IF NOT WITH VALUE
6653 fd15 8d 62                      BSR     READC           ; OBTAIN NEXT CHARACTER
6654                         * TEST FOR + OR -
6655 fd17 9e 9b              EXPCDL  LDX     <NUMBER         ; LOAD LAST VALUE
6656 fd19 81 2b                      CMPA    #'+             ; ? ADD OPERATOR
6657 fd1b 26 0e                      BNE     EXPCHM          ; BRANCH NOT
6658 fd1d 8d 23                      BSR     EXPTRM          ; COMPUTE NEXT TERM
6659 fd1f 34 02                      PSHS    A               ; SAVE DELIMITER
6660 fd21 dc 9b                      LDD     <NUMBER         ; LOAD NEW TERM
6661 fd23 30 8b              EXPADD  LEAX    D,X             ; ADD TO X
6662 fd25 9f 9b                      STX     <NUMBER         ; STORE AS NEW RESULT
6663 fd27 35 02                      PULS    A               ; RESTORE DELIMITER
6664 fd29 20 ec                      BRA     EXPCDL          ; NOW TEST IT
6665 fd2b 81 2d              EXPCHM  CMPA    #'-             ; ? SUBTRACT OPERATOR
6666 fd2d 27 07                      BEQ     EXPSUB          ; BRANCH IF SO
6667 fd2f 81 40                      CMPA    #'@             ; ? INDIRECTION DESIRED
6668 fd31 27 da                      BEQ     EXPTDI          ; BRANCH IF SO
6669 fd33 5f                         CLRB                    ; SET DELIMITER RETURN
6670 fd34 20 cf                      BRA     EXPRTN          ; AND RETURN TO CALLER
6671 fd36 8d 0a              EXPSUB  BSR     EXPTRM          ; OBTAIN NEXT TERM
6672 fd38 34 02                      PSHS    A               ; SAVE DELIMITER
6673 fd3a dc 9b                      LDD     <NUMBER         ; LOAD UP NEXT TERM
6674 fd3c 40                         NEGA                    ; NEGATE A
6675 fd3d 50                         NEGB                    ; NEGATE B
6676 fd3e 82 00                      SBCA    #0              ; CORRECT FOR A
6677 fd40 20 e1                      BRA     EXPADD          ; GO ADD TO EXPRESSION
6678                         * COMPUTE NEXT EXPRESSION TERM
6679                         * OUTPUT: X=OLD VALUE
6680                         * 'NUMBER'=NEXT TERM
6681 fd42 8d 9d              EXPTRM  BSR     BLDNUM          ; OBTAIN NEXT VALUE
6682 fd44 27 32                      BEQ     CNVRTS          ; RETURN IF VALID NUMBER
6683 fd46 16 fc 13           BLDBAD  LBRA    CMDBAD          ; ABORT COMMAND IF INVALID
6684                         
6685                         *********************************************
6686                         * BUILD BINARY VALUE USING INPUT CHARACTERS.
6687                         * INPUT: A=ASCII HEX VALUE OR DELIMITER
6688                         * SP+0=RETURN ADDRESS
6689                         * SP+2=16 BIT RESULT AREA
6690                         * OUTPUT: Z=1 A=BINARY VALUE
6691                         * Z=0 IF INVALID HEX CHARACTER (A UNCHANGED)
6692                         * VOLATILE: D
6693                         ****************************************
6694 fd49 0f 9b              BLDHXI  CLR     <NUMBER         ; CLEAR NUMBER
6695 fd4b 0f 9c                      CLR     <NUMBER+1       ; CLEAR NUMBER
6696 fd4d 8d 2a              BLDHEX  BSR     READC           ; GET INPUT CHARACTER
6697 fd4f 8d 11              BLDHXC  BSR     CNVHEX          ; CONVERT AND TEST CHARACTER
6698 fd51 26 25                      BNE     CNVRTS          ; RETURN IF NOT A NUMBER
6699 fd53 c6 10                      LDB     #16             ; PREPARE SHIFT
6700 fd55 3d                         MUL                     ; BY FOUR PLACES
6701 fd56 86 04                      LDA     #4              ; ROTATE BINARY INTO VALUE
6702 fd58 58                 BLDSHF  ASLB                    ; OBTAIN NEXT BIT
6703 fd59 09 9c                      ROL     <NUMBER+1       ; INTO LOW BYTE
6704 fd5b 09 9b                      ROL     <NUMBER         ; INTO HI BYTE
6705 fd5d 4a                         DECA                    ; COUNT DOWN
6706 fd5e 26 f8                      BNE     BLDSHF          ; BRANCH IF MORE TO DO
6707 fd60 20 14                      BRA     CNVOK           ; SET GOOD RETURN CODE
6708                         
6709                         ****************************************
6710                         * CONVERT ASCII CHARACTER TO BINARY BYTE
6711                         * INPUT: A=ASCII
6712                         * OUTPUT: Z=1 A=BINARY VALUE
6713                         * Z=0 IF INVALID
6714                         * ALL REGISTERS TRANSPARENT
6715                         * (A UNALTERED IF INVALID HEX)
6716                         **************************************
6717 fd62 81 30              CNVHEX  CMPA    #'0             ; ? LOWER THAN A ZERO
6718 fd64 25 12                      BLO     CNVRTS          ; BRANCH NOT VALUE
6719 fd66 81 39                      CMPA    #'9             ; ? POSSIBLE A-F
6720 fd68 2f 0a                      BLE     CNVGOT          ; BRANCH NO TO ACCEPT
6721 fd6a 81 41                      CMPA    #'A             ; ? LESS THEN TEN
6722 fd6c 25 0a                      BLO     CNVRTS          ; RETURN IF MINUS (INVALID)
6723 fd6e 81 46                      CMPA    #'F             ; ? NOT TOO LARGE
6724 fd70 22 06                      BHI     CNVRTS          ; NO, RETURN TOO LARGE
6725 fd72 80 07                      SUBA    #7              ; DOWN TO BINARY
6726 fd74 84 0f              CNVGOT  ANDA    #$0F            ; CLEAR HIGH HEX
6727 fd76 1a 04              CNVOK   ORCC    #4              ; FORCE ZERO ON FOR VALID HEX
6728 fd78 39                 CNVRTS  RTS                     ; RETURN TO CALLER
6729                         
6730                         * GET INPUT CHAR, ABORT COMMAND IF CONTROL-X (CANCEL)
6731 fd79 3f                 READC    SWI                    ; GET NEXT CHARACTER
6732 fd7a 00                          FCB    INCHNP          ; FUNCTION
6733 fd7b 81 18                       CMPA   #CAN            ; ? ABORT COMMAND
6734 fd7d 27 c7                       BEQ    BLDBAD          ; BRANCH TO ABORT IF SO
6735 fd7f 39                          RTS                    ; RETURN TO CALLER
6736                         *G
6737                         
6738                         ***************GO - START PROGRAM EXECUTION
6739 fd80 8d 01              CGO      BSR    GOADDR          ; BUILD ADDRESS IF NEEDED
6740 fd82 3b                          RTI                    ; START EXECUTING
6741                         
6742                         * FIND OPTIONAL NEW PROGRAM COUNTER. ALSO ARM THE
6743                         * BREAKPOINTS.
6744 fd83 35 30              GOADDR   PULS   Y,X             ; RECOVER RETURN ADDRESS
6745 fd85 34 10                       PSHS   X               ; STORE RETURN BACK
6746 fd87 26 19                       BNE    GONDFT          ; IF NO CARRIAGE RETURN THEN NEW PC
6747                         
6748                         * DEFAULT PROGRAM COUNTER, SO FALL THROUGH IF
6749                         * IMMEDIATE BREAKPOINT.
6750 fd89 17 01 b6                    LBSR   CBKLDR          ; SEARCH BREAKPOINTS
6751 fd8c ae 6c                       LDX    12,S            ; LOAD PROGRAM COUNTER
6752 fd8e 5a                 ARMBLP  DECB                    ; COUNT DOWN
6753 fd8f 2b 16                      BMI     ARMBK2          ; DONE, NONE TO SINGLE TRACE
6754 fd91 a6 30                      LDA     -NUMBKP*2,Y     ; PRE-FETCH OPCODE
6755 fd93 ac a1                      CMPX    ,Y++            ; ? IS THIS A BREAKPOINT
6756 fd95 26 f7                      BNE     ARMBLP          ; LOOP IF NOT
6757 fd97 81 3f                      CMPA    #$3F            ; ? SWI BREAKPOINTED
6758 fd99 26 02                      BNE     ARMNSW          ; NO, SKIP SETTING OF PASS FLAG
6759 fd9b 97 fb                      STA     <SWIBFL         ; SHOW UPCOMING SWI NOT BRKPNT
6760 fd9d 0c 8f              ARMNSW  INC     <MISFLG         ; FLAG THRU A BREAKPOINT
6761 fd9f 16 01 06                   LBRA    CDOT            ; DO SINGLE TRACE W/O BREAKPOINTS
6762                         
6763                         * OBTAIN NEW PROGRAM COUNTER
6764 fda2 17 00 bb           GONDFT  LBSR    CDNUM           ; OBTAIN NEW PROGRAM COUNTER
6765 fda5 ed 6c                      STD     12,S            ; STORE INTO STACK
6766 fda7 17 01 98           ARMBK2  LBSR    CBKLDR          ; OBTAIN TABLE
6767 fdaa 00 fa                      NEG     <BKPTCT         ; COMPLEMENT TO SHOW ARMED
6768 fdac 5a                 ARMLOP  DECB                    ; ? DONE
6769 fdad 2b c9                      BMI     CNVRTS          ; RETURN WHEN DONE
6770 fdaf a6 b4                      LDA     [,Y]            ; LOAD OPCODE
6771 fdb1 a7 30                      STA     -NUMBKP*2,Y     ; STORE INTO OPCODE TABLE
6772 fdb3 86 3f                      LDA     #$3F            ; READY "SWI" OPCODE
6773 fdb5 a7 b1                      STA     [,Y++]          ; STORE AND MOVE UP TABLE
6774 fdb7 20 f3                      BRA     ARMLOP          ; AND CONTINUE
6775                         
6776                         *******************CALL - CALL ADDRESS AS SUBROUTINE
6777 fdb9 8d c8              CCALL   BSR     GOADDR          ; FETCH ADDRESS IF NEEDED
6778 fdbb 35 7f                      PULS    U,Y,X,DP,D,CC   ; RESTORE USERS REGISTERS
6779 fdbd ad f1                      JSR     [,S++]          ; CALL USER SUBROUTINE
6780 fdbf 3f                 CGOBRK  SWI                     ; PERFORM BREAKPOINT
6781 fdc0 0a                         FCB     BRKPT           ; FUNCTION
6782 fdc1 20 fc                      BRA     CGOBRK          ; LOOP UNTIL USER CHANGES PC
6783                         
6784                         ****************MEMORY - DISPLAY/CHANGE MEMORY
6785                         * CMEMN AND CMPADP ARE DIRECT ENTRY POINTS FROM
6786                         * THE COMMAND HANDLER FOR QUICK COMMANDS
6787 fdc3 17 00 9a           CMEM    LBSR    CDNUM           ; OBTAIN ADDRESS
6788 fdc6 dd 9e              CMEMN   STD     <ADDR           ; STORE DEFAULT
6789 fdc8 9e 9e              CMEM2   LDX     <ADDR           ; LOAD POINTER
6790 fdca 17 fc 0c                   LBSR    ZOUT2H          ; SEND OUT HEX VALUE OF BYTE
6791 fdcd 86 2d                      LDA     #'-             ; LOAD DELIMITER
6792 fdcf 3f                         SWI                     ; SEND OUT
6793 fdd0 01                         FCB     OUTCH           ; FUNCTION
6794 fdd1 17 ff 0b           CMEM4   LBSR    BLDNNB          ; OBTAIN NEW BYTE VALUE
6795 fdd4 27 0a                      BEQ     CMENUM          ; BRANCH IF NUMBER
6796                         * COMA - SKIP BYTE
6797 fdd6 81 2c                      CMPA    #',             ; ? COMMA
6798 fdd8 26 0e                      BNE     CMNOTC          ; BRANCH NOT
6799 fdda 9f 9e                      STX     <ADDR           ; UPDATE POINTER
6800 fddc 30 01                      LEAX    1,X             ; TO NEXT BYTE
6801 fdde 20 f1                      BRA     CMEM4           ; AND INPUT IT
6802 fde0 d6 9c              CMENUM  LDB     <NUMBER+1       ; LOAD LOW BYTE VALUE
6803 fde2 8d 47                      BSR     MUPDAT          ; GO OVERLAY MEMORY BYTE
6804 fde4 81 2c                      CMPA    #',             ; ? CONTINUE WITH NO DISPLAY
6805 fde6 27 e9                      BEQ     CMEM4           ; BRANCH YES
6806                         * QUOTED STRING
6807 fde8 81 27              CMNOTC  CMPA    #$27            ; ? QUOTED STRING
6808 fdea 26 0c                      BNE     CMNOTQ          ; BRANCH NO
6809 fdec 8d 8b              CMESTR  BSR     READC           ; OBTAIN NEXT CHARACTER
6810 fdee 81 27                      CMPA    #$27            ; ? END OF QUOTED STRING
6811 fdf0 27 0c                      BEQ     CMSPCE          ; YES, QUIT STRING MODE
6812 fdf2 1f 89                      TFR     A,B             ; TO B FOR SUBROUTINE
6813 fdf4 8d 35                      BSR     MUPDAT          ; GO UPDATE BYTE
6814 fdf6 20 f4                      BRA     CMESTR          ; GET NEXT CHARACTER
6815                         * BLANK - NEXT BYTE
6816 fdf8 81 20              CMNOTQ  CMPA    #$20            ; ? BLANK FOR NEXT BYTE
6817 fdfa 26 06                      BNE     CMNOTB          ; BRANCH NOT
6818 fdfc 9f 9e                      STX     <ADDR           ; UPDATE POINTER
6819 fdfe 3f                 CMSPCE  SWI                     ; GIVE SPACE
6820 fdff 07                         FCB     SPACEF          ; FUNCTION
6821 fe00 20 c6                      BRA     CMEM2           ; NOW PROMPT FOR NEXT
6822                         
6823                         * LINE FEED - NEXT BYTE WITH ADDRESS
6824 fe02 81 0a              CMNOTB  CMPA    #LF             ; ? LINE FEED FOR NEXT BYTE
6825 fe04 26 08                      BNE     CMNOTL          ; BRANCH NO
6826 fe06 86 0d                      LDA     #CR             ; GIVE CARRIAGE RETURN
6827 fe08 3f                         SWI                     ; TO CONSOLE
6828 fe09 01                         FCB     OUTCH           ; HANDLER
6829 fe0a 9f 9e                      STX     <ADDR           ; STORE NEXT ADDRESS
6830 fe0c 20 0a                      BRA     CMPADP          ; BRANCH TO SHOW
6831                         
6832                         * UP ARROW - PREVIOUS BYTE AND ADDRESS
6833 fe0e 81 5e              CMNOTL  CMPA    #'^             ; ? UP ARROW FOR PREVIOUS BYTE
6834 fe10 26 0a                      BNE     CMNOTU          ; BRANCH NOT
6835 fe12 30 1e                      LEAX    -2,X            ; DOWN TO PREVIOUS BYTE
6836 fe14 9f 9e                      STX     <ADDR           ; STORE NEW POINTER
6837 fe16 3f                 CMPADS  SWI                     ; FORCE NEW LINE
6838 fe17 06                         FCB     PCRLF           ; FUNCTION
6839 fe18 8d 07              CMPADP  BSR     PRTADR          ; GO PRINT ITS VALUE
6840 fe1a 20 ac                      BRA     CMEM2           ; THEN PROMPT FOR INPUT
6841                         
6842                         * SLASH - NEXT BYTE WITH ADDRESS
6843 fe1c 81 2f              CMNOTU  CMPA    #'/             ; ? SLASH FOR CURRENT DISPLAY
6844 fe1e 27 f6                      BEQ     CMPADS          ; YES, SEND ADDRESS
6845 fe20 39                         RTS                     ; RETURN FROM COMMAND
6846                         
6847                         * PRINT CURRENT ADDRESS
6848 fe21 9e 9e              PRTADR  LDX     <ADDR           ; LOAD POINTER VALUE
6849 fe23 34 10                      PSHS    X               ; SAVE X ON STACK
6850 fe25 30 e4                      LEAX    ,S              ; POINT TO IT FOR DISPLAY
6851 fe27 3f                         SWI                     ; DISPLAY POINTER IN HEX
6852 fe28 05                         FCB     OUT4HS          ; FUNCTION
6853 fe29 35 90                      PULS    PC,X            ; RECOVER POINTER AND RETURN
6854                         
6855                         * UPDATE BYTE
6856 fe2b 9e 9e              MUPDAT  LDX     <ADDR           ; LOAD NEXT BYTE POINTER
6857 fe2d e7 80                      STB     ,X+             ; STORE AND INCREMENT X
6858 fe2f e1 1f                      CMPB    -1,X            ; ? SUCCESFULL STORE
6859 fe31 26 03                      BNE     MUPBAD          ; BRANCH FOR '?' IF NOT
6860 fe33 9f 9e                      STX     <ADDR           ; STORE NEW POINTER VALUE
6861 fe35 39                         RTS                     ; BACK TO CALLER
6862 fe36 34 02              MUPBAD  PSHS    A               ; SAVE A REGISTER
6863 fe38 86 3f                      LDA     #'?             ; SHOW INVALID
6864 fe3a 3f                         SWI                     ; SEND OUT
6865 fe3b 01                         FCB     OUTCH           ; FUNCTION
6866 fe3c 35 82                      PULS    PC,A            ; RETURN TO CALLER
6867                         
6868                         ********************WINDOW - SET WINDOW VALUE
6869 fe3e 8d 20              CWINDO  BSR     CDNUM           ; OBTAIN WINDOW VALUE
6870 fe40 dd a0                      STD     <WINDOW         ; STORE IT IN
6871 fe42 39                         RTS                     ; END COMMAND
6872                         
6873                         ******************DISPLAY - HIGH SPEED DISPLAY MEMORY
6874 fe43 8d 1b              CDISP   BSR     CDNUM           ; FETCH ADDRESS
6875 fe45 c4 f0                      ANDB    #$F0            ; FORCE TO 16 BOUNDARY
6876 fe47 1f 02                      TFR     D,Y             ; SAVE IN Y
6877 fe49 30 2f                      LEAX    15,Y            ; DEFAULT LENGTH
6878 fe4b 25 04                      BCS     CDISPS          ; BRANCH IF END OF INPUT
6879 fe4d 8d 11                      BSR     CDNUM           ; OBTAIN COUNT
6880 fe4f 30 ab                      LEAX    D,Y             ; ASSUME COUNT, COMPUTE END ADDR
6881 fe51 34 30              CDISPS  PSHS    Y,X             ; SETUP PARAMETERS FOR HSDATA
6882 fe53 10 a3 62                   CMPD    2,S             ; ? WAS IT COUNT
6883 fe56 23 02                      BLS     CDCNT           ; BRANCH YES
6884 fe58 ed e4                      STD     ,S              ; STORE HIGH ADDRESS
6885 fe5a ad 9d 62 84        CDCNT   JSR     [VECTAB+.HSDTA,PCR] ; CALL PRINT ROUTINE
6886 fe5e 35 e0                      PULS    PC,U,Y          ; CLEAN STACK AND END COMMAND
6887                         
6888                         * OBTAIN NUMBER - ABORT IF NONE
6889                         * ONLY DELIMITERS OF CR, BLANK, OR '/' ARE ACCEPTED
6890                         * OUTPUT: D=VALUE, C=1 IF CARRIAGE RETURN DELMITER,
6891                         * ELSE C=0
6892 fe60 17 fe 7e           CDNUM   LBSR    BLDNUM          ; OBTAIN NUMBER
6893 fe63 26 09                      BNE     CDBADN          ; BRANCH IF INVALID
6894 fe65 81 2f                      CMPA    #'/             ; ? VALID DELIMITER
6895 fe67 22 05                      BHI     CDBADN          ; BRANCH IF NOT FOR ERROR
6896 fe69 81 0e                      CMPA    #CR+1           ; LEAVE COMPARE FOR CARRIAGE RET
6897 fe6b dc 9b                      LDD     <NUMBER         ; LOAD NUMBER
6898 fe6d 39                         RTS                     ; RETURN WITH COMPARE
6899 fe6e 16 fa eb           CDBADN  LBRA    CMDBAD          ; RETURN TO ERROR MECHANISM
6900                         
6901                         *****************PUNCH - PUNCH MEMORY IN S1-S9 FORMAT
6902 fe71 8d ed              CPUNCH  BSR     CDNUM           ; OBTAIN START ADDRESS
6903 fe73 1f 02                      TFR     D,Y             ; SAVE IN Y
6904 fe75 8d e9                      BSR     CDNUM           ; OBTAIN END ADDRESS
6905 fe77 6f e2                      CLR     ,-S             ; SETUP PUNCH FUNCTION CODE
6906 fe79 34 26                      PSHS    Y,D             ; STORE VALUES ON STACK
6907 fe7b ad 9d 62 65        CCALBS  JSR     [VECTAB+.BSON,PCR] ; INITIALIZE HANDLER
6908 fe7f ad 9d 62 63                JSR     [VECTAB+.BSDTA,PCR] ; PERFORM FUNCTION
6909 fe83 34 01                      PSHS    CC              ; SAVE RETURN CODE
6910 fe85 ad 9d 62 5f                JSR     [VECTAB+.BSOFF,PCR] ; TURN OFF HANDLER
6911 fe89 35 01                      PULS    CC              ; OBTAIN CONDITION CODE SAVED
6912 fe8b 26 e1                      BNE     CDBADN          ; BRANCH IF ERROR
6913 fe8d 35 b2                      PULS    PC,Y,X,A        ; RETURN FROM COMMAND
6914                         
6915                         *****************LOAD - LOAD MEMORY FROM S1-S9 FORMAT
6916 fe8f 8d 01              CLOAD   BSR     CLVOFS          ; CALL SETUP AND PASS CODE
6917 fe91 01                         FCB     1               ; LOAD FUNCTION CODE FOR PACKET
6918                         
6919 fe92 33 f1              CLVOFS  LEAU    [,S++]          ; LOAD CODE IN HIGH BYTE OF U
6920 fe94 33 d4                      LEAU    [,U]            ; NOT CHANGING CC AND RESTORE S
6921 fe96 27 03                      BEQ     CLVDFT          ; BRANCH IF CARRIAGE RETURN NEXT
6922 fe98 8d c6                      BSR     CDNUM           ; OBTAIN OFFSET
6923 fe9a 8c                         FCB     SKIP2           ; SKIP DEFAULT OFFSET
6924 fe9b 4f                 CLVDFT  CLRA                    ; CREATE ZERO OFFSET
6925 fe9c 5f                         CLRB                    ; AS DEFAULT
6926 fe9d 34 4e                      PSHS    U,DP,D          ; SETUP CODE, NULL WORD, OFFSET
6927 fe9f 20 da                      BRA     CCALBS          ; ENTER CALL TO BS ROUTINES
6928                         
6929                         ******************VERIFY - COMPARE MEMORY WITH FILES
6930 fea1 8d ef              CVER    BSR     CLVOFS          ; COMPUTE OFFSET IF ANY
6931 fea3 ff                         FCB     -1              ; VERIFY FNCTN CODE FOR PACKET
6932                         
6933                         *******************TRACE - TRACE INSTRUCTIONS
6934                         ******************* . - SINGLE STEP TRACE
6935 fea4 8d ba              CTRACE  BSR     CDNUM           ; OBTAIN TRACE COUNT
6936 fea6 dd 91                      STD     <TRACEC         ; STORE COUNT
6937 fea8 32 62              CDOT    LEAS    2,S             ; RID COMMAND RETURN FROM STACK
6938 feaa ee f8 0a           CTRCE3  LDU     [10,S]          ; LOAD OPCODE TO EXECUTE
6939 fead df 99                      STU     <LASTOP         ; STORE FOR TRACE INTERRUPT
6940 feaf de f6                      LDU     <VECTAB+.PTM    ; LOAD PTM ADDRESS
6941 feb1 cc 07 01                   LDD     #$0701          ; 7,1 CYCLES DOWN+CYCLES UP
6942 feb4 ed 42                      STD     PTMTM1-PTM,U    ; START NMI TIMEOUT
6943 feb6 3b                         RTI                     ; RETURN FOR ONE INSTRUCTION
6944                         
6945                         *************NULLS  -  SET NEW LINE AND CHAR PADDING
6946 feb7 8d a7              CNULLS  BSR     CDNUM           ; OBTAIN NEW LINE PAD
6947 feb9 dd f2                      STD     <VECTAB+.PAD    ; RESET VALUES
6948 febb 39                         RTS                     ; END COMMAND
6949                         
6950                         ******************STLEVEL - SET STACK TRACE LEVEL
6951 febc 27 05              CSTLEV  BEQ     STLDFT          ; TAKE DEFAULT
6952 febe 8d a0                      BSR     CDNUM           ; OBTAIN NEW STACK LEVEL
6953 fec0 dd f8                      STD     <SLEVEL         ; STORE NEW ENTRY
6954 fec2 39                         RTS                     ; TO COMMAND HANDLER
6955 fec3 30 6e              STLDFT  LEAX    14,S            ; COMPUTE NMI COMPARE
6956 fec5 9f f8                      STX     <SLEVEL         ; AND STORE IT
6957 fec7 39                         RTS                     ; END COMMAND
6958                         
6959                         ******************OFFSET - COMPUTE SHORT AND LONG
6960                         ******************                  BRANCH OFFSETS
6961 fec8 8d 96              COFFS   BSR     CDNUM           ; OBTAIN INSTRUCTION ADDRESS
6962 feca 1f 01                      TFR     D,X             ; USE AS FROM ADDRESS
6963 fecc 8d 92                      BSR     CDNUM           ; OBTAIN TO ADDRESS
6964                         * D=TO INSTRUCTION, X=FROM INSTRUCTION OFFSET BYTE(S)
6965 fece 30 01                      LEAX    1,X             ; ADJUST FOR *+2 SHORT BRANCH
6966 fed0 34 30                      PSHS    Y,X             ; STORE WORK WORD AND VALUE ON S
6967 fed2 a3 e4                      SUBD    ,S              ; FIND OFFSET
6968 fed4 ed e4                      STD     ,S              ; SAVE OVER STACK
6969 fed6 30 61                      LEAX    1,S             ; POINT FOR ONE BYTE DISPLAY
6970 fed8 1d                         SEX                     ; SIGN EXTEND LOW BYTE
6971 fed9 a1 e4                      CMPA    ,S              ; ? VALID ONE BYTE OFFSET
6972 fedb 26 02                      BNE     COFNO1          ; BRANCH IF NOT
6973 fedd 3f                         SWI                     ; SHOW ONE BYTE OFFSET
6974 fede 04                         FCB     OUT2HS          ; FUNCTION
6975 fedf ee e4              COFNO1  LDU     ,S              ; RELOAD OFFSET
6976 fee1 33 5f                      LEAU    -1,U            ; CONVERT TO LONG BRANCH OFFSET
6977 fee3 ef 84                      STU     ,X              ; STORE BACK WHERE X POINTS NOW
6978 fee5 3f                         SWI                     ; SHOW TWO BYTE OFFSET
6979 fee6 05                         FCB     OUT4HS          ; FUNCTION
6980 fee7 3f                         SWI                     ; FORCE NEW LINE
6981 fee8 06                         FCB     PCRLF           ; FUNCTION
6982 fee9 35 96                      PULS    PC,X,D          ; RESTORE STACK AND END COMMAND
6983                         *H
6984                         
6985                         *************BREAKPOINT - DISPLAY/ENTER/DELETE/CLEAR
6986                         *************             BREAKPOINTS
6987 feeb 27 23              CBKPT   BEQ     CBKDSP          ; BRANCH DISPLAY OF JUST 'B'
6988 feed 17 fd f1                   LBSR    BLDNUM          ; ATTEMPT VALUE ENTRY
6989 fef0 27 2c                      BEQ     CBKADD          ; BRANCH TO ADD IF SO
6990 fef2 81 2d                      CMPA    #'-             ; ? CORRECT DELIMITER
6991 fef4 26 3f                      BNE     CBKERR          ; NO, BRANCH FOR ERROR
6992 fef6 17 fd e8                   LBSR    BLDNUM          ; ATTEMPT DELETE VALUE
6993 fef9 27 03                      BEQ     CBKDLE          ; GOT ONE, GO DELETE IT
6994 fefb 0f fa                      CLR     <BKPTCT         ; WAS 'B -', SO ZERO COUNT
6995 fefd 39                 CBKRTS  RTS                     ; END COMMAND
6996                         * DELETE THE ENTRY
6997 fefe 8d 40              CBKDLE  BSR     CBKSET          ; SETUP REGISTERS AND VALUE
6998 ff00 5a                 CBKDLP  DECB                    ; ? ANY ENTRIES IN TABLE
6999 ff01 2b 32                      BMI     CBKERR          ; BRANCH NO, ERROR
7000 ff03 ac a1                      CMPX    ,Y++            ; ? IS THIS THE ENTRY
7001 ff05 26 f9                      BNE     CBKDLP          ; NO, TRY NEXT
7002                         * FOUND, NOW MOVE OTHERS UP IN ITS PLACE
7003 ff07 ae a1              CBKDLM  LDX     ,Y++            ; LOAD NEXT ONE UP
7004 ff09 af 3c                      STX     -4,Y            ; MOVE DOWN BY ONE
7005 ff0b 5a                         DECB                    ; ? DONE
7006 ff0c 2a f9                      BPL     CBKDLM          ; NO, CONTINUE MOVE
7007 ff0e 0a fa                      DEC     <BKPTCT         ; DECREMENT BREAKPOINT COUNT
7008 ff10 8d 2e              CBKDSP  BSR     CBKSET          ; SETUP REGISTERS AND LOAD VALUE
7009 ff12 27 e9                      BEQ     CBKRTS          ; RETURN IF NONE TO DISPLY
7010 ff14 30 a1              CBKDSL  LEAX    ,Y++            ; POINT TO NEXT ENTRY
7011 ff16 3f                         SWI                     ; DISPLAY IN HEX
7012 ff17 05                         FCB     OUT4HS          ; FUNCTION
7013 ff18 5a                         DECB                    ; COUNT DOWN
7014 ff19 26 f9                      BNE     CBKDSL          ; LOOP IF NGABLE RAM
7015 ff1b 3f                         SWI                     ; SKIP TO NEW LINK
7016 ff1c 06                         FCB     PCRLF           ; FUNCTIONRTS
7017 ff1d 39                         RTS
7018                         
7019                         * ADD NEW ENTRY
7020 ff1e 8d 20              CBKADD  BSR     CBKSET          ; SETUP REGISTERS
7021 ff20 c1 08                      CMPB    #NUMBKP         ; ? ALREADY FULL
7022 ff22 27 11                      BEQ     CBKERR          ; BRANCH ERROR IF SO
7023 ff24 a6 84                      LDA     ,X              ; LOAD BYTE TO TRAP
7024 ff26 e7 84                      STB     ,X              ; TRY TO CHANGE
7025 ff28 e1 84                      CMPB    ,X              ; ? CHANGEABLE RAM
7026 ff2a 26 09                      BNE     CBKERR          ; BRANCH ERROR IF NOT
7027 ff2c a7 84                      STA ,X                  ; RESTORE BYTE
7028 ff2e 5a                 CBKADL  DECB                    ; COUNT DOWN
7029 ff2f 2b 07                      BMI     CBKADT          ; BRANCH IF DONE TO ADD IT
7030 ff31 ac a1                      CMPX    ,Y++            ; ? ENTRY ALREADY HERE
7031 ff33 26 f9                      BNE     CBKADL          ; LOOP IF NOT
7032 ff35 16 fa 24           CBKERR  LBRA    CMDBAD          ; RETURN TO ERROR PRODUCE
7033 ff38 af a4              CBKADT  STX ,Y                  ; ADD THIS ENTRY
7034 ff3a 6f 31                      CLR     -NUMBKP*2+1,Y   ; CLEAR OPTIONAL BYTE
7035 ff3c 0c fa                      INC     <BKPTCT         ; ADD ONE TO COUNT
7036 ff3e 20 d0                      BRA     CBKDSP          ; AND NOW DISPLAY ALL OF 'EM
7037                         * SETUP REGISTERS FOR SCAN
7038 ff40 9e 9b              CBKSET  LDX     <NUMBER         ; LOAD VALUE DESIRED
7039 ff42 31 8d 61 6c        CBKLDR  LEAY    BKPTBL,PCR      ; LOAD START OF TABLE
7040 ff46 d6 fa                      LDB     <BKPTCT         ; LOAD ENTRY COUNT
7041 ff48 39                         RTS                     ; RETURN
7042                         
7043                         *****************ENCODE  -  ENCODE A POSTBYTE
7044 ff49 6f e2              CENCDE  CLR     ,-S             ; DEFAULT TO NOT INDIRECT
7045 ff4b 5f                         CLRB                    ; ZERO POSTBYTE VALUE
7046 ff4c 30 8c 3f                   LEAX    <CONV1,PCR      ; START TABLE SEARCH
7047 ff4f 3f                         SWI                     ; OBTAIN FIRST CHARACTER
7048 ff50 00                         FCB     INCHNP          ; FUNCTION
7049 ff51 81 5b                      CMPA    #'[             ; ? INDIRECT HERE
7050 ff53 26 06                      BNE     CEN2            ; BRANCH IF NOT
7051 ff55 86 10                      LDA     #$10            ; SET INDIRECT BIT ON
7052 ff57 a7 e4                      STA     ,S              ; SAVE FOR LATER
7053 ff59 3f                 CENGET  SWI                     ; OBTAIN NEXT CHARACTER
7054 ff5a 00                         FCB     INCHNP          ; FUNCTION
7055 ff5b 81 0d              CEN2    CMPA    #CR             ; ? END OF ENTRY
7056 ff5d 27 0c                      BEQ     CEND1           ; BRANCH YES
7057 ff5f 6d 84              CENLP1  TST     ,X              ; ? END OF TABLE
7058 ff61 2b d2                      BMI     CBKERR          ; BRANCH ERROR IF SO
7059 ff63 a1 81                      CMPA    ,X++            ; ? THIS THE CHARACTER
7060 ff65 26 f8                      BNE     CENLP1          ; BRANCH IF NOT
7061 ff67 eb 1f                      ADDB    -1,X            ; ADD THIS VALUE
7062 ff69 20 ee                      BRA     CENGET          ; GET NEXT INPUT
7063 ff6b 30 8c 49           CEND1   LEAX    <CONV2,PCR      ; POINT AT TABLE 2
7064 ff6e 1f 98                      TFR     B,A             ; SAVE COPY IN A
7065 ff70 84 60                      ANDA    #$60            ; ISOLATE REGISTER MASK
7066 ff72 aa e4                      ORA     ,S              ; ADD IN INDIRECTION BIT
7067 ff74 a7 e4                      STA     ,S              ; SAVE BACK AS POSTBYTE SKELETON
7068 ff76 c4 9f                      ANDB    #$9F            ; CLEAR REGISTER BITS
7069 ff78 6d 84              CENLP2  TST     ,X              ; ? END OF TABLE
7070 ff7a 27 b9                      BEQ     CBKERR          ; BRANCH ERROR IF SO
7071 ff7c e1 81                      CMPB    ,X++            ; ? SAME VALUE
7072 ff7e 26 f8                      BNE     CENLP2          ; LOOP IF NOT
7073 ff80 e6 1f                      LDB     -1,X            ; LOAD RESULT VALUE
7074 ff82 ea e4                      ORB     ,S              ; ADD TO BASE SKELETON
7075 ff84 e7 e4                      STB     ,S              ; SAVE POSTBYTE ON STACK
7076 ff86 30 e4                      LEAX    ,S              ; POINT TO IT
7077 ff88 3f                         SWI                     ; SEND OUT AS HEX
7078 ff89 04                         FCB     OUT2HS          ; FUNCTION
7079 ff8a 3f                         SWI                     ; TO NEXT LINE
7080 ff8b 06                         FCB     PCRLF           ; FUNCTION
7081 ff8c 35 84                      PULS    PC,B            ; END OF COMMAND
7082                         
7083                         * TABLE ONE DEFINES VALID INPUT IN SEQUENCE
7084                         CONV1
7085 ff8e 41 04 42 05 44 06          FCB     'A,$04,'B,$05,'D,$06,'H,$01
     48 01
7086 ff96 48 01 48 01 48 00          FCB     'H,$01,'H,$01,'H,$00,',,$00
     2c 00
7087 ff9e 2d 09 2d 01 53 70          FCB     '-,$09,'-,$01,'S,$70,'Y,$30
     59 30
7088 ffa6 55 50 58 10 2b 07          FCB     'U,$50,'X,$10,'+,$07,'+,$01
     2b 01
7089 ffae 50 80 43 00 52 00          FCB     'P,$80,'C,$00,'R,$00,'],$00
     5d 00
7090 ffb6 ff                         FCB     $FF             ; END OF TABLE
7091                         
7092                         * CONV2 USES ABOVE CONVERSION TO SET POSTBYTE
7093                         * BIT SKELETON.
7094                         CONV2
7095 ffb7 10 84 11 00                FDB     $1084,$1100     ; R,      H,R
7096 ffbb 12 88 13 89                FDB     $1288,$1389     ; HH,R    HHHH,R
7097 ffbf 14 86 15 85                FDB     $1486,$1585     ; A,R     B,R
7098 ffc3 16 8b 17 80                FDB     $168B,$1780     ; D,R     ,R+
7099 ffc7 18 81 19 82                FDB     $1881,$1982     ; ,R++    ,-R
7100 ffcb 1a 83 82 8c                FDB     $1A83,$828C     ; ,--R    HH,PCR
7101 ffcf 83 8d 03 9f                FDB     $838D,$039F     ; HHHH,PCR [HHHH]
7102 ffd3 00                         FCB     0               ; END OF TABLE
7103                         
7104                         ****************************************************
7105                         *            DEFAULT INTERRUPT TRANSFERS           *
7106                         ****************************************************
7107 ffd4 6e 9d 60 ee        RSRVD   JMP     [VECTAB+.RSVD,PCR]      ; RESERVED VECTOR
7108 ffd8 6e 9d 60 ec        SWI3    JMP     [VECTAB+.SWI3,PCR]      ; SWI3 VECTOR
7109 ffdc 6e 9d 60 ea        SWI2    JMP     [VECTAB+.SWI2,PCR]      ; SWI2 VECTOR
7110 ffe0 6e 9d 60 e8        FIRQ    JMP     [VECTAB+.FIRQ,PCR]      ; FIRQ VECTOR
7111 ffe4 6e 9d 60 e6        IRQ     JMP     [VECTAB+.IRQ,PCR]       ; IRQ VECTOR
7112 ffe8 6e 9d 60 e4        SWI     JMP     [VECTAB+.SWI,PCR]       ; SWI VECTOR
7113 ffec 6e 9d 60 e2        NMI     JMP     [VECTAB+.NMI,PCR]       ; NMI VECTOR
7114                         
7115                         ******************************************************
7116                         *            ASSIST09 HARDWARE VECTOR TABLE
7117                         * THIS TABLE IS USED IF THE ASSIST09 ROM ADDRESSES
7118                         * THE MC6809 HARDWARE VECTORS.
7119                         ******************************************************
7120 fff0                            ORG     ROMBEG+ROMSIZ-16 ; SETUP HARDWARE VECTORS
7121 fff0 ff d4                      FDB     RSRVD           ; RESERVED SLOT
7122 fff2 ff d8                      FDB     SWI3            ; SOFTWARE INTERRUPT 3
7123 fff4 ff dc                      FDB     SWI2            ; SOFTWARE INTERRUPT 2
7124 fff6 ff e0                      FDB     FIRQ            ; FAST INTERRUPT REQUEST
7125 fff8 ff e4                      FDB     IRQ             ; INTERRUPT REQUEST
7126 fffa ff e8                      FDB     SWI             ; SOFTWARE INTERRUPT
7127 fffc ff ec                      FDB     NMI             ; NON-MASKABLE INTERRUPT
7128 fffe f8 37                      FDB     RESET           ; RESTART
