0001                         ;
0002                         ; 6809 Disassembler
0003                         ;
0004                         ; Copyright (C) 2019 by Jeff Tranter <tranter@pobox.com>
0005                         ;
0006                         ; Licensed under the Apache License, Version 2.0 (the "License");
0007                         ; you may not use this file except in compliance with the License.
0008                         ; You may obtain a copy of the License at
0009                         ;
0010                         ;   http://www.apache.org/licenses/LICENSE-2.0
0011                         ;
0012                         ; Unless required by applicable law or agreed to in writing, software
0013                         ; distributed under the License is distributed on an "AS IS" BASIS,
0014                         ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0015                         ; See the License for the specific language governing permissions and
0016                         ; limitations under the License.
0017                         ;
0018                         ; Revision History
0019                         ; Version Date         Comments
0020                         ; 0.0     29-Jan-2019  First version started, based on 6502 code.
0021                         ; 0.1     03-Feb-2019  All instructions now supported.
0022                         ; 0.2     05-Feb-2019  Integrated into ASSSIST09/BASIC ROM.
0023                         
0024                         ; Character defines
0025                         
0026 000d                    RET     EQU     $0D             ; Carriage return
0027 0020                    SP      EQU     $20             ; Space
0028                         
0029 0018                    PAGELEN EQU     24              ; Number of instructions to show before waiting for keypress
0030                         
0031                         ; Start address for RAM variables
0032 5ff0                            ORG     $5FF0
0033                         
0034                         ; Variables
0035                         
0036 5ff0                    ADRS    RMB     2               ; Current address to disassemble
0037 5ff2                    OPCODE  RMB     1               ; Opcode of instruction
0038 5ff3                    AM      RMB     1               ; Addressing mode of instruction
0039 5ff4                    OPTYPE  RMB     1               ; Instruction type
0040 5ff5                    POSTBYT RMB     1               ; Post byte (for indexed addressing)
0041 5ff6                    LENG    RMB     1               ; Length of instruction
0042 5ff7                    TEMP    RMB     2               ; Temp variable (used by print routines)
0043 5ff9                    TEMP1   RMB     2               ; Temp variable
0044 5ffb                    FIRST   RMB     1               ; Flag used to indicate first time an item printed
0045 5ffc                    PAGE23  RMB     1               ; Flag indicating page2/3 instruction when non-zero
0046                         
0047                         ; Instructions. Matches indexes into entries in table MNEMONICS.
0048                         
0049 0000                    OP_INV   EQU    $00
0050 0001                    OP_ABX   EQU    $01
0051 0002                    OP_ADCA  EQU    $02
0052 0003                    OP_ADCB  EQU    $03
0053 0004                    OP_ADDA  EQU    $04
0054 0005                    OP_ADDB  EQU    $05
0055 0006                    OP_ADDD  EQU    $06
0056 0007                    OP_ANDA  EQU    $07
0057 0008                    OP_ANDB  EQU    $08
0058 0009                    OP_ANDCC EQU    $09
0059 000a                    OP_ASL   EQU    $0A
0060 000b                    OP_ASLA  EQU    $0B
0061 000c                    OP_ASLB  EQU    $0C
0062 000d                    OP_ASR   EQU    $0D
0063 000e                    OP_ASRA  EQU    $0E
0064 000f                    OP_ASRB  EQU    $0F
0065 0010                    OP_BCC   EQU    $10
0066 0011                    OP_BCS   EQU    $11
0067 0012                    OP_BEQ   EQU    $12
0068 0013                    OP_BGE   EQU    $13
0069 0014                    OP_BGT   EQU    $14
0070 0015                    OP_BHI   EQU    $15
0071 0016                    OP_BITA  EQU    $16
0072 0017                    OP_BITB  EQU    $17
0073 0018                    OP_BLE   EQU    $18
0074 0019                    OP_BLS   EQU    $19
0075 001a                    OP_BLT   EQU    $1A
0076 001b                    OP_BMI   EQU    $1B
0077 001c                    OP_BNE   EQU    $1C
0078 001d                    OP_BPL   EQU    $1D
0079 001e                    OP_BRA   EQU    $1E
0080 001f                    OP_BRN   EQU    $1F
0081 0020                    OP_BSR   EQU    $20
0082 0021                    OP_BVC   EQU    $21
0083 0022                    OP_BVS   EQU    $22
0084 0023                    OP_CLR   EQU    $23
0085 0024                    OP_CLRA  EQU    $24
0086 0025                    OP_CLRB  EQU    $25
0087 0026                    OP_CMPA  EQU    $26
0088 0027                    OP_CMPB  EQU    $27
0089 0028                    OP_CMPD  EQU    $28
0090 0029                    OP_CMPS  EQU    $29
0091 002a                    OP_CMPU  EQU    $2A
0092 002b                    OP_CMPX  EQU    $2B
0093 002c                    OP_CMPY  EQU    $2C
0094 002d                    OP_COMA  EQU    $2D
0095 002e                    OP_COMB  EQU    $2E
0096 002f                    OP_COM   EQU    $2F
0097 0030                    OP_CWAI  EQU    $30
0098 0031                    OP_DAA   EQU    $31
0099 0032                    OP_DEC   EQU    $32
0100 0033                    OP_DECA  EQU    $33
0101 0034                    OP_DECB  EQU    $34
0102 0035                    OP_EORA  EQU    $35
0103 0036                    OP_EORB  EQU    $36
0104 0037                    OP_EXG   EQU    $37
0105 0038                    OP_INC   EQU    $38
0106 0039                    OP_INCA  EQU    $39
0107 003a                    OP_INCB  EQU    $3A
0108 003b                    OP_JMP   EQU    $3B
0109 003c                    OP_JSR   EQU    $3C
0110 003d                    OP_LBCC  EQU    $3D
0111 003e                    OP_LBCS  EQU    $3E
0112 003f                    OP_LBEQ  EQU    $3F
0113 0040                    OP_LBGE  EQU    $40
0114 0041                    OP_LBGT  EQU    $41
0115 0042                    OP_LBHI  EQU    $42
0116 0043                    OP_LBLE  EQU    $43
0117 0044                    OP_LBLS  EQU    $44
0118 0045                    OP_LBLT  EQU    $45
0119 0046                    OP_LBMI  EQU    $46
0120 0047                    OP_LBNE  EQU    $47
0121 0048                    OP_LBPL  EQU    $48
0122 0049                    OP_LBRA  EQU    $49
0123 004a                    OP_LBRN  EQU    $4A
0124 004b                    OP_LBSR  EQU    $4B
0125 004c                    OP_LBVC  EQU    $4C
0126 004d                    OP_LBVS  EQU    $4D
0127 004e                    OP_LDA   EQU    $4E
0128 004f                    OP_LDB   EQU    $4F
0129 0050                    OP_LDD   EQU    $50
0130 0051                    OP_LDS   EQU    $51
0131 0052                    OP_LDU   EQU    $52
0132 0053                    OP_LDX   EQU    $53
0133 0054                    OP_LDY   EQU    $54
0134 0055                    OP_LEAS  EQU    $55
0135 0056                    OP_LEAU  EQU    $56
0136 0057                    OP_LEAX  EQU    $57
0137 0058                    OP_LEAY  EQU    $58
0138 0059                    OP_LSR   EQU    $59
0139 005a                    OP_LSRA  EQU    $5A
0140 005b                    OP_LSRB  EQU    $5B
0141 005c                    OP_MUL   EQU    $5C
0142 005d                    OP_NEG   EQU    $5D
0143 005e                    OP_NEGA  EQU    $5E
0144 005f                    OP_NEGB  EQU    $5F
0145 0060                    OP_NOP   EQU    $60
0146 0061                    OP_ORA   EQU    $61
0147 0062                    OP_ORB   EQU    $62
0148 0063                    OP_ORCC  EQU    $63
0149 0064                    OP_PSHS  EQU    $64
0150 0065                    OP_PSHU  EQU    $65
0151 0066                    OP_PULS  EQU    $66
0152 0067                    OP_PULU  EQU    $67
0153 0068                    OP_ROL   EQU    $68
0154 0069                    OP_ROLA  EQU    $69
0155 006a                    OP_ROLB  EQU    $6A
0156 006b                    OP_ROR   EQU    $6B
0157 006c                    OP_RORA  EQU    $6C
0158 006d                    OP_RORB  EQU    $6D
0159 006e                    OP_RTI   EQU    $6E
0160 006f                    OP_RTS   EQU    $6F
0161 0070                    OP_SBCA  EQU    $70
0162 0071                    OP_SBCB  EQU    $71
0163 0072                    OP_SEX   EQU    $72
0164 0073                    OP_STA   EQU    $73
0165 0074                    OP_STB   EQU    $74
0166 0075                    OP_STD   EQU    $75
0167 0076                    OP_STS   EQU    $76
0168 0077                    OP_STU   EQU    $77
0169 0078                    OP_STX   EQU    $78
0170 0079                    OP_STY   EQU    $79
0171 007a                    OP_SUBA  EQU    $7A
0172 007b                    OP_SUBB  EQU    $7B
0173 007c                    OP_SUBD  EQU    $7C
0174 007d                    OP_SWI   EQU    $7D
0175 007e                    OP_SWI2  EQU    $7E
0176 007f                    OP_SWI3  EQU    $7F
0177 0080                    OP_SYNC  EQU    $80
0178 0081                    OP_TFR   EQU    $81
0179 0082                    OP_TST   EQU    $82
0180 0083                    OP_TSTA  EQU    $83
0181 0084                    OP_TSTB  EQU    $84
0182                         
0183                         ; Addressing Modes. OPCODES table lists these for each instruction.
0184                         ; LENGTHS lists the instruction length for each addressing mode.
0185                         ; Need to distinguish relative modes that are 2 and 3 (long) bytes.
0186                         ; Some immediate are 2 and some 3 bytes.
0187                         ; Indexed modes can be longer depending on postbyte.
0188                         ; Page 2 and 3 opcodes are one byte longer (prefixed by 10 or 11)
0189                         
0190 0000                    AM_INVALID      EQU     0       ; $01 (1)
0191 0001                    AM_INHERENT     EQU     1       ; RTS (1)
0192 0002                    AM_IMMEDIATE8   EQU     2       ; LDA #$12 (2)
0193 0003                    AM_IMMEDIATE16  EQU     3       ; LDD #$1234 (3)
0194 0004                    AM_DIRECT       EQU     4       ; LDA $12 (2)
0195 0005                    AM_EXTENDED     EQU     5       ; LDA $1234 (3)
0196 0006                    AM_RELATIVE8    EQU     6       ; BSR $1234 (2)
0197 0007                    AM_RELATIVE16   EQU     7       ; LBSR $1234 (3)
0198 0008                    AM_INDEXED      EQU     8       ; LDA 0,X (2+)
0199                         
0200                         ; *** CODE ***
0201                         
0202 c000                      ORG     $C000
0203                         
0204                         ; Main program. Disassembles a page at a time. Can be run directly or
0205                         ; as an ASSIST09 monitor external command. Gets start address from
0206                         ; command line.
0207                         
0208 c000 17 3e 59           CUNAS:  LBSR    CDNUM           ; Parse command line, return 16-bit number in D
0209 c003 fd 5f f0                   STD     ADRS            ; Store it
0210 c006 86 18              PAGE:   LDA     #PAGELEN        ; Number of instruction to disassemble per page
0211 c008 34 02              DIS:    PSHS    A               ; Save A
0212 c00a 17 00 97                   LBSR    DISASM          ; Do disassembly of one instruction
0213 c00d 35 02                      PULS    A               ; Restore A
0214 c00f 4a                         DECA                    ; Decrement count
0215 c010 26 f6                      BNE     DIS             ; Go back and repeat until a page has been done
0216 c012 30 8d 0b 8b                LEAX    MSG2,PCR        ; Display message to press a key
0217 c016 17 00 84                   LBSR    PrintString
0218 c019 8d 63              BADKEY: BSR     GetChar         ; Wait for keyboard input
0219 c01b 8d 11                      BSR     PrintCR
0220 c01d 81 20                      CMPA    #SP             ; Space key pressed?
0221 c01f 27 e5                      BEQ     PAGE            ; If so, display next page
0222 c021 81 51                      CMPA    #'Q             ; Q key pressed?
0223 c023 27 08                      BEQ     RETN            ; If so, return
0224 c025 81 71                      CMPA    #'q             ; q key pressed?
0225 c027 27 04                      BEQ     RETN            ; If so, return
0226 c029 8d 72                      BSR     PrintString     ; Bad key, prompt and try again
0227 c02b 20 ec                      BRA     BADKEY
0228 c02d 39                 RETN:   RTS                     ; Return to caller
0229                         
0230                         ; *** Utility Functions ***
0231                         ; Some of these call ASSIST09 ROM monitor routines.
0232                         
0233                         ; Print CR/LF to the console.
0234                         ; Registers changed: none
0235                         PrintCR:
0236 c02e 34 02                      PSHS    A               ; Save A
0237 c030 86 0d                      LDA     #RET
0238 c032 8d 47                      BSR     PrintChar
0239 c034 86 0a                      LDA     #LF
0240 c036 8d 43                      BSR     PrintChar
0241 c038 35 02                      PULS    A               ; Restore A
0242 c03a 39                         RTS
0243                         
0244                         ; Print dollar sign to the console.
0245                         ; Registers changed: none
0246                         PrintDollar:
0247 c03b 34 02                      PSHS    A               ; Save A
0248 c03d 86 24                      LDA     #'$
0249 c03f 8d 3a                      BSR     PrintChar
0250 c041 35 02                      PULS    A               ; Restore A
0251 c043 39                         RTS
0252                         
0253                         ; Print comma to the console.
0254                         ; Registers changed: none
0255                         PrintComma:
0256 c044 34 02                      PSHS    A               ; Save A
0257 c046 86 2c                      LDA     #',
0258 c048 8d 31                      BSR     PrintChar
0259 c04a 35 02                      PULS    A               ; Restore A
0260 c04c 39                         RTS
0261                         
0262                         ; Print left square bracket to the console.
0263                         ; Registers changed: none
0264                         PrintLBracket:
0265 c04d 34 02                      PSHS    A               ; Save A
0266 c04f 86 5b                      LDA     #'[
0267 c051 8d 28                      BSR     PrintChar
0268 c053 35 02                      PULS    A               ; Restore A
0269 c055 39                         RTS
0270                         
0271                         ; Print right square bracket to the console.
0272                         ; Registers changed: none
0273                         PrintRBracket:
0274 c056 34 02                      PSHS    A               ; Save A
0275 c058 86 5d                      LDA     #']
0276 c05a 8d 1f                      BSR     PrintChar
0277 c05c 35 02                      PULS    A               ; Restore A
0278 c05e 39                         RTS
0279                         
0280                         ; Print space sign to the console.
0281                         ; Registers changed: none
0282                         PrintSpace:
0283 c05f 3f                         SWI
0284 c060 07                         FCB     SPACEF
0285 c061 39                         RTS
0286                         
0287                         ; Print two spaces to the console.
0288                         ; Registers changed: none
0289                         Print2Spaces:
0290 c062 34 02                      PSHS    A               ; Save A
0291 c064 86 20                      LDA     #SP
0292 c066 8d 13                      BSR     PrintChar
0293 c068 8d 11                      BSR     PrintChar
0294 c06a 35 02                      PULS    A               ; Restore A
0295 c06c 39                         RTS
0296                         
0297                         ; Print several space characters.
0298                         ; A contains number of spaces to print.
0299                         ; Registers changed: none
0300                         PrintSpaces:
0301 c06d 34 02                      PSHS    A               ; Save registers used
0302 c06f 81 00              PS1:    CMPA    #0              ; Is count zero?
0303 c071 27 05                      BEQ     PS2             ; Is so, done
0304 c073 8d ea                      BSR     PrintSpace      ; Print a space
0305 c075 4a                         DECA                    ; Decrement count
0306 c076 20 f7                      BRA     PS1             ; Check again
0307 c078 35 02              PS2:    PULS    A               ; Restore registers used
0308 c07a 39                         RTS
0309                         
0310                         ; Print character to the console
0311                         ; A contains character to print.
0312                         ; Registers changed: none
0313                         PrintChar:
0314 c07b 3f                         SWI                     ; Call ASSIST09 monitor function
0315 c07c 01                         FCB     OUTCH           ; Service code byte
0316 c07d 39                         RTS
0317                         
0318                         ; Get character from the console
0319                         ; A contains character read. Blocks until key pressed. Character is
0320                         ; echoed. Ignores NULL ($00) and RUBOUT ($7F). CR ($OD) is converted
0321                         ; to LF ($0A).
0322                         ; Registers changed: none (flags may change). Returns char in A.
0323                         GetChar:
0324 c07e 3f                         SWI                     ; Call ASSIST09 monitor function
0325 c07f 00                         FCB     INCHNP          ; Service code byte
0326 c080 39                         RTS
0327                         
0328                         ; Print a byte as two hex digits followed by a space.
0329                         ; A contains byte to print.
0330                         ; Registers changed: none
0331                         PrintByte:
0332 c081 34 16                      PSHS    A,B,X           ; Save registers used
0333 c083 b7 5f f7                   STA     TEMP            ; Needs to be in memory so we can point to it
0334 c086 30 8d 9f 6d                LEAX    TEMP,PCR        ; Get pointer to it
0335 c08a 3f                         SWI                     ; Call ASSIST09 monitor function
0336 c08b 04                         FCB     OUT2HS          ; Service code byte
0337 c08c 35 16                      PULS    X,B,A           ; Restore registers used
0338 c08e 39                         RTS
0339                         
0340                         ; Print a word as four hex digits followed by a space.
0341                         ; X contains word to print.
0342                         ; Registers changed: none
0343                         PrintAddress:
0344 c08f 34 16                      PSHS    A,B,X           ; Save registers used
0345 c091 bf 5f f7                   STX     TEMP            ; Needs to be in memory so we can point to it
0346 c094 30 8d 9f 5f                LEAX    TEMP,PCR        ; Get pointer to it
0347 c098 3f                         SWI                     ; Call ASSIST09 monitor function
0348 c099 05                         FCB     OUT4HS          ; Service code byte
0349 c09a 35 16                      PULS    X,B,A           ; Restore registers used
0350 c09c 39                         RTS
0351                         
0352                         ; Print a string.
0353                         ; X points to start of string to display.
0354                         ; String must be terminated in EOT character.
0355                         ; Registers changed: none
0356                         PrintString:
0357 c09d 34 10                      PSHS    X               ; Save registers used
0358 c09f 3f                         SWI                     ; Call ASSIST09 monitor function
0359 c0a0 02                         FCB     PDATA1          ; Service code byte
0360 c0a1 35 10                      PULS    X               ; Restore registers used
0361 c0a3 39                         RTS
0362                         
0363                         ; Disassemble instruction at address ADRS. On return, ADRS points to
0364                         ; next instruction so it can be called again.
0365                         
0366 c0a4 7f 5f fc           DISASM: CLR     PAGE23          ; Clear page2/3 flag
0367 c0a7 ae 8d 9f 45                LDX     ADRS,PCR        ; Get address of instruction
0368 c0ab e6 84                      LDB     ,X              ; Get instruction op code
0369 c0ad c1 10                      CMPB    #$10            ; Is it a page 2 16-bit opcode prefix with 10?
0370 c0af 27 07                      BEQ     handle10        ; If so, do special handling
0371 c0b1 c1 11                      CMPB    #$11            ; Is it a page 3 16-bit opcode prefix with 11?
0372 c0b3 27 53                      BEQ     handle11        ; If so, do special handling
0373 c0b5 16 00 a0                   LBRA    not1011         ; If not, handle as normal case
0374                         
0375                         handle10:                       ; Handle page 2 instruction
0376 c0b8 86 01                      LDA     #1              ; Set page2/3 flag
0377 c0ba b7 5f fc                   STA     PAGE23
0378 c0bd e6 01                      LDB     1,X             ; Get real opcode
0379 c0bf f7 5f f2                   STB     OPCODE          ; Save it.
0380 c0c2 30 8d 0a 42                LEAX    PAGE2,PCR       ; Pointer to start of table
0381 c0c6 4f                         CLRA                    ; Set index into table to zero
0382                         search10:
0383 c0c7 e1 86                      CMPB    A,X             ; Check for match of opcode in table
0384 c0c9 27 1f                      BEQ     found10         ; Branch if found
0385 c0cb 8b 03                      ADDA    #3              ; Advance to next entry in table (entries are 3 bytes long)
0386 c0cd 6d 86                      TST     A,X             ; Check entry
0387 c0cf 27 02                      BEQ     notfound10      ; If zero, then reached end of table
0388 c0d1 20 f4                      BRA     search10        ; If not, keep looking
0389                         
0390                         notfound10:                     ; Instruction not found, so is invalid.
0391 c0d3 86 10                      LDA     #$10            ; Set opcode to 10
0392 c0d5 b7 5f f2                   STA     OPCODE
0393 c0d8 86 00                      LDA     #OP_INV         ; Set as instruction type invalid
0394 c0da b7 5f f4                   STA     OPTYPE
0395 c0dd 86 00                      LDA     #AM_INVALID     ; Set as addressing mode invalid
0396 c0df b7 5f f3                   STA     AM
0397 c0e2 86 01                      LDA     #1              ; Set length to one
0398 c0e4 b7 5f f6                   STA     LENG
0399 c0e7 16 00 90                   LBRA    dism            ; Disassemble as normal
0400                         
0401                         found10:                        ; Found entry in table
0402 c0ea 8b 01                      ADDA    #1              ; Advance to instruction type entry in table
0403 c0ec e6 86                      LDB     A,X             ; Get instruction type
0404 c0ee f7 5f f4                   STB     OPTYPE          ; Save it
0405 c0f1 8b 01                      ADDA    #1              ; Advanced to address mode entry in table
0406 c0f3 e6 86                      LDB     A,X             ; Get address mode
0407 c0f5 f7 5f f3                   STB     AM              ; Save it
0408 c0f8 4f                         CLRA                    ; Clear MSB of D, addressing mode is now in A:B (D)
0409 c0f9 1f 01                      TFR     D,X             ; Put addressing mode in X
0410 c0fb e6 89 c8 db                LDB     LENGTHS,X       ; Get instruction length from table
0411 c0ff f7 5f f6                   STB     LENG            ; Store it
0412 c102 7c 5f f6                   INC     LENG            ; Add one because it is a two byte op code
0413 c105 16 00 72                   LBRA    dism            ; Continue normal disassembly processing.
0414                         
0415                         handle11:                       ; Same logic as above, but use table for page 3 opcodes.
0416 c108 86 01                      LDA     #1              ; Set page2/3 flag
0417 c10a b7 5f fc                   STA     PAGE23
0418 c10d e6 01                      LDB     1,X             ; Get real opcode
0419 c10f f7 5f f2                   STB     OPCODE          ; Save it.
0420 c112 30 8d 0a 65                LEAX    PAGE3,PCR       ; Pointer to start of table
0421 c116 4f                         CLRA                    ; Set index into table to zero
0422                         search11:
0423 c117 e1 86                      CMPB    A,X             ; Check for match of opcode in table
0424 c119 27 1f                      BEQ     found11         ; Branch if found
0425 c11b 8b 03                      ADDA    #3              ; Advance to next entry in table (entries are 3 bytes long)
0426 c11d 6d 86                      TST     A,X             ; Check entry
0427 c11f 27 02                      BEQ     notfound11      ; If zero, then reached end of table
0428 c121 20 f4                      BRA     search11        ; If not, keep looking
0429                         
0430                         notfound11:                     ; Instruction not found, so is invalid.
0431 c123 86 11                      LDA     #$11            ; Set opcode to 10
0432 c125 b7 5f f2                   STA     OPCODE
0433 c128 86 00                      LDA     #OP_INV         ; Set as instruction type invalid
0434 c12a b7 5f f4                   STA     OPTYPE
0435 c12d 86 00                      LDA     #AM_INVALID     ; Set as addressing mode invalid
0436 c12f b7 5f f3                   STA     AM
0437 c132 86 01                      LDA     #1              ; Set length to one
0438 c134 b7 5f f6                   STA     LENG
0439 c137 16 00 40                   LBRA    dism            ; Disassemble as normal
0440                         
0441                         found11:                        ; Found entry in table
0442 c13a 8b 01                      ADDA    #1              ; Advance to instruction type entry in table
0443 c13c e6 86                      LDB     A,X             ; Get instruction type
0444 c13e f7 5f f4                   STB     OPTYPE          ; Save it
0445 c141 8b 01                      ADDA    #1              ; Advanced to address mode entry in table
0446 c143 e6 86                      LDB     A,X             ; Get address mode
0447 c145 f7 5f f3                   STB     AM              ; Save it
0448 c148 4f                         CLRA                    ; Clear MSB of D, addressing mode is now in A:B (D)
0449 c149 1f 01                      TFR     D,X             ; Put addressing mode in X
0450 c14b e6 89 c8 db                LDB     LENGTHS,X       ; Get instruction length from table
0451 c14f f7 5f f6                   STB     LENG            ; Store it
0452 c152 7c 5f f6                   INC     LENG            ; Add one because it is a two byte op code
0453 c155 16 00 22                   LBRA    dism            ; Continue normal disassembly processing.
0454                         
0455                         not1011:
0456 c158 f7 5f f2                   STB     OPCODE          ; Save the op code
0457 c15b 4f                         CLRA                    ; Clear MSB of D
0458 c15c 1f 01                      TFR     D,X             ; Put op code in X
0459 c15e e6 89 c9 08                LDB     OPCODES,X       ; Get opcode type from table
0460 c162 f7 5f f4                   STB     OPTYPE          ; Store it
0461 c165 f6 5f f2                   LDB     OPCODE          ; Get op code again
0462 c168 1f 01                      TFR     D,X             ; Put opcode in X
0463 c16a e6 89 ca 08                LDB     MODES,X         ; Get addressing mode type from table
0464 c16e f7 5f f3                   STB     AM              ; Store it
0465 c171 1f 01                      TFR     D,X             ; Put addressing mode in X
0466 c173 e6 89 c8 db                LDB     LENGTHS,X       ; Get instruction length from table
0467 c177 f7 5f f6                   STB     LENG            ; Store it
0468                         
0469                         ; If addressing mode is indexed, get and save the indexed addressing
0470                         ; post byte.
0471                         
0472 c17a b6 5f f3           dism:   LDA     AM              ; Get addressing mode
0473 c17d 81 08                      CMPA    #AM_INDEXED     ; Is it indexed mode?
0474 c17f 26 22                      BNE     NotIndexed      ; Branch if not
0475 c181 ae 8d 9e 6b                LDX     ADRS,PCR        ; Get address of op code
0476                                                         ; If it is a page2/3 instruction, op code is the next byte after ADRS
0477 c185 7d 5f fc                   TST     PAGE23          ; Page2/3 instruction?
0478 c188 27 04                      BEQ     norm            ; Branch of not
0479 c18a a6 02                      LDA     2,X             ; Post byte is two past ADRS
0480 c18c 20 02                      BRA     getpb
0481 c18e a6 01              norm:   LDA     1,X             ; Get next byte (the post byte)
0482 c190 b7 5f f5           getpb:  STA     POSTBYT         ; Save it
0483                         
0484                         ; Determine number of additional bytes for indexed addressing based on
0485                         ; postbyte. If most significant bit is 0, there are no additional
0486                         ; bytes and we can skip the rest of the check.
0487                         
0488 c193 2a 0e                      BPL     NotIndexed      ; Branch of MSB is zero
0489                         
0490                         ; Else if most significant bit is 1, mask off all but low order 5 bits
0491                         ; and look up length in table.
0492                         
0493 c195 84 1f                      ANDA    #%00011111      ; Mask off bits
0494 c197 30 8d 07 4d                LEAX    POSTBYTES,PCR   ; Lookup table of lengths
0495 c19b a6 86                      LDA     A,X             ; Get table entry
0496 c19d bb 5f f6                   ADDA    LENG            ; Add to instruction length
0497 c1a0 b7 5f f6                   STA     LENG            ; Save new length
0498                         
0499                         NotIndexed:
0500                         
0501                         ; Print address followed by a space
0502 c1a3 ae 8d 9e 49                LDX     ADRS,PCR
0503 c1a7 17 fe e5                   LBSR    PrintAddress
0504                         
0505                         ; Print one more space
0506                         
0507 c1aa 17 fe b2                   LBSR    PrintSpace
0508                         
0509                         ; Print the op code bytes based on the instruction length
0510                         
0511 c1ad f6 5f f6                   LDB     LENG            ; Number of bytes in instruction
0512 c1b0 ae 8d 9e 3c                LDX     ADRS,PCR        ; Pointer to start of instruction
0513 c1b4 a6 80              opby:   LDA     ,X+             ; Get instruction byte and increment pointer
0514 c1b6 17 fe c8                   LBSR    PrintByte       ; Print it, followed by a space
0515 c1b9 5a                         DECB                    ; Decrement byte count
0516 c1ba 26 f8                      BNE     opby            ; Repeat until done
0517                         
0518                         ; Print needed remaining spaces to pad out to correct column
0519                         
0520 c1bc 30 8d 07 24                LEAX    PADDING,PCR     ; Pointer to start of lookup table
0521 c1c0 b6 5f f6                   LDA     LENG            ; Number of bytes in instruction
0522 c1c3 4a                         DECA                    ; Subtract 1 since table starts at 1, not 0
0523 c1c4 a6 86                      LDA     A,X             ; Get number of spaces to print
0524 c1c6 17 fe a4                   LBSR    PrintSpaces
0525                         
0526                         ; If a page2/3 instruction, advance ADRS to the next byte which points
0527                         ; to the real op code.
0528                         
0529 c1c9 7d 5f fc                   TST     PAGE23          ; Flag set
0530 c1cc 27 09                      BEQ     noinc           ; Branch if not
0531 c1ce fc 5f f0                   LDD     ADRS            ; Increment 16-bit address
0532 c1d1 c3 00 01                   ADDD    #1
0533 c1d4 fd 5f f0                   STD     ADRS
0534                         
0535                         ; Get and print mnemonic (4 chars)
0536                         
0537 c1d7 f6 5f f4           noinc   LDB     OPTYPE          ; Get instruction type to index into table
0538 c1da 4f                         CLRA                    ; Clear MSB of D
0539 c1db 58                         ASLB                    ; 16-bit shift of D: Rotate B, MSB into Carry
0540 c1dc 49                         ROLA                    ; Rotate A, Carry into LSB
0541 c1dd 58                         ASLB                    ; Do it twice to multiple by four
0542 c1de 49                         ROLA                    ;
0543 c1df 30 8d 04 e4                LEAX    MNEMONICS,PCR   ; Pointer to start of table
0544 c1e3 b7 5f f9                   STA     TEMP1           ; Save value of A
0545 c1e6 a6 8b                      LDA     D,X             ; Get first char of mnemonic
0546 c1e8 17 fe 90                   LBSR    PrintChar       ; Print it
0547 c1eb b6 5f f9                   LDA     TEMP1           ; Restore value of A
0548 c1ee 5c                         INCB                    ; Advance pointer
0549 c1ef a6 8b                      LDA     D,X             ; Get second char of mnemonic
0550 c1f1 17 fe 87                   LBSR    PrintChar       ; Print it
0551 c1f4 b6 5f f9                   LDA     TEMP1           ; Restore value of A
0552 c1f7 5c                         INCB                    ; Advance pointer
0553 c1f8 a6 8b                      LDA     D,X             ; Get third char of mnemonic
0554 c1fa 17 fe 7e                   LBSR    PrintChar       ; Print it
0555 c1fd b6 5f f9                   LDA     TEMP1           ; Restore value of A
0556 c200 5c                         INCB                    ; Advance pointer
0557 c201 a6 8b                      LDA     D,X             ; Get fourth char of mnemonic
0558 c203 17 fe 75                   LBSR    PrintChar       ; Print it
0559                         
0560                         ; Display any operands based on addressing mode and call appropriate
0561                         ; routine. TODO: Could use a lookup table for this.
0562                         
0563 c206 b6 5f f3                   LDA     AM              ; Get addressing mode
0564 c209 81 00                      CMPA    #AM_INVALID
0565 c20b 27 2e                      BEQ     DO_INVALID
0566 c20d 81 01                      CMPA    #AM_INHERENT
0567 c20f 27 39                      BEQ     DO_INHERENT
0568 c211 81 02                      CMPA    #AM_IMMEDIATE8
0569 c213 27 38                      BEQ     DO_IMMEDIATE8
0570 c215 81 03                      CMPA    #AM_IMMEDIATE16
0571 c217 10 27 01 af                LBEQ    DO_IMMEDIATE16
0572 c21b 81 04                      CMPA    #AM_DIRECT
0573 c21d 10 27 01 c4                LBEQ    DO_DIRECT
0574 c221 81 05                      CMPA    #AM_EXTENDED
0575 c223 10 27 01 d0                LBEQ    DO_EXTENDED
0576 c227 81 06                      CMPA    #AM_RELATIVE8
0577 c229 10 27 01 e0                LBEQ    DO_RELATIVE8
0578 c22d 81 07                      CMPA    #AM_RELATIVE16
0579 c22f 10 27 01 f5                LBEQ    DO_RELATIVE16
0580 c233 81 08                      CMPA    #AM_INDEXED
0581 c235 10 27 02 09                LBEQ    DO_INDEXED
0582 c239 20 00                      BRA     DO_INVALID      ; Should never be reached
0583                         
0584                         DO_INVALID:                     ; Display "   ; INVALID"
0585 c23b 86 0f                      LDA     #15             ; Want 15 spaces
0586 c23d 17 fe 2d                   LBSR    PrintSpaces
0587 c240 30 8d 09 53                LEAX    MSG1,PCR
0588 c244 17 fe 56                   LBSR    PrintString
0589 c247 16 04 67                   LBRA    done
0590                         
0591                         DO_INHERENT:                    ; Nothing else to do
0592 c24a 16 04 64                   LBRA    done
0593                         
0594                         DO_IMMEDIATE8:
0595 c24d b6 5f f4                   LDA     OPTYPE          ; Get opcode type
0596 c250 81 81                      CMPA    #OP_TFR         ; Is is TFR?
0597 c252 27 33                      BEQ     XFREXG          ; Handle special case of TFR
0598 c254 81 37                      CMPA    #OP_EXG         ; Is is EXG?
0599 c256 27 2f                      BEQ     XFREXG          ; Handle special case of EXG
0600                         
0601 c258 81 66                      CMPA    #OP_PULS        ; Is is PULS?
0602 c25a 10 27 00 ad                LBEQ    PULPSH
0603 c25e 81 67                      CMPA    #OP_PULU        ; Is is PULU?
0604 c260 10 27 00 a7                LBEQ    PULPSH
0605 c264 81 64                      CMPA    #OP_PSHS        ; Is is PSHS?
0606 c266 10 27 00 a1                LBEQ    PULPSH
0607 c26a 81 65                      CMPA    #OP_PSHU        ; Is is PSHU?
0608 c26c 10 27 00 9b                LBEQ    PULPSH
0609                         
0610                                                         ; Display "  #$nn"
0611 c270 17 fd ef                   LBSR    Print2Spaces    ; Two spaces
0612 c273 86 23                      LDA     #'#             ; Number sign
0613 c275 17 fe 03                   LBSR    PrintChar
0614 c278 17 fd c0                   LBSR    PrintDollar     ; Dollar sign
0615 c27b ae 8d 9d 71                LDX     ADRS,PCR        ; Get address of op code
0616 c27f a6 01                      LDA     1,X             ; Get next byte (immediate data)
0617 c281 17 fd fd                   LBSR    PrintByte       ; Print as hex value
0618 c284 16 04 2a                   LBRA    done
0619                         
0620                         XFREXG:                         ; Handle special case of TFR and EXG
0621                                                         ; Display "  r1,r2"
0622 c287 17 fd d8                   LBSR    Print2Spaces    ; Two spaces
0623 c28a ae 8d 9d 62                LDX     ADRS,PCR        ; Get address of op code
0624 c28e a6 01                      LDA     1,X             ; Get next byte (postbyte)
0625 c290 84 f0                      ANDA    #%11110000      ; Mask out source register bits
0626 c292 44                         LSRA                    ; Shift into low order bits
0627 c293 44                         LSRA
0628 c294 44                         LSRA
0629 c295 44                         LSRA
0630 c296 8d 0e                      BSR     TFREXGRegister  ; Print source register name
0631 c298 86 2c                      LDA     #',             ; Print comma
0632 c29a 17 fd de                   LBSR    PrintChar
0633 c29d a6 01                      LDA     1,X             ; Get postbyte again
0634 c29f 84 0f                      ANDA    #%00001111      ; Mask out destination register bits
0635 c2a1 8d 03                      BSR     TFREXGRegister  ; Print destination register name
0636 c2a3 16 04 0b                   LBRA    done
0637                         
0638                         ; Look up register name (in A) from Transfer/Exchange postbyte. 4 LSB
0639                         ; bits determine the register name. Value is printed. Invalid value
0640                         ; is shown as '?'.
0641                         ; Value:    0 1 2 3 4 5  8 9 10 11
0642                         ; Register: D X Y U S PC A B CC DP
0643                         
0644                         TFREXGRegister:
0645 c2a6 81 00                      CMPA    #0
0646 c2a8 26 04                      BNE     Try1
0647 c2aa 86 44                      LDA     #'D
0648 c2ac 20 50                      BRA     Print1Reg
0649 c2ae 81 01              Try1:   CMPA    #1
0650 c2b0 26 04                      BNE     Try2
0651 c2b2 86 58                      LDA     #'X
0652 c2b4 20 48                      BRA     Print1Reg
0653 c2b6 81 02              Try2:   CMPA    #2
0654 c2b8 26 04                      BNE     Try3
0655 c2ba 86 59                      LDA     #'Y
0656 c2bc 20 40                      BRA     Print1Reg
0657 c2be 81 03              Try3:   CMPA    #3
0658 c2c0 26 04                      BNE     Try4
0659 c2c2 86 55                      LDA     #'U
0660 c2c4 20 38                      BRA     Print1Reg
0661 c2c6 81 04              Try4:   CMPA    #4
0662 c2c8 26 04                      BNE     Try5
0663 c2ca 86 53                      LDA     #'S
0664 c2cc 20 30                      BRA     Print1Reg
0665 c2ce 81 05              Try5:   CMPA    #5
0666 c2d0 26 06                      BNE     Try8
0667 c2d2 86 50                      LDA     #'P
0668 c2d4 c6 43                      LDB     #'C
0669 c2d6 20 2a                      BRA     Print2Reg
0670 c2d8 81 08              Try8:   CMPA    #8
0671 c2da 26 04                      BNE     Try9
0672 c2dc 86 41                      LDA     #'A
0673 c2de 20 1e                      BRA     Print1Reg
0674 c2e0 81 09              Try9:   CMPA    #9
0675 c2e2 26 04                      BNE     Try10
0676 c2e4 86 42                      LDA     #'B
0677 c2e6 20 16                      BRA     Print1Reg
0678 c2e8 81 0a              Try10:  CMPA    #10
0679 c2ea 26 06                      BNE     Try11
0680 c2ec 86 43                      LDA     #'C
0681 c2ee c6 43                      LDB     #'C
0682 c2f0 20 10                      BRA     Print2Reg
0683 c2f2 81 0b              Try11:  CMPA    #11
0684 c2f4 26 06                      BNE     Inv
0685 c2f6 86 44                      LDA     #'D
0686 c2f8 c6 50                      LDB     #'P
0687 c2fa 20 06                      BRA     Print2Reg
0688 c2fc 86 3f              Inv:    LDA     #'?             ; Invalid
0689                                                         ; Fall through
0690                         Print1Reg:
0691 c2fe 17 fd 7a                   LBSR   PrintChar        ; Print character
0692 c301 39                         RTS
0693                         Print2Reg:
0694 c302 17 fd 76                   LBSR   PrintChar        ; Print first character
0695 c305 1f 98                      TFR    B,A
0696 c307 17 fd 71                   LBSR   PrintChar        ; Print second character
0697 c30a 39                         RTS
0698                         
0699                         ; Handle PSHS/PSHU/PULS/PULU instruction operands
0700                         ; Format is a register list, eg; "  A,B,X"
0701                         
0702                         PULPSH:
0703 c30b 17 fd 54                   LBSR    Print2Spaces    ; Two spaces
0704 c30e 86 01                      LDA     #1
0705 c310 b7 5f fb                   STA     FIRST           ; Flag set before any items printed
0706 c313 ae 8d 9c d9                LDX     ADRS,PCR        ; Get address of op code
0707 c317 a6 01                      LDA     1,X             ; Get next byte (postbyte)
0708                         
0709                         ; Postbyte bits indicate registers to push/pull when 1.
0710                         ; 7  6   5 4 3  2 1 0
0711                         ; PC S/U Y X DP B A CC
0712                         
0713                         ; TODO: Could simplify this with shifting and lookup table.
0714                         
0715 c319 85 80                      BITA    #%10000000      ; Bit 7 set?
0716 c31b 27 0d                      BEQ     bit6
0717 c31d 34 06                      PSHS    A,B
0718 c31f 86 50                      LDA     #'P
0719 c321 c6 43                      LDB     #'C
0720 c323 8d dd                      BSR     Print2Reg       ; Print PC
0721 c325 7f 5f fb                   CLR     FIRST
0722 c328 35 06                      PULS    A,B
0723 c32a 85 40              bit6:   BITA    #%01000000      ; Bit 6 set?
0724 c32c 27 21                      BEQ     bit5
0725                         
0726                         ; Need to show S or U depending on instruction
0727                         
0728 c32e 34 02                      PSHS    A               ; Save postbyte
0729 c330 b6 5f f4                   LDA     OPTYPE          ; Get opcode type
0730 c333 81 66                      CMPA    #OP_PULS
0731 c335 27 12                      BEQ     printu
0732 c337 81 64                      CMPA    #OP_PSHS
0733 c339 27 0e                      BEQ     printu
0734 c33b 17 00 81                   LBSR    PrintCommaIfNotFirst
0735 c33e 86 53                      LDA     #'S             ; Print S
0736 c340 8d bc              pr1     BSR     Print1Reg
0737 c342 7f 5f fb                   CLR     FIRST
0738 c345 35 02                      PULS    A
0739 c347 20 06                      bra     bit5
0740 c349 8d 74              printu: BSR     PrintCommaIfNotFirst
0741 c34b 86 55                      LDA     #'U             ; Print U
0742 c34d 20 f1                      bra     pr1
0743 c34f 85 20              bit5:   BITA    #%00100000      ; Bit 5 set?
0744 c351 27 0d                      BEQ     bit4
0745 c353 34 02                      PSHS    A
0746 c355 8d 68                      BSR     PrintCommaIfNotFirst
0747 c357 86 59                      LDA     #'Y
0748 c359 8d a3                      BSR     Print1Reg       ; Print Y
0749 c35b 7f 5f fb                   CLR     FIRST
0750 c35e 35 02                      PULS    A
0751 c360 85 10              bit4:   BITA    #%00010000      ; Bit 4 set?
0752 c362 27 0d                      BEQ     bit3
0753 c364 34 02                      PSHS    A
0754 c366 8d 57                      BSR     PrintCommaIfNotFirst
0755 c368 86 58                      LDA     #'X
0756 c36a 8d 92                      BSR     Print1Reg       ; Print X
0757 c36c 7f 5f fb                   CLR     FIRST
0758 c36f 35 02                      PULS    A
0759 c371 85 08              bit3:   BITA    #%00001000      ; Bit 3 set?
0760 c373 27 0f                      BEQ     bit2
0761 c375 34 06                      PSHS    A,B
0762 c377 8d 46                      BSR     PrintCommaIfNotFirst
0763 c379 86 44                      LDA     #'D
0764 c37b c6 50                      LDB     #'P
0765 c37d 8d 83                      BSR     Print2Reg       ; Print DP
0766 c37f 7f 5f fb                   CLR     FIRST
0767 c382 35 06                      PULS    A,B
0768 c384 85 04              bit2:   BITA    #%00000100      ; Bit 2 set?
0769 c386 27 0e                      BEQ     bit1
0770 c388 34 02                      PSHS    A
0771 c38a 8d 33                      BSR     PrintCommaIfNotFirst
0772 c38c 86 42                      LDA     #'B
0773 c38e 17 ff 6d                   LBSR    Print1Reg       ; Print B
0774 c391 7f 5f fb                   CLR     FIRST
0775 c394 35 02                      PULS    A
0776 c396 85 02              bit1:   BITA    #%00000010      ; Bit 1 set?
0777 c398 27 0e                      BEQ     bit0
0778 c39a 34 02                      PSHS    A
0779 c39c 8d 21                      BSR     PrintCommaIfNotFirst
0780 c39e 86 41                      LDA     #'A
0781 c3a0 17 ff 5b                   LBSR    Print1Reg       ; Print A
0782 c3a3 7f 5f fb                   CLR     FIRST
0783 c3a6 35 02                      PULS    A
0784 c3a8 85 01              bit0:   BITA    #%00000001      ; Bit 0 set?
0785 c3aa 27 10                      BEQ     done1
0786 c3ac 34 06                      PSHS    A,B
0787 c3ae 8d 0f                      BSR     PrintCommaIfNotFirst
0788 c3b0 86 43                      LDA     #'C
0789 c3b2 c6 43                      LDB     #'C
0790 c3b4 17 ff 4b                   LBSR    Print2Reg       ; Print CC
0791 c3b7 7f 5f fb                   CLR     FIRST
0792 c3ba 35 06                      PULS    A,B
0793 c3bc 16 02 f2           done1   LBRA    done
0794                         
0795                         ; Print comma if FIRST flag is not set.
0796                         PrintCommaIfNotFirst:
0797 c3bf 7d 5f fb                   TST     FIRST
0798 c3c2 26 05                      BNE     ret1
0799 c3c4 86 2c                      LDA     #',
0800 c3c6 17 fc b2                   LBSR    PrintChar
0801 c3c9 39                 ret1:   RTS
0802                         
0803                         DO_IMMEDIATE16:                 ; Display "  #$nnnn"
0804 c3ca 17 fc 95                   LBSR    Print2Spaces    ; Two spaces
0805 c3cd 86 23                      LDA     #'#             ; Number sign
0806 c3cf 17 fc a9                   LBSR    PrintChar
0807 c3d2 17 fc 66                   LBSR    PrintDollar     ; Dollar sign
0808 c3d5 ae 8d 9c 17                LDX     ADRS,PCR        ; Get address of op code
0809 c3d9 a6 01                      LDA     1,X             ; Get first byte (immediate data MSB)
0810 c3db e6 02                      LDB     2,X             ; Get second byte (immediate data LSB)
0811 c3dd 1f 01                      TFR     D,X             ; Put in X to print
0812 c3df 17 fc ad                   LBSR    PrintAddress    ; Print as hex value
0813 c3e2 16 02 cc                   LBRA    done
0814                         
0815                         DO_DIRECT:                      ; Display "  $nn"
0816 c3e5 17 fc 7a                   LBSR    Print2Spaces    ; Two spaces
0817 c3e8 17 fc 50                   LBSR    PrintDollar     ; Dollar sign
0818 c3eb ae 8d 9c 01                LDX     ADRS,PCR        ; Get address of op code
0819 c3ef a6 01                      LDA     1,X             ; Get next byte (byte data)
0820 c3f1 17 fc 8d                   LBSR    PrintByte       ; Print as hex value
0821 c3f4 16 02 ba                   LBRA    done
0822                         
0823                         DO_EXTENDED:                    ; Display "  $nnnn"
0824 c3f7 17 fc 68                   LBSR    Print2Spaces    ; Two spaces
0825 c3fa 17 fc 3e                   LBSR    PrintDollar     ; Dollar sign
0826 c3fd ae 8d 9b ef                LDX     ADRS,PCR        ; Get address of op code
0827 c401 a6 01                      LDA     1,X             ; Get first byte (address MSB)
0828 c403 e6 02                      LDB     2,X             ; Get second byte (address LSB)
0829 c405 1f 01                      TFR     D,X             ; Put in X to print
0830 c407 17 fc 85                   LBSR    PrintAddress    ; Print as hex value
0831 c40a 16 02 a4                   LBRA    done
0832                         
0833                         DO_RELATIVE8:                   ; Display "  $nnnn"
0834 c40d 17 fc 52                   LBSR    Print2Spaces    ; Two spaces
0835 c410 17 fc 28                   LBSR    PrintDollar     ; Dollar sign
0836                         
0837                         ; Destination address for relative branch is address of opcode + (sign
0838                         ; extended)offset + 2, e.g.
0839                         ;   $1015 + $(FF)FC + 2 = $1013
0840                         ;   $101B + $(00)27 + 2 = $1044
0841                         
0842 c413 ae 8d 9b d9                LDX     ADRS,PCR        ; Get address of op code
0843 c417 e6 01                      LDB     1,X             ; Get first byte (8-bit branch offset)
0844 c419 1d                         SEX                     ; Sign extend to 16 bits
0845 c41a f3 5f f0                   ADDD    ADRS            ; Add address of op code
0846 c41d c3 00 02                   ADDD    #2              ; Add 2
0847 c420 1f 01                      TFR     D,X             ; Put in X to print
0848 c422 17 fc 6a                   LBSR    PrintAddress    ; Print as hex value
0849 c425 16 02 89                   LBRA    done
0850                         
0851                         DO_RELATIVE16:                  ; Display "  $nnnn"
0852 c428 17 fc 37                   LBSR    Print2Spaces    ; Two spaces
0853 c42b 17 fc 0d                   LBSR    PrintDollar     ; Dollar sign
0854                         
0855                         ; Destination address calculation is similar to above, except offset
0856                         ; is 16 bits and need to add 3.
0857                         
0858 c42e ae 8d 9b be                LDX     ADRS,PCR        ; Get address of op code
0859 c432 ec 01                      LDD     1,X             ; Get next 2 bytes (16-bit branch offset)
0860 c434 f3 5f f0                   ADDD    ADRS            ; Add address of op code
0861 c437 c3 00 03                   ADDD    #3              ; Add 3
0862 c43a 1f 01                      TFR     D,X             ; Put in X to print
0863 c43c 17 fc 50                   LBSR    PrintAddress    ; Print as hex value
0864 c43f 16 02 6f                   LBRA    done
0865                         
0866                         DO_INDEXED:
0867 c442 17 fc 1d                   LBSR    Print2Spaces    ; Two spaces
0868                         
0869                         ; Addressing modes are determined by the postbyte:
0870                         ;
0871                         ; Postbyte  Format  Additional Bytes
0872                         ; --------  ------  ----------------
0873                         ; 0RRnnnnn  n,R     0
0874                         ; 1RR00100  ,R      0
0875                         ; 1RR01000  n,R     1
0876                         ; 1RR01001  n,R     2
0877                         ; 1RR00110  A,R     0
0878                         ; 1RR00101  B,R     0
0879                         ; 1RR01011  D,R     0
0880                         ; 1RR00000  ,R+     0
0881                         ; 1RR00001  ,R++    0
0882                         ; 1RR00010  ,-R     0
0883                         ; 1RR00011  ,--R    0
0884                         ; 1xx01100  n,PCR   1
0885                         ; 1xx01101  n,PCR   2
0886                         ; 1RR10100  [,R]    0
0887                         ; 1RR11000  [n,R]   1
0888                         ; 1RR11001  [n,R]   2
0889                         ; 1RR10110  [A,R]   0
0890                         ; 1RR10101  [B,R]   0
0891                         ; 1RR11011  [D,R]   0
0892                         ; 1RR10001  [,R++]  0
0893                         ; 1RR10011  [,--R]  0
0894                         ; 1xx11100  [n,PCR] 1
0895                         ; 1xx11101  [n,PCR] 2
0896                         ; 10011111  [n]     2
0897                         ;
0898                         ; Where RR: 00=X 01=Y 10=U 11=S
0899                         
0900 c445 b6 5f f5                   LDA     POSTBYT         ; Get postbyte
0901 c448 2b 14                      BMI     ind2            ; Branch if MSB is 1
0902                         
0903                                                         ; Format is 0RRnnnnn  n,R
0904 c44a 84 1f                      ANDA    #%00011111      ; Get 5-bit offset
0905 c44c 17 fb ec                   LBSR    PrintDollar     ; Dollar sign
0906 c44f 17 fc 2f                   LBSR    PrintByte       ; Print offset
0907 c452 17 fb ef                   LBSR    PrintComma      ; Print comma
0908 c455 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0909 c458 17 02 35                   LBSR    PrintRegister   ; Print register name
0910 c45b 16 02 53                   LBRA    done
0911                         ind2:
0912 c45e 84 9f                      ANDA    #%10011111      ; Mask out register bits
0913 c460 81 84                      CMPA    #%10000100      ; Check against pattern
0914 c462 26 0c                      BNE     ind3
0915                                                         ; Format is 1RR00100  ,R
0916 c464 17 fb dd                   LBSR    PrintComma      ; Print comma
0917 c467 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0918 c46a 17 02 23                   LBSR    PrintRegister   ; Print register name
0919 c46d 16 02 41                   LBRA    done
0920                         ind3:
0921 c470 81 88                      CMPA    #%10001000      ; Check against pattern
0922 c472 26 18                      BNE     ind4
0923                                                         ; Format is 1RR01000  n,R
0924 c474 ae 8d 9b 78                LDX     ADRS,PCR
0925 c478 a6 02                      LDA     2,X             ; Get 8-bit offset
0926 c47a 17 fb be                   LBSR    PrintDollar     ; Dollar sign
0927 c47d 17 fc 01                   LBSR    PrintByte       ; Display it
0928 c480 17 fb c1                   LBSR    PrintComma      ; Print comma
0929 c483 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0930 c486 17 02 07                   LBSR    PrintRegister   ; Print register name
0931 c489 16 02 25                   LBRA    done
0932                         ind4:
0933 c48c 81 89                      CMPA    #%10001001      ; Check against pattern
0934 c48e 26 1a                      BNE     ind5
0935                                                         ; Format is 1RR01001  n,R
0936 c490 ae 8d 9b 5c                LDX     ADRS,PCR
0937 c494 ec 02                      LDD     2,X             ; Get 16-bit offset
0938 c496 1f 01                      TFR     D,X
0939 c498 17 fb a0                   LBSR    PrintDollar     ; Dollar sign
0940 c49b 17 fb f1                   LBSR    PrintAddress    ; Display it
0941 c49e 17 fb a3                   LBSR    PrintComma      ; Print comma
0942 c4a1 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0943 c4a4 17 01 e9                   LBSR    PrintRegister   ; Print register name
0944 c4a7 16 02 07                   LBRA    done
0945                         ind5:
0946 c4aa 81 86                      CMPA    #%10000110      ; Check against pattern
0947 c4ac 26 11                      BNE     ind6
0948                                                         ; Format is 1RR00110  A,R
0949 c4ae 86 41                      LDA     #'A
0950 c4b0 17 fb c8                   LBSR    PrintChar       ; Print A
0951 c4b3 17 fb 8e           commar: LBSR    PrintComma      ; Print comma
0952 c4b6 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0953 c4b9 17 01 d4                   LBSR    PrintRegister   ; Print register name
0954 c4bc 16 01 f2                   LBRA    done
0955                         ind6:
0956 c4bf 81 85                      CMPA    #%10000101      ; Check against pattern
0957 c4c1 26 07                      BNE     ind7
0958                                                         ; Format is 1RR00101  B,R
0959 c4c3 86 42                      LDA     #'B
0960 c4c5 17 fb b3                   LBSR    PrintChar
0961 c4c8 20 e9                      BRA     commar
0962                         ind7:
0963 c4ca 81 8b                      CMPA    #%10001011      ; Check against pattern
0964 c4cc 26 07                      BNE     ind8
0965                                                         ; Format is 1RR01011  D,R
0966 c4ce 86 44                      LDA     #'D
0967 c4d0 17 fb a8                   LBSR    PrintChar
0968 c4d3 20 de                      BRA     commar
0969                         ind8:
0970 c4d5 81 80                      CMPA    #%10000000      ; Check against pattern
0971 c4d7 26 11                      BNE     ind9
0972                                                         ; Format is 1RR00000  ,R+
0973 c4d9 17 fb 68                   LBSR    PrintComma      ; Print comma
0974 c4dc b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0975 c4df 17 01 ae                   LBSR    PrintRegister   ; Print register name
0976 c4e2 86 2b                      LDA     #'+             ; Print plus
0977 c4e4 17 fb 94                   LBSR    PrintChar
0978 c4e7 16 01 c7                   LBRA    done
0979                         ind9:
0980 c4ea 81 81                      CMPA    #%10000001      ; Check against pattern
0981 c4ec 26 14                      BNE     ind10
0982                                                         ; Format is 1RR00001  ,R++
0983 c4ee 17 fb 53                   LBSR    PrintComma      ; Print comma
0984 c4f1 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0985 c4f4 17 01 99                   LBSR    PrintRegister   ; Print register name
0986 c4f7 86 2b                      LDA     #'+             ; Print plus twice
0987 c4f9 17 fb 7f                   LBSR    PrintChar
0988 c4fc 17 fb 7c                   LBSR    PrintChar
0989 c4ff 16 01 af                   LBRA    done
0990                         ind10:
0991 c502 81 82                      CMPA    #%10000010      ; Check against pattern
0992 c504 26 11                      BNE     ind11
0993                                                         ; Format is 1RR00010  ,-R
0994 c506 17 fb 3b                   LBSR    PrintComma      ; Print comma
0995 c509 86 2d                      LDA     #'-             ; Print minus
0996 c50b 17 fb 6d                   LBSR    PrintChar
0997 c50e b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0998 c511 17 01 7c                   LBSR    PrintRegister   ; Print register name
0999 c514 16 01 9a                   LBRA    done
1000                         ind11:
1001 c517 81 83                      CMPA    #%10000011      ; Check against pattern
1002 c519 26 14                      BNE     ind12
1003                                                         ; Format is 1RR00011  ,--R
1004 c51b 17 fb 26                   LBSR    PrintComma      ; Print comma
1005 c51e 86 2d                      LDA     #'-             ; Print minus twice
1006 c520 17 fb 58                   LBSR    PrintChar
1007 c523 17 fb 55                   LBSR    PrintChar
1008 c526 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1009 c529 17 01 64                   LBSR    PrintRegister   ; Print register name
1010 c52c 16 01 82                   LBRA    done
1011                         ind12:
1012 c52f 81 8c                      CMPA    #%10001100      ; Check against pattern
1013 c531 26 15                      BNE     ind13
1014                                                         ; Format is 1xx01100  n,PCR
1015 c533 ae 8d 9a b9                LDX     ADRS,PCR
1016 c537 a6 02                      LDA     2,X             ; Get 8-bit offset
1017 c539 17 fa ff                   LBSR    PrintDollar     ; Dollar sign
1018 c53c 17 fb 42                   LBSR    PrintByte       ; Display it
1019 c53f 17 fb 02                   LBSR    PrintComma      ; Print comma
1020 c542 17 01 64                   LBSR    PrintPCR        ; Print PCR
1021 c545 16 01 69                   LBRA    done
1022                         ind13:
1023 c548 81 8d                      CMPA    #%10001101      ; Check against pattern
1024 c54a 26 17                      BNE     ind14
1025                                                         ; Format is 1xx01101  n,PCR
1026 c54c ae 8d 9a a0                LDX     ADRS,PCR
1027 c550 ec 02                      LDD     2,X             ; Get 16-bit offset
1028 c552 1f 01                      TFR     D,X
1029 c554 17 fa e4                   LBSR    PrintDollar     ; Dollar sign
1030 c557 17 fb 35                   LBSR    PrintAddress    ; Display it
1031 c55a 17 fa e7                   LBSR    PrintComma      ; Print comma
1032 c55d 17 01 49                   LBSR    PrintPCR        ; Print PCR
1033 c560 16 01 4e                   LBRA    done
1034                         ind14:
1035 c563 81 94                      CMPA    #%10010100      ; Check against pattern
1036 c565 26 12                      BNE     ind15
1037                                                         ; Format is 1RR10100  [,R]
1038 c567 17 fa e3                   LBSR    PrintLBracket   ; Print left bracket
1039 c56a 17 fa d7                   LBSR    PrintComma      ; Print comma
1040 c56d b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1041 c570 17 01 1d                   LBSR    PrintRegister   ; Print register name
1042 c573 17 fa e0                   LBSR    PrintRBracket   ; Print right bracket
1043 c576 16 01 38                   LBRA    done
1044                         ind15:
1045 c579 81 98                      CMPA    #%10011000      ; Check against pattern
1046 c57b 26 1e                      BNE     ind16
1047                                                         ; Format is 1RR11000  [n,R]
1048 c57d 17 fa cd                   LBSR    PrintLBracket   ; Print left bracket
1049 c580 ae 8d 9a 6c                LDX     ADRS,PCR
1050 c584 a6 02                      LDA     2,X             ; Get 8-bit offset
1051 c586 17 fa b2                   LBSR    PrintDollar     ; Dollar sign
1052 c589 17 fa f5                   LBSR    PrintByte       ; Display it
1053 c58c 17 fa b5                   LBSR    PrintComma      ; Print comma
1054 c58f b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1055 c592 17 00 fb                   LBSR    PrintRegister   ; Print register name
1056 c595 17 fa be                   LBSR    PrintRBracket   ; Print right bracket
1057 c598 16 01 16                   LBRA    done
1058                         ind16:
1059 c59b 81 99                      CMPA    #%10011001      ; Check against pattern
1060 c59d 26 20                      BNE     ind17
1061                                                         ; Format is 1RR11001  [n,R]
1062 c59f 17 fa ab                   LBSR    PrintLBracket   ; Print left bracket
1063 c5a2 ae 8d 9a 4a                LDX     ADRS,PCR
1064 c5a6 ec 02                      LDD     2,X             ; Get 16-bit offset
1065 c5a8 1f 01                      TFR     D,X
1066 c5aa 17 fa 8e                   LBSR    PrintDollar     ; Dollar sign
1067 c5ad 17 fa df                   LBSR    PrintAddress    ; Display it
1068 c5b0 17 fa 91                   LBSR    PrintComma      ; Print comma
1069 c5b3 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1070 c5b6 17 00 d7                   LBSR    PrintRegister   ; Print register name
1071 c5b9 17 fa 9a                   LBSR    PrintRBracket   ; Print right bracket
1072 c5bc 16 00 f2                   LBRA    done
1073                         ind17:
1074 c5bf 81 96                      CMPA    #%10010110      ; Check against pattern
1075 c5c1 26 17                      BNE     ind18
1076                                                         ; Format is 1RR10110  [A,R]
1077 c5c3 17 fa 87                   LBSR    PrintLBracket   ; Print left bracket
1078 c5c6 86 41                      LDA     #'A
1079 c5c8 17 fa b0                   LBSR    PrintChar       ; Print A
1080 c5cb 17 fa 76           comrb:  LBSR    PrintComma      ; Print comma
1081 c5ce b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1082 c5d1 17 00 bc                   LBSR    PrintRegister   ; Print register name
1083 c5d4 17 fa 7f                   LBSR    PrintRBracket   ; Print right bracket
1084 c5d7 16 00 d7                   LBRA    done
1085                         ind18:
1086 c5da 81 95                      CMPA    #%10010101      ; Check against pattern
1087 c5dc 26 0a                      BNE     ind19
1088                                                         ; Format is 1RR10101  [B,R]
1089 c5de 17 fa 6c                   LBSR    PrintLBracket   ; Print left bracket
1090 c5e1 86 42                      LDA     #'B
1091 c5e3 17 fa 95                   LBSR    PrintChar
1092 c5e6 20 e3                      BRA     comrb
1093                         ind19:
1094 c5e8 81 9b                      CMPA    #%10011011      ; Check against pattern
1095 c5ea 26 0a                      BNE     ind20
1096                                                         ; Format is 1RR11011  [D,R]
1097 c5ec 17 fa 5e                   LBSR    PrintLBracket   ; Print left bracket
1098 c5ef 86 44                      LDA     #'D
1099 c5f1 17 fa 87                   LBSR    PrintChar
1100 c5f4 20 d5                      BRA     comrb
1101                         ind20:
1102 c5f6 81 91                      CMPA    #%10010001      ; Check against pattern
1103 c5f8 26 1a                      BNE     ind21
1104                                                         ; Format is 1RR10001  [,R++]
1105 c5fa 17 fa 50                   LBSR    PrintLBracket   ; Print left bracket
1106 c5fd 17 fa 44                   LBSR    PrintComma      ; Print comma
1107 c600 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1108 c603 17 00 8a                   LBSR    PrintRegister   ; Print register name
1109 c606 86 2b                      LDA     #'+             ; Print plus twice
1110 c608 17 fa 70                   LBSR    PrintChar
1111 c60b 17 fa 6d                   LBSR    PrintChar
1112 c60e 17 fa 45                   LBSR    PrintRBracket   ; Print right bracket
1113 c611 16 00 9d                   LBRA    done
1114                         ind21:
1115 c614 81 93                      CMPA    #%10010011      ; Check against pattern
1116 c616 26 1a                      BNE     ind22
1117                                                         ; Format is 1RR10011  [,--R]
1118 c618 17 fa 32                   LBSR    PrintLBracket   ; Print left bracket
1119 c61b 17 fa 26                   LBSR    PrintComma      ; Print comma
1120 c61e 86 2d                      LDA     #'-             ; Print minus twice
1121 c620 17 fa 58                   LBSR    PrintChar
1122 c623 17 fa 55                   LBSR    PrintChar
1123 c626 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1124 c629 17 00 64                   LBSR    PrintRegister   ; Print register name
1125 c62c 17 fa 27                   LBSR    PrintRBracket   ; Print right bracket
1126 c62f 16 00 7f                   LBRA    done
1127                         ind22:
1128 c632 81 9c                      CMPA    #%10011100      ; Check against pattern
1129 c634 26 1b                      BNE     ind23
1130                                                         ; Format is 1xx11100  [n,PCR]
1131 c636 17 fa 14                   LBSR    PrintLBracket   ; Print left bracket
1132 c639 ae 8d 99 b3                LDX     ADRS,PCR
1133 c63d a6 02                      LDA     2,X             ; Get 8-bit offset
1134 c63f 17 f9 f9                   LBSR    PrintDollar     ; Dollar sign
1135 c642 17 fa 3c                   LBSR    PrintByte       ; Display it
1136 c645 17 f9 fc                   LBSR    PrintComma      ; Print comma
1137 c648 17 00 5e                   LBSR    PrintPCR        ; Print PCR
1138 c64b 17 fa 08                   LBSR    PrintRBracket   ; Print right bracket
1139 c64e 16 00 60                   LBRA    done
1140                         ind23:
1141 c651 81 9d                      CMPA    #%10011101      ; Check against pattern
1142 c653 26 1d                      BNE     ind24
1143                                                         ; Format is 1xx11101  [n,PCR]
1144 c655 17 f9 f5                   LBSR    PrintLBracket   ; Print left bracket
1145 c658 ae 8d 99 94                LDX     ADRS,PCR
1146 c65c ec 02                      LDD     2,X             ; Get 16-bit offset
1147 c65e 1f 01                      TFR     D,X
1148 c660 17 f9 d8                   LBSR    PrintDollar     ; Dollar sign
1149 c663 17 fa 29                   LBSR    PrintAddress    ; Display it
1150 c666 17 f9 db                   LBSR    PrintComma      ; Print comma
1151 c669 17 00 3d                   LBSR    PrintPCR        ; Print PCR
1152 c66c 17 f9 e7                   LBSR    PrintRBracket   ; Print right bracket
1153 c66f 16 00 3f                   LBRA    done
1154                         ind24:
1155 c672 81 9f                      CMPA    #%10011111      ; Check against pattern
1156 c674 26 17                      BNE     ind25
1157                                                         ; Format is 1xx11111  [n]
1158 c676 17 f9 d4                   LBSR    PrintLBracket   ; Print left bracket
1159 c679 ae 8d 99 73                LDX     ADRS,PCR
1160 c67d ec 02                      LDD     2,X             ; Get 16-bit offset
1161 c67f 1f 01                      TFR     D,X
1162 c681 17 f9 b7                   LBSR    PrintDollar     ; Dollar sign
1163 c684 17 fa 08                   LBSR    PrintAddress    ; Display it
1164 c687 17 f9 cc                   LBSR    PrintRBracket   ; Print right bracket
1165 c68a 16 00 24                   LBRA    done
1166                         ind25:                          ; Should never be reached
1167 c68d 16 00 21                   LBRA    done
1168                         
1169                         ; Print register name encoded in bits 5 and 6 of A for indexed
1170                         ; addressing: xRRxxxxx where RR: 00=X 01=Y 10=U 11=S
1171                         ; Registers changed: X
1172                         PrintRegister:
1173 c690 34 02                      PSHS    A               ; Save A
1174 c692 84 60                      ANDA    #%01100000      ; Mask out other bits
1175 c694 44                         LSRA                    ; Shift into 2 LSB
1176 c695 44                         LSRA
1177 c696 44                         LSRA
1178 c697 44                         LSRA
1179 c698 44                         LSRA
1180 c699 30 8d 00 08                LEAX    REGTABLE,PCR    ; Lookup table of register name characters
1181 c69d a6 86                      LDA     A,X             ; Get character
1182 c69f 17 f9 d9                   LBSR    PrintChar       ; Print it
1183 c6a2 35 02                      PULS    A               ; Restore A
1184 c6a4 39                         RTS                     ; Return
1185                         REGTABLE:
1186 c6a5 58 59 55 53                FCC     "XYUS"
1187                         
1188                         
1189                         ; Print the string "PCR" on the console.
1190                         ; Registers changed: X
1191                         PrintPCR:
1192 c6a9 30 8d 05 1c                LEAX    MSG3,PCR        ; "PCR" string
1193 c6ad 17 f9 ed                   LBSR    PrintString
1194 c6b0 39                         RTS
1195                         
1196                         ; Print final CR
1197                         
1198 c6b1 17 f9 7a           done:   LBSR    PrintCR
1199                         
1200                         ; Update address to next instruction
1201                         ; If it was a page 2/3 instruction, we need to subtract one from the
1202                         ; length to account for ADRS being moved to the second byte of the
1203                         ; instruction.
1204                         
1205 c6b4 7d 5f fc                   TST     PAGE23          ; Flag set
1206 c6b7 27 03                      BEQ     not23           ; Branch if not
1207 c6b9 7a 5f f6                   DEC     LENG            ; Decrement length
1208 c6bc 4f                 not23:  CLRA                    ; Clear MSB of D
1209 c6bd f6 5f f6                   LDB     LENG            ; Get length byte in LSB of D
1210 c6c0 f3 5f f0                   ADDD    ADRS            ; Add to address
1211 c6c3 fd 5f f0                   STD     ADRS            ; Write new address
1212                         
1213                         ; Return
1214 c6c6 39                         RTS
1215                         
1216                         ; *** DATA
1217                         
1218                         ; Table of instruction strings. 4 bytes per table entry
1219                         MNEMONICS:
1220 c6c7 3f 3f 3f 20                FCC     "??? "          ; $00
1221 c6cb 41 42 58 20                FCC     "ABX "          ; $01
1222 c6cf 41 44 43 41                FCC     "ADCA"          ; $02
1223 c6d3 41 44 43 42                FCC     "ADCB"          ; $03
1224 c6d7 41 44 44 41                FCC     "ADDA"          ; $04
1225 c6db 41 44 44 42                FCC     "ADDB"          ; $05
1226 c6df 41 44 44 44                FCC     "ADDD"          ; $06
1227 c6e3 41 4e 44 41                FCC     "ANDA"          ; $07
1228 c6e7 41 4e 44 42                FCC     "ANDB"          ; $08
1229 c6eb 41 4e 44 43                FCC     "ANDC"          ; $09 Should really  be "ANDCC"
1230 c6ef 41 53 4c 20                FCC     "ASL "          ; $0A
1231 c6f3 41 53 4c 41                FCC     "ASLA"          ; $0B
1232 c6f7 41 53 4c 42                FCC     "ASLB"          ; $0C
1233 c6fb 41 53 52 20                FCC     "ASR "          ; $0D
1234 c6ff 41 53 52 41                FCC     "ASRA"          ; $0E
1235 c703 41 53 52 42                FCC     "ASRB"          ; $0F
1236 c707 42 43 43 20                FCC     "BCC "          ; $10
1237 c70b 42 43 53 20                FCC     "BCS "          ; $11
1238 c70f 42 45 51 20                FCC     "BEQ "          ; $12
1239 c713 42 47 45 20                FCC     "BGE "          ; $13
1240 c717 42 47 54 20                FCC     "BGT "          ; $14
1241 c71b 42 48 49 20                FCC     "BHI "          ; $15
1242 c71f 42 49 54 41                FCC     "BITA"          ; $16
1243 c723 42 49 54 42                FCC     "BITB"          ; $17
1244 c727 42 4c 45 20                FCC     "BLE "          ; $18
1245 c72b 42 4c 53 20                FCC     "BLS "          ; $19
1246 c72f 42 4c 54 20                FCC     "BLT "          ; $1A
1247 c733 42 4d 49 20                FCC     "BMI "          ; $1B
1248 c737 42 4e 45 20                FCC     "BNE "          ; $1C
1249 c73b 42 50 4c 20                FCC     "BPL "          ; $1D
1250 c73f 42 52 41 20                FCC     "BRA "          ; $1E
1251 c743 42 52 4e 20                FCC     "BRN "          ; $1F
1252 c747 42 53 52 20                FCC     "BSR "          ; $20
1253 c74b 42 56 43 20                FCC     "BVC "          ; $21
1254 c74f 42 56 53 20                FCC     "BVS "          ; $22
1255 c753 43 4c 52 20                FCC     "CLR "          ; $23
1256 c757 43 4c 52 41                FCC     "CLRA"          ; $24
1257 c75b 43 4c 52 42                FCC     "CLRB"          ; $25
1258 c75f 43 4d 50 41                FCC     "CMPA"          ; $26
1259 c763 43 4d 50 42                FCC     "CMPB"          ; $27
1260 c767 43 4d 50 44                FCC     "CMPD"          ; $28
1261 c76b 43 4d 50 53                FCC     "CMPS"          ; $29
1262 c76f 43 4d 50 55                FCC     "CMPU"          ; $2A
1263 c773 43 4d 50 58                FCC     "CMPX"          ; $2B
1264 c777 43 4d 50 59                FCC     "CMPY"          ; $2C
1265 c77b 43 4f 4d 41                FCC     "COMA"          ; $2D
1266 c77f 43 4f 4d 42                FCC     "COMB"          ; $2E
1267 c783 43 4f 4d 20                FCC     "COM "          ; $2F
1268 c787 43 57 41 49                FCC     "CWAI"          ; $30
1269 c78b 44 41 41 20                FCC     "DAA "          ; $31
1270 c78f 44 45 43 20                FCC     "DEC "          ; $32
1271 c793 44 45 43 41                FCC     "DECA"          ; $33
1272 c797 44 45 43 42                FCC     "DECB"          ; $34
1273 c79b 45 4f 52 41                FCC     "EORA"          ; $35
1274 c79f 45 4f 52 42                FCC     "EORB"          ; $36
1275 c7a3 45 58 47 20                FCC     "EXG "          ; $37
1276 c7a7 49 4e 43 20                FCC     "INC "          ; $38
1277 c7ab 49 4e 43 41                FCC     "INCA"          ; $39
1278 c7af 49 4e 43 42                FCC     "INCB"          ; $3A
1279 c7b3 4a 4d 50 20                FCC     "JMP "          ; $3B
1280 c7b7 4a 53 52 20                FCC     "JSR "          ; $3C
1281 c7bb 4c 42 43 43                FCC     "LBCC"          ; $3D
1282 c7bf 4c 42 43 53                FCC     "LBCS"          ; $3E
1283 c7c3 4c 42 45 51                FCC     "LBEQ"          ; $3F
1284 c7c7 4c 42 47 45                FCC     "LBGE"          ; $40
1285 c7cb 4c 42 47 54                FCC     "LBGT"          ; $41
1286 c7cf 4c 42 48 49                FCC     "LBHI"          ; $42
1287 c7d3 4c 42 4c 45                FCC     "LBLE"          ; $43
1288 c7d7 4c 42 4c 53                FCC     "LBLS"          ; $44
1289 c7db 4c 42 4c 54                FCC     "LBLT"          ; $45
1290 c7df 4c 42 4d 49                FCC     "LBMI"          ; $46
1291 c7e3 4c 42 4e 45                FCC     "LBNE"          ; $47
1292 c7e7 4c 42 50 4c                FCC     "LBPL"          ; $48
1293 c7eb 4c 42 52 41                FCC     "LBRA"          ; $49
1294 c7ef 4c 42 52 4e                FCC     "LBRN"          ; $4A
1295 c7f3 4c 42 53 52                FCC     "LBSR"          ; $4B
1296 c7f7 4c 42 56 43                FCC     "LBVC"          ; $4C
1297 c7fb 4c 42 56 53                FCC     "LBVS"          ; $4D
1298 c7ff 4c 44 41 20                FCC     "LDA "          ; $4E
1299 c803 4c 44 42 20                FCC     "LDB "          ; $4F
1300 c807 4c 44 44 20                FCC     "LDD "          ; $50
1301 c80b 4c 44 53 20                FCC     "LDS "          ; $51
1302 c80f 4c 44 55 20                FCC     "LDU "          ; $52
1303 c813 4c 44 58 20                FCC     "LDX "          ; $53
1304 c817 4c 44 59 20                FCC     "LDY "          ; $54
1305 c81b 4c 45 41 53                FCC     "LEAS"          ; $55
1306 c81f 4c 45 41 55                FCC     "LEAU"          ; $56
1307 c823 4c 45 41 58                FCC     "LEAX"          ; $57
1308 c827 4c 45 41 59                FCC     "LEAY"          ; $58
1309 c82b 4c 53 52 20                FCC     "LSR "          ; $59
1310 c82f 4c 53 52 41                FCC     "LSRA"          ; $5A
1311 c833 4c 53 52 42                FCC     "LSRB"          ; $5B
1312 c837 4d 55 4c 20                FCC     "MUL "          ; $5C
1313 c83b 4e 45 47 20                FCC     "NEG "          ; $5D
1314 c83f 4e 45 47 41                FCC     "NEGA"          ; $5E
1315 c843 4e 45 47 42                FCC     "NEGB"          ; $5F
1316 c847 4e 4f 50 20                FCC     "NOP "          ; $60
1317 c84b 4f 52 41 20                FCC     "ORA "          ; $61
1318 c84f 4f 52 42 20                FCC     "ORB "          ; $62
1319 c853 4f 52 43 43                FCC     "ORCC"          ; $63
1320 c857 50 53 48 53                FCC     "PSHS"          ; $64
1321 c85b 50 53 48 55                FCC     "PSHU"          ; $65
1322 c85f 50 55 4c 53                FCC     "PULS"          ; $66
1323 c863 50 55 4c 55                FCC     "PULU"          ; $67
1324 c867 52 4f 4c 20                FCC     "ROL "          ; $68
1325 c86b 52 4f 4c 41                FCC     "ROLA"          ; $69
1326 c86f 52 4f 4c 42                FCC     "ROLB"          ; $6A
1327 c873 52 4f 52 20                FCC     "ROR "          ; $6B
1328 c877 52 4f 52 41                FCC     "RORA"          ; $6C
1329 c87b 52 4f 52 42                FCC     "RORB"          ; $6D
1330 c87f 52 54 49 20                FCC     "RTI "          ; $6E
1331 c883 52 54 53 20                FCC     "RTS "          ; $6F
1332 c887 53 42 43 41                FCC     "SBCA"          ; $70
1333 c88b 53 42 43 42                FCC     "SBCB"          ; $71
1334 c88f 53 45 58 20                FCC     "SEX "          ; $72
1335 c893 53 54 41 20                FCC     "STA "          ; $73
1336 c897 53 54 42 20                FCC     "STB "          ; $74
1337 c89b 53 54 44 20                FCC     "STD "          ; $75
1338 c89f 53 54 53 20                FCC     "STS "          ; $76
1339 c8a3 53 54 55 20                FCC     "STU "          ; $77
1340 c8a7 53 54 58 20                FCC     "STX "          ; $78
1341 c8ab 53 54 59 20                FCC     "STY "          ; $79
1342 c8af 53 55 42 41                FCC     "SUBA"          ; $7A
1343 c8b3 53 55 42 42                FCC     "SUBB"          ; $7B
1344 c8b7 53 55 42 44                FCC     "SUBD"          ; $7C
1345 c8bb 53 57 49 20                FCC     "SWI "          ; $7D
1346 c8bf 53 57 49 32                FCC     "SWI2"          ; $7E
1347 c8c3 53 57 49 33                FCC     "SWI3"          ; $7F
1348 c8c7 53 59 4e 43                FCC     "SYNC"          ; $80
1349 c8cb 54 46 52 20                FCC     "TFR "          ; $81
1350 c8cf 54 53 54 20                FCC     "TST "          ; $82
1351 c8d3 54 53 54 41                FCC     "TSTA"          ; $83
1352 c8d7 54 53 54 42                FCC     "TSTB"          ; $84
1353                         
1354                         ; Lengths of instructions given an addressing mode. Matches values of
1355                         ; AM_* Indexed addessing instructions length can increase due to post
1356                         ; byte.
1357                         LENGTHS:
1358 c8db 01                         FCB     1               ; 0 AM_INVALID
1359 c8dc 01                         FCB     1               ; 1 AM_INHERENT
1360 c8dd 02                         FCB     2               ; 2 AM_IMMEDIATE8
1361 c8de 03                         FCB     3               ; 3 AM_IMMEDIATE16
1362 c8df 02                         FCB     2               ; 4 AM_DIRECT
1363 c8e0 03                         FCB     3               ; 5 AM_EXTENDED
1364 c8e1 02                         FCB     2               ; 6 AM_RELATIVE8
1365 c8e2 03                         FCB     3               ; 7 AM_RELATIVE16
1366 c8e3 02                         FCB     2               ; 8 AM_INDEXED
1367                         
1368                         ; Lookup table to return needed remaining spaces to print to pad out
1369                         ; instruction to correct column in disassembly.
1370                         ; # bytes: 1 2 3 4
1371                         ; Padding: 9 6 3 0
1372                         PADDING:
1373 c8e4 0a 07 04 01                FCB     10, 7, 4, 1
1374                         
1375                         ; Lookup table to return number of additional bytes for indexed
1376                         ; addressing based on low order 5 bits of postbyte. Based on
1377                         ; detailed list of values below.
1378                         
1379                         POSTBYTES:
1380 c8e8 00 00 00 00 00 00          FCB     0, 0, 0, 0, 0, 0, 0, 0
     00 00
1381 c8f0 01 02 00 00 01 02          FCB     1, 2, 0, 0, 1, 2, 0, 0
     00 00
1382 c8f8 00 00 00 00 00 00          FCB     0, 0, 0, 0, 0, 0, 0, 0
     00 00
1383 c900 01 02 00 00 01 02          FCB     1, 2, 0, 0, 1, 2, 0, 2
     00 02
1384                         
1385                         ; Pattern:  # Extra bytes:
1386                         ; --------  --------------
1387                         ; 0XXXXXXX   0
1388                         ; 1XX00000   0
1389                         ; 1XX00001   0
1390                         ; 1XX00010   0
1391                         ; 1XX00011   0
1392                         ; 1XX00100   0
1393                         ; 1X000101   0
1394                         ; 1XX00110   0
1395                         ; 1XX00111   0 (INVALID)
1396                         ; 1XX01000   1
1397                         ; 1XX01001   2
1398                         ; 1XX01010   0 (INVALID)
1399                         ; 1XX01011   0
1400                         ; 1XX01100   1
1401                         ; 1XX01101   2
1402                         ; 1XX01110   0 (INVALID)
1403                         ; 1XX01111   0 (INVALID)
1404                         ; 1XX10000   0 (INVALID)
1405                         ; 1XX10001   0
1406                         ; 1XX10010   0 (INVALID)
1407                         ; 1XX10011   0
1408                         ; 1XX10100   0
1409                         ; 1XX10101   0
1410                         ; 1XX10110   0
1411                         ; 1XX10111   0 (INVALID)
1412                         ; 1XX11000   1
1413                         ; 1XX11001   2
1414                         ; 1XX11010   0 (INVALID)
1415                         ; 1XX11011   0
1416                         ; 1XX11100   1
1417                         ; 1XX11101   2
1418                         ; 1XX11110   0 (INVALID)
1419                         ; 1XX11111   2
1420                         
1421                         ; Opcodes. Listed in order indexed by op code. Defines the mnemonic.
1422                         OPCODES:
1423 c908 5d                         FCB     OP_NEG          ; 00
1424 c909 00                         FCB     OP_INV          ; 01
1425 c90a 00                         FCB     OP_INV          ; 02
1426 c90b 2e                         FCB     OP_COMB         ; 03
1427 c90c 59                         FCB     OP_LSR          ; 04
1428 c90d 00                         FCB     OP_INV          ; 05
1429 c90e 6b                         FCB     OP_ROR          ; 06
1430 c90f 0d                         FCB     OP_ASR          ; 07
1431 c910 0a                         FCB     OP_ASL          ; 08
1432 c911 68                         FCB     OP_ROL          ; 09
1433 c912 32                         FCB     OP_DEC          ; 0A
1434 c913 00                         FCB     OP_INV          ; 0B
1435 c914 38                         FCB     OP_INC          ; 0C
1436 c915 82                         FCB     OP_TST          ; 0D
1437 c916 3b                         FCB     OP_JMP          ; 0E
1438 c917 23                         FCB     OP_CLR          ; 0F
1439                         
1440 c918 00                         FCB     OP_INV          ; 10 Page 2 extended opcodes (see other table)
1441 c919 00                         FCB     OP_INV          ; 11 Page 3 extended opcodes (see other table)
1442 c91a 60                         FCB     OP_NOP          ; 12
1443 c91b 80                         FCB     OP_SYNC         ; 13
1444 c91c 00                         FCB     OP_INV          ; 14
1445 c91d 00                         FCB     OP_INV          ; 15
1446 c91e 49                         FCB     OP_LBRA         ; 16
1447 c91f 4b                         FCB     OP_LBSR         ; 17
1448 c920 00                         FCB     OP_INV          ; 18
1449 c921 31                         FCB     OP_DAA          ; 19
1450 c922 63                         FCB     OP_ORCC         ; 1A
1451 c923 00                         FCB     OP_INV          ; 1B
1452 c924 09                         FCB     OP_ANDCC        ; 1C
1453 c925 72                         FCB     OP_SEX          ; 1D
1454 c926 37                         FCB     OP_EXG          ; 1E
1455 c927 81                         FCB     OP_TFR          ; 1F
1456                         
1457 c928 1e                         FCB     OP_BRA          ; 20
1458 c929 1f                         FCB     OP_BRN          ; 21
1459 c92a 15                         FCB     OP_BHI          ; 22
1460 c92b 19                         FCB     OP_BLS          ; 23
1461 c92c 10                         FCB     OP_BCC          ; 24
1462 c92d 11                         FCB     OP_BCS          ; 25
1463 c92e 1c                         FCB     OP_BNE          ; 26
1464 c92f 12                         FCB     OP_BEQ          ; 27
1465 c930 21                         FCB     OP_BVC          ; 28
1466 c931 22                         FCB     OP_BVS          ; 29
1467 c932 1d                         FCB     OP_BPL          ; 2A
1468 c933 1b                         FCB     OP_BMI          ; 2B
1469 c934 13                         FCB     OP_BGE          ; 2C
1470 c935 1a                         FCB     OP_BLT          ; 2D
1471 c936 14                         FCB     OP_BGT          ; 2E
1472 c937 18                         FCB     OP_BLE          ; 2F
1473                         
1474 c938 57                         FCB     OP_LEAX         ; 30
1475 c939 58                         FCB     OP_LEAY         ; 31
1476 c93a 55                         FCB     OP_LEAS         ; 32
1477 c93b 56                         FCB     OP_LEAU         ; 33
1478 c93c 64                         FCB     OP_PSHS         ; 34
1479 c93d 66                         FCB     OP_PULS         ; 35
1480 c93e 65                         FCB     OP_PSHU         ; 36
1481 c93f 67                         FCB     OP_PULU         ; 37
1482 c940 00                         FCB     OP_INV          ; 38
1483 c941 6f                         FCB     OP_RTS          ; 39
1484 c942 01                         FCB     OP_ABX          ; 3A
1485 c943 6e                         FCB     OP_RTI          ; 3B
1486 c944 30                         FCB     OP_CWAI         ; 3C
1487 c945 5c                         FCB     OP_MUL          ; 3D
1488 c946 00                         FCB     OP_INV          ; 3E
1489 c947 7d                         FCB     OP_SWI          ; 3F
1490                         
1491 c948 5e                         FCB     OP_NEGA         ; 40
1492 c949 00                         FCB     OP_INV          ; 41
1493 c94a 00                         FCB     OP_INV          ; 42
1494 c94b 2d                         FCB     OP_COMA         ; 43
1495 c94c 5a                         FCB     OP_LSRA         ; 44
1496 c94d 00                         FCB     OP_INV          ; 45
1497 c94e 6c                         FCB     OP_RORA         ; 46
1498 c94f 0e                         FCB     OP_ASRA         ; 47
1499 c950 0b                         FCB     OP_ASLA         ; 48
1500 c951 69                         FCB     OP_ROLA         ; 49
1501 c952 33                         FCB     OP_DECA         ; 4A
1502 c953 00                         FCB     OP_INV          ; 4B
1503 c954 39                         FCB     OP_INCA         ; 4C
1504 c955 83                         FCB     OP_TSTA         ; 4D
1505 c956 00                         FCB     OP_INV          ; 4E
1506 c957 24                         FCB     OP_CLRA         ; 4F
1507                         
1508 c958 5f                         FCB     OP_NEGB         ; 50
1509 c959 00                         FCB     OP_INV          ; 51
1510 c95a 00                         FCB     OP_INV          ; 52
1511 c95b 2e                         FCB     OP_COMB         ; 53
1512 c95c 5b                         FCB     OP_LSRB         ; 54
1513 c95d 00                         FCB     OP_INV          ; 55
1514 c95e 6d                         FCB     OP_RORB         ; 56
1515 c95f 0f                         FCB     OP_ASRB         ; 57
1516 c960 0c                         FCB     OP_ASLB         ; 58
1517 c961 6a                         FCB     OP_ROLB         ; 59
1518 c962 34                         FCB     OP_DECB         ; 5A
1519 c963 00                         FCB     OP_INV          ; 5B
1520 c964 3a                         FCB     OP_INCB         ; 5C
1521 c965 84                         FCB     OP_TSTB         ; 5D
1522 c966 00                         FCB     OP_INV          ; 5E
1523 c967 25                         FCB     OP_CLRB         ; 5F
1524                         
1525 c968 5d                         FCB     OP_NEG          ; 60
1526 c969 00                         FCB     OP_INV          ; 61
1527 c96a 00                         FCB     OP_INV          ; 62
1528 c96b 2f                         FCB     OP_COM          ; 63
1529 c96c 59                         FCB     OP_LSR          ; 64
1530 c96d 00                         FCB     OP_INV          ; 65
1531 c96e 6b                         FCB     OP_ROR          ; 66
1532 c96f 0d                         FCB     OP_ASR          ; 67
1533 c970 0a                         FCB     OP_ASL          ; 68
1534 c971 68                         FCB     OP_ROL          ; 69
1535 c972 32                         FCB     OP_DEC          ; 6A
1536 c973 00                         FCB     OP_INV          ; 6B
1537 c974 38                         FCB     OP_INC          ; 6C
1538 c975 82                         FCB     OP_TST          ; 6D
1539 c976 3b                         FCB     OP_JMP          ; 6E
1540 c977 23                         FCB     OP_CLR          ; 6F
1541                         
1542 c978 5d                         FCB     OP_NEG          ; 70
1543 c979 00                         FCB     OP_INV          ; 71
1544 c97a 00                         FCB     OP_INV          ; 72
1545 c97b 2f                         FCB     OP_COM          ; 73
1546 c97c 59                         FCB     OP_LSR          ; 74
1547 c97d 00                         FCB     OP_INV          ; 75
1548 c97e 6b                         FCB     OP_ROR          ; 76
1549 c97f 0d                         FCB     OP_ASR          ; 77
1550 c980 0a                         FCB     OP_ASL          ; 78
1551 c981 68                         FCB     OP_ROL          ; 79
1552 c982 32                         FCB     OP_DEC          ; 7A
1553 c983 00                         FCB     OP_INV          ; 7B
1554 c984 38                         FCB     OP_INC          ; 7C
1555 c985 82                         FCB     OP_TST          ; 7D
1556 c986 3b                         FCB     OP_JMP          ; 7E
1557 c987 23                         FCB     OP_CLR          ; 7F
1558                         
1559 c988 7a                         FCB     OP_SUBA         ; 80
1560 c989 26                         FCB     OP_CMPA         ; 81
1561 c98a 70                         FCB     OP_SBCA         ; 82
1562 c98b 7c                         FCB     OP_SUBD         ; 83
1563 c98c 07                         FCB     OP_ANDA         ; 84
1564 c98d 16                         FCB     OP_BITA         ; 85
1565 c98e 4e                         FCB     OP_LDA          ; 86
1566 c98f 00                         FCB     OP_INV          ; 87
1567 c990 35                         FCB     OP_EORA         ; 88
1568 c991 02                         FCB     OP_ADCA         ; 89
1569 c992 61                         FCB     OP_ORA          ; 8A
1570 c993 04                         FCB     OP_ADDA         ; 8B
1571 c994 2b                         FCB     OP_CMPX         ; 8C
1572 c995 20                         FCB     OP_BSR          ; 8D
1573 c996 53                         FCB     OP_LDX          ; 8E
1574 c997 00                         FCB     OP_INV          ; 8F
1575                         
1576 c998 7a                         FCB     OP_SUBA         ; 90
1577 c999 26                         FCB     OP_CMPA         ; 91
1578 c99a 70                         FCB     OP_SBCA         ; 92
1579 c99b 7c                         FCB     OP_SUBD         ; 93
1580 c99c 07                         FCB     OP_ANDA         ; 94
1581 c99d 16                         FCB     OP_BITA         ; 95
1582 c99e 4e                         FCB     OP_LDA          ; 96
1583 c99f 73                         FCB     OP_STA          ; 97
1584 c9a0 35                         FCB     OP_EORA         ; 98
1585 c9a1 02                         FCB     OP_ADCA         ; 99
1586 c9a2 61                         FCB     OP_ORA          ; 9A
1587 c9a3 04                         FCB     OP_ADDA         ; 9B
1588 c9a4 2b                         FCB     OP_CMPX         ; 9C
1589 c9a5 3c                         FCB     OP_JSR          ; 9D
1590 c9a6 53                         FCB     OP_LDX          ; 9E
1591 c9a7 78                         FCB     OP_STX          ; 9F
1592                         
1593 c9a8 7a                         FCB     OP_SUBA         ; A0
1594 c9a9 26                         FCB     OP_CMPA         ; A1
1595 c9aa 70                         FCB     OP_SBCA         ; A2
1596 c9ab 7c                         FCB     OP_SUBD         ; A3
1597 c9ac 07                         FCB     OP_ANDA         ; A4
1598 c9ad 16                         FCB     OP_BITA         ; A5
1599 c9ae 4e                         FCB     OP_LDA          ; A6
1600 c9af 73                         FCB     OP_STA          ; A7
1601 c9b0 35                         FCB     OP_EORA         ; A8
1602 c9b1 02                         FCB     OP_ADCA         ; A9
1603 c9b2 61                         FCB     OP_ORA          ; AA
1604 c9b3 04                         FCB     OP_ADDA         ; AB
1605 c9b4 2b                         FCB     OP_CMPX         ; AC
1606 c9b5 3c                         FCB     OP_JSR          ; AD
1607 c9b6 53                         FCB     OP_LDX          ; AE
1608 c9b7 78                         FCB     OP_STX          ; AF
1609                         
1610 c9b8 7a                         FCB     OP_SUBA         ; B0
1611 c9b9 26                         FCB     OP_CMPA         ; B1
1612 c9ba 70                         FCB     OP_SBCA         ; B2
1613 c9bb 7c                         FCB     OP_SUBD         ; B3
1614 c9bc 07                         FCB     OP_ANDA         ; B4
1615 c9bd 16                         FCB     OP_BITA         ; B5
1616 c9be 4e                         FCB     OP_LDA          ; B6
1617 c9bf 73                         FCB     OP_STA          ; B7
1618 c9c0 35                         FCB     OP_EORA         ; B8
1619 c9c1 02                         FCB     OP_ADCA         ; B9
1620 c9c2 61                         FCB     OP_ORA          ; BA
1621 c9c3 04                         FCB     OP_ADDA         ; BB
1622 c9c4 2b                         FCB     OP_CMPX         ; BC
1623 c9c5 3c                         FCB     OP_JSR          ; BD
1624 c9c6 53                         FCB     OP_LDX          ; BE
1625 c9c7 78                         FCB     OP_STX          ; BF
1626                         
1627 c9c8 7b                         FCB     OP_SUBB         ; C0
1628 c9c9 27                         FCB     OP_CMPB         ; C1
1629 c9ca 71                         FCB     OP_SBCB         ; C2
1630 c9cb 06                         FCB     OP_ADDD         ; C3
1631 c9cc 08                         FCB     OP_ANDB         ; C4
1632 c9cd 17                         FCB     OP_BITB         ; C5
1633 c9ce 4f                         FCB     OP_LDB          ; C6
1634 c9cf 00                         FCB     OP_INV          ; C7
1635 c9d0 36                         FCB     OP_EORB         ; C8
1636 c9d1 03                         FCB     OP_ADCB         ; C9
1637 c9d2 62                         FCB     OP_ORB          ; CA
1638 c9d3 05                         FCB     OP_ADDB         ; CB
1639 c9d4 50                         FCB     OP_LDD          ; CC
1640 c9d5 00                         FCB     OP_INV          ; CD
1641 c9d6 52                         FCB     OP_LDU          ; CE
1642 c9d7 00                         FCB     OP_INV          ; CF
1643                         
1644 c9d8 7b                         FCB     OP_SUBB         ; D0
1645 c9d9 27                         FCB     OP_CMPB         ; D1
1646 c9da 71                         FCB     OP_SBCB         ; D2
1647 c9db 06                         FCB     OP_ADDD         ; D3
1648 c9dc 08                         FCB     OP_ANDB         ; D4
1649 c9dd 17                         FCB     OP_BITB         ; D5
1650 c9de 4f                         FCB     OP_LDB          ; D6
1651 c9df 74                         FCB     OP_STB          ; D7
1652 c9e0 36                         FCB     OP_EORB         ; D8
1653 c9e1 03                         FCB     OP_ADCB         ; D9
1654 c9e2 62                         FCB     OP_ORB          ; DA
1655 c9e3 05                         FCB     OP_ADDB         ; DB
1656 c9e4 50                         FCB     OP_LDD          ; DC
1657 c9e5 75                         FCB     OP_STD          ; DD
1658 c9e6 52                         FCB     OP_LDU          ; DE
1659 c9e7 77                         FCB     OP_STU          ; DF
1660                         
1661 c9e8 7b                         FCB     OP_SUBB         ; E0
1662 c9e9 27                         FCB     OP_CMPB         ; E1
1663 c9ea 71                         FCB     OP_SBCB         ; E2
1664 c9eb 06                         FCB     OP_ADDD         ; E3
1665 c9ec 08                         FCB     OP_ANDB         ; E4
1666 c9ed 17                         FCB     OP_BITB         ; E5
1667 c9ee 4f                         FCB     OP_LDB          ; E6
1668 c9ef 74                         FCB     OP_STB          ; E7
1669 c9f0 36                         FCB     OP_EORB         ; E8
1670 c9f1 03                         FCB     OP_ADCB         ; E9
1671 c9f2 62                         FCB     OP_ORB          ; EA
1672 c9f3 05                         FCB     OP_ADDB         ; EB
1673 c9f4 50                         FCB     OP_LDD          ; EC
1674 c9f5 75                         FCB     OP_STD          ; ED
1675 c9f6 52                         FCB     OP_LDU          ; EE
1676 c9f7 77                         FCB     OP_STU          ; EF
1677                         
1678 c9f8 7b                         FCB     OP_SUBB         ; F0
1679 c9f9 27                         FCB     OP_CMPB         ; F1
1680 c9fa 71                         FCB     OP_SBCB         ; F2
1681 c9fb 06                         FCB     OP_ADDD         ; F3
1682 c9fc 08                         FCB     OP_ANDB         ; F4
1683 c9fd 17                         FCB     OP_BITB         ; F5
1684 c9fe 4f                         FCB     OP_LDB          ; F6
1685 c9ff 74                         FCB     OP_STB          ; F7
1686 ca00 36                         FCB     OP_EORB         ; F8
1687 ca01 03                         FCB     OP_ADCB         ; F9
1688 ca02 62                         FCB     OP_ORB          ; FA
1689 ca03 05                         FCB     OP_ADDB         ; FB
1690 ca04 50                         FCB     OP_LDD          ; FC
1691 ca05 75                         FCB     OP_STD          ; FD
1692 ca06 52                         FCB     OP_LDU          ; FE
1693 ca07 77                         FCB     OP_STU          ; FF
1694                         
1695                         ; Table of addressing modes. Listed in order,indexed by op code.
1696                         MODES:
1697 ca08 04                         FCB     AM_DIRECT       ; 00
1698 ca09 00                         FCB     AM_INVALID      ; 01
1699 ca0a 00                         FCB     AM_INVALID      ; 02
1700 ca0b 04                         FCB     AM_DIRECT       ; 03
1701 ca0c 04                         FCB     AM_DIRECT       ; 04
1702 ca0d 00                         FCB     AM_INVALID      ; 05
1703 ca0e 04                         FCB     AM_DIRECT       ; 06
1704 ca0f 04                         FCB     AM_DIRECT       ; 07
1705 ca10 04                         FCB     AM_DIRECT       ; 08
1706 ca11 04                         FCB     AM_DIRECT       ; 09
1707 ca12 04                         FCB     AM_DIRECT       ; 0A
1708 ca13 00                         FCB     AM_INVALID      ; 0B
1709 ca14 04                         FCB     AM_DIRECT       ; 0C
1710 ca15 04                         FCB     AM_DIRECT       ; 0D
1711 ca16 04                         FCB     AM_DIRECT       ; 0E
1712 ca17 04                         FCB     AM_DIRECT       ; 0F
1713                         
1714 ca18 00                         FCB     AM_INVALID      ; 10 Page 2 extended opcodes (see other table)
1715 ca19 00                         FCB     AM_INVALID      ; 11 Page 3 extended opcodes (see other table)
1716 ca1a 01                         FCB     AM_INHERENT     ; 12
1717 ca1b 01                         FCB     AM_INHERENT     ; 13
1718 ca1c 00                         FCB     AM_INVALID      ; 14
1719 ca1d 00                         FCB     AM_INVALID      ; 15
1720 ca1e 07                         FCB     AM_RELATIVE16   ; 16
1721 ca1f 07                         FCB     AM_RELATIVE16   ; 17
1722 ca20 00                         FCB     AM_INVALID      ; 18
1723 ca21 01                         FCB     AM_INHERENT     ; 19
1724 ca22 02                         FCB     AM_IMMEDIATE8   ; 1A
1725 ca23 00                         FCB     AM_INVALID      ; 1B
1726 ca24 02                         FCB     AM_IMMEDIATE8   ; 1C
1727 ca25 01                         FCB     AM_INHERENT     ; 1D
1728 ca26 02                         FCB     AM_IMMEDIATE8   ; 1E
1729 ca27 02                         FCB     AM_IMMEDIATE8   ; 1F
1730                         
1731 ca28 06                         FCB     AM_RELATIVE8    ; 20
1732 ca29 06                         FCB     AM_RELATIVE8    ; 21
1733 ca2a 06                         FCB     AM_RELATIVE8    ; 22
1734 ca2b 06                         FCB     AM_RELATIVE8    ; 23
1735 ca2c 06                         FCB     AM_RELATIVE8    ; 24
1736 ca2d 06                         FCB     AM_RELATIVE8    ; 25
1737 ca2e 06                         FCB     AM_RELATIVE8    ; 26
1738 ca2f 06                         FCB     AM_RELATIVE8    ; 27
1739 ca30 06                         FCB     AM_RELATIVE8    ; 28
1740 ca31 06                         FCB     AM_RELATIVE8    ; 29
1741 ca32 06                         FCB     AM_RELATIVE8    ; 2A
1742 ca33 06                         FCB     AM_RELATIVE8    ; 2B
1743 ca34 06                         FCB     AM_RELATIVE8    ; 2C
1744 ca35 06                         FCB     AM_RELATIVE8    ; 2D
1745 ca36 06                         FCB     AM_RELATIVE8    ; 2E
1746 ca37 06                         FCB     AM_RELATIVE8    ; 2F
1747                         
1748 ca38 08                         FCB     AM_INDEXED      ; 30
1749 ca39 08                         FCB     AM_INDEXED      ; 31
1750 ca3a 08                         FCB     AM_INDEXED      ; 32
1751 ca3b 08                         FCB     AM_INDEXED      ; 33
1752 ca3c 02                         FCB     AM_IMMEDIATE8   ; 34
1753 ca3d 02                         FCB     AM_IMMEDIATE8   ; 35
1754 ca3e 02                         FCB     AM_IMMEDIATE8   ; 36
1755 ca3f 02                         FCB     AM_IMMEDIATE8   ; 37
1756 ca40 00                         FCB     AM_INVALID      ; 38
1757 ca41 01                         FCB     AM_INHERENT     ; 39
1758 ca42 01                         FCB     AM_INHERENT     ; 3A
1759 ca43 01                         FCB     AM_INHERENT     ; 3B
1760 ca44 02                         FCB     AM_IMMEDIATE8   ; 3C
1761 ca45 01                         FCB     AM_INHERENT     ; 3D
1762 ca46 00                         FCB     AM_INVALID      ; 3E
1763 ca47 01                         FCB     AM_INHERENT     ; 3F
1764                         
1765 ca48 01                         FCB     AM_INHERENT     ; 40
1766 ca49 00                         FCB     AM_INVALID      ; 41
1767 ca4a 00                         FCB     AM_INVALID      ; 42
1768 ca4b 01                         FCB     AM_INHERENT     ; 43
1769 ca4c 01                         FCB     AM_INHERENT     ; 44
1770 ca4d 00                         FCB     AM_INVALID      ; 45
1771 ca4e 01                         FCB     AM_INHERENT     ; 46
1772 ca4f 01                         FCB     AM_INHERENT     ; 47
1773 ca50 01                         FCB     AM_INHERENT     ; 48
1774 ca51 01                         FCB     AM_INHERENT     ; 49
1775 ca52 01                         FCB     AM_INHERENT     ; 4A
1776 ca53 00                         FCB     AM_INVALID      ; 4B
1777 ca54 01                         FCB     AM_INHERENT     ; 4C
1778 ca55 01                         FCB     AM_INHERENT     ; 4D
1779 ca56 00                         FCB     AM_INVALID      ; 4E
1780 ca57 01                         FCB     AM_INHERENT     ; 4F
1781                         
1782 ca58 01                         FCB     AM_INHERENT     ; 50
1783 ca59 00                         FCB     AM_INVALID      ; 51
1784 ca5a 00                         FCB     AM_INVALID      ; 52
1785 ca5b 01                         FCB     AM_INHERENT     ; 53
1786 ca5c 01                         FCB     AM_INHERENT     ; 54
1787 ca5d 00                         FCB     AM_INVALID      ; 55
1788 ca5e 01                         FCB     AM_INHERENT     ; 56
1789 ca5f 01                         FCB     AM_INHERENT     ; 57
1790 ca60 01                         FCB     AM_INHERENT     ; 58
1791 ca61 01                         FCB     AM_INHERENT     ; 59
1792 ca62 01                         FCB     AM_INHERENT     ; 5A
1793 ca63 00                         FCB     AM_INVALID      ; 5B
1794 ca64 01                         FCB     AM_INHERENT     ; 5C
1795 ca65 01                         FCB     AM_INHERENT     ; 5D
1796 ca66 00                         FCB     AM_INVALID      ; 5E
1797 ca67 01                         FCB     AM_INHERENT     ; 5F
1798                         
1799 ca68 08                         FCB     AM_INDEXED      ; 60
1800 ca69 00                         FCB     AM_INVALID      ; 61
1801 ca6a 00                         FCB     AM_INVALID      ; 62
1802 ca6b 08                         FCB     AM_INDEXED      ; 63
1803 ca6c 08                         FCB     AM_INDEXED      ; 64
1804 ca6d 00                         FCB     AM_INVALID      ; 65
1805 ca6e 08                         FCB     AM_INDEXED      ; 66
1806 ca6f 08                         FCB     AM_INDEXED      ; 67
1807 ca70 08                         FCB     AM_INDEXED      ; 68
1808 ca71 08                         FCB     AM_INDEXED      ; 69
1809 ca72 08                         FCB     AM_INDEXED      ; 6A
1810 ca73 00                         FCB     AM_INVALID      ; 6B
1811 ca74 08                         FCB     AM_INDEXED      ; 6C
1812 ca75 08                         FCB     AM_INDEXED      ; 6D
1813 ca76 08                         FCB     AM_INDEXED      ; 6E
1814 ca77 08                         FCB     AM_INDEXED      ; 6F
1815                         
1816 ca78 05                         FCB     AM_EXTENDED     ; 70
1817 ca79 00                         FCB     AM_INVALID      ; 71
1818 ca7a 00                         FCB     AM_INVALID      ; 72
1819 ca7b 05                         FCB     AM_EXTENDED     ; 73
1820 ca7c 05                         FCB     AM_EXTENDED     ; 74
1821 ca7d 00                         FCB     AM_INVALID      ; 75
1822 ca7e 05                         FCB     AM_EXTENDED     ; 76
1823 ca7f 05                         FCB     AM_EXTENDED     ; 77
1824 ca80 05                         FCB     AM_EXTENDED     ; 78
1825 ca81 05                         FCB     AM_EXTENDED     ; 79
1826 ca82 05                         FCB     AM_EXTENDED     ; 7A
1827 ca83 00                         FCB     AM_INVALID      ; 7B
1828 ca84 05                         FCB     AM_EXTENDED     ; 7C
1829 ca85 05                         FCB     AM_EXTENDED     ; 7D
1830 ca86 05                         FCB     AM_EXTENDED     ; 7E
1831 ca87 05                         FCB     AM_EXTENDED     ; 7F
1832                         
1833 ca88 02                         FCB     AM_IMMEDIATE8   ; 80
1834 ca89 02                         FCB     AM_IMMEDIATE8   ; 81
1835 ca8a 02                         FCB     AM_IMMEDIATE8   ; 82
1836 ca8b 03                         FCB     AM_IMMEDIATE16  ; 83
1837 ca8c 02                         FCB     AM_IMMEDIATE8   ; 84
1838 ca8d 02                         FCB     AM_IMMEDIATE8   ; 85
1839 ca8e 02                         FCB     AM_IMMEDIATE8   ; 86
1840 ca8f 00                         FCB     AM_INVALID      ; 87
1841 ca90 02                         FCB     AM_IMMEDIATE8   ; 88
1842 ca91 02                         FCB     AM_IMMEDIATE8   ; 89
1843 ca92 02                         FCB     AM_IMMEDIATE8   ; 8A
1844 ca93 02                         FCB     AM_IMMEDIATE8   ; 8B
1845 ca94 03                         FCB     AM_IMMEDIATE16  ; 8C
1846 ca95 06                         FCB     AM_RELATIVE8    ; 8D
1847 ca96 03                         FCB     AM_IMMEDIATE16  ; 8E
1848 ca97 00                         FCB     AM_INVALID      ; 8F
1849                         
1850 ca98 04                         FCB     AM_DIRECT       ; 90
1851 ca99 04                         FCB     AM_DIRECT       ; 91
1852 ca9a 04                         FCB     AM_DIRECT       ; 92
1853 ca9b 04                         FCB     AM_DIRECT       ; 93
1854 ca9c 04                         FCB     AM_DIRECT       ; 94
1855 ca9d 04                         FCB     AM_DIRECT       ; 95
1856 ca9e 04                         FCB     AM_DIRECT       ; 96
1857 ca9f 04                         FCB     AM_DIRECT       ; 97
1858 caa0 04                         FCB     AM_DIRECT       ; 98
1859 caa1 04                         FCB     AM_DIRECT       ; 99
1860 caa2 04                         FCB     AM_DIRECT       ; 9A
1861 caa3 04                         FCB     AM_DIRECT       ; 9B
1862 caa4 04                         FCB     AM_DIRECT       ; 9C
1863 caa5 04                         FCB     AM_DIRECT       ; 9D
1864 caa6 04                         FCB     AM_DIRECT       ; 9E
1865 caa7 04                         FCB     AM_DIRECT       ; 9F
1866                         
1867 caa8 08                         FCB     AM_INDEXED      ; A0
1868 caa9 08                         FCB     AM_INDEXED      ; A1
1869 caaa 08                         FCB     AM_INDEXED      ; A2
1870 caab 08                         FCB     AM_INDEXED      ; A3
1871 caac 08                         FCB     AM_INDEXED      ; A4
1872 caad 08                         FCB     AM_INDEXED      ; A5
1873 caae 08                         FCB     AM_INDEXED      ; A6
1874 caaf 08                         FCB     AM_INDEXED      ; A7
1875 cab0 08                         FCB     AM_INDEXED      ; A8
1876 cab1 08                         FCB     AM_INDEXED      ; A9
1877 cab2 08                         FCB     AM_INDEXED      ; AA
1878 cab3 08                         FCB     AM_INDEXED      ; AB
1879 cab4 08                         FCB     AM_INDEXED      ; AC
1880 cab5 08                         FCB     AM_INDEXED      ; AD
1881 cab6 08                         FCB     AM_INDEXED      ; AE
1882 cab7 08                         FCB     AM_INDEXED      ; AF
1883                         
1884 cab8 05                         FCB     AM_EXTENDED     ; B0
1885 cab9 05                         FCB     AM_EXTENDED     ; B1
1886 caba 05                         FCB     AM_EXTENDED     ; B2
1887 cabb 05                         FCB     AM_EXTENDED     ; B3
1888 cabc 05                         FCB     AM_EXTENDED     ; B4
1889 cabd 05                         FCB     AM_EXTENDED     ; B5
1890 cabe 05                         FCB     AM_EXTENDED     ; B6
1891 cabf 05                         FCB     AM_EXTENDED     ; B7
1892 cac0 05                         FCB     AM_EXTENDED     ; B8
1893 cac1 05                         FCB     AM_EXTENDED     ; B9
1894 cac2 05                         FCB     AM_EXTENDED     ; BA
1895 cac3 05                         FCB     AM_EXTENDED     ; BB
1896 cac4 05                         FCB     AM_EXTENDED     ; BC
1897 cac5 05                         FCB     AM_EXTENDED     ; BD
1898 cac6 05                         FCB     AM_EXTENDED     ; BE
1899 cac7 05                         FCB     AM_EXTENDED     ; BF
1900                         
1901 cac8 02                         FCB     AM_IMMEDIATE8   ; C0
1902 cac9 02                         FCB     AM_IMMEDIATE8   ; C1
1903 caca 02                         FCB     AM_IMMEDIATE8   ; C2
1904 cacb 03                         FCB     AM_IMMEDIATE16  ; C3
1905 cacc 02                         FCB     AM_IMMEDIATE8   ; C4
1906 cacd 02                         FCB     AM_IMMEDIATE8   ; C5
1907 cace 02                         FCB     AM_IMMEDIATE8   ; C6
1908 cacf 00                         FCB     AM_INVALID      ; C7
1909 cad0 02                         FCB     AM_IMMEDIATE8   ; C8
1910 cad1 02                         FCB     AM_IMMEDIATE8   ; C9
1911 cad2 02                         FCB     AM_IMMEDIATE8   ; CA
1912 cad3 02                         FCB     AM_IMMEDIATE8   ; CB
1913 cad4 03                         FCB     AM_IMMEDIATE16  ; CC
1914 cad5 01                         FCB     AM_INHERENT     ; CD
1915 cad6 03                         FCB     AM_IMMEDIATE16  ; CE
1916 cad7 00                         FCB     AM_INVALID      ; CF
1917                         
1918 cad8 04                         FCB     AM_DIRECT       ; D0
1919 cad9 04                         FCB     AM_DIRECT       ; D1
1920 cada 04                         FCB     AM_DIRECT       ; D2
1921 cadb 04                         FCB     AM_DIRECT       ; D3
1922 cadc 04                         FCB     AM_DIRECT       ; D4
1923 cadd 04                         FCB     AM_DIRECT       ; D5
1924 cade 04                         FCB     AM_DIRECT       ; D6
1925 cadf 04                         FCB     AM_DIRECT       ; D7
1926 cae0 04                         FCB     AM_DIRECT       ; D8
1927 cae1 04                         FCB     AM_DIRECT       ; D9
1928 cae2 04                         FCB     AM_DIRECT       ; DA
1929 cae3 04                         FCB     AM_DIRECT       ; DB
1930 cae4 04                         FCB     AM_DIRECT       ; DC
1931 cae5 04                         FCB     AM_DIRECT       ; DD
1932 cae6 04                         FCB     AM_DIRECT       ; DE
1933 cae7 04                         FCB     AM_DIRECT       ; DF
1934                         
1935 cae8 08                         FCB     AM_INDEXED      ; E0
1936 cae9 08                         FCB     AM_INDEXED      ; E1
1937 caea 08                         FCB     AM_INDEXED      ; E2
1938 caeb 08                         FCB     AM_INDEXED      ; E3
1939 caec 08                         FCB     AM_INDEXED      ; E4
1940 caed 08                         FCB     AM_INDEXED      ; E5
1941 caee 08                         FCB     AM_INDEXED      ; E6
1942 caef 08                         FCB     AM_INDEXED      ; E7
1943 caf0 08                         FCB     AM_INDEXED      ; E8
1944 caf1 08                         FCB     AM_INDEXED      ; E9
1945 caf2 08                         FCB     AM_INDEXED      ; EA
1946 caf3 08                         FCB     AM_INDEXED      ; EB
1947 caf4 08                         FCB     AM_INDEXED      ; EC
1948 caf5 08                         FCB     AM_INDEXED      ; ED
1949 caf6 08                         FCB     AM_INDEXED      ; EE
1950 caf7 08                         FCB     AM_INDEXED      ; EF
1951                         
1952 caf8 05                         FCB     AM_EXTENDED     ; F0
1953 caf9 05                         FCB     AM_EXTENDED     ; F1
1954 cafa 05                         FCB     AM_EXTENDED     ; F2
1955 cafb 05                         FCB     AM_EXTENDED     ; F3
1956 cafc 05                         FCB     AM_EXTENDED     ; F4
1957 cafd 05                         FCB     AM_EXTENDED     ; F5
1958 cafe 05                         FCB     AM_EXTENDED     ; F6
1959 caff 05                         FCB     AM_EXTENDED     ; F7
1960 cb00 05                         FCB     AM_EXTENDED     ; F8
1961 cb01 05                         FCB     AM_EXTENDED     ; F9
1962 cb02 05                         FCB     AM_EXTENDED     ; FA
1963 cb03 05                         FCB     AM_EXTENDED     ; FB
1964 cb04 05                         FCB     AM_EXTENDED     ; FC
1965 cb05 05                         FCB     AM_EXTENDED     ; FD
1966 cb06 05                         FCB     AM_EXTENDED     ; FE
1967 cb07 05                         FCB     AM_EXTENDED     ; FF
1968                         
1969                         ; Special table for page 2 instructions prefixed by $10.
1970                         ; Format: opcode (less 10), instruction, addressing mode
1971                         
1972                         PAGE2:
1973 cb08 21 4a 07                   FCB     $21, OP_LBRN,  AM_RELATIVE16
1974 cb0b 22 42 07                   FCB     $22, OP_LBHI,  AM_RELATIVE16
1975 cb0e 23 44 07                   FCB     $23, OP_LBLS,  AM_RELATIVE16
1976 cb11 24 3d 07                   FCB     $24, OP_LBCC,  AM_RELATIVE16
1977 cb14 25 3e 07                   FCB     $25, OP_LBCS,  AM_RELATIVE16
1978 cb17 26 47 07                   FCB     $26, OP_LBNE,  AM_RELATIVE16
1979 cb1a 27 3f 07                   FCB     $27, OP_LBEQ,  AM_RELATIVE16
1980 cb1d 28 4c 07                   FCB     $28, OP_LBVC,  AM_RELATIVE16
1981 cb20 29 4d 07                   FCB     $29, OP_LBVS,  AM_RELATIVE16
1982 cb23 2a 48 07                   FCB     $2A, OP_LBPL,  AM_RELATIVE16
1983 cb26 2b 46 07                   FCB     $2B, OP_LBMI,  AM_RELATIVE16
1984 cb29 2c 40 07                   FCB     $2C, OP_LBGE,  AM_RELATIVE16
1985 cb2c 2d 45 07                   FCB     $2D, OP_LBLT,  AM_RELATIVE16
1986 cb2f 2e 41 07                   FCB     $2E, OP_LBGT,  AM_RELATIVE16
1987 cb32 2f 43 07                   FCB     $2F, OP_LBLE,  AM_RELATIVE16
1988 cb35 3f 7e 01                   FCB     $3F, OP_SWI2,  AM_INHERENT
1989 cb38 83 28 03                   FCB     $83, OP_CMPD,  AM_IMMEDIATE16
1990 cb3b 8c 2c 03                   FCB     $8C, OP_CMPY,  AM_IMMEDIATE16
1991 cb3e 8e 54 03                   FCB     $8E, OP_LDY,   AM_IMMEDIATE16
1992 cb41 93 28 04                   FCB     $93, OP_CMPD,  AM_DIRECT
1993 cb44 9c 2c 04                   FCB     $9C, OP_CMPY,  AM_DIRECT
1994 cb47 9e 54 04                   FCB     $9E, OP_LDY,   AM_DIRECT
1995 cb4a 9d 79 04                   FCB     $9D, OP_STY,   AM_DIRECT
1996 cb4d a3 28 08                   FCB     $A3, OP_CMPD,  AM_INDEXED
1997 cb50 ac 2c 08                   FCB     $AC, OP_CMPY,  AM_INDEXED
1998 cb53 ae 54 08                   FCB     $AE, OP_LDY,   AM_INDEXED
1999 cb56 af 79 08                   FCB     $AF, OP_STY,   AM_INDEXED
2000 cb59 b3 28 05                   FCB     $B3, OP_CMPD,  AM_EXTENDED
2001 cb5c bc 2c 05                   FCB     $BC, OP_CMPY,  AM_EXTENDED
2002 cb5f be 54 05                   FCB     $BE, OP_LDY,   AM_EXTENDED
2003 cb62 bf 79 05                   FCB     $BF, OP_STY,   AM_EXTENDED
2004 cb65 ce 51 03                   FCB     $CE, OP_LDS,   AM_IMMEDIATE16
2005 cb68 de 51 04                   FCB     $DE, OP_LDS,   AM_DIRECT
2006 cb6b dd 76 04                   FCB     $DD, OP_STS,   AM_DIRECT
2007 cb6e ee 51 08                   FCB     $EE, OP_LDS,   AM_INDEXED
2008 cb71 ef 76 08                   FCB     $EF, OP_STS,   AM_INDEXED
2009 cb74 fe 51 05                   FCB     $FE, OP_LDS,   AM_EXTENDED
2010 cb77 ff 76 05                   FCB     $FF, OP_STS,   AM_EXTENDED
2011 cb7a 00                         FCB     0                             ; indicates end of table
2012                         
2013                         ; Special table for page 3 instructions prefixed by $11.
2014                         ; Same format as table above.
2015                         
2016                         PAGE3:
2017 cb7b 3f 7f 01                   FCB     $3F, OP_SWI3,  AM_INHERENT
2018 cb7e 83 2a 03                   FCB     $83, OP_CMPU,  AM_IMMEDIATE16
2019 cb81 8c 29 03                   FCB     $8C, OP_CMPS,  AM_IMMEDIATE16
2020 cb84 93 2a 04                   FCB     $93, OP_CMPU,  AM_DIRECT
2021 cb87 9c 29 04                   FCB     $9C, OP_CMPS,  AM_DIRECT
2022 cb8a a3 2a 08                   FCB     $A3, OP_CMPU,  AM_INDEXED
2023 cb8d ac 29 08                   FCB     $AC, OP_CMPS,  AM_INDEXED
2024 cb90 b3 2a 05                   FCB     $B3, OP_CMPU,  AM_EXTENDED
2025 cb93 bc 29 05                   FCB     $BC, OP_CMPS,  AM_EXTENDED
2026 cb96 00                         FCB     0                             ; indicates end of table
2027                         
2028                         ; Display strings. Should be terminated in EOT character.
2029                         
2030 cb97 3b 20 49 4e 56 41  MSG1:   FCC     "; INVALID"
     4c 49 44
2031 cba0 04                         FCB     EOT
2032                         
2033 cba1 50 52 45 53 53 20  MSG2:   FCC     "PRESS <SPACE> TO CONTINUE, <Q> TO QUIT "
     3c 53 50 41 43 45
     3e 20 54 4f 20 43
     4f 4e 54 49 4e 55
     45 2c 20 3c 51 3e
     20 54 4f 20 51 55
     49 54 20
2034 cbc8 04                         FCB     EOT
2035                         
2036 cbc9 50 43 52           MSG3:   FCC     "PCR"
2037 cbcc 04                         FCB     EOT
2038                         
2039 cbcd ff ff ff ff ff ff            FILL $FF, $D000-*   ; Fill ROM with FFs until $D000
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff
2040                         
2041                         ************************************************************************
2042                         
2043 a000                    UART      EQU  $A000
2044 a001                    RECEV     EQU  UART+1
2045 a001                    TRANS     EQU  UART+1
2046 a000                    USTAT     EQU  UART
2047 a000                    UCTRL     EQU  UART
2048                         
2049 0008                    BS        EQU  8              ; BACKSPACE
2050 000d                    CR        EQU  $D             ; ENTER KEY
2051 001b                    ESC       EQU  $1B            ; ESCAPE CODE
2052 0020                    SPACE     EQU  $20            ; SPACE (BLANK)
2053 003a                    STKBUF    EQU  58             ; STACK BUFFER ROOM
2054 00fa                    LBUFMX    EQU  250            ; MAX NUMBER OF CHARS IN A BASIC LINE
2055 00fa                    MAXLIN    EQU  $FA            ; MAXIMUM MS BYTE OF LINE NUMBER
2056                         * PSEUDO OPS
2057 0021                    SKP1      EQU  $21            ; OP CODE OF BRN - SKIP ONE BYTE
2058 008c                    SKP2      EQU  $8C            ; OP CODE OF CMPX # - SKIP TWO BYTES
2059 0086                    SKP1LD    EQU  $86            ; OP CODE OF LDA # - SKIP THE NEXT BYTE
2060                         *                             ; AND LOAD THE VALUE OF THAT BYTE INTO ACCA - THIS
2061                         *                             ; IS USUALLY USED TO LOAD ACCA WITH A NON ZERO VALUE
2062 0015                    RTS_LOW   EQU  $15            ; 6850 ACIA CONTROL REGISTER: RX INT DISABLED, RTS LOW, TX INT DISABLED, 8N1, CLK/16
2063 0000                              ORG  0
2064 0000                    ENDFLG    RMB  1              ; STOP/END FLAG: POSITIVE=STOP, NEG=END
2065 0001                    CHARAC    RMB  1              ; TERMINATOR FLAG 1
2066 0002                    ENDCHR    RMB  1              ; TERMINATOR FLAG 2
2067 0003                    TMPLOC    RMB  1              ; SCRATCH VARIABLE
2068 0004                    IFCTR     RMB  1              ; IF COUNTER - HOW MANY IF STATEMENTS IN A LINE
2069 0005                    DIMFLG    RMB  1              ; *DV* ARRAY FLAG 0=EVALUATE, 1=DIMENSIONING
2070 0006                    VALTYP    RMB  1              ; *DV* *PV TYPE FLAG: 0=NUMERIC, $FF=STRING
2071 0007                    GARBFL    RMB  1              ; *TV STRING SPACE HOUSEKEEPING FLAG
2072 0008                    ARYDIS    RMB  1              ; DISABLE ARRAY SEARCH: 00=ALLOW SEARCH
2073 0009                    INPFLG    RMB  1              ; *TV INPUT FLAG: READ=0, INPUT<>0
2074 000a                    RELFLG    RMB  1              ; *TV RELATIONAL OPERATOR FLAG
2075 000b                    TEMPPT    RMB  2              ; *PV TEMPORARY STRING STACK POINTER
2076 000d                    LASTPT    RMB  2              ; *PV ADDR OF LAST USED STRING STACK ADDRESS
2077 000f                    TEMPTR    RMB  2              ; TEMPORARY POINTER
2078 0011                    TMPTR1    RMB  2              ; TEMPORARY DESCRIPTOR STORAGE (STACK SEARCH)
2079 0013                    FPA2      RMB  4              ; FLOATING POINT ACCUMULATOR #2 MANTISSA
2080 0017                    BOTSTK    RMB  2              ; BOTTOM OF STACK AT LAST CHECK
2081 0019                    TXTTAB    RMB  2              ; *PV BEGINNING OF BASIC PROGRAM
2082 001b                    VARTAB    RMB  2              ; *PV START OF VARIABLES
2083 001d                    ARYTAB    RMB  2              ; *PV START OF ARRAYS
2084 001f                    ARYEND    RMB  2              ; *PV END OF ARRAYS (+1)
2085 0021                    FRETOP    RMB  2              ; *PV START OF STRING STORAGE (TOP OF FREE RAM)
2086 0023                    STRTAB    RMB  2              ; *PV START OF STRING VARIABLES
2087 0025                    FRESPC    RMB  2              ; UTILITY STRING POINTER
2088 0027                    MEMSIZ    RMB  2              ; *PV TOP OF STRING SPACE
2089 0029                    OLDTXT    RMB  2              ; SAVED LINE NUMBER DURING A "STOP"
2090 002b                    BINVAL    RMB  2              ; BINARY VALUE OF A CONVERTED LINE NUMBER
2091 002d                    OLDPTR    RMB  2              ; SAVED INPUT PTR DURING A "STOP"
2092 002f                    TINPTR    RMB  2              ; TEMPORARY INPUT POINTER STORAGE
2093 0031                    DATTXT    RMB  2              ; *PV 'DATA' STATEMENT LINE NUMBER POINTER
2094 0033                    DATPTR    RMB  2              ; *PV 'DATA' STATEMENT ADDRESS POINTER
2095 0035                    DATTMP    RMB  2              ; DATA POINTER FOR 'INPUT' & 'READ'
2096 0037                    VARNAM    RMB  2              ; *TV TEMP STORAGE FOR A VARIABLE NAME
2097 0039                    VARPTR    RMB  2              ; *TV POINTER TO A VARIABLE DESCRIPTOR
2098 003b                    VARDES    RMB  2              ; TEMP POINTER TO A VARIABLE DESCRIPTOR
2099 003d                    RELPTR    RMB  2              ; POINTER TO RELATIONAL OPERATOR PROCESSING ROUTINE
2100 003f                    TRELFL    RMB  1              ; TEMPORARY RELATIONAL OPERATOR FLAG BYTE
2101                         * FLOATING POINT ACCUMULATORS #3,4 & 5 ARE MOSTLY
2102                         * USED AS SCRATCH PAD VARIABLES.
2103                         ** FLOATING POINT ACCUMULATOR #3 :PACKED: ($40-$44)
2104 0040                    V40       RMB  1
2105 0041                    V41       RMB  1
2106 0042                    V42       RMB  1
2107 0043                    V43       RMB  1
2108 0044                    V44       RMB  1
2109                         ** FLOATING POINT ACCUMULATOR #4 :PACKED: ($45-$49)
2110 0045                    V45       RMB  1
2111 0046                    V46       RMB  1
2112 0047                    V47       RMB  1
2113 0048                    V48       RMB  2
2114                         ** FLOATING POINT ACCUMULATOR #5 :PACKED: ($4A-$4E)
2115 004a                    V4A       RMB  1
2116 004b                    V4B       RMB  2
2117 004d                    V4D       RMB  2
2118                         ** FLOATING POINT ACCUMULATOR #0
2119 004f                    FP0EXP    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #0 EXPONENT
2120 0050                    FPA0      RMB  4              ; *PV FLOATING POINT ACCUMULATOR #0 MANTISSA
2121 0054                    FP0SGN    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #0 SIGN
2122 0055                    COEFCT    RMB  1              ; POLYNOMIAL COEFFICIENT COUNTER
2123 0056                    STRDES    RMB  5              ; TEMPORARY STRING DESCRIPTOR
2124 005b                    FPCARY    RMB  1              ; FLOATING POINT CARRY BYTE
2125                         ** FLOATING POINT ACCUMULATOR #1
2126 005c                    FP1EXP    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #1 EXPONENT
2127 005d                    FPA1      RMB  4              ; *PV FLOATING POINT ACCUMULATOR #1 MANTISSA
2128 0061                    FP1SGN    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #1 SIGN
2129 0062                    RESSGN    RMB  1              ; SIGN OF RESULT OF FLOATING POINT OPERATION
2130 0063                    FPSBYT    RMB  1              ; FLOATING POINT SUB BYTE (FIFTH BYTE)
2131 0064                    COEFPT    RMB  2              ; POLYNOMIAL COEFFICIENT POINTER
2132 0066                    LSTTXT    RMB  2              ; CURRENT LINE POINTER DURING LIST
2133 0068                    CURLIN    RMB  2              ; *PV CURRENT LINE # OF BASIC PROGRAM, $FFFF = DIRECT
2134 006a                    DEVCFW    RMB  1              ; *TV TAB FIELD WIDTH
2135 006b                    DEVLCF    RMB  1              ; *TV TAB ZONE
2136 006c                    DEVPOS    RMB  1              ; *TV PRINT POSITION
2137 006d                    DEVWID    RMB  1              ; *TV PRINT WIDTH
2138 006e                    RSTFLG    RMB  1              ; *PV WARM START FLAG: $55=WARM, OTHER=COLD
2139 006f                    RSTVEC    RMB  2              ; *PV WARM START VECTOR - JUMP ADDRESS FOR WARM START
2140 0071                    TOPRAM    RMB  2              ; *PV TOP OF RAM
2141 0073                    IKEYIM    RMB  1              ; *TV INKEY$ RAM IMAGE
2142 0074                    ZERO      RMB  2              ; *PV DUMMY - THESE TWO BYTES ARE ALWAYS ZERO
2143                         * THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM
2144 0076                    LPTCFW    RMB  1              ; 16
2145 0077                    LPTLCF    RMB  1              ; 112
2146 0078                    LPTWID    RMB  1              ; 132
2147 0079                    LPTPOS    RMB  1              ; 0
2148 007a                    EXECJP    RMB  2              ; LB4AA
2149                         
2150                         * THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM
2151                         * BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE
2152                         * INTERPRETED IS STORED AT CHARAD.
2153 007c 0c 84              GETNCH    INC  <CHARAD+1      ; *PV INCREMENT LS BYTE OF INPUT POINTER
2154 007e 26 02                        BNE  GETCCH         ; *PV BRANCH IF NOT ZERO (NO CARRY)
2155 0080 0c 83                        INC  <CHARAD        ; *PV INCREMENT MS BYTE OF INPUT POINTER
2156 0082 b6                 GETCCH    FCB  $B6            ; *PV OP CODE OF LDA EXTENDED
2157 0083                    CHARAD    RMB  2              ; *PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT
2158                         *         *    CHARACTER WHICH THE BASIC INTERPRETER IS
2159                         *         *    PROCESSING
2160 0085 7e d1 c2                     JMP  BROMHK         ; JUMP BACK INTO THE BASIC RUM
2161                         
2162 0088                    VAB       RMB  1              ; = LOW ORDER FOUR BYTES OF THE PRODUCT
2163 0089                    VAC       RMB  1              ; = OF A FLOATING POINT MULTIPLICATION
2164 008a                    VAD       RMB  1              ; = THESE BYTES ARE USE AS RANDOM DATA
2165 008b                    VAE       RMB  1              ; = BY THE RND STATEMENT
2166                         
2167                         * EXTENDED BASIC VARIABLES
2168 008c                    TRCFLG    RMB  1              ; *PV TRACE FLAG 0=OFF ELSE=ON
2169 008d                    USRADR    RMB  2              ; *PV ADDRESS OF THE START OF USR VECTORS
2170                         
2171                         * EXTENDED BASIC SCRATCH PAD VARIABLES
2172 008f                    VCF       RMB  2
2173 0091                    VD1       RMB  2
2174 0093                    VD3       RMB  2
2175 0095                    VD5       RMB  2
2176 0097                    VD7       RMB  1
2177 0098                    VD8       RMB  1
2178 0099                    VD9       RMB  1
2179 009a                    VDA       RMB  1
2180 009b                    SW3VEC    RMB  3
2181 009e                    SW2VEC    RMB  3
2182 00a1                    SWIVEC    RMB  3
2183 00a4                    NMIVEC    RMB  3
2184 00a7                    IRQVEC    RMB  3
2185 00aa                    FRQVEC    RMB  3
2186 00ad                    USRJMP    RMB  3              ; JUMP ADDRESS FOR BASIC'S USR FUNCTION
2187 00b0                    RVSEED    RMB  1              ; * FLOATING POINT RANDOM NUMBER SEED EXPONENT
2188 00b1                              RMB  4              ; * MANTISSA: INITIALLY SET TO $804FC75259
2189                         
2190                         **** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)
2191 00b5                    USR0      RMB  2              ; USR 0 VECTOR
2192 00b7                              RMB  2              ; USR 1
2193 00b9                              RMB  2              ; USR 2
2194 00bb                              RMB  2              ; USR 3
2195 00bd                              RMB  2              ; USR 4
2196 00bf                              RMB  2              ; USR 5
2197 00c1                              RMB  2              ; USR 6
2198 00c3                              RMB  2              ; USR 7
2199 00c5                              RMB  2              ; USR 8
2200 00c7                              RMB  2              ; USR 9
2201                         
2202 00c9                    STRSTK    RMB  8*5            ; STRING DESCRIPTOR STACK
2203 00f1                    LINHDR    RMB  2              ; LINE INPUT BUFFER HEADER
2204 00f3                    LINBUF    RMB  LBUFMX+1       ; BASIC LINE INPUT BUFFER
2205 01ee                    STRBUF    RMB  41             ; STRING BUFFER
2206                         
2207 0217                    PROGST    RMB  1              ; START OF PROGRAM SPACE
2208                         *         INTERRUPT VECTORS
2209                         *          ORG  $FFF2
2210                         *SWI3      RMB  2
2211                         *SWI2      RMB  2
2212                         *FIRQ      RMB  2
2213                         *IRQ       RMB  2
2214                         *SWI       RMB  2
2215                         *NMI       RMB  2
2216                         *RESETV    RMB  2
2217                         
2218 d000                              ORG  $D000
2219                         
2220                         * JUMP TO BASIC COLD START AT START OF ROM FOR CONVENIENCE
2221 d000 7e d0 49                     JMP   RESVEC
2222                         
2223                         * CONSOLE IN
2224 d003 8d 03              LA171     BSR  KEYIN          ; GET A CHARACTER FROM CONSOLE IN
2225 d005 27 fc                        BEQ  LA171          ; LOOP IF NO KEY DOWN
2226 d007 39                           RTS
2227                         
2228                         *
2229                         * THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A KEY
2230                         * IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DOWN.
2231                         *
2232                         *
2233                         LA1C1
2234 d008 b6 a0 00           KEYIN     LDA  USTAT
2235 d00b 85 01                        BITA #1
2236 d00d 27 06                        BEQ  NOCHAR
2237 d00f b6 a0 01                     LDA  RECEV
2238 d012 84 7f                        ANDA #$7F
2239 d014 39                           RTS
2240 d015 4f                 NOCHAR    CLRA
2241 d016 39                           RTS
2242                         
2243                         
2244                         
2245                         * CONSOLE OUT
2246 d017 8d 24              PUTCHR    BSR  WAITACIA
2247 d019 34 02                        PSHS A              ;
2248 d01b 81 0d                        CMPA #CR            ; IS IT CARRIAGE RETURN?
2249 d01d 27 0b                        BEQ  NEWLINE        ; YES
2250 d01f b7 a0 01                     STA  TRANS
2251 d022 0c 79                        INC  LPTPOS         ; INCREMENT CHARACTER COUNTER
2252 d024 96 79                        LDA  LPTPOS         ; CHECK FOR END OF LINE PRINTER LINE
2253 d026 91 78                        CMPA LPTWID         ; AT END OF LINE PRINTER LINE?
2254 d028 25 10                        BLO  PUTEND         ; NO
2255 d02a 0f 79              NEWLINE   CLR  LPTPOS         ; RESET CHARACTER COUNTER
2256 d02c 8d 0f                        BSR  WAITACIA
2257 d02e 86 0d                        LDA  #13
2258 d030 b7 a0 01                     STA  TRANS
2259 d033 8d 08                        BSR  WAITACIA
2260 d035 86 0a                        LDA  #10            ; DO LINEFEED AFTER CR
2261 d037 b7 a0 01                     STA  TRANS
2262 d03a 35 02              PUTEND    PULS A              ;
2263 d03c 39                           RTS
2264                         
2265 d03d 34 02              WAITACIA  PSHS A
2266 d03f b6 a0 00           WRWAIT    LDA  USTAT
2267 d042 85 02                        BITA #2
2268 d044 27 f9                        BEQ  WRWAIT
2269 d046 35 02                        PULS A              ;
2270 d048 39                           RTS
2271                         
2272                         *
2273                         RESVEC
2274 d049 10 ce 01 ee        LA00E     LDS  #LINBUF+LBUFMX+1 ; SET STACK TO TOP OF LINE INPUT BUFFER
2275 d04d 96 6e                        LDA  RSTFLG         ; GET WARM START FLAG
2276 d04f 81 55                        CMPA #$55           ; IS IT A WARM START?
2277 d051 26 0a                        BNE  BACDST         ; NO - D0 A COLD START
2278 d053 9e 6f                        LDX  RSTVEC         ; WARM START VECTOR
2279 d055 a6 84                        LDA  ,X             ; GET FIRST BYTE OF WARM START ADDR
2280 d057 81 12                        CMPA #$12           ; IS IT NOP?
2281 d059 26 02                        BNE  BACDST         ; NO - DO A COLD START
2282 d05b 6e 84                        JMP  ,X             ; YES, G0 THERE
2283                         
2284                         * COLD START ENTRY
2285                         
2286 d05d 8e 02 18           BACDST    LDX  #PROGST+1      ; POINT X TO CLEAR 1ST 1K OF RAM
2287 d060 6f 83              LA077     CLR  ,--X           ; MOVE POINTER DOWN TWO-CLEAR BYTE
2288 d062 30 01                        LEAX 1,X            ; ADVANCE POINTER ONE
2289 d064 26 fa                        BNE  LA077          ; KEEP GOING IF NOT AT BOTTOM OF PAGE 0
2290 d066 8e 02 17                     LDX  #PROGST        ; SET TO START OF PROGRAM SPACE
2291 d069 6f 80                        CLR  ,X+            ; CLEAR 1ST BYTE OF BASIC PROGRAM
2292 d06b 9f 19                        STX  TXTTAB         ; BEGINNING OF BASIC PROGRAM
2293 d06d a6 02              LA084     LDA  2,X            ; LOOK FOR END OF MEMORY
2294 d06f 43                           COMA                ; * COMPLEMENT IT AND PUT IT BACK
2295 d070 a7 02                        STA  2,X            ; * INTO SYSTEM MEMORY
2296 d072 a1 02                        CMPA 2,X            ; IS IT RAM?
2297 d074 26 06                        BNE  LA093          ; BRANCH IF NOT (ROM, BAD RAM OR NO RAM)
2298 d076 30 01                        LEAX 1,X            ; MOVE POINTER UP ONE
2299 d078 63 01                        COM  1,X            ; RE-COMPLEMENT TO RESTORE BYTE
2300 d07a 20 f1                        BRA  LA084          ; KEEP LOOKING FOR END OF RAM
2301 d07c 9f 71              LA093     STX  TOPRAM         ; SAVE ABSOLUTE TOP OF RAM
2302 d07e 9f 27                        STX  MEMSIZ         ; SAVE TOP OF STRING SPACE
2303 d080 9f 23                        STX  STRTAB         ; SAVE START OF STRING VARIABLES
2304 d082 30 89 ff 38                  LEAX -200,X         ; CLEAR 200 - DEFAULT STRING SPACE TO 200 BYTES
2305 d086 9f 21                        STX  FRETOP         ; SAVE START OF STRING SPACE
2306 d088 1f 14                        TFR  X,S            ; PUT STACK THERE
2307 d08a 8e d0 d1                     LDX  #LA10D         ; POINT X TO ROM SOURCE DATA
2308 d08d ce 00 76                     LDU  #LPTCFW        ; POINT U TO RAM DESTINATION
2309 d090 c6 12                        LDB  #18            ; MOVE 18 BYTES
2310 d092 bd d1 b1                     JSR  LA59A          ; MOVE 18 BYTES FROM ROM TO RAM
2311 d095 ce 00 a7                     LDU  #IRQVEC        ; POINT U TO NEXT RAM DESTINATION
2312 d098 c6 04                        LDB  #4             ; MOVE 4 MORE BYTES
2313 d09a bd d1 b1                     JSR  LA59A          ; MOVE 4 BYTES FROM ROM TO RAM
2314 d09d 86 39                        LDA  #$39
2315 d09f 97 f0                        STA  LINHDR-1       ; PUT RTS IN LINHDR-1
2316 d0a1 bd d4 bd                     JSR  LAD19          ; G0 DO A 'NEW'
2317                         * EXTENDED BASIC INITIALISATION
2318 d0a4 8e 00 b5                     LDX  #USR0          ; INITIALIZE ADDRESS OF START OF
2319 d0a7 9f 8d                        STX  USRADR         ; USR JUMP TABLE
2320                         * INITIALIZE THE USR CALLS TO 'FC ERROR'
2321 d0a9 ce db d1                     LDU  #LB44A         ; ADDRESS OF 'FC ERROR' ROUTINE
2322 d0ac c6 0a                        LDB  #10            ; 10 USR CALLS IN EX BASIC
2323 d0ae ef 81              L8031     STU  ,X++           ; STORE 'FC' ERROR AT USR ADDRESSES
2324 d0b0 5a                           DECB                ; FINISHED ALL 10?
2325 d0b1 26 fb                        BNE  L8031          ; NO
2326                         
2327                         * INITIALISE ACIA
2328 d0b3 86 15                        LDA  #RTS_LOW       ; DIV16 CLOCK -> 7372800 / 4 / 16 = 115200
2329 d0b5 b7 a0 00                     STA  UCTRL
2330 d0b8 8e d1 06                     LDX  #LA147-1       ; POINT X TO COLOR BASIC COPYRIGHT MESSAGE
2331 d0bb bd e0 e8                     JSR  LB99C          ; PRINT 'COLOR BASIC'
2332 d0be 8e d0 c9                     LDX  #BAWMST        ; WARM START ADDRESS
2333 d0c1 9f 6f                        STX  RSTVEC         ; SAVE IT
2334 d0c3 86 55                        LDA  #$55           ; WARM START FLAG
2335 d0c5 97 6e                        STA  RSTFLG         ; SAVE IT
2336 d0c7 20 04                        BRA  LA0F3          ; GO TO BASIC'S MAIN LOOP
2337 d0c9 12                 BAWMST    NOP                 ; NOP REQ'D FOR WARM START
2338 d0ca bd d4 d7                     JSR  LAD33          ; DO PART OF A NEW
2339 d0cd 7e d4 25           LA0F3     JMP  LAC73          ; GO TO MAIN LOOP OF BASIC
2340                         *
2341                         * FIRQ SERVICE ROUTINE
2342                         BFRQSV
2343 d0d0 3b                           RTI
2344                         *
2345                         * THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIRECT PAGE
2346 d0d1 10                 LA10D     FCB  16             ; TAB FIELD WIDTH
2347 d0d2 40                           FCB  64             ; LAST TAB ZONE
2348 d0d3 50                           FCB  80             ; PRINTER WIDTH
2349 d0d4 00                           FCB  0              ; LINE PRINTER POSITION
2350 d0d5 db d1                        FDB  LB44A          ; ARGUMENT OF EXEC COMMAND - SET TO 'FC' ERROR
2351                         * LINE INPUT ROUTINE
2352 d0d7 0c 84                        INC  CHARAD+1
2353 d0d9 26 02                        BNE  LA123
2354 d0db 0c 83                        INC  CHARAD
2355 d0dd b6 00 00           LA123     LDA  >0000
2356 d0e0 7e d1 c2                     JMP  BROMHK
2357                         *
2358                         * THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1
2359 d0e3 7e d1 c1                     JMP  BIRQSV         ; IRQ SERVICE
2360 d0e6 7e d0 d0                     JMP  BFRQSV         ; FIRQ SERVICE
2361 d0e9 7e db d1                     JMP  LB44A          ; USR ADDRESS FOR 8K BASIC (INITIALIZED TO 'FC' ERROR)
2362 d0ec 80                           FCB  $80            ; *RANDOM SEED
2363 d0ed 4f c7                        FDB  $4FC7          ; *RANDON SEED OF MANTISSA
2364 d0ef 52 59                        FDB  $5259          ; *.811635157
2365                         * BASIC COMMAND INTERPRETATION TABLE ROM IMAGE
2366 d0f1 32                 COMVEC    FCB  50             ; 50 BASIC COMMANDS
2367 d0f2 d2 20                        FDB  LAA66          ; POINTS TO RESERVED WORDS
2368 d0f4 d3 2d                        FDB  LAB67          ; POINTS TO JUMP TABLE FOR COMMANDS
2369 d0f6 1d                           FCB  29             ; 29 BASIC SECONDARY COMMANDS
2370 d0f7 d2 c0                        FDB  LAB1A          ; POINTS TO SECONDARY FUNCTION RESERVED WORDS
2371 d0f9 d1 d1                        FDB  LAA29          ; POINTS TO SECONDARY FUNCTION JUMP TABLE
2372 d0fb 00 00                        FDB  0              ; NO MORE TABLES (RES WORDS=0)
2373 d0fd 00 00                        FDB  0              ; NO MORE TABLES
2374 d0ff 00 00                        FDB  0              ; NO MORE TABLES
2375 d101 00 00                        FDB  0              ; NO MORE TABLES
2376 d103 00 00                        FDB  0              ; NO MORE TABLES
2377 d105 00 00                        FDB  0              ; NO MORE TABLES (SECONDARY FNS =0)
2378                         
2379                         * COPYRIGHT MESSAGES
2380 d107 36 38 30 39 20 45  LA147     FCC  "6809 EXTENDED BASIC"
     58 54 45 4e 44 45
     44 20 42 41 53 49
     43
2381 d11a 0d                           FCB  CR
2382 d11b 28 43 29 20 31 39            FCC  "(C) 1982 BY MICROSOFT"
     38 32 20 42 59 20
     4d 49 43 52 4f 53
     4f 46 54
2383 d130 0d 0d              LA156     FCB  CR,CR
2384 d132 00                 LA165     FCB  $00
2385                         
2386                         
2387 d133 34 16              LA35F     PSHS X,B,A          ; SAVE REGISTERS
2388 d135 9e 76                        LDX  LPTCFW         ; TAB FIELD WIDTH AND TAB ZONE
2389 d137 dc 78                        LDD  LPTWID         ; PRINTER WIDTH AND POSITION
2390 d139 9f 6a              LA37C     STX  DEVCFW         ; SAVE TAB FIELD WIDTH AND ZONE
2391 d13b d7 6c                        STB  DEVPOS         ; SAVE PRINT POSITION
2392 d13d 97 6d                        STA  DEVWID         ; SAVE PRINT WIDTH
2393 d13f 35 96                        PULS A,B,X,PC       ; RESTORE REGISTERS
2394                         
2395                         * THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASIC
2396                         * EXIT WITH BREAK KEY: CARRY = 1
2397                         * EXIT WITH ENTER KEY: CARRY = 0
2398                         LA38D
2399 d141 0f 73              LA390     CLR  IKEYIM         ; RESET BREAK CHECK KEY TEMP KEY STORAGE
2400 d143 8e 00 f4                     LDX  #LINBUF+1      ; INPUT LINE BUFFER
2401 d146 c6 01                        LDB  #1             ; ACCB CHAR COUNTER: SET TO 1 TO ALLOW A
2402                         *         BACKSPACE AS FIRST CHARACTER
2403 d148 bd d0 03           LA39A     JSR  LA171          ; GO GET A CHARACTER FROM CONSOLE IN
2404 d14b 81 08                        CMPA #BS            ; BACKSPACE
2405 d14d 26 07                        BNE  LA3B4          ; NO
2406 d14f 5a                           DECB                ; YES - DECREMENT CHAR COUNTER
2407 d150 27 ef                        BEQ  LA390          ; BRANCH IF BACK AT START OF LINE AGAIN
2408 d152 30 1f                        LEAX -1,X           ; DECREMENT BUFFER POINTER
2409 d154 20 34                        BRA  LA3E8          ; ECHO CHAR TO SCREEN
2410 d156 81 15              LA3B4     CMPA #$15           ; SHIFT RIGHT ARROW?
2411 d158 26 0a                        BNE  LA3C2          ; NO
2412                         * YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LINE
2413 d15a 5a                 LA3B8     DECB                ; DEC CHAR CTR
2414 d15b 27 e4                        BEQ  LA390          ; GO BACK TO START IF CHAR CTR = 0
2415 d15d 86 08                        LDA  #BS            ; BACKSPACE?
2416 d15f bd d0 17                     JSR  PUTCHR         ; SEND TO CONSOLE OUT (SCREEN)
2417 d162 20 f6                        BRA  LA3B8          ; KEEP GOING
2418 d164 81 03              LA3C2     CMPA #3             ; BREAK KEY?
2419 d166 1a 01                        ORCC #1             ; SET CARRY FLAG
2420 d168 27 05                        BEQ  LA3CD          ; BRANCH IF BREAK KEY DOWN
2421 d16a 81 0d              LA3C8     CMPA #CR            ; ENTER KEY?
2422 d16c 26 0d                        BNE  LA3D9          ; NO
2423 d16e 4f                 LA3CC     CLRA                ; CLEAR CARRY FLAG IF ENTER KEY - END LINE ENTRY
2424 d16f 34 01              LA3CD     PSHS CC             ; SAVE CARRY FLAG
2425 d171 bd e0 a8                     JSR  LB958          ; SEND CR TO SCREEN
2426 d174 6f 84                        CLR  ,X             ; MAKE LAST BYTE IN INPUT BUFFER = 0
2427 d176 8e 00 f3                     LDX  #LINBUF        ; RESET INPUT BUFFER POINTER
2428 d179 35 81                        PULS CC,PC          ; RESTORE CARRY FLAG
2429                         
2430                         * INSERT A CHARACTER INTO THE BASIC LINE INPUT BUFFER
2431 d17b 81 20              LA3D9     CMPA #$20           ; IS IT CONTROL CHAR?
2432 d17d 25 c9                        BLO  LA39A          ; BRANCH IF CONTROL CHARACTER
2433 d17f 81 7b                        CMPA #'z+1          ; *
2434 d181 24 c5                        BCC  LA39A          ; * IGNORE IF > LOWER CASE Z
2435 d183 c1 fa                        CMPB #LBUFMX        ; HAVE 250 OR MORE CHARACTERS BEEN ENTERED?
2436 d185 24 c1                        BCC  LA39A          ; YES, IGNORE ANY MORE
2437 d187 a7 80                        STA  ,X+            ; PUT IT IN INPUT BUFFER
2438 d189 5c                           INCB                ; INCREMENT CHARACTER COUNTER
2439 d18a bd d0 17           LA3E8     JSR  PUTCHR         ; ECHO IT TO SCREEN
2440 d18d 20 b9                        BRA  LA39A          ; GO SET SOME MORE
2441                         
2442                         
2443                         * EXEC
2444 d18f 27 05              EXEC      BEQ  LA545          ; BRANCH IF NO ARGUMENT
2445 d191 bd de c4                     JSR  LB73D          ; EVALUATE ARGUMENT - ARGUMENT RETURNED IN X
2446 d194 9f 7a                        STX  EXECJP         ; STORE X TO EXEC JUMP ADDRESS
2447 d196 6e 9f 00 7a        LA545     JMP  [EXECJP]       ; GO DO IT
2448                         
2449                         * BREAK CHECK
2450 d19a 7e d5 a6           LA549     JMP  LADEB          ; GO DO BREAK KEY CHECK
2451                         
2452                         * INKEY$
2453 d19d 96 73              INKEY     LDA  IKEYIM         ; WAS A KEY DOWN IN THE BREAK CHECK?
2454 d19f 26 03                        BNE  LA56B          ; YES
2455 d1a1 bd d0 08                     JSR  KEYIN          ; GO GET A KEY
2456 d1a4 0f 73              LA56B     CLR  IKEYIM         ; CLEAR INKEY RAM IMAGE
2457 d1a6 97 53                        STA  FPA0+3         ; STORE THE KEY IN FPA0
2458 d1a8 10 26 0c 6a                  LBNE LB68F          ; CONVERT FPA0+3 TO A STRING
2459 d1ac 97 56                        STA  STRDES         ; SET LENGTH OF STRING = 0 IF NO KEY DOWN
2460 d1ae 7e de 22                     JMP  LB69B          ; PUT A NULL STRING ONTO THE STRING STACK
2461                         
2462                         * MOVE ACCB BYTES FROM (X) TO (U)
2463 d1b1 a6 80              LA59A     LDA  ,X+            ; GET BYTE FROM X
2464 d1b3 a7 c0                        STA  ,U+            ; STORE IT AT U
2465 d1b5 5a                           DECB                ; MOVED ALL BYTES?
2466 d1b6 26 f9                        BNE  LA59A          ; NO
2467 d1b8 39                 LA5A1     RTS
2468                         
2469 d1b9 39                 LA5C4     RTS
2470                         
2471                         ** THIS ROUTINE WILL SCAN OFF THE FILE NAME FROM A BASIC LINE
2472                         ** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTERS
2473                         ** FOLLOWING THE END OF THE NAME
2474 d1ba 9d 82              LA5C7     JSR  GETCCH         ; GET CURRENT INPUT CHAR FROM BASIC LINE
2475 d1bc 27 fb              LA5C9     BEQ  LA5C4          ; RETURN IF END OF LINE
2476 d1be 7e da 03                     JMP  LB277          ; SYNTAX ERROR IF ANY MORE CHARACTERS
2477                         * IRQ SERVICE
2478                         BIRQSV
2479 d1c1 3b                 LA9C5     RTI                 ; RETURN FROM INTERRUPT
2480                         
2481                         * SET CARRY IF NUMERIC - RETURN WITH
2482                         * ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END
2483                         * OF BASIC LINE OR SUB LINE
2484 d1c2 81 3a              BROMHK    CMPA #'9+1          ; IS THIS CHARACTER >=(ASCII 9)+1?
2485 d1c4 24 0a                        BHS  LAA28          ; BRANCH IF > 9; Z SET IF = COLON
2486 d1c6 81 20                        CMPA #SPACE         ; SPACE?
2487 d1c8 26 02                        BNE  LAA24          ; NO - SET CARRY IF NUMERIC
2488 d1ca 0e 7c                        JMP  GETNCH         ; IF SPACE, GET NECT CHAR (IGNORE SPACES)
2489 d1cc 80 30              LAA24     SUBA #'0            ; * SET CARRY IF
2490 d1ce 80 d0                        SUBA #-'0           ; * CHARACTER > ASCII 0
2491 d1d0 39                 LAA28     RTS
2492                         
2493                         * DISPATCH TABLE FOR SECONDARY FUNCTIONS
2494                         * TOKENS ARE PRECEEDED BY $FF
2495                         * FIRST SET ALWAYS HAS ONE PARAMETER
2496                         FUNC_TAB
2497 d1d1 e3 c6              LAA29     FDB  SGN            ; SGN
2498 d1d3 e4 3a                        FDB  INT            ; INT
2499 d1d5 e3 df                        FDB  ABS            ; ABS
2500 d1d7 00 ad                        FDB  USRJMP         ; USR
2501 0083                    TOK_USR   EQU  *-FUNC_TAB/2+$7F
2502 ff83                    TOK_FF_USR EQU  *-FUNC_TAB/2+$FF7F
2503 d1d9 e6 6b                        FDB  RND            ; RND
2504 d1db e6 c0                        FDB  SIN            ; SIN
2505 d1dd de d7                        FDB  PEEK           ; PEEK
2506 d1df de 08                        FDB  LEN            ; LEN
2507 d1e1 dc 84                        FDB  STR            ; STR$
2508 d1e3 de 9d                        FDB  VAL            ; VAL
2509 d1e5 de 27                        FDB  ASC            ; ASC
2510 d1e7 de 13                        FDB  CHR            ; CHR$
2511 d1e9 e7 70                        FDB  ATN            ; ATN
2512 d1eb e7 38                        FDB  COS            ; COS
2513 d1ed e7 41                        FDB  TAN            ; TAN
2514 d1ef e8 b2                        FDB  EXP            ; EXP
2515 d1f1 e8 e4                        FDB  FIX            ; FIX
2516 d1f3 e8 06                        FDB  LOG            ; LOG
2517 d1f5 ea 6c                        FDB  POS            ; POS
2518 d1f7 e8 40                        FDB  SQR            ; SQR
2519 d1f9 ef 3e                        FDB  HEXDOL         ; HEX$
2520                         * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
2521 d1fb de 32                        FDB  LEFT           ; LEFT$
2522 0095                    TOK_LEFT  EQU  *-FUNC_TAB/2+$7F
2523 d1fd de 4f                        FDB  RIGHT          ; RIGHT$
2524 d1ff de 56                        FDB  MID            ; MID$
2525 0097                    TOK_MID   EQU  *-FUNC_TAB/2+$7F
2526                         * REMAINING FUNCTIONS
2527 d201 d1 9d                        FDB  INKEY          ; INKEY$
2528 0098                    TOK_INKEY EQU  *-FUNC_TAB/2+$7F
2529 d203 dc 75                        FDB  MEM            ; MEM
2530 d205 ea 74                        FDB  VARPT          ; VARPTR
2531 d207 eb 34                        FDB  INSTR          ; INSTR
2532 d209 eb 04                        FDB  STRING         ; STRING$
2533 001d                    NUM_SEC_FNS EQU  *-FUNC_TAB/2
2534                         
2535                         * THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESSES FOR ARITHMETIC
2536                         * AND LOGICAL OPERATORS - THE NEGATION OPERATORS DO NOT ACT ON TWO OPERANDS
2537                         * S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREATED SEPARATELY IN THE
2538                         * EXPRESSION EVALUATION ROUTINE. THEY ARE:
2539                         * UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGATION (NOT), PRECEDENCE $5A
2540                         * THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, PRECEDENCE $64.
2541                         * A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSION OR PARENTHESES
2542                         *
2543 d20b 79                 LAA51     FCB  $79
2544 d20c e1 11                        FDB  LB9C5          ; +
2545 d20e 79                           FCB  $79
2546 d20f e1 08                        FDB  LB9BC          ; -
2547 d211 7b                           FCB  $7B
2548 d212 e2 18                        FDB  LBACC          ; *
2549 d214 7b                           FCB  $7B
2550 d215 e2 dd                        FDB  LBB91          ; /
2551 d217 7f                           FCB  $7F
2552 d218 e8 49                        FDB  L8489          ; EXPONENTIATION
2553 d21a 50                           FCB  $50
2554 d21b da 5c                        FDB  LB2D5          ; AND
2555 d21d 46                           FCB  $46
2556 d21e da 5b                        FDB  LB2D4          ; OR
2557                         
2558                         * THIS IS THE RESERVED WORD TABLE
2559                         * FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS
2560 d220 46 4f              LAA66     FCC  "FO"           ; 80
2561 d222 d2                           FCB  $80+'R
2562 d223 47                           FCC  "G"            ; 81
2563 d224 cf                           FCB  $80+'O
2564 0081                    TOK_GO    EQU  $81
2565 d225 52 45                        FCC  "RE"           ; 82
2566 d227 cd                           FCB  $80+'M
2567 d228 a7                           FCB  ''+$80         ; 83
2568 d229 45 4c 53                     FCC  "ELS"          ; 84
2569 d22c c5                           FCB  $80+'E
2570 d22d 49                           FCC  "I"            ; 85
2571 d22e c6                           FCB  $80+'F
2572 d22f 44 41 54                     FCC  "DAT"          ; 86
2573 d232 c1                           FCB  $80+'A
2574 d233 50 52 49 4e                  FCC  "PRIN"         ; 87
2575 d237 d4                           FCB  $80+'T
2576 d238 4f                           FCC  "O"            ; 88
2577 d239 ce                           FCB  $80+'N
2578 d23a 49 4e 50 55                  FCC  "INPU"         ; 89
2579 d23e d4                           FCB  $80+'T
2580 d23f 45 4e                        FCC  "EN"           ; 8A
2581 d241 c4                           FCB  $80+'D
2582 d242 4e 45 58                     FCC  "NEX"          ; 8B
2583 d245 d4                           FCB  $80+'T
2584 d246 44 49                        FCC  "DI"           ; 8C
2585 d248 cd                           FCB  $80+'M
2586 d249 52 45 41                     FCC  "REA"          ; 8D
2587 d24c c4                           FCB  $80+'D
2588 d24d 52 55                        FCC  "RU"           ; 8E
2589 d24f ce                           FCB  $80+'N
2590 d250 52 45 53 54 4f 52            FCC  "RESTOR"       ; 8F
2591 d256 c5                           FCB  $80+'E
2592 d257 52 45 54 55 52               FCC  "RETUR"        ; 90
2593 d25c ce                           FCB  $80+'N
2594 d25d 53 54 4f                     FCC  "STO"          ; 91
2595 d260 d0                           FCB  $80+'P
2596 d261 50 4f 4b                     FCC  "POK"          ; 92
2597 d264 c5                           FCB  $80+'E
2598 d265 43 4f 4e                     FCC  "CON"          ; 93
2599 d268 d4                           FCB  $80+'T
2600 d269 4c 49 53                     FCC  "LIS"          ; 94
2601 d26c d4                           FCB  $80+'T
2602 d26d 43 4c 45 41                  FCC  "CLEA"         ; 95
2603 d271 d2                           FCB  $80+'R
2604 d272 4e 45                        FCC  "NE"           ; 96
2605 d274 d7                           FCB  $80+'W
2606 d275 45 58 45                     FCC  "EXE"          ; 97
2607 d278 c3                           FCB  $80+'C
2608 d279 54 52 4f                     FCC  "TRO"          ; 98
2609 d27c ce                           FCB  $80+'N
2610 d27d 54 52 4f 46                  FCC  "TROF"         ; 99
2611 d281 c6                           FCB  $80+'F
2612 d282 44 45                        FCC  "DE"           ; 9A
2613 d284 cc                           FCB  $80+'L
2614 d285 44 45                        FCC  "DE"           ; 9B
2615 d287 c6                           FCB  $80+'F
2616 d288 4c 49 4e                     FCC  "LIN"          ; 9C
2617 d28b c5                           FCB  $80+'E
2618 d28c 52 45 4e 55                  FCC  "RENU"         ; 9D
2619 d290 cd                           FCB  $80+'M
2620 d291 45 44 49                     FCC  "EDI"          ; 9E
2621 d294 d4                           FCB  $80+'T
2622                         * END OF EXECUTABLE COMMANDS. THE REMAINDER OF THE TABLE ARE NON-EXECUTABLE TOKENS
2623 d295 54 41 42                     FCC  "TAB"          ; 9F
2624 d298 a8                           FCB  $80+'(
2625 009f                    TOK_TAB   EQU  $9F
2626 d299 54                           FCC  "T"            ; A0
2627 d29a cf                           FCB  $80+'O
2628 00a0                    TOK_TO    EQU  $A0
2629 d29b 53 55                        FCC  "SU"           ; A1
2630 d29d c2                           FCB  $80+'B
2631 00a1                    TOK_SUB   EQU  $A1
2632 d29e 54 48 45                     FCC  "THE"          ; A2
2633 d2a1 ce                           FCB  $80+'N
2634 00a2                    TOK_THEN  EQU  $A2
2635 d2a2 4e 4f                        FCC  "NO"           ; A3
2636 d2a4 d4                           FCB  $80+'T
2637 00a3                    TOK_NOT   EQU  $A3
2638 d2a5 53 54 45                     FCC  "STE"          ; A4
2639 d2a8 d0                           FCB  $80+'P
2640 00a4                    TOK_STEP  EQU  $A4
2641 d2a9 4f 46                        FCC  "OF"           ; A5
2642 d2ab c6                           FCB  $80+'F
2643 d2ac ab                           FCB  '++$80         ; A6
2644 00a6                    TOK_PLUS  EQU  $A6
2645 d2ad ad                           FCB  '-+$80         ; A7
2646 00a7                    TOK_MINUS EQU  $A7
2647 d2ae aa                           FCB  '*+$80         ; A8
2648 d2af af                           FCB  '/+$80         ; A9
2649 d2b0 de                           FCB  '^+$80         ; AA
2650 d2b1 41 4e                        FCC  "AN"           ; AB
2651 d2b3 c4                           FCB  $80+'D
2652 d2b4 4f                           FCC  "O"            ; AC
2653 d2b5 d2                           FCB  $80+'R
2654 d2b6 be                           FCB  '>+$80         ; AD
2655 00ad                    TOK_GREATER EQU  $AD
2656 d2b7 bd                           FCB  '=+$80         ; AE
2657 00ae                    TOK_EQUALS EQU  $AE
2658 d2b8 bc                           FCB  '<+$80         ; AF
2659 d2b9 46                           FCC  "F"            ; B0
2660 d2ba ce                           FCB  $80+'N
2661 00b0                    TOK_FN    EQU  $B0
2662 d2bb 55 53 49 4e                  FCC  "USIN"         ; B1
2663 d2bf c7                           FCB  $80+'G
2664 00b1                    TOK_USING EQU  $B1
2665                         *
2666                         
2667                         * FIRST SET ALWAYS HAS ONE PARAMETER
2668 d2c0 53 47              LAB1A     FCC  "SG"           ; 80
2669 d2c2 ce                           FCB  $80+'N
2670 d2c3 49 4e                        FCC  "IN"           ; 81
2671 d2c5 d4                           FCB  $80+'T
2672 d2c6 41 42                        FCC  "AB"           ; 82
2673 d2c8 d3                           FCB  $80+'S
2674 d2c9 55 53                        FCC  "US"           ; 83
2675 d2cb d2                           FCB  $80+'R
2676 d2cc 52 4e                        FCC  "RN"           ; 84
2677 d2ce c4                           FCB  $80+'D
2678 d2cf 53 49                        FCC  "SI"           ; 85
2679 d2d1 ce                           FCB  $80+'N
2680 d2d2 50 45 45                     FCC  "PEE"          ; 86
2681 d2d5 cb                           FCB  $80+'K
2682 d2d6 4c 45                        FCC  "LE"           ; 87
2683 d2d8 ce                           FCB  $80+'N
2684 d2d9 53 54 52                     FCC  "STR"          ; 88
2685 d2dc a4                           FCB  $80+'$
2686 d2dd 56 41                        FCC  "VA"           ; 89
2687 d2df cc                           FCB  $80+'L
2688 d2e0 41 53                        FCC  "AS"           ; 8A
2689 d2e2 c3                           FCB  $80+'C
2690 d2e3 43 48 52                     FCC  "CHR"          ; 8B
2691 d2e6 a4                           FCB  $80+'$
2692 d2e7 41 54                        FCC  "AT"           ; 8C
2693 d2e9 ce                           FCB  $80+'N
2694 d2ea 43 4f                        FCC  "CO"           ; 8D
2695 d2ec d3                           FCB  $80+'S
2696 d2ed 54 41                        FCC  "TA"           ; 8E
2697 d2ef ce                           FCB  $80+'N
2698 d2f0 45 58                        FCC  "EX"           ; 8F
2699 d2f2 d0                           FCB  $80+'P
2700 d2f3 46 49                        FCC  "FI"           ; 90
2701 d2f5 d8                           FCB  $80+'X
2702 d2f6 4c 4f                        FCC  "LO"           ; 91
2703 d2f8 c7                           FCB  $80+'G
2704 d2f9 50 4f                        FCC  "PO"           ; 92
2705 d2fb d3                           FCB  $80+'S
2706 d2fc 53 51                        FCC  "SQ"           ; 93
2707 d2fe d2                           FCB  $80+'R
2708 d2ff 48 45 58                     FCC  "HEX"          ; 94
2709 d302 a4                           FCB  $80+'$
2710                         * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
2711 d303 4c 45 46 54                  FCC  "LEFT"         ; 95
2712 d307 a4                           FCB  $80+'$
2713 d308 52 49 47 48 54               FCC  "RIGHT"        ; 96
2714 d30d a4                           FCB  $80+'$
2715 d30e 4d 49 44                     FCC  "MID"          ; 97
2716 d311 a4                           FCB  $80+'$
2717                         * REMAINING FUNCTIONS
2718 d312 49 4e 4b 45 59               FCC  "INKEY"        ; 98
2719 d317 a4                           FCB  $80+'$
2720 d318 4d 45                        FCC  "ME"           ; 99
2721 d31a cd                           FCB  $80+'M
2722 d31b 56 41 52 50 54               FCC  "VARPT"        ; 9A
2723 d320 d2                           FCB  $80+'R
2724 d321 49 4e 53 54                  FCC  "INST"         ; 9B
2725 d325 d2                           FCB  $80+'R
2726 d326 53 54 52 49 4e 47            FCC  "STRING"       ; 9C
2727 d32c a4                           FCB  $80+'$
2728                         
2729                         *
2730                         * DISPATCH TABLE FOR COMMANDS TOKEN #
2731                         CMD_TAB
2732 d32d d4 eb              LAB67     FDB  FOR            ; 80
2733 d32f d6 36                        FDB  GO             ; 81
2734 d331 d6 93                        FDB  REM            ; 82
2735 0082                    TOK_REM   EQU  *-CMD_TAB/2+$7F
2736 d333 d6 93                        FDB  REM            ; 83 (')
2737 0083                    TOK_SNGL_Q EQU  *-CMD_TAB/2+$7F
2738 d335 d6 93                        FDB  REM            ; 84 (ELSE)
2739 0084                    TOK_ELSE  EQU  *-CMD_TAB/2+$7F
2740 d337 d6 c4                        FDB  IF             ; 85
2741 0085                    TOK_IF    EQU  *-CMD_TAB/2+$7F
2742 d339 d6 90                        FDB  DATA           ; 86
2743 0086                    TOK_DATA  EQU  *-CMD_TAB/2+$7F
2744 d33b e0 6d                        FDB  PRINT          ; 87
2745 0087                    TOK_PRINT EQU  *-CMD_TAB/2+$7F
2746 d33d d6 f2                        FDB  ON             ; 88
2747 d33f d7 9f                        FDB  INPUT          ; 89
2748 0089                    TOK_INPUT EQU  *-CMD_TAB/2+$7F
2749 d341 d5 bd                        FDB  END            ; 8A
2750 d343 d8 84                        FDB  NEXT           ; 8B
2751 d345 da d5                        FDB  DIM            ; 8C
2752 d347 d7 d9                        FDB  READ           ; 8D
2753 d349 d6 2b                        FDB  RUN            ; 8E
2754 d34b d5 9f                        FDB  RESTOR         ; 8F
2755 d34d d6 70                        FDB  RETURN         ; 90
2756 d34f d5 c1                        FDB  STOP           ; 91
2757 d351 de de                        FDB  POKE           ; 92
2758 d353 d5 e6                        FDB  CONT           ; 93
2759 d355 de e5                        FDB  LIST           ; 94
2760 d357 d5 f7                        FDB  CLEAR          ; 95
2761 d359 d4 bb                        FDB  NEW            ; 96
2762 d35b d1 8f                        FDB  EXEC           ; 97
2763 d35d ea 67                        FDB  TRON           ; 98
2764 d35f ea 68                        FDB  TROFF          ; 99
2765 d361 ec e3                        FDB  DEL            ; 9A
2766 d363 ec 27                        FDB  DEF            ; 9B
2767 d365 f3 d1                        FDB  LINE           ; 9C
2768 d367 ed 6d                        FDB  RENUM          ; 9D
2769 d369 e8 f3                        FDB  EDIT           ; 9E
2770 009e                    TOK_HIGH_EXEC EQU  *-CMD_TAB/2+$7F
2771                         
2772                         * ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY
2773 d36b 4e 46              LABAF     FCC  "NF"           ; 0 NEXT WITHOUT FOR
2774 d36d 53 4e                        FCC  "SN"           ; 1 SYNTAX ERROR
2775 d36f 52 47                        FCC  "RG"           ; 2 RETURN WITHOUT GOSUB
2776 d371 4f 44                        FCC  "OD"           ; 3 OUT OF DATA
2777 d373 46 43                        FCC  "FC"           ; 4 ILLEGAL FUNCTION CALL
2778 d375 4f 56                        FCC  "OV"           ; 5 OVERFLOW
2779 d377 4f 4d                        FCC  "OM"           ; 6 OUT OF MEMORY
2780 d379 55 4c                        FCC  "UL"           ; 7 UNDEFINED LINE NUMBER
2781 d37b 42 53                        FCC  "BS"           ; 8 BAD SUBSCRIPT
2782 d37d 44 44                        FCC  "DD"           ; 9 REDIMENSIONED ARRAY
2783 d37f 2f 30                        FCC  "/0"           ; 10 DIVISION BY ZERO
2784 d381 49 44                        FCC  "ID"           ; 11 ILLEGAL DIRECT STATEMENT
2785 d383 54 4d                        FCC  "TM"           ; 12 TYPE MISMATCH
2786 d385 4f 53                        FCC  "OS"           ; 13 OUT OF STRING SPACE
2787 d387 4c 53                        FCC  "LS"           ; 14 STRING TOO LONG
2788 d389 53 54                        FCC  "ST"           ; 15 STRING FORMULA TOO COMPLEX
2789 d38b 43 4e                        FCC  "CN"           ; 16 CAN'T CONTINUE
2790 d38d 46 44                        FCC  "FD"           ; 17 BAD FILE DATA
2791 d38f 41 4f                        FCC  "AO"           ; 18 FILE ALREADY OPEN
2792 d391 44 4e                        FCC  "DN"           ; 19 DEVICE NUMBER ERROR
2793 d393 49 4f                        FCC  "IO"           ; 20 I/O ERROR
2794 d395 46 4d                        FCC  "FM"           ; 21 BAD FILE MODE
2795 d397 4e 4f                        FCC  "NO"           ; 22 FILE NOT OPEN
2796 d399 49 45                        FCC  "IE"           ; 23 INPUT PAST END OF FILE
2797 d39b 44 53                        FCC  "DS"           ; 24 DIRECT STATEMENT IN FILE
2798                         * ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC
2799 d39d 55 46              L890B     FCC  "UF"           ; 25 UNDEFINED FUNCTION (FN) CALL
2800 d39f 4e 45              L890D     FCC  "NE"           ; 26 FILE NOT FOUND
2801                         
2802 d3a1 20 45 52 52 4f 52  LABE1     FCC  " ERROR"
2803 d3a7 00                           FCB  $00
2804 d3a8 20 49 4e 20        LABE8     FCC  " IN "
2805 d3ac 00                           FCB  $00
2806 d3ad 0d                 LABED     FCB  CR
2807 d3ae 4f 4b              LABEE     FCC  "OK"
2808 d3b0 0d 00                        FCB  CR,$00
2809 d3b2 0d                 LABF2     FCB  CR
2810 d3b3 42 52 45 41 4b               FCC  "BREAK"
2811 d3b8 00                           FCB  $00
2812                         
2813                         * SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DATA.
2814                         * THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEING
2815                         * SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT DATA IS 18
2816                         * BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DATA IS 5 BYTES
2817                         * WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DATA
2818                         * IS CONSIDERED 'GOSUB/RETURN'
2819 d3b9 30 64              LABF9     LEAX 4,S            ; POINT X TO 3RD ADDRESS ON STACK - IGNORE THE
2820                         *         FIRST TWO RETURN ADDRESSES ON THE STACK
2821 d3bb c6 12              LABFB     LDB  #18            ; 18 BYTES SAVED ON STACK FOR EACH 'FOR' LOOP
2822 d3bd 9f 0f                        STX  TEMPTR         ; SAVE POINTER
2823 d3bf a6 84                        LDA  ,X             ; GET 1ST BYTE
2824 d3c1 80 80                        SUBA #$80           ; * CHECK FOR TYPE OF STACK JUMP FOUND
2825 d3c3 26 15                        BNE  LAC1A          ; * BRANCH IF NOT 'FOR/NEXT'
2826 d3c5 ae 01                        LDX  1,X            ; = GET INDEX VARIABLE DESCRIPTOR
2827 d3c7 9f 11                        STX  TMPTR1         ; = POINTER AND SAVE IT IN TMPTR1
2828 d3c9 9e 3b                        LDX  VARDES         ; GET INDEX VARIABLE BEING SEARCHED FOR
2829 d3cb 27 09                        BEQ  LAC16          ; BRANCH IF DEFAULT INDEX VARIABLE - USE THE
2830                         *                             ; FIRST 'FOR/NEXT' DATA FOUND ON STACK
2831                         *                             ; IF NO INDEX VARIABLE AFTER 'NEXT'
2832 d3cd 9c 11                        CMPX TMPTR1         ; DOES THE STACK INDEX MATCH THE ONE
2833                         *                             ; BEING SEARCHED FOR?
2834 d3cf 27 09                        BEQ  LAC1A          ; YES
2835 d3d1 9e 0f                        LDX  TEMPTR         ; * RESTORE INITIAL POINTER, ADD
2836 d3d3 3a                           ABX                 ; * 18 TO IT AND LOOK FOR
2837 d3d4 20 e5                        BRA  LABFB          ; * NEXT BLOCK OF DATA
2838 d3d6 9e 11              LAC16     LDX  TMPTR1         ; = GET 1ST INDEX VARIABLE FOUND AND
2839 d3d8 9f 3b                        STX  VARDES         ; = SAVE AS 'NEXT' INDEX
2840 d3da 9e 0f              LAC1A     LDX  TEMPTR         ; POINT X TO START OF 'FOR/NEXT' DATA
2841 d3dc 4d                           TSTA                ; SET ZERO FLAG IF 'FOR/NEXT' DATA
2842 d3dd 39                           RTS
2843                         * CHECK FOR MEMORY SPACE FOR NEW TOP OF
2844                         * ARRAYS AND MOVE ARRAYS TO NEW LOCATION
2845 d3de 8d 17              LAC1E     BSR  LAC37          ; ACCD = NEW BOTTOM OF FREE RAM - IS THERE
2846                         *                             ; ROOM FOR THE STACK?
2847                         * MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND
2848                         * SAVE FINAL VALUE OF U IN V45
2849 d3e0 de 41              LAC20     LDU  V41            ; POINT U TO DESTINATION ADDRESS (V41)
2850 d3e2 33 41                        LEAU 1,U            ; ADD ONE TO U - COMPENSATE FOR FIRST PSHU
2851 d3e4 9e 43                        LDX  V43            ; POINT X TO SOURCE ADDRESS (V43)
2852 d3e6 30 01                        LEAX 1,X            ; ADD ONE - COMPENSATE FOR FIRST LDA ,X
2853 d3e8 a6 82              LAC28     LDA  ,-X            ; GRAB A BYTE FROM SOURCE
2854 d3ea 36 02                        PSHU A              ; MOVE IT TO DESTINATION
2855 d3ec 9c 47                        CMPX V47            ; DONE?
2856 d3ee 26 f8                        BNE  LAC28          ; NO - KEEP MOVING BYTES
2857 d3f0 df 45                        STU  V45            ; SAVE FINAL DESTINATION ADDRESS
2858 d3f2 39                 LAC32     RTS
2859                         * CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB
2860                         * BYTES IN FREE RAM - OM ERROR IF NOT
2861 d3f3 4f                 LAC33     CLRA                ; * ACCD CONTAINS NUMBER OF EXTRA
2862 d3f4 58                           ASLB                ; * BYTES TO PUT ON STACK
2863 d3f5 d3 1f                        ADDD ARYEND         ; END OF PROGRAM AND VARIABLES
2864 d3f7 c3 00 3a           LAC37     ADDD #STKBUF        ; ADD STACK BUFFER - ROOM FOR STACK?
2865 d3fa 25 08                        BCS  LAC44          ; BRANCH IF GREATER THAN $FFFF
2866 d3fc 10 df 17                     STS  BOTSTK         ; CURRENT NEW BOTTOM OF STACK STACK POINTER
2867 d3ff 10 93 17                     CMPD BOTSTK         ; ARE WE GOING TO BE BELOW STACK?
2868 d402 25 ee                        BCS  LAC32          ; YES - NO ERROR
2869 d404 c6 0c              LAC44     LDB  #6*2           ; OUT OF MEMORY ERROR
2870                         
2871                         * ERROR SERVICING ROUTINE
2872 d406 bd d4 d7           LAC46     JSR  LAD33          ; RESET STACK, STRING STACK, CONTINUE POINTER
2873 d409 bd e0 ac                     JSR  LB95C          ; SEND A CR TO SCREEN
2874 d40c bd e0 fb                     JSR  LB9AF          ; SEND A '?' TO SCREEN
2875 d40f 8e d3 6b                     LDX  #LABAF         ; POINT TO ERROR TABLE
2876 d412 3a                 LAC60     ABX                 ; ADD MESSAGE NUMBER OFFSET
2877 d413 8d 31                        BSR  LACA0          ; * GET TWO CHARACTERS FROM X AND
2878 d415 8d 2f                        BSR  LACA0          ; * SEND TO CONSOLE OUT (SCREEN)
2879 d417 8e d3 a0                     LDX  #LABE1-1       ; POINT TO "ERROR" MESSAGE
2880 d41a bd e0 e8           LAC68     JSR  LB99C          ; PRINT MESSAGE POINTED TO BY X
2881 d41d 96 68                        LDA  CURLIN         ; GET CURRENT LINE NUMBER (CURL IN)
2882 d41f 4c                           INCA                ; TEST FOR DIRECT MODE
2883 d420 27 03                        BEQ  LAC73          ; BRANCH IF DIRECT MODE
2884 d422 bd e5 11                     JSR  LBDC5          ; PRINT 'IN ****'
2885                         
2886                         * THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE
2887 d425 bd e0 ac           LAC73     JSR  LB95C          ; MOVE CURSOR TO START OF LINE
2888 d428 8e d3 ad                     LDX  #LABED         ; POINT X TO 'OK', CR MESSAGE
2889 d42b bd e0 e8                     JSR  LB99C          ; PRINT 'OK', CR
2890 d42e bd d1 41           LAC7C     JSR  LA390          ; GO GET AN INPUT LINE
2891 d431 ce ff ff                     LDU  #$FFFF         ; THE LINE NUMBER FOR DIRECT MODE IS $FFFF
2892 d434 df 68                        STU  CURLIN         ; SAVE IT IN CURLIN
2893 d436 25 f6                        BCS  LAC7C          ; BRANCH IF LINE INPUT TERMINATED BY BREAK
2894 d438 9f 83                        STX  CHARAD         ; SAVE (X) AS CURRENT INPUT POINTER - THIS WILL
2895                         *         ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. THE
2896                         *         LINE JUST ENTERED WILL BE INTERPRETED
2897 d43a 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
2898 d43c 27 f0                        BEQ  LAC7C          ; NO LINE INPUT - GET ANOTHER LINE
2899 d43e 25 0b                        BCS  LACA5          ; BRANCH IF NUMER1C - THERE WAS A LINE NUMBER BEFORE
2900                         *         THE  STATEMENT ENTERED, SO THIS STATEMENT
2901                         *         WILL BE MERGED INTO THE BASIC PROGRAM
2902 d440 bd df 9a                     JSR  LB821          ; GO CRUNCH LINE
2903 d443 7e d5 74                     JMP  LADC0          ; GO EXECUTE THE STATEMENT (LIVE KEYBOARD)
2904                         *
2905 d446 a6 80              LACA0     LDA  ,X+            ; GET A CHARACTER
2906 d448 7e e0 fd                     JMP  LB9B1          ; SEND TO CONSOLE OUT
2907                         * TAKE A LINE FROM THE LINE INPUT BUFFER
2908                         * AND INSERT IT INTO THE BASIC PROGRAM
2909 d44b bd d7 17           LACA5     JSR  LAF67          ; CONVERT LINE NUMBER TO BINARY
2910 d44e 9e 2b              LACA8     LDX  BINVAL         ; GET CONVERTED LINE NUMBER
2911 d450 9f f1                        STX  LINHDR         ; STORE IT IN LINE INPUT HEADER
2912 d452 bd df 9a                     JSR  LB821          ; GO CRUNCH THE LINE
2913 d455 d7 03                        STB  TMPLOC         ; SAVE LINE LENGTH
2914 d457 8d 4c                        BSR  LAD01          ; FIND OUT WHERE TO INSERT LINE
2915 d459 25 12                        BCS  LACC8          ; RANCH IF LINE NUMBER DOES NOT ALREADY EXIST
2916 d45b dc 47                        LDD  V47            ; GET ABSOLUTE ADDRESS OF LINE NUMBER
2917 d45d a3 84                        SUBD ,X             ; SUBTRACT ADDRESS OF NEXT LINE NUMBER
2918 d45f d3 1b                        ADDD VARTAB         ; * ADD TO CURRENT END OF PROGRAM - THIS WILL REMOVE
2919 d461 dd 1b                        STD  VARTAB         ; * THE LENGTH OF THIS LINE NUMBER FROM THE PROGRAM
2920 d463 ee 84                        LDU  ,X             ; POINT U TO ADDRESS OF NEXT LINE NUMBER
2921                         * DELETE OLD LINE FROM BASIC PROGRAM
2922 d465 37 02              LACC0     PULU A              ; GET A BYTE FROM WHAT'S LEFT OF PROGRAM
2923 d467 a7 80                        STA  ,X+            ; MOVE IT DOWN
2924 d469 9c 1b                        CMPX VARTAB         ; COMPARE TO END OF BASIC PROGRAM
2925 d46b 26 f8                        BNE  LACC0          ; BRANCH IF NOT AT END
2926 d46d 96 f3              LACC8     LDA  LINBUF         ; * CHECK TO SEE IF THERE IS A LINE IN
2927 d46f 27 1c                        BEQ  LACE9          ; * THE BUFFER AND BRANCH IF NONE
2928 d471 dc 1b                        LDD  VARTAB         ; = SAVE CURRENT END OF
2929 d473 dd 43                        STD  V43            ; = PROGRAM IN V43
2930 d475 db 03                        ADDB TMPLOC         ; * ADD LENGTH OF CRUNCHED LINE,
2931 d477 89 00                        ADCA #0             ; * PROPOGATE CARRY AND SAVE NEW END
2932 d479 dd 41                        STD  V41            ; * OF PROGRAM IN V41
2933 d47b bd d3 de                     JSR  LAC1E          ; = MAKE SURE THERE'S ENOUGH RAM FOR THIS
2934                         *         =    LINE & MAKE A HOLE IN BASIC FOR NEW LINE
2935 d47e ce 00 ef                     LDU  #LINHDR-2      ; POINT U TO LINE TO BE INSERTED
2936 d481 37 02              LACDD     PULU A              ; GET A BYTE FROM NEW LINE
2937 d483 a7 80                        STA  ,X+            ; INSERT IT IN PROGRAM
2938 d485 9c 45                        CMPX V45            ; * COMPARE TO ADDRESS OF END OF INSERTED
2939 d487 26 f8                        BNE  LACDD          ; * LINE AND BRANCH IF NOT DONE
2940 d489 9e 41                        LDX  V41            ; = GET AND SAVE
2941 d48b 9f 1b                        STX  VARTAB         ; = END OF PROGRAM
2942 d48d 8d 36              LACE9     BSR  LAD21          ; RESET INPUT POINTER, CLEAR VARIABLES, INITIALIZE
2943 d48f 8d 02                        BSR  LACEF          ; ADJUST START OF NEXT LINE ADDRESSES
2944 d491 20 9b                        BRA  LAC7C          ; EENTER BASIC'S INPUT LOOP
2945                         * COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BASIC PROGRAM
2946 d493 9e 19              LACEF     LDX  TXTTAB         ; POINT X TO START OF PROGRAM
2947 d495 ec 84              LACF1     LDD  ,X             ; GET ADDRESS OF NEXT LINE
2948 d497 27 21                        BEQ  LAD16          ; RETURN IF END OF PROGRAM
2949 d499 33 04                        LEAU 4,X            ; POINT U TO START OF BASIC TEXT IN LINE
2950 d49b a6 c0              LACF7     LDA  ,U+            ; * SKIP THROUGH THE LINE UNTIL A
2951 d49d 26 fc                        BNE  LACF7          ; * ZERO (END OF LINE) IS FOUND
2952 d49f ef 84                        STU  ,X             ; SAVE THE NEW START OF NEXT LINE ADDRESS
2953 d4a1 ae 84                        LDX  ,X             ; POINT X TO START OF NEXT LINE
2954 d4a3 20 f0                        BRA  LACF1          ; KEEP GOING
2955                         *
2956                         * FIND A LINE NUMBER IN THE BASIC PROGRAM
2957                         * RETURN WITH CARRY SET IF NO MATCH FOUND
2958 d4a5 dc 2b              LAD01     LDD  BINVAL         ; GET THE LINE NUMBER TO FIND
2959 d4a7 9e 19                        LDX  TXTTAB         ; BEGINNING OF PROGRAM
2960 d4a9 ee 84              LAD05     LDU  ,X             ; GET ADDRESS OF NEXT LINE NUMBER
2961 d4ab 27 09                        BEQ  LAD12          ; BRANCH IF END OF PROG
2962 d4ad 10 a3 02                     CMPD 2,X            ; IS IT A MATCH?
2963 d4b0 23 06                        BLS  LAD14          ; CARRY SET IF LOWER; CARRY CLEAR IF MATCH
2964 d4b2 ae 84                        LDX  ,X             ; X = ADDRESS OF NEXT LINE
2965 d4b4 20 f3                        BRA  LAD05          ; KEEP LOOPING FOR LINE NUMBER
2966 d4b6 1a 01              LAD12     ORCC #1             ; SET CARRY FLAG
2967 d4b8 9f 47              LAD14     STX  V47            ; SAVE MATCH LINE NUMBER OR NUMBER OF LINE JUST AFTER
2968                         *                             ; WHERE IT SHOULD HAVE BEEN
2969 d4ba 39                 LAD16     RTS
2970                         
2971                         * NEW
2972 d4bb 26 fb              NEW       BNE  LAD14          ; BRANCH IF ARGUMENT GIVEN
2973 d4bd 9e 19              LAD19     LDX  TXTTAB         ; GET START OF BASIC
2974 d4bf 6f 80                        CLR  ,X+            ; * PUT 2 ZERO BYTES THERE - ERASE
2975 d4c1 6f 80                        CLR  ,X+            ; * THE BASIC PROGRAM
2976 d4c3 9f 1b                        STX  VARTAB         ; AND THE NEXT ADDRESS IS NOW THE END OF PROGRAM
2977 d4c5 9e 19              LAD21     LDX  TXTTAB         ; GET START OF BASIC
2978 d4c7 bd d6 6b                     JSR  LAEBB          ; PUT INPUT POINTER ONE BEFORE START OF BASIC
2979                         * ERASE ALL VARIABLES
2980 d4ca 9e 27              LAD26     LDX  MEMSIZ         ; * RESET START OF STRING VARIABLES
2981 d4cc 9f 23                        STX  STRTAB         ; * TO TOP OF STRING SPACE
2982 d4ce bd d5 9f                     JSR  RESTOR         ; RESET 'DATA' POINTER TO START OF BASIC
2983 d4d1 9e 1b                        LDX  VARTAB         ; * GET START OF VARIABLES AND USE IT
2984 d4d3 9f 1d                        STX  ARYTAB         ; * TO RESET START OF ARRAYS
2985 d4d5 9f 1f                        STX  ARYEND         ; RESET END OF ARRAYS
2986 d4d7 8e 00 c9           LAD33     LDX  #STRSTK        ; * RESET STRING STACK POINTER TO
2987 d4da 9f 0b                        STX  TEMPPT         ; * BOTTOM OF STRING STACK
2988 d4dc ae e4                        LDX  ,S             ; GET RETURN ADDRESS OFF STACK
2989 d4de 10 de 21                     LDS  FRETOP         ; RESTORE STACK POINTER
2990 d4e1 6f e2                        CLR  ,-S            ; PUT A ZERO BYTE ON STACK - TO CLEAR ANY RETURN OF
2991                         *                             ; FOR/NEXT DATA FROM THE STACK
2992 d4e3 0f 2d                        CLR  OLDPTR         ; RESET 'CONT' ADDRESS SO YOU
2993 d4e5 0f 2e                        CLR  OLDPTR+1       ; 'CAN'T CONTINUE'
2994 d4e7 0f 08                        CLR  ARYDIS         ; CLEAR THE ARRAY DISABLE FLAG
2995 d4e9 6e 84                        JMP  ,X             ; RETURN TO CALLING ROUTINE - THIS IS NECESSARY
2996                         *                             ; SINCE THE STACK WAS RESET
2997                         *
2998                         * FOR
2999                         *
3000                         * THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR
3001                         * EACH FOR-NEXT LOOP WHICH IS BEING PROCESSED. THESE
3002                         * BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);
3003                         *         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=FP VALUE OF STEP;
3004                         *         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO; 1 IF POSITIVE;
3005                         * 9-13=FP VALUE OF 'TO' PARAMETER;
3006                         * 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE END
3007                         *         OF   THE LINE CONTAINING THE 'FOR' STATEMENT
3008 d4eb 86 80              FOR       LDA  #$80           ; * SAVE THE DISABLE ARRAY FLAG IN VO8
3009 d4ed 97 08                        STA  ARYDIS         ; * DO NOT ALLOW THE INDEX VARIABLE TO BE AN ARRAY
3010 d4ef bd d7 39                     JSR  LET            ; SET INDEX VARIABLE TO INITIAL VALUE
3011 d4f2 bd d3 b9                     JSR  LABF9          ; SEARCH THE STACK FOR 'FOR/NEXT' DATA
3012 d4f5 32 62                        LEAS 2,S            ; PURGE RETURN ADDRESS OFF OF THE STACK
3013 d4f7 26 04                        BNE  LAD59          ; BRANCH IF INDEX VARIABLE NOT ALREADY BEING USED
3014 d4f9 9e 0f                        LDX  TEMPTR         ; GET (ADDRESS + 18) OF MATCHED 'FOR/NEXT' DATA
3015 d4fb 32 85                        LEAS B,X            ; MOVE THE STACK POINTER TO THE BEGINNING OF THE
3016                         * MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
3017                         * OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY
3018                         * ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
3019                         * THIS POINT ON THE STACK
3020 d4fd c6 09              LAD59     LDB  #$09           ; * CHECK FOR ROOM FOR 18 BYTES
3021 d4ff bd d3 f3                     JSR  LAC33          ; * IN FREE RAM
3022 d502 bd d6 98                     JSR  LAEE8          ; GET ADDR OF END OF SUBLINE IN X
3023 d505 dc 68                        LDD  CURLIN         ; GET CURRENT LINE NUMBER
3024 d507 34 16                        PSHS X,B,A          ; SAVE LINE ADDR AND LINE NUMBER ON STACK
3025 d509 c6 a0                        LDB  #TOK_TO        ; TOKEN FOR 'TO'
3026 d50b bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR 'TO'
3027 d50e bd d8 cf                     JSR  LB143          ; 'TM' ERROR IF INDEX VARIABLE SET TO STRING
3028 d511 bd d8 cd                     JSR  LB141          ; EVALUATE EXPRESSION
3029                         *
3030 d514 d6 54                        LDB  FP0SGN         ; GET FPA0 MANTISSA SIGN
3031 d516 ca 7f                        ORB  #$7F           ; FORM A MASK TO SAVE DATA BITS OF HIGH ORDER MANTISSA
3032 d518 d4 50                        ANDB FPA0           ; PUT THE MANTISSA SIGN IN BIT 7 OF HIGH ORDER MANTISSA
3033 d51a d7 50                        STB  FPA0           ; SAVE THE PACKED HIGH ORDER MANTISSA
3034 d51c 10 8e d5 23                  LDY  #LAD7F         ; LOAD FOLLOWING ADDRESS INTO Y AS A RETURN
3035 d520 7e d9 76                     JMP  LB1EA          ; ADDRESS - PUSH FPA0 ONTO THE STACK
3036 d523 8e e2 11           LAD7F     LDX  #LBAC5         ; POINT X TO FLOATING POINT NUMBER 1.0 (DEFAULT STEP VALUE)
3037 d526 bd e3 60                     JSR  LBC14          ; MOVE (X) TO FPA0
3038 d529 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3039 d52b 81 a4                        CMPA #TOK_STEP      ; STEP TOKEN
3040 d52d 26 05                        BNE  LAD90          ; BRANCH IF NO 'STEP' VALUE
3041 d52f 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3042 d531 bd d8 cd                     JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
3043 d534 bd e3 b9           LAD90     JSR  LBC6D          ; CHECK STATUS OF FPA0
3044 d537 bd d9 72                     JSR  LB1E6          ; SAVE STATUS AND FPA0 ON THE STACK
3045 d53a dc 3b                        LDD  VARDES         ; * GET DESCRIPTOR POINTER FOR THE 'STEP'
3046 d53c 34 06                        PSHS B,A            ; * VARIABLE AND SAVE IT ON THE STACK
3047 d53e 86 80                        LDA  #$80           ; = GET THE 'FOR' FLAG AND
3048 d540 34 02                        PSHS A              ; = SAVE IT ON THE STACK
3049                         *
3050                         * MAIN COMMAND INTERPRETATION LOOP
3051 d542 1c af              LAD9E     ANDCC #$AF          ; ENABLE IRQ,FIRQ
3052 d544 8d 60                        BSR  LADEB          ; CHECK FOR KEYBOARD BREAK
3053 d546 9e 83                        LDX  CHARAD         ; GET BASIC'S INPUT POINTER
3054 d548 9f 2f                        STX  TINPTR         ; SAVE IT
3055 d54a a6 80                        LDA  ,X+            ; GET CURRENT INPUT CHAR & MOVE POINTER
3056 d54c 27 07                        BEQ  LADB4          ; BRANCH IF END OF LINE
3057 d54e 81 3a                        CMPA #':            ; CHECK FOR LINE SEPARATOR
3058 d550 27 22                        BEQ  LADC0          ; BRANCH IF COLON
3059 d552 7e da 03           LADB1     JMP  LB277          ; 'SYNTAX ERROR'-IF NOT LINE SEPARATOR
3060 d555 a6 81              LADB4     LDA  ,X++           ; GET MS BYTE OF ADDRESS OF NEXT BASIC LINE
3061 d557 97 00                        STA  ENDFLG         ; SAVE IN STOP/END FLAG - CAUSE A STOP IF
3062                         *                             ; NEXT LINE ADDRESS IS < $8000; CAUSE
3063                         *                             ; AN END IF ADDRESS > $8000
3064 d559 27 72                        BEQ  LAE15          ; BRANCH TO 'STOP' - END OF PROGRAM
3065 d55b ec 80                        LDD  ,X+            ; GET CURRENT LINE NUMBER
3066 d55d dd 68                        STD  CURLIN         ; SAVE IN CURLIN
3067 d55f 9f 83                        STX  CHARAD         ; SAVE ADDRESS OF FIRST BYTE OF LINE
3068                         * EXTENDED BASIC TRACE
3069 d561 96 8c                        LDA  TRCFLG         ; TEST THE TRACE FLAG
3070 d563 27 0f                        BEQ  LADC0          ; BRANCH IF TRACE OFF
3071 d565 86 5b                        LDA  #$5B           ; <LEFT HAND MARKER FOR TRON LINE NUMBER
3072 d567 bd d0 17                     JSR  PUTCHR         ; OUTPUT A CHARACTER
3073 d56a 96 68                        LDA  CURLIN         ; GET MS BYTE OF LINE NUMBER
3074 d56c bd e5 18                     JSR  LBDCC          ; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN
3075 d56f 86 5d                        LDA  #$5D           ; > RIGHT HAND MARKER FOR TRON LINE NUMBER
3076 d571 bd d0 17                     JSR  PUTCHR         ; OUTPUT A CHARACTER
3077                         * END OF EXTENDED BASIC TRACE
3078 d574 9d 7c              LADC0     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3079 d576 8d 02                        BSR  LADC6          ; GO PROCESS COMMAND
3080 d578 20 c8                        BRA  LAD9E          ; GO BACK TO MAIN LOOP
3081 d57a 27 29              LADC6     BEQ  LADEA          ; RETURN IF END OF LINE (RTS - was BEQ LAE40)
3082 d57c 4d                           TSTA                ; CHECK FOR TOKEN - BIT 7 SET (NEGATIVE)
3083 d57d 10 2a 01 b8                  LBPL LET            ; BRANCH IF NOT A TOKEN - GO DO A 'LET' WHICH
3084                         *                             ; IS THE 'DEFAULT' TOKEN FOR MICROSOFT BASIC
3085 d581 81 ff                        CMPA #$FF           ; SECONDARY TOKEN
3086 d583 27 0f                        BEQ  SECTOK
3087 d585 81 9e                        CMPA #TOK_HIGH_EXEC ; SKIPF TOKEN - HIGHEST EXECUTABLE COMMAND IN BASIC
3088 d587 22 c9                        BHI  LADB1          ; 'SYNTAX ERROR' IF NON-EXECUTABLE TOKEN
3089 d589 be d0 f4                     LDX  COMVEC+3       ; GET ADDRESS OF BASIC'S COMMAND TABLE
3090 d58c 48                 LADD4     ASLA                ; X2 (2 BYTE/JUMP ADDRESS) & DISCARD BIT 7
3091 d58d 1f 89                        TFR  A,B            ; SAVE COMMAND OFFSET IN ACCB
3092 d58f 3a                           ABX                 ; NON X POINTS TO COMMAND JUMP ADDR
3093 d590 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
3094                         *
3095                         * HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
3096 d592 6e 94                        JMP  [,X]           ; GO DO A COMMAND
3097                         SECTOK
3098                         * THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTABLE IS
3099                         * THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHECK DONE HERE
3100 d594 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
3101 d596 81 97                        CMPA #TOK_MID       ; TOKEN FOR "MID$"
3102 d598 10 27 14 f0                  LBEQ L86D6          ; PROCESS MID$ REPLACEMENT
3103 d59c 7e da 03                     JMP  LB277          ; SYNTAX ERROR
3104                         
3105                         *
3106                         * RESTORE
3107 d59f 9e 19              RESTOR    LDX  TXTTAB         ; BEGINNING OF PROGRAM ADDRESS
3108 d5a1 30 1f                        LEAX -1,X           ; MOVE TO ONE BYTE BEFORE PROGRAM
3109 d5a3 9f 33              LADE8     STX  DATPTR         ; SAVE NEW DATA POINTER
3110 d5a5 39                 LADEA     RTS
3111                         *
3112                         * BREAK CHECK
3113 d5a6 bd d0 08           LADEB     JSR  LA1C1          ; GET A KEYSTROKE ENTRY
3114 d5a9 27 0a                        BEQ  LADFA          ; RETURN IF NO INPUT
3115 d5ab 81 03              LADF0     CMPA #3             ; CONTROL C? (BREAK)
3116 d5ad 27 12                        BEQ  STOP           ; YES
3117 d5af 81 13                        CMPA #$13           ; CONTROL S? (PAUSE)
3118 d5b1 27 03                        BEQ  LADFB          ; YES
3119 d5b3 97 73                        STA  IKEYIM         ; SAVE KEYSTROKE IN INKEY IMAGE
3120 d5b5 39                 LADFA     RTS
3121 d5b6 bd d0 08           LADFB     JSR  KEYIN          ; GET A KEY
3122 d5b9 27 fb                        BEQ  LADFB          ; BRANCH IF NO KEY DOWN
3123 d5bb 20 ee                        BRA  LADF0          ; CONTINUE - DO A BREAK CHECK
3124                         *
3125                         * END
3126 d5bd 9d 82              END       JSR  GETCCH         ; GET CURRENT INPUT CHAR
3127 d5bf 20 02                        BRA  LAE0B
3128                         *
3129                         * STOP
3130 d5c1 1a 01              STOP      ORCC #$01           ; SET CARRY FLAG
3131 d5c3 26 31              LAE0B     BNE  LAE40          ; BRANCH IF ARGUMENT EXISTS
3132 d5c5 9e 83                        LDX  CHARAD         ; * SAVE CURRENT POSITION OF
3133 d5c7 9f 2f                        STX  TINPTR         ; * BASIC'S INPUT POINTER
3134 d5c9 06 00              LAE11     ROR  ENDFLG         ; ROTATE CARRY INTO BIT 7 OF STOP/END FLAG
3135 d5cb 32 62                        LEAS 2,S            ; PURGE RETURN ADDRESS OFF STACK
3136 d5cd 9e 68              LAE15     LDX  CURLIN         ; GET CURRENT LINE NUMBER
3137 d5cf 8c ff ff                     CMPX #$FFFF         ; DIRECT MODE?
3138 d5d2 27 06                        BEQ  LAE22          ; YES
3139 d5d4 9f 29                        STX  OLDTXT         ; SAVE CURRENT LINE NUMBER
3140 d5d6 9e 2f                        LDX  TINPTR         ; * GET AND SAVE CURRENT POSITION
3141 d5d8 9f 2d                        STX  OLDPTR         ; * OF BASIC'S INPUT POINTER
3142                         LAE22
3143 d5da 8e d3 b1                     LDX  #LABF2-1       ; POINT TO CR, 'BREAK' MESSAGE
3144 d5dd 0d 00                        TST  ENDFLG         ; CHECK STOP/END FLAG
3145 d5df 10 2a fe 42                  LBPL LAC73          ; BRANCH TO MAIN LOOP OF BASIC IF END
3146 d5e3 7e d4 1a                     JMP  LAC68          ; PRINT 'BREAK AT ####' AND GO TO
3147                         *                             ; BASIC'S MAIN LOOP IF 'STOP'
3148                         
3149                         * CONT
3150 d5e6 26 0e              CONT      BNE  LAE40          ; RETURN IF ARGUMENT GIVEN
3151 d5e8 c6 20                        LDB  #2*16          ; 'CAN'T CONTINUE' ERROR
3152 d5ea 9e 2d                        LDX  OLDPTR         ; GET CONTINUE ADDRESS (INPUT POINTER)
3153 d5ec 10 27 fe 16                  LBEQ LAC46          ; 'CN' ERROR IF CONTINUE ADDRESS = 0
3154 d5f0 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3155 d5f2 9e 29                        LDX  OLDTXT         ; GET LINE NUMBER
3156 d5f4 9f 68                        STX  CURLIN         ; RESET CURRENT LINE NUMBER
3157 d5f6 39                 LAE40     RTS
3158                         *
3159                         * CLEAR
3160 d5f7 27 2c              CLEAR     BEQ  LAE6F          ; BRANCH IF NO ARGUMENT
3161 d5f9 bd db 6d                     JSR  LB3E6          ; EVALUATE ARGUMENT
3162 d5fc 34 06                        PSHS B,A            ; SAVE AMOUNT OF STRING SPACE ON STACK
3163 d5fe 9e 27                        LDX  MEMSIZ         ; GET CURRENT TOP OF CLEARED SPACE
3164 d600 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3165 d602 27 0c                        BEQ  LAE5A          ; BRANCH IF NO NEW TOP OF CLEARED SPACE
3166 d604 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
3167 d607 bd de c4                     JSR  LB73D          ; EVALUATE EXPRESSlON; RETURN VALUE IN X
3168 d60a 30 1f                        LEAX -1,X           ; X = TOP OF CLEARED SPACE
3169 d60c 9c 71                        CMPX TOPRAM         ; COMPARE TO TOP OF RAM
3170 d60e 22 18                        BHI  LAE72          ; 'OM' ERROR IF > TOP OF RAM
3171 d610 1f 10              LAE5A     TFR  X,D            ; ACCD = TOP OF CLEARED SPACE
3172 d612 a3 e1                        SUBD ,S++           ; SUBTRACT OUT AMOUNT OF CLEARED SPACE
3173 d614 25 12                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
3174 d616 1f 03                        TFR  D,U            ; U = BOTTOM OF CLEARED SPACE
3175 d618 83 00 3a                     SUBD #STKBUF        ; SUBTRACT OUT STACK BUFFER
3176 d61b 25 0b                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
3177 d61d 93 1b                        SUBD VARTAB         ; SUBTRACT OUT START OF VARIABLES
3178 d61f 25 07                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
3179 d621 df 21                        STU  FRETOP         ; SAVE NEW BOTTOM OF CLEARED SPACE
3180 d623 9f 27                        STX  MEMSIZ         ; SAVE NEW TOP OF CLEARED SPACE
3181 d625 7e d4 ca           LAE6F     JMP  LAD26          ; ERASE ALL VARIABLES, INITIALIZE POINTERS, ETC
3182 d628 7e d4 04           LAE72     JMP  LAC44          ; 'OM' ERROR
3183                         *
3184                         * RUN
3185 d62b 9d 82              RUN       JSR  GETCCH         ; * GET CURRENT INPUT CHARACTER
3186 d62d 10 27 fe 94                  LBEQ LAD21          ; * IF NO LINE NUMBER
3187 d631 bd d4 ca                     JSR  LAD26          ; ERASE ALL VARIABLES
3188 d634 20 19                        BRA  LAE9F          ; 'GOTO' THE RUN ADDRESS
3189                         *
3190                         * GO
3191 d636 1f 89              GO        TFR  A,B            ; SAVE INPUT CHARACTER IN ACCB
3192 d638 9d 7c              LAE88     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3193 d63a c1 a0                        CMPB #TOK_TO        ; 'TO' TOKEN
3194 d63c 27 16                        BEQ  LAEA4          ; BRANCH IF GOTO
3195 d63e c1 a1                        CMPB #TOK_SUB       ; 'SUB' TOKEN
3196 d640 26 45                        BNE  LAED7          ; 'SYNTAX ERROR' IF NEITHER
3197 d642 c6 03                        LDB  #3             ; =ROOM FOR 6
3198 d644 bd d3 f3                     JSR  LAC33          ; =BYTES ON STACK?
3199 d647 de 83                        LDU  CHARAD         ; * SAVE CURRENT BASIC INPUT POINTER, LINE
3200 d649 9e 68                        LDX  CURLIN         ; * NUMBER AND SUB TOKEN ON STACK
3201 d64b 86 a1                        LDA  #TOK_SUB       ; *
3202 d64d 34 52                        PSHS U,X,A          ; *
3203 d64f 8d 03              LAE9F     BSR  LAEA4          ; GO DO A 'GOTO'
3204 d651 7e d5 42                     JMP  LAD9E          ; JUMP BACK TO BASIC'S MAIN LOOP
3205                         * GOTO
3206 d654 9d 82              LAEA4     JSR  GETCCH         ; GET CURRENT INPUT CHAR
3207 d656 bd d7 17                     JSR  LAF67          ; GET LINE NUMBER TO BINARY IN BINVAL
3208 d659 8d 40                        BSR  LAEEB          ; ADVANCE BASIC'S POINTER TO END OF LINE
3209 d65b 30 01                        LEAX $01,X          ; POINT TO START OF NEXT LINE
3210 d65d dc 2b                        LDD  BINVAL         ; GET THE LINE NUMBER TO RUN
3211 d65f 10 93 68                     CMPD CURLIN         ; COMPARE TO CURRENT LINE NUMBER
3212 d662 22 02                        BHI  LAEB6          ; IF REO'D LINE NUMBER IS > CURRENT LINE NUMBER,
3213                         *              ; DON'T START LOOKING FROM
3214                         *              ; START OF PROGRAM
3215 d664 9e 19                        LDX  TXTTAB         ; BEGINNING OF PROGRAM
3216 d666 bd d4 a9           LAEB6     JSR  LAD05          ; GO FIND A LINE NUMBER
3217 d669 25 17                        BCS  LAED2          ; 'UNDEFINED LINE NUMBER'
3218 d66b 30 1f              LAEBB     LEAX -1,X           ; MOVE BACK TO JUST BEFORE START OF LINE
3219 d66d 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3220 d66f 39                 LAEBF     RTS
3221                         *
3222                         * RETURN
3223 d670 26 fd              RETURN    BNE  LAEBF          ; EXIT ROUTINE IF ARGUMENT GIVEN
3224 d672 86 ff                        LDA  #$FF           ; * PUT AN ILLEGAL VARIABLE NAME IN FIRST BYTE OF
3225 d674 97 3b                        STA  VARDES         ; * VARDES WHICH WILL CAUSE 'FOR/NEXT' DATA ON THE
3226                         *              ; STACK TO BE IGNORED
3227 d676 bd d3 b9                     JSR  LABF9          ; CHECK FOR RETURN DATA ON THE STACK
3228 d679 1f 14                        TFR  X,S            ; RESET STACK POINTER - PURGE TWO RETURN ADDRESSES
3229                         *              ; FROM THE STACK
3230 d67b 81 21                        CMPA #TOK_SUB-$80   ; SUB TOKEN - $80
3231 d67d 27 0b                        BEQ  LAEDA          ; BRANCH IF 'RETURN' FROM SUBROUTINE
3232 d67f c6 04                        LDB  #2*2           ; ERROR #2 'RETURN WITHOUT GOSUB'
3233 d681 8c                           FCB  SKP2           ; SKIP TWO BYTES
3234 d682 c6 0e              LAED2     LDB  #7*2           ; ERROR #7 'UNDEFINED LINE NUMBER'
3235 d684 7e d4 06                     JMP  LAC46          ; JUMP TO ERROR HANDLER
3236 d687 7e da 03           LAED7     JMP  LB277          ; 'SYNTAX ERROR'
3237 d68a 35 52              LAEDA     PULS A,X,U          ; * RESTORE VALUES OF CURRENT LINE NUMBER AND
3238 d68c 9f 68                        STX  CURLIN         ; * BASIC'S INPUT POINTER FOR THIS SUBROUTINE
3239 d68e df 83                        STU  CHARAD         ; * AND LOAD ACCA WITH SUB TOKEN ($A6)
3240                         *
3241                         * DATA
3242 d690 8d 06              DATA      BSR  LAEE8          ; MOVE INPUT POINTER TO END OF SUBLINE OR LINE
3243 d692 8c                           FCB  SKP2           ; SKIP 2 BYTES
3244                         
3245                         * REM, ELSE
3246                         ELSE
3247 d693 8d 06              REM       BSR  LAEEB          ; MOVE INPUT POINTER TO END OF LINE
3248 d695 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3249 d697 39                 LAEE7     RTS
3250                         * ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE
3251 d698 c6 3a              LAEE8     LDB  #':            ; COLON = SUBLINE TERMINATOR CHARACTER
3252 d69a 86                 LAEEA     FCB  SKP1LD         ; SKPILD SKIP ONE BYTE; LDA #$5F
3253                         * ADVANCE BASIC'S INPUT POINTER TO END OF
3254                         * LINE - RETURN ADDRESS OF END OF LINE+1 IN X
3255 d69b 5f                 LAEEB     CLRB                ; 0 = LINE TERMINATOR CHARACTER
3256 d69c d7 01                        STB  CHARAC         ; TEMP STORE PRIMARY TERMINATOR CHARACTER
3257 d69e 5f                           CLRB                ; 0 (END OF LINE) = ALTERNATE TERM. CHAR.
3258 d69f 9e 83                        LDX  CHARAD         ; LOAD X W/BASIC'S INPUT POINTER
3259 d6a1 1f 98              LAEF1     TFR  B,A            ; * CHANGE TERMINATOR CHARACTER
3260 d6a3 d6 01                        LDB  CHARAC         ; * FROM ACCB TO CHARAC - SAVE OLD TERMINATOR
3261                         *         IN   CHARAC
3262 d6a5 97 01                        STA  CHARAC         ; SWAP PRIMARY AND SECONDARY TERMINATORS
3263 d6a7 a6 84              LAEF7     LDA  ,X             ; GET NEXT INPUT CHARACTER
3264 d6a9 27 ec                        BEQ  LAEE7          ; RETURN IF 0 (END OF LINE)
3265 d6ab 34 04                        PSHS B              ; SAVE TERMINATOR ON STACK
3266 d6ad a1 e0                        CMPA ,S+            ; COMPARE TO INPUT CHARACTER
3267 d6af 27 e6                        BEQ  LAEE7          ; RETURN IF EQUAL
3268 d6b1 30 01                        LEAX 1,X            ; MOVE POINTER UP ONE
3269 d6b3 81 22                        CMPA #'"            ; CHECK FOR DOUBLE QUOTES
3270 d6b5 27 ea                        BEQ  LAEF1          ; BRANCH IF " - TOGGLE TERMINATOR CHARACTERS
3271 d6b7 4c                           INCA                ; * CHECK FOR $FF AND BRANCH IF
3272 d6b8 26 02                        BNE  LAF0C          ; * NOT SECONDARY TOKEN
3273 d6ba 30 01                        LEAX 1,X            ; MOVE INPUT POINTER 1 MORE IF SECONDARY
3274 d6bc 81 86              LAF0C     CMPA #TOK_IF+1      ; TOKEN FOR IF?
3275 d6be 26 e7                        BNE  LAEF7          ; NO - GET ANOTHER INPUT CHARACTER
3276 d6c0 0c 04                        INC  IFCTR          ; INCREMENT IF COUNTER - KEEP TRACK OF HOW MANY
3277                         *                             ; 'IF' STATEMENTS ARE NESTED IN ONE LINE
3278 d6c2 20 e3                        BRA  LAEF7          ; GET ANOTHER INPUT CHARACTER
3279                         
3280                         * IF
3281 d6c4 bd d8 cd           IF        JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
3282 d6c7 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3283 d6c9 81 81                        CMPA #TOK_GO        ; TOKEN FOR GO
3284 d6cb 27 05                        BEQ  LAF22          ; TREAT 'GO' THE SAME AS 'THEN'
3285 d6cd c6 a2                        LDB  #TOK_THEN      ; TOKEN FOR THEN
3286 d6cf bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK ON ACCB
3287 d6d2 96 4f              LAF22     LDA  FP0EXP         ; CHECK FOR TRUE/FALSE - FALSE IF FPA0 EXPONENT = ZERO
3288 d6d4 26 13                        BNE  LAF39          ; BRANCH IF CONDITION TRUE
3289 d6d6 0f 04                        CLR  IFCTR          ; CLEAR FLAG - KEEP TRACK OF WHICH NESTED ELSE STATEMENT
3290                         *                             ; TO SEARCH FOR IN NESTED 'IF' LOOPS
3291 d6d8 8d b6              LAF28     BSR  DATA           ; MOVE BASIC'S POINTER TO END OF SUBLINE
3292 d6da 4d                           TSTA                ; * CHECK TO SEE IF END OF LINE OR SUBLINE
3293 d6db 27 ba                        BEQ  LAEE7          ; * AND RETURN IF END OF LINE
3294 d6dd 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
3295 d6df 81 84                        CMPA #TOK_ELSE      ; TOKEN FOR ELSE
3296 d6e1 26 f5                        BNE  LAF28          ; IGNORE ALL DATA EXCEPT 'ELSE' UNTIL
3297                         *                             ; END OF LINE (ZERO BYTE)
3298 d6e3 0a 04                        DEC  IFCTR          ; CHECK TO SEE IF YOU MUST SEARCH ANOTHER SUBLINE
3299 d6e5 2a f1                        BPL  LAF28          ; BRANCH TO SEARCH ANOTHER SUBLINE FOR 'ELSE'
3300 d6e7 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
3301 d6e9 9d 82              LAF39     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3302 d6eb 10 25 ff 65                  LBCS LAEA4          ; BRANCH TO 'GOTO' IF NUMERIC CHARACTER
3303 d6ef 7e d5 7a                     JMP  LADC6          ; RETURN TO MAIN INTERPRETATION LOOP
3304                         
3305                         * ON
3306 d6f2 bd de 92           ON        JSR  LB70B          ; EVALUATE EXPRESSION
3307 d6f5 c6 81                        LDB  #TOK_GO        ; TOKEN FOR GO
3308 d6f7 bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR GO
3309 d6fa 34 02                        PSHS A              ; SAVE NEW TOKEN (TO,SUB)
3310 d6fc 81 a1                        CMPA #TOK_SUB       ; TOKEN FOR SUB?
3311 d6fe 27 04                        BEQ  LAF54          ; YES
3312 d700 81 a0                        CMPA #TOK_TO        ; TOKEN FOR TO?
3313 d702 26 83              LAF52     BNE  LAED7          ; 'SYNTAX' ERROR IF NOT 'SUB' OR 'TO'
3314 d704 0a 53              LAF54     DEC  FPA0+3         ; DECREMENT IS BYTE OF MANTISSA OF FPA0 - THIS
3315                         *                             ; IS THE ARGUMENT OF THE 'ON' STATEMENT
3316 d706 26 05                        BNE  LAF5D          ; BRANCH IF NOT AT THE PROPER GOTO OR GOSUB LINE NUMBER
3317 d708 35 04                        PULS B              ; GET BACK THE TOKEN FOLLOWING 'GO'
3318 d70a 7e d6 38                     JMP  LAE88          ; GO DO A 'GOTO' OR 'GOSUB'
3319 d70d 9d 7c              LAF5D     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3320 d70f 8d 06                        BSR  LAF67          ; CONVERT BASIC LINE NUMBER TO BINARY
3321 d711 81 2c                        CMPA #',            ; IS CHARACTER FOLLOWING LINE NUMBER A COMMA?
3322 d713 27 ef                        BEQ  LAF54          ; YES
3323 d715 35 84                        PULS B,PC           ; IF NOT, FALL THROUGH TO NEXT COMMAND
3324 d717 9e 74              LAF67     LDX  ZERO           ; DEFAULT LINE NUMBER OF ZERO
3325 d719 9f 2b                        STX  BINVAL         ; SAVE IT IN BINVAL
3326                         *
3327                         * CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINVAL
3328                         *
3329 d71b 24 61              LAF6B     BCC  LAFCE          ; RETURN IF NOT NUMERIC CHARACTER
3330 d71d 80 30                        SUBA #'0            ; MASK OFF ASCII
3331 d71f 97 01                        STA  CHARAC         ; SAVE DIGIT IN VO1
3332 d721 dc 2b                        LDD  BINVAL         ; GET ACCUMULATED LINE NUMBER VALUE
3333 d723 81 18                        CMPA #24            ; LARGEST LINE NUMBER IS $F9FF (63999) -
3334                         *         (24*256+255)*10+9
3335 d725 22 db                        BHI  LAF52          ; 'SYNTAX' ERROR IF TOO BIG
3336                         * MULT ACCD X 10
3337 d727 58                           ASLB                ; *
3338 d728 49                           ROLA                ; * TIMES 2
3339 d729 58                           ASLB                ; =
3340 d72a 49                           ROLA                ; = TIMES 4
3341 d72b d3 2b                        ADDD BINVAL         ; ADD 1 = TIMES 5
3342 d72d 58                           ASLB                ; *
3343 d72e 49                           ROLA                ; * TIMES 10
3344 d72f db 01                        ADDB CHARAC         ; ADD NEXT DIGIT
3345 d731 89 00                        ADCA #0             ; PROPAGATE CARRY
3346 d733 dd 2b                        STD  BINVAL         ; SAVE NEW ACCUMULATED LINE NUMBER
3347 d735 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
3348 d737 20 e2                        BRA  LAF6B          ; LOOP- PROCESS NEXT DIGIT
3349                         *
3350                         * LET (EXBAS)
3351                         * EVALUATE A NON-TOKEN EXPRESSION
3352                         * TARGET = REPLACEMENT
3353 d739 bd da de           LET       JSR  LB357          ; FIND TARGET VARIABLE DESCRIPTOR
3354 d73c 9f 3b                        STX  VARDES         ; SAVE DESCRIPTOR ADDRESS OF 1ST EXPRESSION
3355 d73e c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR "="
3356 d740 bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR '='
3357 d743 96 06                        LDA  VALTYP         ; * GET VARIABLE TYPE AND
3358 d745 34 02                        PSHS A              ; * SAVE ON THE STACK
3359 d747 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
3360 d74a 35 02                        PULS A              ; * REGET VARIABLE TYPE OF 1ST EXPRESSION AND
3361 d74c 46                           RORA                ; * SET CARRY IF STRING
3362 d74d bd d8 d4                     JSR  LB148          ; TYPE CHECK-TM ERROR IF VARIABLE TYPES ON
3363                         *                             ; BOTH SIDES OF EQUALS SIGN NOT THE SAME
3364 d750 10 27 0c 2b                  LBEQ LBC33          ; GO PUT FPA0 INTO VARIABLE DESCRIPTOR IF NUMERIC
3365                         * MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT
3366                         * FPA0+2 INTO THE STRING SPACE. TRANSFER THE
3367                         * DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES
3368                         * DON'T MOVE THE STRING IF IT IS ALREADY IN THE
3369                         * STRING SPACE. REMOVE DESCRIPTOR FROM STRING
3370                         * STACK IF IT IS LAST ONE ON THE STACK
3371 d754 9e 52              LAFA4     LDX  FPA0+2         ; POINT X TO DESCRIPTOR OF REPLACEMENT STRING
3372 d756 dc 21                        LDD  FRETOP         ; LOAD ACCD WITH START OF STRING SPACE
3373 d758 10 a3 02                     CMPD 2,X            ; IS THE STRING IN STRING SPACE?
3374 d75b 24 11                        BCC  LAFBE          ; BRANCH IF IT'S NOT IN THE STRING SPACE
3375 d75d 9c 1b                        CMPX VARTAB         ; COMPARE DESCRIPTOR ADDRESS TO START OF VARIABLES
3376 d75f 25 0d                        BCS  LAFBE          ; BRANCH IF DESCRIPTOR ADDRESS NOT IN VARIABLES
3377 d761 e6 84              LAFB1     LDB  ,X             ; GET LENGTH OF REPLACEMENT STRING
3378 d763 bd dc 94                     JSR  LB50D          ; RESERVE ACCB BYTES OF STRING SPACE
3379 d766 9e 4d                        LDX  V4D            ; GET DESCRIPTOR ADDRESS BACK
3380 d768 bd dd ca                     JSR  LB643          ; MOVE STRING INTO STRING SPACE
3381 d76b 8e 00 56                     LDX  #STRDES        ; POINT X TO TEMP STRING DESCRIPTOR ADDRESS
3382 d76e 9f 4d              LAFBE     STX  V4D            ; SAVE STRING DESCRIPTOR ADDRESS IN V4D
3383 d770 bd dd fc                     JSR  LB675          ; REMOVE STRING DESCRIPTOR IF LAST ONE
3384                         *              ; ON STRING STACK
3385 d773 de 4d                        LDU  V4D            ; POINT U TO REPLACEMENT DESCRIPTOR ADDRESS
3386 d775 9e 3b                        LDX  VARDES         ; GET TARGET DESCRIPTOR ADDRESS
3387 d777 37 26                        PULU A,B,Y          ; GET LENGTH AND START OF REPLACEMENT STRING
3388 d779 a7 84                        STA  ,X             ; * SAVE STRING LENGTH AND START IN
3389 d77b 10 af 02                     STY  2,X            ; * TARGET DESCRIPTOR LOCATION
3390 d77e 39                 LAFCE     RTS
3391                         
3392 d77f 3f 52 45 44 4f     LAFCF     FCC  "?REDO"        ; ?REDO MESSAGE
3393 d784 0d 00                        FCB  CR,$00
3394                         
3395                         LAFD6
3396 d786 7e d4 06           LAFDC     JMP  LAC46          ; JMP TO ERROR HANDLER
3397 d789 96 09              LAFDF     LDA  INPFLG         ; = GET THE INPUT FLAG AND BRANCH
3398 d78b 27 07                        BEQ  LAFEA          ; = IF 'INPUT'
3399 d78d 9e 31                        LDX  DATTXT         ; * GET LINE NUMBER WHERE THE ERROR OCCURRED
3400 d78f 9f 68                        STX  CURLIN         ; * AND USE IT AS THE CURRENT LINE NUMBER
3401 d791 7e da 03                     JMP  LB277          ; 'SYNTAX ERROR'
3402 d794 8e d7 7e           LAFEA     LDX  #LAFCF-1       ; * POINT X TO '?REDO' AND PRINT
3403 d797 bd e0 e8                     JSR  LB99C          ; * IT ON THE SCREEN
3404 d79a 9e 2f                        LDX  TINPTR         ; = GET THE SAVED ABSOLUTE ADDRESS OF
3405 d79c 9f 83                        STX  CHARAD         ; = INPUT POINTER AND RESTORE IT
3406 d79e 39                           RTS
3407                         *
3408                         * INPUT
3409 d79f c6 16              INPUT     LDB  #11*2          ; 'ID' ERROR
3410 d7a1 9e 68                        LDX  CURLIN         ; GET CURRENT LINE NUMBER
3411 d7a3 30 01                        LEAX 1,X            ; ADD ONE
3412 d7a5 27 df                        BEQ  LAFDC          ; 'ID' ERROR BRANCH IF DIRECT MODE
3413 d7a7 8d 01                        BSR  LB00F          ; GET SOME INPUT DATA - WAS LB002
3414 d7a9 39                           RTS
3415 d7aa 81 22              LB00F     CMPA #'"            ; CHECK FOR PROMPT STRING DELIMITER
3416 d7ac 26 0b                        BNE  LB01E          ; BRANCH IF NO PROMPT STRING
3417 d7ae bd d9 d0                     JSR  LB244          ; PUT PROMPT STRING ON STRING STACK
3418 d7b1 c6 3b                        LDB  #';            ; *
3419 d7b3 bd d9 fb                     JSR  LB26F          ; * DO A SYNTAX CHECK FOR SEMICOLON
3420 d7b6 bd e0 eb                     JSR  LB99F          ; PRINT MESSAGE TO CONSOLE OUT
3421 d7b9 8e 00 f3           LB01E     LDX  #LINBUF        ; POINT TO BASIC'S LINE BUFFER
3422 d7bc 6f 84                        CLR  ,X             ; CLEAR 1ST BYTE - FLAG TO INDICATE NO DATA
3423                         *              ; IN LINE BUFFER
3424 d7be 8d 06                        BSR  LB02F          ; INPUT A STRING TO LINE BUFFER
3425 d7c0 c6 2c                        LDB  #',            ; * INSERT A COMMA AT THE END
3426 d7c2 e7 84                        STB  ,X             ; * OF THE LINE INPUT BUFFER
3427 d7c4 20 16                        BRA  LB049
3428                         * FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
3429 d7c6 bd e0 fb           LB02F     JSR  LB9AF          ; SEND A "?" TO CONSOLE OUT
3430 d7c9 bd e0 f8                     JSR  LB9AC          ; SEND A 'SPACE' TO CONSOLE OUT
3431 d7cc bd d1 41           LB035     JSR  LA390          ; GO READ IN A BASIC LINE
3432 d7cf 24 05                        BCC  LB03F          ; BRANCH IF ENTER KEY ENDED ENTRY
3433 d7d1 32 64                        LEAS 4,S            ; PURGE TWO RETURN ADDRESSES OFF THE STACK
3434 d7d3 7e d5 c9                     JMP  LAE11          ; GO DO A 'STOP' IF BREAK KEY ENDED LINE ENTRY
3435 d7d6 c6 2e              LB03F     LDB  #2*23          ; 'INPUT PAST END OF FILE' ERROR
3436 d7d8 39                           RTS
3437                         *
3438                         * READ
3439 d7d9 9e 33              READ      LDX  DATPTR         ; GET 'READ' START ADDRESS
3440 d7db 86                           FCB  SKP1LD         ; SKIP ONE BYTE - LDA #*$4F
3441 d7dc 4f                 LB049     CLRA                ; 'INPUT' ENTRY POINT: INPUT FLAG = 0
3442 d7dd 97 09                        STA  INPFLG         ; SET INPUT FLAG; 0 = INPUT: <> 0 = READ
3443 d7df 9f 35                        STX  DATTMP         ; SAVE 'READ' START ADDRESS/'INPUT' BUFFER START
3444 d7e1 bd da de           LB04E     JSR  LB357          ; EVALUATE A VARIABLE
3445 d7e4 9f 3b                        STX  VARDES         ; SAVE DESCRIPTOR ADDRESS
3446 d7e6 9e 83                        LDX  CHARAD         ; * GET BASIC'S INPUT POINTER
3447 d7e8 9f 2b                        STX  BINVAL         ; * AND SAVE IT
3448 d7ea 9e 35                        LDX  DATTMP         ; GET 'READ' ADDRESS START/'INPUT' BUFFER POINTER
3449 d7ec a6 84                        LDA  ,X             ; GET A CHARACTER FROM THE BASIC PROGRAM
3450 d7ee 26 09                        BNE  LB069          ; BRANCH IF NOT END OF LINE
3451 d7f0 96 09                        LDA  INPFLG         ; * CHECK INPUT FLAG AND BRANCH
3452 d7f2 26 51                        BNE  LB0B9          ; * IF LOOKING FOR DATA (READ)
3453                         * NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
3454                         * NOT COMING FROM SCREEN
3455 d7f4 bd e0 fb                     JSR  LB9AF          ; SEND A '?' TO CONSOLE OUT
3456 d7f7 8d cd                        BSR  LB02F          ; FILL INPUT BUFFER FROM CONSOLE IN
3457 d7f9 9f 83              LB069     STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3458 d7fb 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3459 d7fd d6 06                        LDB  VALTYP         ; * CHECK VARIABLE TYPE AND
3460 d7ff 27 23                        BEQ  LB098          ; * BRANCH IF NUMERIC
3461                         * READ/INPUT A STRING VARIABLE
3462 d801 9e 83                        LDX  CHARAD         ; LOAD X WITH CURRENT BASIC INPUT POINTER
3463 d803 97 01                        STA  CHARAC         ; SAVE CURRENT INPUT CHARACTER
3464 d805 81 22                        CMPA #'"            ; CHECK FOR STRING DELIMITER
3465 d807 27 0e                        BEQ  LB08B          ; BRANCH IF STRING DELIMITER
3466 d809 30 1f                        LEAX -1,X           ; BACK UP POINTER
3467 d80b 4f                           CLRA                ; * ZERO = END OF LINE CHARACTER
3468 d80c 97 01                        STA  CHARAC         ; * SAVE AS TERMINATOR
3469 d80e bd d1 33                     JSR  LA35F          ; SET UP PRINT PARAMETERS
3470 d811 86 3a                        LDA  #':            ; END OF SUBLINE CHARACTER
3471 d813 97 01                        STA  CHARAC         ; SAVE AS TERMINATOR I
3472 d815 86 2c                        LDA  #',            ; COMMA
3473 d817 97 02              LB08B     STA  ENDCHR         ; SAVE AS TERMINATOR 2
3474 d819 bd dc a5                     JSR  LB51E          ; STRIP A STRING FROM THE INPUT BUFFER
3475 d81c bd d9 d5                     JSR  LB249          ; MOVE INPUT POINTER TO END OF STRING
3476 d81f bd d7 54                     JSR  LAFA4          ; PUT A STRING INTO THE STRING SPACE IF NECESSARY
3477 d822 20 06                        BRA  LB09E          ; CHECK FOR ANOTHER DATA ITEM
3478                         * SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM
3479 d824 bd e4 5e           LB098     JSR  LBD12          ; CONVERT AN ASCII STRING TO FP NUMBER
3480 d827 bd e3 7f                     JSR  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS IN VARDES -
3481                         *                             ; INPUT OR READ DATA ITEM
3482 d82a 9d 82              LB09E     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3483 d82c 27 06                        BEQ  LB0A8          ; BRANCH IF END OF LINE
3484 d82e 81 2c                        CMPA #',            ; CHECK FOR A COMMA
3485 d830 10 26 ff 52                  LBNE LAFD6          ; BAD FILE DATA' ERROR OR RETRY
3486 d834 9e 83              LB0A8     LDX  CHARAD         ; * GET CURRENT INPUT
3487 d836 9f 35                        STX  DATTMP         ; * POINTER (USED AS A DATA POINTER) AND SAVE IT
3488 d838 9e 2b                        LDX  BINVAL         ; * RESET INPUT POINTER TO INPUT OR
3489 d83a 9f 83                        STX  CHARAD         ; * READ STATEMENT
3490 d83c 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
3491 d83e 27 21                        BEQ  LB0D5          ; BRANCH IF END OF LINE - EXIT COMMAND
3492 d840 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
3493 d843 20 9c                        BRA  LB04E          ; GET ANOTHER INPUT OR READ ITEM
3494                         * SEARCH FROM ADDRESS IN X FOR
3495                         * 1ST OCCURENCE OF THE TOKEN FOR DATA
3496 d845 9f 83              LB0B9     STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3497 d847 bd d6 98                     JSR  LAEE8          ; SEARCH FOR END OF CURRENT LINE OR SUBLINE
3498 d84a 30 01                        LEAX 1,X            ; MOVE X ONE PAST END OF LINE
3499 d84c 4d                           TSTA                ; CHECK FOR END OF LINE
3500 d84d 26 0a                        BNE  LB0CD          ; BRANCH IF END OF SUBLINE
3501 d84f c6 06                        LDB  #2*3           ; 'OUT OF DATA' ERROR
3502 d851 ee 81                        LDU  ,X++           ; GET NEXT 2 CHARACTERS
3503 d853 27 41                        BEQ  LB10A          ; 'OD' ERROR IF END OF PROGRAM
3504 d855 ec 81                        LDD  ,X++           ; GET BASIC LINE NUMBER AND
3505 d857 dd 31                        STD  DATTXT         ; SAVE IT IN DATTXT
3506 d859 a6 84              LB0CD     LDA  ,X             ; GET AN INPUT CHARACTER
3507 d85b 81 86                        CMPA #TOK_DATA      ; DATA TOKEN?
3508 d85d 26 e6                        BNE  LB0B9          ; NO - KEEP LOOKING
3509 d85f 20 98                        BRA  LB069          ; YES
3510                         * EXIT READ AND INPUT COMMANDS
3511 d861 9e 35              LB0D5     LDX  DATTMP         ; GET DATA POINTER
3512 d863 d6 09                        LDB  INPFLG         ; * CHECK INPUT FLAG
3513 d865 10 26 fd 3a                  LBNE LADE8          ; * SAVE NEW DATA POINTER IF READ
3514 d869 a6 84                        LDA  ,X             ; = CHECK NEXT CHARACTER IN 'INPUT' BUFFER
3515 d86b 27 06                        BEQ  LB0E7          ; =
3516 d86d 8e d8 73                     LDX  #LB0E8-1       ; POINT X TO '?EXTRA IGNORED'
3517 d870 7e e0 e8                     JMP  LB99C          ; PRINT THE MESSAGE
3518 d873 39                 LB0E7     RTS
3519                         
3520 d874 3f 45 58 54 52 41  LB0E8     FCC  "?EXTRA IGNORED" ; ?EXTRA IGNORED MESSAGE
     20 49 47 4e 4f 52
     45 44
3521                         
3522                         
3523 d882 0d 00                        FCB  CR,$00
3524                         
3525                         * NEXT
3526 d884 26 04              NEXT      BNE  LB0FE          ; BRANCH IF ARGUMENT GIVEN
3527 d886 9e 74                        LDX  ZERO           ; X = 0: DEFAULT FOR NO ARGUMENT
3528 d888 20 03                        BRA  LB101
3529 d88a bd da de           LB0FE     JSR  LB357          ; EVALUATE AN ALPHA EXPRESSION
3530 d88d 9f 3b              LB101     STX  VARDES         ; SAVE VARIABLE DESCRIPTOR POINTER
3531 d88f bd d3 b9                     JSR  LABF9          ; GO SCAN FOR 'FOR/NEXT' DATA ON STACK
3532 d892 27 04                        BEQ  LB10C          ; BRANCH IF DATA FOUND
3533 d894 c6 00                        LDB  #0             ; 'NEXT WITHOUT FOR' ERROR (SHOULD BE CLRB)
3534 d896 20 47              LB10A     BRA  LB153          ; PROCESS ERROR
3535 d898 1f 14              LB10C     TFR  X,S            ; POINT S TO START OF 'FOR/NEXT' DATA
3536 d89a 30 03                        LEAX 3,X            ; POINT X TO FP VALUE OF STEP
3537 d89c bd e3 60                     JSR  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
3538 d89f a6 68                        LDA  8,S            ; GET THE DIRECTION OF STEP
3539 d8a1 97 54                        STA  FP0SGN         ; SAVE IT AS THE SIGN OF FPA0
3540 d8a3 9e 3b                        LDX  VARDES         ; POINT (X) TO INDEX VARIABLE DESCRIPTOR
3541 d8a5 bd e1 0e                     JSR  LB9C2          ; ADD (X) TO FPA0 (STEP TO INDEX)
3542 d8a8 bd e3 7f                     JSR  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS
3543                         *                             ; CONTAINED IN VARDES
3544 d8ab 30 69                        LEAX 9,S            ; POINT (X) TO TERMINAL VALUE OF INDEX
3545 d8ad bd e3 e2                     JSR  LBC96          ; COMPARE CURRENT INDEX VALUE TO TERMINAL VALUE OF INDEX
3546 d8b0 e0 68                        SUBB 8,S            ; ACCB = 0 IF TERMINAL VALUE=CURRENT VALUE AND STEP=0 OR IF
3547                         *                             ; STEP IS POSITIVE AND CURRENT VALUE>TERMINAL VALUE OR
3548                         *                             ; STEP IS NEGATIVE AND CURRENT VALUE<TERMINAL VALUE
3549 d8b2 27 0c                        BEQ  LB134          ; BRANCH IF 'FOR/NEXT' LOOP DONE
3550 d8b4 ae 6e                        LDX  14,S           ; * GET LINE NUMBER AND
3551 d8b6 9f 68                        STX  CURLIN         ; * BASIC POINTER OF
3552 d8b8 ae e8 10                     LDX  16,S           ; * STATEMENT FOLLOWING THE
3553 d8bb 9f 83                        STX  CHARAD         ; * PROPER FOR STATEMENT
3554 d8bd 7e d5 42           LB131     JMP  LAD9E          ; JUMP BACK TO COMMAND INTEPR. LOOP
3555 d8c0 32 e8 12           LB134     LEAS 18,S           ; PULL THE 'FOR-NEXT' DATA OFF THE STACK
3556 d8c3 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3557 d8c5 81 2c                        CMPA #',            ; CHECK FOR ANOTHER ARGUMENT
3558 d8c7 26 f4                        BNE  LB131          ; RETURN IF NONE
3559 d8c9 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
3560 d8cb 8d bd                        BSR  LB0FE          ; BSR SIMULATES A CALL TO 'NEXT' FROM COMMAND LOOP
3561                         
3562                         
3563 d8cd 8d 13              LB141     BSR  LB156          ; EVALUATE EXPRESSION AND DO A TYPE CHECK FOR NUMERIC
3564 d8cf 1c fe              LB143     ANDCC #$FE          ; CLEAR CARRY FLAG
3565 d8d1 7d                 LB145     FCB  $7D            ; OP CODE OF TST $1A01 - SKIP TWO BYTES (DO
3566                         *              ; NOT CHANGE CARRY FLAG)
3567 d8d2 1a 01              LB146     ORCC #1             ; SET CARRY
3568                         
3569                         * STRING TYPE MODE CHECK - IF ENTERED AT LB146 THEN VALTYP PLUS IS 'TM' ERROR
3570                         * NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN VALTYP MINUS IS 'TM' ERROR
3571                         * IF ENTERED AT LB148, A TYPE CHECK IS DONE ON VALTYP
3572                         * IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERIC
3573                         * IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRING.
3574 d8d4 0d 06              LB148     TST  VALTYP         ; TEST TYPE FLAG; DO NOT CHANGE CARRY
3575 d8d6 25 03                        BCS  LB14F          ; BRANCH IF STRING
3576 d8d8 2a 99                        BPL  LB0E7          ; RETURN ON PLUS
3577 d8da 8c                           FCB  SKP2           ; SKIP 2 BYTES - 'TM' ERROR
3578 d8db 2b 96              LB14F     BMI  LB0E7          ; RETURN ON MINUS
3579 d8dd c6 18                        LDB  #12*2          ; 'TYPE M1SMATCH' ERROR
3580 d8df 7e d4 06           LB153     JMP  LAC46          ; PROCESS ERROR
3581                         * EVALUATE EXPRESSION
3582 d8e2 8d 6e              LB156     BSR  LB1C6          ; BACK UP INPUT POINTER
3583 d8e4 4f                 LB158     CLRA                ; END OF OPERATION PRECEDENCE FLAG
3584 d8e5 8c                           FCB  SKP2           ; SKIP TWO BYTES
3585 d8e6 34 04              LB15A     PSHS B              ; SAVE FLAG (RELATIONAL OPERATOR FLAG)
3586 d8e8 34 02                        PSHS A              ; SAVE FLAG (PRECEDENCE FLAG)
3587 d8ea c6 01                        LDB  #1             ; *
3588 d8ec bd d3 f3                     JSR  LAC33          ; * SEE IF ROOM IN FREE RAM FOR (B) WORDS
3589 d8ef bd d9 af                     JSR  LB223          ; GO EVALUATE AN EXPRESSION
3590 d8f2 0f 3f                        CLR  TRELFL         ; RESET RELATIONAL OPERATOR FLAG
3591 d8f4 9d 82              LB168     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3592                         * CHECK FOR RELATIONAL OPERATORS
3593 d8f6 80 ad              LB16A     SUBA #TOK_GREATER   ; TOKEN FOR >
3594 d8f8 25 13                        BCS  LB181          ; BRANCH IF LESS THAN RELATIONAL OPERATORS
3595 d8fa 81 03                        CMPA #3             ; *
3596 d8fc 24 0f                        BCC  LB181          ; * BRANCH IF GREATER THAN RELATIONAL OPERATORS
3597 d8fe 81 01                        CMPA #1             ; SET CARRY IF '>'
3598 d900 49                           ROLA                ; CARRY TO BIT 0
3599 d901 98 3f                        EORA TRELFL         ; * CARRY SET IF
3600 d903 91 3f                        CMPA TRELFL         ; * TRELFL = ACCA
3601 d905 25 64                        BCS  LB1DF          ; BRANCH IF SYNTAX ERROR : == << OR >>
3602 d907 97 3f                        STA  TRELFL         ; BIT 0: >, BIT 1 =, BIT 2: <
3603 d909 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER
3604 d90b 20 e9                        BRA  LB16A          ; CHECK FOR ANOTHER RELATIONAL OPERATOR
3605                         *
3606 d90d d6 3f              LB181     LDB  TRELFL         ; GET RELATIONAL OPERATOR FLAG
3607 d90f 26 33                        BNE  LB1B8          ; BRANCH IF RELATIONAL COMPARISON
3608 d911 10 24 00 6b                  LBCC LB1F4          ; BRANCH IF > RELATIONAL OPERATOR
3609 d915 8b 07                        ADDA #7             ; SEVEN ARITHMETIC/LOGICAL OPERATORS
3610 d917 24 67                        BCC  LB1F4          ; BRANCH IF NOT ARITHMETIC/LOGICAL OPERATOR
3611 d919 99 06                        ADCA VALTYP         ; ADD CARRY, NUMERIC FLAG AND MODIFIED TOKEN NUMBER
3612 d91b 10 27 04 77                  LBEQ LB60F          ; BRANCH IF VALTYP = FF, AND ACCA = '+' TOKEN -
3613                         *                             ; CONCATENATE TWO STRINGS
3614 d91f 89 ff                        ADCA #-1            ; RESTORE ARITHMETIC/LOGICAL OPERATOR NUMBER
3615 d921 34 02                        PSHS A              ; * STORE OPERATOR NUMBER ON STACK; MULTIPLY IT BY 2
3616 d923 48                           ASLA                ; * THEN ADD THE STORED STACK DATA = MULTIPLY
3617 d924 ab e0                        ADDA ,S+            ; * X 3; 3 BYTE/TABLE ENTRY
3618 d926 8e d2 0b                     LDX  #LAA51         ; JUMP TABLE FOR ARITHMETIC & LOGICAL OPERATORS
3619 d929 30 86                        LEAX A,X            ; POINT X TO PROPER TABLE
3620 d92b 35 02              LB19F     PULS A              ; GET PRECEDENCE FLAG FROM STACK
3621 d92d a1 84                        CMPA ,X             ; COMPARE TO CURRENT OPERATOR
3622 d92f 24 55                        BCC  LB1FA          ; BRANCH IF STACK OPERATOR > CURRENT OPERATOR
3623 d931 8d 9c                        BSR  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
3624                         
3625                         * OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE THAN THE PREVIOUS OPERATION.
3626 d933 34 02              LB1A7     PSHS A              ; SAVE PRECEDENCE FLAG
3627 d935 8d 29                        BSR  LB1D4          ; PUSH OPERATOR ROUTINE ADDRESS AND FPA0 ONTO STACK
3628 d937 9e 3d                        LDX  RELPTR         ; GET POINTER TO ARITHMETIC/LOGICAL TABLE ENTRY FOR
3629                         *                             ; LAST CALCULATED OPERATION
3630 d939 35 02                        PULS A              ; GET PRECEDENCE FLAG OF PREVIOUS OPERATION
3631 d93b 26 1d                        BNE  LB1CE          ; BRANCH IF NOT END OF OPERATION
3632 d93d 4d                           TSTA                ; CHECK TYPE OF PRECEDENCE FLAG
3633 d93e 10 27 00 6a                  LBEQ LB220          ; BRANCH IF END OF EXPRESSION OR SUB-EXPRESSION
3634 d942 20 4b                        BRA  LB203          ; EVALUATE AN OPERATION
3635                         
3636 d944 08 06              LB1B8     ASL  VALTYP         ; BIT 7 OF TYPE FLAG TO CARRY
3637 d946 59                           ROLB                ; SHIFT RELATIONAL FLAG LEFT - VALTYP TO BIT 0
3638 d947 8d 09                        BSR  LB1C6          ; MOVE THE INPUT POINTER BACK ONE
3639 d949 8e d9 57                     LDX  #LB1CB         ; POINT X TO RELATIONAL COMPARISON JUMP TABLE
3640 d94c d7 3f                        STB  TRELFL         ; SAVE RELATIONAL COMPARISON DATA
3641 d94e 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
3642 d950 20 d9                        BRA  LB19F          ; PERFORM OPERATION OR SAVE ON STACK
3643                         
3644 d952 9e 83              LB1C6     LDX  CHARAD         ; * GET BASIC'S INPUT POINTER AND
3645 d954 7e d6 6b                     JMP  LAEBB          ; * MOVE IT BACK ONE
3646                         * RELATIONAL COMPARISON JUMP TABLE
3647 d957 64                 LB1CB     FCB  $64            ; RELATIONAL COMPARISON FLAG
3648 d958 da 7b              LB1CC     FDB  LB2F4          ; JUMP ADDRESS
3649                         
3650 d95a a1 84              LB1CE     CMPA ,X             ; COMPARE PRECEDENCE OF LAST DONE OPERATION TO
3651                         *         NEXT TO BE DONE OPERATION
3652 d95c 24 31                        BCC  LB203          ; EVALUATE OPERATION IF LOWER PRECEDENCE
3653 d95e 20 d3                        BRA  LB1A7          ; PUSH OPERATION DATA ON STACK IF HIGHER PRECEDENCE
3654                         
3655                         * PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK AND EVALUATE ANOTHER EXPR
3656 d960 ec 01              LB1D4     LDD  1,X            ; GET ADDRESS OF OPERATOR ROUTINE
3657 d962 34 06                        PSHS B,A            ; SAVE IT ON THE STACK
3658 d964 8d 08                        BSR  LB1E2          ; PUSH FPA0 ONTO STACK
3659 d966 d6 3f                        LDB  TRELFL         ; GET BACK RELATIONAL OPERATOR FLAG
3660 d968 16 ff 7b                     LBRA LB15A          ; EVALUATE ANOTHER EXPRESSION
3661 d96b 7e da 03           LB1DF     JMP  LB277          ; 'SYNTAX ERROR'
3662                         * PUSH FPA0 ONTO THE STACK. ,S   = EXPONENT
3663                         * 1-2,S =HIGH ORDER MANTISSA 3-4,S = LOW ORDER MANTISSA
3664                         * 5,S = SIGN RETURN WITH PRECEDENCE CODE IN ACCA
3665 d96e d6 54              LB1E2     LDB  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
3666 d970 a6 84                        LDA  ,X             ; GET PRECEDENCE CODE TO ACCA
3667 d972 35 20              LB1E6     PULS Y              ; GET RETURN ADDRESS FROM STACK & PUT IT IN Y
3668 d974 34 04                        PSHS B              ; SAVE ACCB ON STACK
3669 d976 d6 4f              LB1EA     LDB  FP0EXP         ; * PUSH FPA0 ONTO THE STACK
3670 d978 9e 50                        LDX  FPA0           ; *
3671 d97a de 52                        LDU  FPA0+2         ; *
3672 d97c 34 54                        PSHS U,X,B          ; *
3673 d97e 6e a4                        JMP  ,Y             ; JUMP TO ADDRESS IN Y
3674                         
3675                         * BRANCH HERE IF NON-OPERATOR CHARACTER FOUND - USUALLY ')' OR END OF LINE
3676 d980 9e 74              LB1F4     LDX  ZERO           ; POINT X TO DUMMY VALUE (ZERO)
3677 d982 a6 e0                        LDA  ,S+            ; GET PRECEDENCE FLAG FROM STACK
3678 d984 27 26                        BEQ  LB220          ; BRANCH IF END OF EXPRESSION
3679 d986 81 64              LB1FA     CMPA #$64           ; * CHECK FOR RELATIONAL COMPARISON FLAG
3680 d988 27 03                        BEQ  LB201          ; * AND BRANCH IF RELATIONAL COMPARISON
3681 d98a bd d8 cf                     JSR  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
3682 d98d 9f 3d              LB201     STX  RELPTR         ; SAVE POINTER TO OPERATOR ROUTINE
3683 d98f 35 04              LB203     PULS B              ; GET RELATIONAL OPERATOR FLAG FROM STACK
3684 d991 81 5a                        CMPA #$5A           ; CHECK FOR 'NOT' OPERATOR
3685 d993 27 19                        BEQ  LB222          ; RETURN IF 'NOT' - NO RELATIONAL COMPARISON
3686 d995 81 7d                        CMPA #$7D           ; CHECK FOR NEGATION (UNARY) FLAG
3687 d997 27 15                        BEQ  LB222          ; RETURN IF NEGATION - NO RELATIONAL COMPARISON
3688                         
3689                         * EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON STACK, FIRST SIX BYTES
3690                         * ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRESS OF ROUTINE WHICH
3691                         * WILL EVALUATE THE OPERATION. THE RTS AT END OF ROUTINE WILL VECTOR
3692                         * TO EVALUATING ROUTINE.
3693 d999 54                           LSRB                ; = ROTATE VALTYP BIT INTO CARRY
3694 d99a d7 0a                        STB  RELFLG         ; = FLAG AND SAVE NEW RELFLG
3695 d99c 35 52                        PULS A,X,U          ; * PULL A FP VALUE OFF OF THE STACK
3696 d99e 97 5c                        STA  FP1EXP         ; * AND SAVE IT IN FPA1
3697 d9a0 9f 5d                        STX  FPA1           ; *
3698 d9a2 df 5f                        STU  FPA1+2         ; *
3699 d9a4 35 04                        PULS B              ; = GET MANTISSA SIGN AND
3700 d9a6 d7 61                        STB  FP1SGN         ; = SAVE IT IN FPA1
3701 d9a8 d8 54                        EORB FP0SGN         ; EOR IT WITH FPA1 MANTISSA SIGN
3702 d9aa d7 62                        STB  RESSGN         ; SAVE IT IN RESULT SIGN BYTE
3703 d9ac d6 4f              LB220     LDB  FP0EXP         ; GET EXPONENT OF FPA0
3704 d9ae 39                 LB222     RTS
3705                         
3706 d9af bd eb fc           LB223     JSR  XVEC15         ; CALL EXTENDED BASIC ADD-IN
3707 d9b2 0f 06                        CLR  VALTYP         ; INITIALIZE TYPE FLAG TO NUMERIC
3708 d9b4 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
3709 d9b6 24 03                        BCC  LB22F          ; BRANCH IF NOT NUMERIC
3710 d9b8 7e e4 5e           LB22C     JMP  LBD12          ; CONVERT ASCII STRING TO FLOATING POINT -
3711                         *         RETURN RESULT IN FPA0
3712                         * PROCESS A NON NUMERIC FIRST CHARACTER
3713 d9bb bd db 29           LB22F     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
3714 d9be 24 50                        BCC  LB284          ; BRANCH IF ALPHA CHARACTER
3715 d9c0 81 2e                        CMPA #'.            ; IS IT '.' (DECIMAL POINT)?
3716 d9c2 27 f4                        BEQ  LB22C          ; CONVERT ASCII STRING TO FLOATING POINT
3717 d9c4 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN
3718 d9c6 27 40                        BEQ  LB27C          ; YES - GO PROCESS THE MINUS OPERATOR
3719 d9c8 81 a6                        CMPA #TOK_PLUS      ; PLUS TOKEN
3720 d9ca 27 e3                        BEQ  LB223          ; YES - GET ANOTHER CHARACTER
3721 d9cc 81 22                        CMPA #'"            ; STRING DELIMITER?
3722 d9ce 26 0a                        BNE  LB24E          ; NO
3723 d9d0 9e 83              LB244     LDX  CHARAD         ; CURRENT BASIC POINTER TO X
3724 d9d2 bd dc 9f                     JSR  LB518          ; SAVE STRING ON STRING STACK
3725 d9d5 9e 64              LB249     LDX  COEFPT         ; * GET ADDRESS OF END OF STRING AND
3726 d9d7 9f 83                        STX  CHARAD         ; * PUT BASIC'S INPUT POINTER THERE
3727 d9d9 39                           RTS
3728 d9da 81 a3              LB24E     CMPA #TOK_NOT       ; NOT TOKEN?
3729 d9dc 26 0d                        BNE  LB25F          ; NO
3730                         * PROCESS THE NOT OPERATOR
3731 d9de 86 5a                        LDA  #$5A           ; 'NOT' PRECEDENCE FLAG
3732 d9e0 bd d8 e6                     JSR  LB15A          ; PROCESS OPERATION FOLLOWING 'NOT'
3733 d9e3 bd db 74                     JSR  INTCNV         ; CONVERT FPA0 TO INTEGER IN ACCD
3734 d9e6 43                           COMA                ; * 'NOT' THE INTEGER
3735 d9e7 53                           COMB                ; *
3736 d9e8 7e dc 7b                     JMP  GIVABF         ; CONVERT ACCD TO FLOATING POINT (FPA0)
3737 d9eb 4c                 LB25F     INCA                ; CHECK FOR TOKENS PRECEEDED BY $FF
3738 d9ec 27 2e                        BEQ  LB290          ; IT WAS PRECEEDED BY $FF
3739 d9ee 8d 06              LB262     BSR  LB26A          ; SYNTAX CHECK FOR A '('
3740 d9f0 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSIONS WITHIN PARENTHESES AT
3741                         *         HIGHEST PRECEDENCE
3742 d9f3 c6 29              LB267     LDB  #')            ; SYNTAX CHECK FOR ')'
3743 d9f5 8c                           FCB  SKP2           ; SKIP 2 BYTES
3744 d9f6 c6 28              LB26A     LDB  #'(            ; SYNTAX CHECK FOR '('
3745 d9f8 8c                           FCB  SKP2           ; SKIP 2 BYTES
3746 d9f9 c6 2c              LB26D     LDB  #',            ; SYNTAX CHECK FOR COMMA
3747 d9fb e1 9f 00 83        LB26F     CMPB [CHARAD]       ; * COMPARE ACCB TO CURRENT INPUT
3748 d9ff 26 02                        BNE  LB277          ; * CHARACTER - SYNTAX ERROR IF NO MATCH
3749 da01 0e 7c                        JMP  GETNCH         ; GET A CHARACTER FROM BASIC
3750 da03 c6 02              LB277     LDB  #2*1           ; SYNTAX ERROR
3751 da05 7e d4 06                     JMP  LAC46          ; JUMP TO ERROR HANDLER
3752                         
3753                         * PROCESS THE MINUS (UNARY) OPERATOR
3754 da08 86 7d              LB27C     LDA  #$7D           ; MINUS (UNARY) PRECEDENCE FLAG
3755 da0a bd d8 e6                     JSR  LB15A          ; PROCESS OPERATION FOLLOWING 'UNARY' NEGATION
3756 da0d 7e e6 35                     JMP  LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
3757                         
3758                         * EVALUATE ALPHA EXPRESSION
3759 da10 bd da de           LB284     JSR  LB357          ; FIND THE DESCRIPTOR ADDRESS OF A VARIABLE
3760 da13 9f 52              LB287     STX  FPA0+2         ; SAVE DESCRIPTOR ADDRESS IN FPA0
3761 da15 96 06                        LDA  VALTYP         ; TEST VARIABLE TYPE
3762 da17 26 95                        BNE  LB222          ; RETURN IF STRING
3763 da19 7e e3 60                     JMP  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
3764                         
3765                         * EVALUATING A SECONDARY TOKEN
3766 da1c 9d 7c              LB290     JSR  GETNCH         ; GET AN INPUT CHARACTER (SECONDARY TOKEN)
3767 da1e 1f 89                        TFR  A,B            ; SAVE IT IN ACCB
3768 da20 58                           ASLB                ; X2 & BET RID OF BIT 7
3769 da21 9d 7c                        JSR  GETNCH         ; GET ANOTHER INPUT CHARACTER
3770 da23 c1 38                        CMPB #NUM_SEC_FNS-1*2 ; 29 SECONDARY FUNCTIONS - 1
3771 da25 23 03                        BLS  LB29F          ; BRANCH IF COLOR BASIC TOKEN
3772 da27 7e da 03                     JMP  LB277          ; SYNTAX ERROR
3773 da2a 34 04              LB29F     PSHS B              ; SAVE TOKEN OFFSET ON STACK
3774 da2c c1 2a                        CMPB #TOK_LEFT-$80*2 ; CHECK FOR TOKEN WITH AN ARGUMENT
3775 da2e 25 1e                        BCS  LB2C7          ; DO SECONDARIES STRING$ OR LESS
3776 da30 c1 30                        CMPB #TOK_INKEY-$80*2 ; *
3777 da32 24 1c                        BCC  LB2C9          ; * DO SECONDARIES $92 (INKEY$) OR >
3778 da34 8d c0                        BSR  LB26A          ; SYNTAX CHECK FOR A '('
3779 da36 a6 e4                        LDA  ,S             ; GET TOKEN NUMBER
3780                         * DO SECONDARIES (LEFT$, RIGHT$, MID$)
3781 da38 bd d8 e2                     JSR  LB156          ; EVALUATE FIRST STRING IN ARGUMENT
3782 da3b 8d bc                        BSR  LB26D          ; SYNTAX CHECK FOR A COMMA
3783 da3d bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARiABLE
3784 da40 35 02                        PULS A              ; GET TOKEN OFFSET FROM STACK
3785 da42 de 52                        LDU  FPA0+2         ; POINT U TO STRING DESCRIPTOR
3786 da44 34 42                        PSHS U,A            ; SAVE TOKEN OFFSET AND DESCRIPTOR ADDRESS
3787 da46 bd de 92                     JSR  LB70B          ; EVALUATE FIRST NUMERIC ARGUMENT
3788 da49 35 02                        PULS A              ; GET TOKEN OFFSET FROM STACK
3789 da4b 34 06                        PSHS B,A            ; SAVE TOKEN OFFSET AND NUMERIC ARGUMENT
3790 da4d 8e                           FCB  $8E            ; OP CODE OF LDX# - SKlP 2 BYTES
3791 da4e 8d 9e              LB2C7     BSR  LB262          ; SYNTAX CHECK FOR A '('
3792 da50 35 04              LB2C9     PULS B              ; GET TOKEN OFFSET
3793 da52 be d0 f9                     LDX  COMVEC+8       ; GET SECONDARY FUNCTION JUMP TABLE ADDRESS
3794 da55 3a                 LB2CE     ABX                 ; ADD IN COMMAND OFFSET
3795                         *
3796                         * HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION
3797 da56 ad 94                        JSR  [,X]           ; GO DO AN SECONDARY FUNCTION
3798 da58 7e d8 cf                     JMP  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
3799                         
3800                         * LOGICAL OPERATOR 'OR' JUMPS HERE
3801 da5b 86                 LB2D4     FCB  SKP1LD         ; SKIP ONE BYTE - 'OR' FLAG = $4F
3802                         
3803                         * LOGICAL OPERATOR 'AND' JUMPS HERE
3804 da5c 4f                 LB2D5     CLRA                ; AND FLAG = 0
3805 da5d 97 03                        STA  TMPLOC         ; AND/OR FLAG
3806 da5f bd db 74                     JSR  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
3807 da62 dd 01                        STD  CHARAC         ; TEMP SAVE ACCD
3808 da64 bd e3 96                     JSR  LBC4A          ; MOVE FPA1 TO FPA0
3809 da67 bd db 74                     JSR  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
3810 da6a 0d 03                        TST  TMPLOC         ; CHECK AND/OR FLAG
3811 da6c 26 06                        BNE  LB2ED          ; BRANCH IF OR
3812 da6e 94 01                        ANDA CHARAC         ; * 'AND' ACCD WITH FPA0 INTEGER
3813 da70 d4 02                        ANDB ENDCHR         ; * STORED IN ENDCHR
3814 da72 20 04                        BRA  LB2F1          ; CONVERT TO FP
3815 da74 9a 01              LB2ED     ORA  CHARAC         ; * 'OR' ACCD WITH FPA0 INTEGER
3816 da76 da 02                        ORB  ENDCHR         ; * STORED IN CHARAC
3817 da78 7e dc 7b           LB2F1     JMP  GIVABF         ; CONVERT THE VALUE IN ACCD INTO A FP NUMBER
3818                         
3819                         * RELATIONAL COMPARISON PROCESS HANDLER
3820 da7b bd d8 d4           LB2F4     JSR  LB148          ; 'TM' ERROR IF TYPE MISMATCH
3821 da7e 26 10                        BNE  LB309          ; BRANCH IF STRING VARIABLE
3822 da80 96 61                        LDA  FP1SGN         ; * 'PACK' THE MANTISSA
3823 da82 8a 7f                        ORA  #$7F           ; * SIGN OF FPA1 INTO
3824 da84 94 5d                        ANDA FPA1           ; * BIT 7 OF THE
3825 da86 97 5d                        STA  FPA1           ; * MANTISSA MS BYTE
3826 da88 8e 00 5c                     LDX  #FP1EXP        ; POINT X TO FPA1
3827 da8b bd e3 e2                     JSR  LBC96          ; COMPARE FPA0 TO FPA1
3828 da8e 20 36                        BRA  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
3829                         
3830                         * RELATIONAL COMPARISON OF STRINGS
3831 da90 0f 06              LB309     CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
3832 da92 0a 3f                        DEC  TRELFL         ; REMOVE STRING TYPE FLAG (BIT0=1 FOR STRINGS) FROM THE
3833                         *                             ; DESIRED RELATIONAL COMPARISON DATA
3834 da94 bd dd de                     JSR  LB657          ; GET LENGTH AND ADDRESS OF STRING WHOSE
3835                         *                             ; DESCRIPTOR ADDRESS IS IN THE BOTTOM OF FPA0
3836 da97 d7 56                        STB  STRDES         ; * SAVE LENGTH AND ADDRESS IN TEMPORARY
3837 da99 9f 58                        STX  STRDES+2       ; * DESCRIPTOR (STRING B)
3838 da9b 9e 5f                        LDX  FPA1+2         ; = RETURN LENGTH AND ADDRESS OF STRING
3839 da9d bd dd e0                     JSR  LB659          ; = WHOSE DESCRIPTOR ADDRESS IS STORED IN FPA1+2
3840 daa0 96 56                        LDA  STRDES         ; LOAD ACCA WITH LENGTH OF STRING B
3841 daa2 34 04                        PSHS B              ; SAVE LENGTH A ON STACK
3842 daa4 a0 e0                        SUBA ,S+            ; SUBTRACT LENGTH A FROM LENGTH B
3843 daa6 27 07                        BEQ  LB328          ; BRANCH IF STRINGS OF EQUAL LENGTH
3844 daa8 86 01                        LDA  #1             ; ; TRUE FLAG
3845 daaa 24 03                        BCC  LB328          ; TRUE IF LENGTH B > LENGTH A
3846 daac d6 56                        LDB  STRDES         ; LOAD ACCB WITH LENGTH B
3847 daae 40                           NEGA                ; SET FLAG = FALSE (1FF)
3848 daaf 97 54              LB328     STA  FP0SGN         ; SAVE TRUE/FALSE FLAG
3849 dab1 de 58                        LDU  STRDES+2       ; POINT U TO START OF STRING
3850 dab3 5c                           INCB                ; COMPENSATE FOR THE DECB BELOW
3851                         * ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING
3852 dab4 5a                 LB32D     DECB                ; DECREMENT SHORTER STRING LENGTH
3853 dab5 26 04                        BNE  LB334          ; BRANCH IF ALL OF STRING NOT COMPARED
3854 dab7 d6 54                        LDB  FP0SGN         ; GET TRUE/FALSE FLAB
3855 dab9 20 0b                        BRA  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
3856 dabb a6 80              LB334     LDA  ,X+            ; GET A BYTE FROM STRING A
3857 dabd a1 c0                        CMPA ,U+            ; COMPARE TO STRING B
3858 dabf 27 f3                        BEQ  LB32D          ; CHECK ANOTHER CHARACTER IF =
3859 dac1 c6 ff                        LDB  #$FF           ; FALSE FLAG IF STRING A > B
3860 dac3 24 01                        BCC  LB33F          ; BRANCH IF STRING A > STRING B
3861 dac5 50                           NEGB                ; SET FLAG = TRUE
3862                         
3863                         * DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA0
3864 dac6 cb 01              LB33F     ADDB #1             ; CONVERT $FF,0,1 TO 0,1,2
3865 dac8 59                           ROLB                ; NOW IT'S 1,2,4 FOR > = <
3866 dac9 d4 0a                        ANDB RELFLG         ; 'AND' THE ACTUAL COMPARISON WITH THE DESIRED -
3867                         COMPARISON
3868 dacb 27 02                        BEQ  LB348          ; BRANCH IF FALSE (NO MATCHING BITS)
3869 dacd c6 ff                        LDB  #$FF           ; TRUE FLAG
3870 dacf 7e e3 c8           LB348     JMP  LBC7C          ; CONVERT ACCB INTO FP NUMBER IN FPA0
3871                         
3872                         * DIM
3873 dad2 bd d9 f9           LB34B     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
3874 dad5 c6 01              DIM       LDB  #1             ; DIMENSION FLAG
3875 dad7 8d 08                        BSR  LB35A          ; SAVE ARRAY SPACE FOR THIS VARIABLE
3876 dad9 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3877 dadb 26 f5                        BNE  LB34B          ; KEEP DIMENSIONING IF NOT END OF LINE
3878 dadd 39                           RTS
3879                         * EVALUATE A VARIABLE - RETURN X AND
3880                         * VARPTR POINTING TO VARIABLE DESCRIPTOR
3881                         * EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO
3882                         * BYTES ARE THE VARIABLE NAME AND THE NEXT 5
3883                         * BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE
3884                         * FIRST BYTE OF VARlABLE NAME IS SET, THE
3885                         * VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF
3886                         * THE SECOND BYTE OF VARIABLE NAME IS SET, THE
3887                         * VARIABLE IS A STRING, OTHERWISE THE VARIABLE
3888                         * IS NUMERIC.
3889                         * IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS
3890                         * INSERTED INTO THE VARIABLE SPACE
3891 dade 5f                 LB357     CLRB                ; DIMENSION FLAG = 0; DO NOT SET UP AN ARRAY
3892 dadf 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3893 dae1 d7 05              LB35A     STB  DIMFLG         ; SAVE ARRAY FLAG
3894                         * ENTRY POINT FOR DEF FN VARIABLE SEARCH
3895 dae3 97 37              LB35C     STA  VARNAM         ; SAVE INPUT CHARACTER
3896 dae5 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3897 dae7 8d 40                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
3898 dae9 10 25 ff 16                  LBCS LB277          ; SYNTAX ERROR IF NOT ALPHA
3899 daed 5f                           CLRB                ; DEFAULT 2ND VARIABLE CHARACTER TO ZERO
3900 daee d7 06                        STB  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
3901 daf0 9d 7c                        JSR  GETNCH         ; GET ANOTHER CHARACTER FROM BASIC
3902 daf2 25 04                        BCS  LB371          ; BRANCH IF NUMERIC (2ND CHARACTER IN
3903                         *                             ; VARIABLE MAY BE NUMERIC)
3904 daf4 8d 33                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
3905 daf6 25 0a                        BCS  LB37B          ; BRANCH IF NOT ALPHA
3906 daf8 1f 89              LB371     TFR  A,B            ; SAVE 2ND CHARACTER IN ACCB
3907                         * READ INPUT CHARACTERS UNTIL A NON ALPHA OR
3908                         * NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS
3909                         * IN VARIABLE NAME AFTER THE 1ST TWO
3910 dafa 9d 7c              LB373     JSR  GETNCH         ; GET AN INPUT CHARACTER
3911 dafc 25 fc                        BCS  LB373          ; BRANCH IF NUMERIC
3912 dafe 8d 29                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
3913 db00 24 f8                        BCC  LB373          ; BRANCH IF ALPHA
3914 db02 81 24              LB37B     CMPA #'$            ; CHECK FOR A STRING VARIABLE
3915 db04 26 06                        BNE  LB385          ; BRANCH IF IT IS NOT A STRING
3916 db06 03 06                        COM  VALTYP         ; SET VARIABLE TYPE TO STRING
3917 db08 cb 80                        ADDB #$80           ; SET BIT 7 OF 2ND CHARACTER (STRING)
3918 db0a 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER
3919 db0c d7 38              LB385     STB  VARNAM+1       ; SAVE 2ND CHARACTER IN VARNAM+1
3920 db0e 9a 08                        ORA  ARYDIS         ; OR IN THE ARRAY DISABLE FLAG - IF = $80,
3921                         *              ; DON'T SEARCH FOR VARIABLES IN THE ARRAYS
3922 db10 80 28                        SUBA #'(            ; IS THIS AN ARRAY VARIABLE?
3923 db12 10 27 00 75                  LBEQ LB404          ; BRANCH IF IT IS
3924 db16 0f 08                        CLR  ARYDIS         ; RESET THE ARRAY DISABLE FLAG
3925 db18 9e 1b                        LDX  VARTAB         ; POINT X TO THE START OF VARIABLES
3926 db1a dc 37                        LDD  VARNAM         ; GET VARIABLE IN QUESTION
3927 db1c 9c 1d              LB395     CMPX ARYTAB         ; COMPARE X TO THE END OF VARIABLES
3928 db1e 27 12                        BEQ  LB3AB          ; BRANCH IF END OF VARIABLES
3929 db20 10 a3 81                     CMPD ,X++           ; * COMPARE VARIABLE IN QUESTION TO CURRENT
3930 db23 27 3e                        BEQ  LB3DC          ; * VARIABLE AND BRANCH IF MATCH
3931 db25 30 05                        LEAX 5,X            ; = MOVE POINTER TO NEXT VARIABLE AND
3932 db27 20 f3                        BRA  LB395          ; = KEEP LOOKING
3933                         
3934                         * SET CARRY IF NOT UPPER CASE ALPHA
3935 db29 81 41              LB3A2     CMPA #'A            ; * CARRY SET IF < 'A'
3936 db2b 25 04                        BCS  LB3AA          ; *
3937 db2d 80 5b                        SUBA #'Z+1          ; =
3938                         *         SUBA #-('Z+1)       ; = CARRY CLEAR IF <= 'Z'
3939 db2f 80 a5                        FCB  $80,$A5
3940 db31 39                 LB3AA     RTS
3941                         * PUT A NEW VARIABLE IN TABLE OF VARIABLES
3942 db32 8e 00 74           LB3AB     LDX  #ZERO          ; POINT X TO ZERO LOCATION
3943 db35 ee e4                        LDU  ,S             ; GET CURRENT RETURN ADDRESS
3944 db37 11 83 da 13                  CMPU #LB287         ; DID WE COME FROM 'EVALUATE ALPHA EXPR'?
3945 db3b 27 28                        BEQ  LB3DE          ; YES - RETURN A ZERO VALUE
3946 db3d dc 1f                        LDD  ARYEND         ; * GET END OF ARRAYS ADDRESS AND
3947 db3f dd 43                        STD  V43            ; * SAVE IT AT V43
3948 db41 c3 00 07                     ADDD #7             ; = ADD 7 TO END OF ARRAYS (EACH
3949 db44 dd 41                        STD  V41            ; = VARIABLE = 7 BYTES) AND SAVE AT V41
3950 db46 9e 1d                        LDX  ARYTAB         ; * GET END OF VARIABLES AND SAVE AT V47
3951 db48 9f 47                        STX  V47            ; *
3952 db4a bd d3 de                     JSR  LAC1E          ; MAKE A SEVEN BYTE SLOT FOR NEW VARIABLE AT
3953                         *         TOP  OF VARIABLES
3954 db4d 9e 41                        LDX  V41            ; = GET NEW END OF ARRAYS AND SAVE IT
3955 db4f 9f 1f                        STX  ARYEND         ; =
3956 db51 9e 45                        LDX  V45            ; * GET NEW END OF VARIABLES AND SAVE IT
3957 db53 9f 1d                        STX  ARYTAB         ; *
3958 db55 9e 47                        LDX  V47            ; GET OLD END OF VARIABLES
3959 db57 dc 37                        LDD  VARNAM         ; GET NEW VARIABLE NAME
3960 db59 ed 81                        STD  ,X++           ; SAVE VARIABLE NAME
3961 db5b 4f                           CLRA                ; * ZERO OUT THE FP VALUE OF THE NUMERIC
3962 db5c 5f                           CLRB                ; * VARIABLE OR THE LENGTH AND ADDRESS
3963 db5d ed 84                        STD  ,X             ; * OF A STRING VARIABLE
3964 db5f ed 02                        STD  2,X            ; *
3965 db61 a7 04                        STA  4,X            ; *
3966 db63 9f 39              LB3DC     STX  VARPTR         ; STORE ADDRESS OF VARIABLE VALUE
3967 db65 39                 LB3DE     RTS
3968                         *
3969 db66 90 80 00 00 00     LB3DF     FCB  $90,$80,$00,$00,$00 ; * FLOATING POINT -32768
3970                         *                             ; SMALLEST SIGNED TWO BYTE INTEGER
3971                         *
3972 db6b 9d 7c              LB3E4     JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
3973 db6d bd d8 cd           LB3E6     JSR  LB141          ; GO EVALUATE NUMERIC EXPRESSION
3974 db70 96 54              LB3E9     LDA  FP0SGN         ; GET FPA0 MANTISSA SIGN
3975 db72 2b 5d                        BMI  LB44A          ; 'FC' ERROR IF NEGATIVE NUMBER
3976                         
3977                         
3978 db74 bd d8 cf           INTCNV    JSR  LB143          ; 'TM' ERROR IF STRING VARIABLE
3979 db77 96 4f                        LDA  FP0EXP         ; GET FPA0 EXPONENT
3980 db79 81 90                        CMPA #$90           ; * COMPARE TO 32768 - LARGEST INTEGER EXPONENT AND
3981 db7b 25 08                        BCS  LB3FE          ; * BRANCH IF FPA0 < 32768
3982 db7d 8e db 66                     LDX  #LB3DF         ; POINT X TO FP VALUE OF -32768
3983 db80 bd e3 e2                     JSR  LBC96          ; COMPARE -32768 TO FPA0
3984 db83 26 4c                        BNE  LB44A          ; 'FC' ERROR IF NOT =
3985 db85 bd e4 14           LB3FE     JSR  LBCC8          ; CONVERT FPA0 TO A TWO BYTE INTEGER
3986 db88 dc 52                        LDD  FPA0+2         ; GET THE INTEGER
3987 db8a 39                           RTS
3988                         * EVALUATE AN ARRAY VARIABLE
3989 db8b dc 05              LB404     LDD  DIMFLG         ; GET ARRAY FLAG AND VARIABLE TYPE
3990 db8d 34 06                        PSHS B,A            ; SAVE THEM ON STACK
3991 db8f 12                           NOP                 ; DEAD SPACE CAUSED BY 1.2 REVISION
3992 db90 5f                           CLRB                ; RESET DIMENSION COUNTER
3993 db91 9e 37              LB40A     LDX  VARNAM         ; GET VARIABLE NAME
3994 db93 34 14                        PSHS X,B            ; SAVE VARIABLE NAME AND DIMENSION COUNTER
3995 db95 8d d4                        BSR  LB3E4          ; EVALUATE EXPRESSION (DIMENSlON LENGTH)
3996 db97 35 34                        PULS B,X,Y          ; PULL OFF VARIABLE NAME, DIMENSlON COUNTER,
3997                         *                             ; ARRAY FLAG
3998 db99 9f 37                        STX  VARNAM         ; SAVE VARIABLE NAME AND VARIABLE TYPE
3999 db9b de 52                        LDU  FPA0+2         ; GET DIMENSION LENGTH
4000 db9d 34 60                        PSHS U,Y            ; SAVE DIMENSION LENGTH, ARRAY FLAG, VARIABLE TYPE
4001 db9f 5c                           INCB                ; INCREASE DIMENSION COUNTER
4002 dba0 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4003 dba2 81 2c                        CMPA #',            ; CHECK FOR ANOTHER DIMENSION
4004 dba4 27 eb                        BEQ  LB40A          ; BRANCH IF MORE
4005 dba6 d7 03                        STB  TMPLOC         ; SAVE DIMENSION COUNTER
4006 dba8 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR A ')'
4007 dbab 35 06                        PULS A,B            ; * RESTORE VARIABLE TYPE AND ARRAY
4008 dbad dd 05                        STD  DIMFLG         ; * FLAG - LEAVE DIMENSION LENGTH ON STACK
4009 dbaf 9e 1d                        LDX  ARYTAB         ; GET START OF ARRAYS
4010 dbb1 9c 1f              LB42A     CMPX ARYEND         ; COMPARE TO END OF ARRAYS
4011 dbb3 27 21                        BEQ  LB44F          ; BRANCH IF NO MATCH FOUND
4012 dbb5 dc 37                        LDD  VARNAM         ; GET VARIABLE IN QUESTION
4013 dbb7 10 a3 84                     CMPD ,X             ; COMPARE TO CURRENT VARIABLE
4014 dbba 27 06                        BEQ  LB43B          ; BRANCH IF =
4015 dbbc ec 02                        LDD  2,X            ; GET OFFSET TO NEXT ARRAY VARIABLE
4016 dbbe 30 8b                        LEAX D,X            ; ADD TO CURRENT POINTER
4017 dbc0 20 ef                        BRA  LB42A          ; KEEP SEARCHING
4018 dbc2 c6 12              LB43B     LDB  #2*9           ; 'REDIMENSIONED ARRAY' ERROR
4019 dbc4 96 05                        LDA  DIMFLG         ; * TEST ARRAY FLAG - IF <>0 YOU ARE TRYING
4020 dbc6 26 0b                        BNE  LB44C          ; * TO REDIMENSION AN ARRAY
4021 dbc8 d6 03                        LDB  TMPLOC         ; GET NUMBER OF DIMENSIONS IN ARRAY
4022 dbca e1 04                        CMPB 4,X            ; COMPARE TO THIS ARRAYS DIMENSIONS
4023 dbcc 27 59                        BEQ  LB4A0          ; BRANCH IF =
4024 dbce c6 10              LB447     LDB  #8*2           ; 'BAD SUBSCRIPT'
4025 dbd0 8c                           FCB  SKP2           ; SKIP TWO BYTES
4026 dbd1 c6 08              LB44A     LDB  #4*2           ; 'ILLEGAL FUNCTION CALL'
4027 dbd3 7e d4 06           LB44C     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
4028                         
4029                         * INSERT A NEW ARRAY INTO ARRAY VARIABLES
4030                         * EACH SET OF ARRAY VARIABLES IS PRECEEDED BY A DE-
4031                         * SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS THE
4032                         * NUMBER OF DIMENSIONS IN THE ARRAY. THE BLOCK IS DEFINED
4033                         * AS FOLLOWS: BYTES 0,1:VARIABLE'S NAME; 2,3:TOTAL LENGTH
4034                         * OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIMEN-
4035                         * ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIMEN-
4036                         * SION 2;... 4+N,5+N:LENGTH OF DIMENSION N.
4037                         
4038 dbd6 cc 00 05           LB44F     LDD  #5             ; * 5 BYTES/ARRAY ENTRY SAVE AT COEFPT
4039 dbd9 dd 64                        STD  COEFPT         ; *
4040 dbdb dc 37                        LDD  VARNAM         ; = GET NAME OF ARRAY AND SAVE IN
4041 dbdd ed 84                        STD  ,X             ; = FIRST 2 BYTES OF DESCRIPTOR
4042 dbdf d6 03                        LDB  TMPLOC         ; GET NUMBER OF DIMENSIONS AND SAVE IN
4043 dbe1 e7 04                        STB  4,X            ; * 5TH BYTE OF DESCRIPTOR
4044 dbe3 bd d3 f3                     JSR  LAC33          ; CHECK FOR ROOM FOR DESCRIPTOR IN FREE RAM
4045 dbe6 9f 41                        STX  V41            ; TEMPORARILY SAVE DESCRIPTOR ADDRESS
4046 dbe8 c6 0b              LB461     LDB  #11            ; * DEFAULT DIMENSION VALUE:X(10)
4047 dbea 4f                           CLRA                ; *
4048 dbeb 0d 05                        TST  DIMFLG         ; = CHECK ARRAY FLAG AND BRANCH IF
4049 dbed 27 05                        BEQ  LB46D          ; = NOT DIMENSIONING AN ARRAY
4050 dbef 35 06                        PULS A,B            ; GET DIMENSION LENGTH
4051 dbf1 c3 00 01                     ADDD #1             ; ADD ONE (X(0) HAS A LENGTH OF ONE)
4052 dbf4 ed 05              LB46D     STD  5,X            ; SAVE LENGTH OF ARRAY DIMENSION
4053 dbf6 8d 5d                        BSR  LB4CE          ; MULTIPLY ACCUM ARRAY SIZE NUMBER LENGTH
4054                         *                             ; OF NEW DIMENSION
4055 dbf8 dd 64                        STD  COEFPT         ; TEMP STORE NEW CURRENT ACCUMULATED ARRAY SIZE
4056 dbfa 30 02                        LEAX 2,X            ; BUMP POINTER UP TWO
4057 dbfc 0a 03                        DEC  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND BRANCH IF
4058 dbfe 26 e8                        BNE  LB461          ; * NOT DONE WITH ALL DIMENSIONS
4059 dc00 9f 0f                        STX  TEMPTR         ; SAVE ADDRESS OF (END OF ARRAY DESCRIPTOR - 5)
4060 dc02 d3 0f                        ADDD TEMPTR         ; ADD TOTAL SIZE OF NEW ARRAY
4061 dc04 10 25 f7 fc                  LBCS LAC44          ; 'OM' ERROR IF > $FFFF
4062 dc08 1f 01                        TFR  D,X            ; SAVE END OF ARRAY IN X
4063 dc0a bd d3 f7                     JSR  LAC37          ; MAKE SURE THERE IS ENOUGH FREE RAM FOR ARRAY
4064 dc0d 83 00 35                     SUBD #STKBUF-5      ; SUBTRACT OUT THE (STACK BUFFER - 5)
4065 dc10 dd 1f                        STD  ARYEND         ; SAVE NEW END OF ARRAYS
4066 dc12 4f                           CLRA                ; ZERO = TERMINATOR BYTE
4067 dc13 30 1f              LB48C     LEAX -1,X           ; * STORE TWO TERMINATOR BYTES AT
4068 dc15 a7 05                        STA  5,X            ; * THE END OF THE ARRAY DESCRIPTOR
4069 dc17 9c 0f                        CMPX TEMPTR         ; *
4070 dc19 26 f8                        BNE  LB48C          ; *
4071 dc1b 9e 41                        LDX  V41            ; GET ADDRESS OF START OF DESCRIPTOR
4072 dc1d 96 1f                        LDA  ARYEND         ; GET MSB OF END OF ARRAYS; LSB ALREADY THERE
4073 dc1f 93 41                        SUBD V41            ; SUBTRACT OUT ADDRESS OF START OF DESCRIPTOR
4074 dc21 ed 02                        STD  2,X            ; SAVE LENGTH OF (ARRAY AND DESCRIPTOR)
4075 dc23 96 05                        LDA  DIMFLG         ; * GET ARRAY FLAG AND BRANCH
4076 dc25 26 2d                        BNE  LB4CD          ; * BACK IF DIMENSIONING
4077                         * CALCULATE POINTER TO CORRECT ELEMENT
4078 dc27 e6 04              LB4A0     LDB  4,X            ; GET THE NUMBER OF DIMENSIONS
4079 dc29 d7 03                        STB  TMPLOC         ; TEMPORARILY SAVE
4080 dc2b 4f                           CLRA                ; * INITIALIZE POINTER
4081 dc2c 5f                           CLRB                ; * TO ZERO
4082 dc2d dd 64              LB4A6     STD  COEFPT         ; SAVE ACCUMULATED POINTER
4083 dc2f 35 06                        PULS A,B            ; * PULL DIMENSION ARGUMENT OFF THE
4084 dc31 dd 52                        STD  FPA0+2         ; * STACK AND SAVE IT
4085 dc33 10 a3 05                     CMPD 5,X            ; COMPARE TO STORED 'DIM' ARGUMENT
4086 dc36 24 3a                        BCC  LB4EB          ; 'BS' ERROR IF > = "DIM" ARGUMENT
4087 dc38 de 64                        LDU  COEFPT         ; * GET ACCUMULATED POINTER AND
4088 dc3a 27 04                        BEQ  LB4B9          ; * BRANCH IF 1ST DIMENSION
4089 dc3c 8d 17                        BSR  LB4CE          ; = MULTIPLY ACCUMULATED POINTER AND DIMENSION
4090 dc3e d3 52                        ADDD FPA0+2         ; = LENGTH AND ADD TO CURRENT ARGUMENT
4091 dc40 30 02              LB4B9     LEAX 2,X            ; MOVE POINTER TO NEXT DIMENSION
4092 dc42 0a 03                        DEC  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND
4093 dc44 26 e7                        BNE  LB4A6          ; * BRANCH IF ANY DIMENSIONS LEFT
4094                         * MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE
4095 dc46 ed e3                        STD  ,--S
4096 dc48 58                           ASLB
4097 dc49 49                           ROLA                ; TIMES 2
4098 dc4a 58                           ASLB
4099 dc4b 49                           ROLA                ; TIMES 4
4100 dc4c e3 e1                        ADDD ,S++           ; TIMES 5
4101 dc4e 30 8b                        LEAX D,X            ; ADD OFFSET TO START OF ARRAY
4102 dc50 30 05                        LEAX 5,X            ; ADJUST POINTER FOR SIZE OF DESCRIPTOR
4103 dc52 9f 39                        STX  VARPTR         ; SAVE POINTER TO ARRAY VALUE
4104 dc54 39                 LB4CD     RTS
4105                         * MULTIPLY 2 BYTE NUMBER IN 5,X BY THE 2 BYTE NUMBER
4106                         * IN COEFPT. RETURN RESULT IN ACCD, BS ERROR IF > $FFFF
4107 dc55 86 10              LB4CE     LDA  #16            ; 16 SHIFTS TO DO A MULTIPLY
4108 dc57 97 45                        STA  V45            ; SHIFT COUNTER
4109 dc59 ec 05                        LDD  5,X            ; * GET SIZE OF DIMENSION
4110 dc5b dd 17                        STD  BOTSTK         ; * AND SAVE IT
4111 dc5d 4f                           CLRA                ; * ZERO
4112 dc5e 5f                           CLRB                ; * ACCD
4113 dc5f 58                 LB4D8     ASLB                ; = SHIFT ACCB LEFT
4114 dc60 49                           ROLA                ; = ONE BIT
4115 dc61 25 0f                        BCS  LB4EB          ; 'BS' ERROR IF CARRY
4116 dc63 08 65                        ASL  COEFPT+1       ; * SHIFT MULTIPLICAND LEFT ONE
4117 dc65 09 64                        ROL  COEFPT         ; * BIT - ADD MULTIPLIER TO ACCUMULATOR
4118 dc67 24 04                        BCC  LB4E6          ; * IF CARRY <> 0
4119 dc69 d3 17                        ADDD BOTSTK         ; ADD MULTIPLIER TO ACCD
4120 dc6b 25 05                        BCS  LB4EB          ; 'BS' ERROR IF CARRY (>$FFFF)
4121 dc6d 0a 45              LB4E6     DEC  V45            ; * DECREMENT SHIFT COUNTER
4122 dc6f 26 ee                        BNE  LB4D8          ; * IF NOT DONE
4123 dc71 39                           RTS
4124 dc72 7e db ce           LB4EB     JMP  LB447          ; 'BS' ERROR
4125                         *
4126                         * MEM
4127                         * THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE
4128                         * BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK
4129                         * FOR WHICH MEM DOES NOT ALLOW.
4130                         *
4131 dc75 1f 40              MEM       TFR  S,D            ; PUT STACK POINTER INTO ACCD
4132 dc77 93 1f                        SUBD ARYEND         ; SUBTRACT END OF ARRAYS
4133 dc79 21                           FCB  SKP1           ; SKIP ONE BYTE
4134                         *CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0
4135 dc7a 4f                 LB4F3     CLRA                ; CLEAR MS BYTE OF ACCD
4136                         * CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMBER IN FPA0
4137 dc7b 0f 06              GIVABF    CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
4138 dc7d dd 50                        STD  FPA0           ; SAVE ACCD IN TOP OF FACA
4139 dc7f c6 90                        LDB  #$90           ; EXPONENT REQUIRED IF THE TOP TWO BYTES
4140                         *         OF   FPA0 ARE TO BE TREATED AS AN INTEGER IN FPA0
4141 dc81 7e e3 ce                     JMP  LBC82          ; CONVERT THE REST OF FPA0 TO AN INTEGER
4142                         
4143                         * STR$
4144 dc84 bd d8 cf           STR       JSR  LB143          ; 'TM' ERROR IF STRING VARIABLE
4145 dc87 ce 01 f0                     LDU  #STRBUF+2      ; *CONVERT FP NUMBER TO ASCII STRING IN
4146 dc8a bd e5 28                     JSR  LBDDC          ; *THE STRING BUFFER
4147 dc8d 32 62                        LEAS 2,S            ; PURGE THE RETURN ADDRESS FROM THE STACK
4148 dc8f 8e 01 ef                     LDX  #STRBUF+1      ; *POINT X TO STRING BUFFER AND SAVE
4149 dc92 20 0b                        BRA  LB518          ; *THE STRING IN THE STRING SPACE
4150                         * RESERVE ACCB BYTES OF STRING SPACE. RETURN START
4151                         * ADDRESS IN (X) AND FRESPC
4152 dc94 9f 4d              LB50D     STX  V4D            ; SAVE X IN V4D
4153 dc96 8d 5c              LB50F     BSR  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
4154 dc98 9f 58              LB511     STX  STRDES+2       ; SAVE NEW STRING ADDRESS
4155 dc9a d7 56                        STB  STRDES         ; SAVE LENGTH OF RESERVED BLOCK
4156 dc9c 39                           RTS
4157 dc9d 30 1f              LB516     LEAX -1,X           ; MOVE POINTER BACK ONE
4158                         * SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO) OR
4159                         * EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR ENDCHR IS MATCHED.
4160                         * THE RESULTING STRING IS STORED IN THE STRING SPACE
4161                         * ONLY IF THE START OF THE STRING IS <= STRBUF+2
4162 dc9f 86 22              LB518     LDA  #'"            ; * INITIALIZE
4163 dca1 97 01                        STA  CHARAC         ; * TERMINATORS
4164 dca3 97 02              LB51A     STA  ENDCHR         ; * TO "
4165 dca5 30 01              LB51E     LEAX 1,X            ; MOVE POINTER UP ONE
4166 dca7 9f 62                        STX  RESSGN         ; TEMPORARILY SAVE START OF STRING
4167 dca9 9f 58                        STX  STRDES+2       ; SAVE START OF STRING IN TEMP DESCRIPTOR
4168 dcab c6 ff                        LDB  #-1            ; INITIALIZE CHARACTER COUNTER TO - 1
4169 dcad 5c                 LB526     INCB                ; INCREMENT CHARACTER COUNTER
4170 dcae a6 80                        LDA  ,X+            ; GET CHARACTER
4171 dcb0 27 0c                        BEQ  LB537          ; BRANCH IF END OF LINE
4172 dcb2 91 01                        CMPA CHARAC         ; * CHECK FOR TERMINATORS
4173 dcb4 27 04                        BEQ  LB533          ; * IN CHARAC AND ENDCHR
4174 dcb6 91 02                        CMPA ENDCHR         ; * DON'T MOVE POINTER BACK
4175 dcb8 26 f3                        BNE  LB526          ; * ONE IF TERMINATOR IS "MATCHED"
4176 dcba 81 22              LB533     CMPA #'"            ; = COMPARE CHARACTER TO STRING DELIMITER
4177 dcbc 27 02                        BEQ  LB539          ; = & DON'T MOVE POINTER BACK IF SO
4178 dcbe 30 1f              LB537     LEAX -1,X           ; MOVE POINTER BACK ONE
4179 dcc0 9f 64              LB539     STX  COEFPT         ; SAVE END OF STRING ADDRESS
4180 dcc2 d7 56                        STB  STRDES         ; SAVE STRING LENGTH IN TEMP DESCRIPTOR
4181 dcc4 de 62                        LDU  RESSGN         ; GET INITlAL STRING START
4182 dcc6 11 83 01 f0                  CMPU #STRBUF+2      ; COMPARE TO START OF STRING BUFFER
4183 dcca 22 07              LB543     BHI  LB54C          ; BRANCH IF > START OF STRING BUFFER
4184 dccc 8d c6                        BSR  LB50D          ; GO RESERVE SPACE FOR THE STRING
4185 dcce 9e 62                        LDX  RESSGN         ; POINT X TO THE BEGINNING OF THE STRING
4186 dcd0 bd dd cc                     JSR  LB645          ; MOVE (B) BYTES FROM (X) TO
4187                         *                             [FRESPC] - MOVE STRING DATA
4188                         * PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA
4189                         * ON THE STRING STACK. SET VARIABLE TYPE TO STRING
4190 dcd3 9e 0b              LB54C     LDX  TEMPPT         ; GET NEXT AVAILABLE STRING STACK DESCRIPTOR
4191 dcd5 8c 00 f1                     CMPX #LINHDR        ; COMPARE TO TOP OF STRING DESCRIPTOR STACK - WAS #CFNBUF
4192 dcd8 26 05                        BNE  LB558          ; FORMULA O.K.
4193 dcda c6 1e                        LDB  #15*2          ; STRING FORMULA TOO COMPLEX' ERROR
4194 dcdc 7e d4 06           LB555     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
4195 dcdf 96 56              LB558     LDA  STRDES         ; * GET LENGTH OF STRING AND SAVE IT
4196                         *         STA  ,X             ; * IN BYTE 0 OF DESCRIPTOR
4197 dce1 a7 00                        FCB  $A7,$00
4198 dce3 dc 58                        LDD  STRDES+2       ; = GET START ADDRESS OF ACTUAL STRING
4199 dce5 ed 02                        STD  2,X            ; = AND SAVE IN BYTES 2,3 OF DESCRIPTOR
4200 dce7 86 ff                        LDA  #$FF           ; * VARIABLE TYPE = STRING
4201 dce9 97 06                        STA  VALTYP         ; * SAVE IN VARIABLE TYPE FLAG
4202 dceb 9f 0d                        STX  LASTPT         ; = SAVE START OF DESCRIPTOR
4203 dced 9f 52                        STX  FPA0+2         ; = ADDRESS IN LASTPT AND FPA0
4204 dcef 30 05                        LEAX 5,X            ; 5 BYTES/STRING DESCRIPTOR
4205 dcf1 9f 0b                        STX  TEMPPT         ; NEXT AVAILABLE STRING VARIABLE DESCRIPTOR
4206 dcf3 39                           RTS
4207                         * RESERVE ACCB BYTES IN STRING STORAGE SPACE
4208                         * RETURN WITH THE STARTING ADDRESS OF THE
4209                         * RESERVED STRING SPACE IN (X) AND FRESPC
4210 dcf4 0f 07              LB56D     CLR  GARBFL         ; CLEAR STRING REORGANIZATION FLAG
4211 dcf6 4f                 LB56F     CLRA                ; * PUSH THE LENGTH OF THE
4212 dcf7 34 06                        PSHS B,A            ; * STRING ONTO THE STACK
4213 dcf9 dc 23                        LDD  STRTAB         ; GET START OF STRING VARIABLES
4214 dcfb a3 e0                        SUBD ,S+            ; SUBTRACT STRING LENGTH
4215 dcfd 10 93 21                     CMPD FRETOP         ; COMPARE TO START OF STRING STORAGE
4216 dd00 25 0a                        BCS  LB585          ; IF BELOW START, THEN REORGANIZE
4217 dd02 dd 23                        STD  STRTAB         ; SAVE NEW START OF STRING VARIABLES
4218 dd04 9e 23                        LDX  STRTAB         ; GET START OF STRING VARIABLES
4219 dd06 30 01                        LEAX 1,X            ; ADD ONE
4220 dd08 9f 25                        STX  FRESPC         ; SAVE START ADDRESS OF NEWLY RESERVED SPACE
4221 dd0a 35 84                        PULS B,PC           ; RESTORE NUMBER OF BYTES RESERVED AND RETURN
4222 dd0c c6 1a              LB585     LDB  #2*13          ; OUT OF STRING SPACE' ERROR
4223 dd0e 03 07                        COM  GARBFL         ; TOGGLE REORGANIZATiON FLAG
4224 dd10 27 ca                        BEQ  LB555          ; ERROR IF FRESHLY REORGANIZED
4225 dd12 8d 04                        BSR  LB591          ; GO REORGANIZE STRING SPACE
4226 dd14 35 04                        PULS B              ; GET BACK THE NUMBER OF BYTES TO RESERVE
4227 dd16 20 de                        BRA  LB56F          ; TRY TO RESERVE ACCB BYTES AGAIN
4228                         * REORGANIZE THE STRING SPACE
4229 dd18 9e 27              LB591     LDX  MEMSIZ         ; GET THE TOP OF STRING SPACE
4230 dd1a 9f 23              LB593     STX  STRTAB         ; SAVE TOP OF UNORGANIZED STRING SPACE
4231 dd1c 4f                           CLRA                ; * ZERO OUT ACCD
4232 dd1d 5f                           CLRB                ; * AND RESET VARIABLE
4233 dd1e dd 4b                        STD  V4B            ; * POINTER TO 0
4234 dd20 9e 21                        LDX  FRETOP         ; POINT X TO START OF STRING SPACE
4235 dd22 9f 47                        STX  V47            ; SAVE POINTER IN V47
4236 dd24 8e 00 c9                     LDX  #STRSTK        ; POINT X TO START OF STRING DESCRIPTOR STACK
4237 dd27 9c 0b              LB5A0     CMPX TEMPPT         ; COMPARE TO ADDRESS OF NEXT AVAILABLE DESCRIPTOR
4238 dd29 27 04                        BEQ  LB5A8          ; BRANCH IF TOP OF STRING STACK
4239 dd2b 8d 32                        BSR  LB5D8          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
4240 dd2d 20 f8                        BRA  LB5A0          ; KEEP CHECKING
4241 dd2f 9e 1b              LB5A8     LDX  VARTAB         ; GET THE END OF BASIC PROGRAM
4242 dd31 9c 1d              LB5AA     CMPX ARYTAB         ; COMPARE TO END OF VARIABLES
4243 dd33 27 04                        BEQ  LB5B2          ; BRANCH IF AT TOP OF VARIABLES
4244 dd35 8d 22                        BSR  LB5D2          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
4245 dd37 20 f8                        BRA  LB5AA          ; KEEP CHECKING VARIABLES
4246 dd39 9f 41              LB5B2     STX  V41            ; SAVE ADDRESS OF THE END OF VARIABLES
4247 dd3b 9e 41              LB5B4     LDX  V41            ; GET CURRENT ARRAY POINTER
4248 dd3d 9c 1f              LB5B6     CMPX ARYEND         ; COMPARE TO THE END OF ARRAYS
4249 dd3f 27 35                        BEQ  LB5EF          ; BRANCH IF AT END OF ARRAYS
4250 dd41 ec 02                        LDD  2,X            ; GET LENGTH OF ARRAY AND DESCRIPTOR
4251 dd43 d3 41                        ADDD V41            ; * ADD TO CURRENT ARRAY POINTER
4252 dd45 dd 41                        STD  V41            ; * AND SAVE IT
4253 dd47 a6 01                        LDA  1,X            ; GET 1ST CHARACTER OF VARIABLE NAME
4254 dd49 2a f0                        BPL  LB5B4          ; BRANCH IF NUMERIC ARRAY
4255 dd4b e6 04                        LDB  4,X            ; GET THE NUMBER OF DIMENSIONS IN THIS ARRAY
4256 dd4d 58                           ASLB                ; MULTIPLY BY 2
4257 dd4e cb 05                        ADDB #5             ; ADD FIVE BYTES (VARIABLE NAME, ARRAY
4258                         *                             ; LENGTH, NUMBER DIMENSIONS)
4259 dd50 3a                           ABX                 ; X NOW POINTS TO START OF ARRAY ELEMENTS
4260 dd51 9c 41              LB5CA     CMPX V41            ; AT END OF THIS ARRAY?
4261 dd53 27 e8                        BEQ  LB5B6          ; YES - CHECK FOR ANOTHER
4262 dd55 8d 08                        BSR  LB5D8          ; CHECK FOR STRING LOCATED IN
4263                         *                             ; UNORGANIZED STRING SPACE
4264 dd57 20 f8                        BRA  LB5CA          ; KEEP CHECKING ELEMENTS IN THIS ARRAY
4265 dd59 a6 01              LB5D2     LDA  1,X            ; GET F1RST BYTE OF VARIABLE NAME
4266 dd5b 30 02                        LEAX 2,X            ; MOVE POINTER TO DESCRIPTOR
4267 dd5d 2a 14                        BPL  LB5EC          ; BRANCH IF VARIABLE IS NUMERIC
4268                         * SEARCH FOR STRING - ENTER WITH X POINTING TO
4269                         * THE STRING DESCRIPTOR. IF STRING IS STORED
4270                         * BETWEEN V47 AND STRTAB, SAVE DESCRIPTOR POINTER
4271                         * IN V4B AND RESET V47 TO STRING ADDRESS
4272 dd5f e6 84              LB5D8     LDB  ,X             ; GET THE LENGTH OF THE STRING
4273 dd61 27 10                        BEQ  LB5EC          ; BRANCH IF NULL - NO STRING
4274 dd63 ec 02                        LDD  2,X            ; GET STARTING ADDRESS OF THE STRING
4275 dd65 10 93 23                     CMPD STRTAB         ; COMPARE TO THE START OF STRING VARIABLES
4276 dd68 22 09                        BHI  LB5EC          ; BRANCH IF THIS STRING IS STORED IN
4277                         *              ; THE STRING VARIABLES
4278 dd6a 10 93 47                     CMPD V47            ; COMPARE TO START OF STRING SPACE
4279 dd6d 23 04                        BLS  LB5EC          ; BRANCH IF NOT STORED IN THE STRING SPACE
4280 dd6f 9f 4b                        STX  V4B            ; SAVE VARIABLE POINTER IF STORED IN STRING SPACE
4281 dd71 dd 47                        STD  V47            ; SAVE STRING STARTING ADDRESS
4282 dd73 30 05              LB5EC     LEAX 5,X            ; MOVE TO NEXT VARIABLE DESCRIPTOR
4283 dd75 39                 LB5EE     RTS
4284 dd76 9e 4b              LB5EF     LDX  V4B            ; GET ADDRESS OF THE DESCRIPTOR FOR THE
4285                         *              ; STRING WHICH IS STORED IN THE HIGHEST RAM ADDRESS IN
4286                         *              ; THE UNORGANIZED STRING SPACE
4287 dd78 27 fb                        BEQ  LB5EE          ; BRANCH IF NONE FOUND AND REORGANIZATION DONE
4288 dd7a 4f                           CLRA                ; CLEAR MS BYTE OF LENGTH
4289 dd7b e6 84                        LDB  ,X             ; GET LENGTH OF STRING
4290 dd7d 5a                           DECB                ; SUBTRACT ONE
4291 dd7e d3 47                        ADDD V47            ; ADD LENGTH OF STRING TO ITS STARTING ADDRESS
4292 dd80 dd 43                        STD  V43            ; SAVE AS MOVE STARTING ADDRESS
4293 dd82 9e 23                        LDX  STRTAB         ; POINT X TO THE START OF ORGANIZED STRING VARIABLES
4294 dd84 9f 41                        STX  V41            ; SAVE AS MOVE ENDING ADDRESS
4295 dd86 bd d3 e0                     JSR  LAC20          ; MOVE STRING FROM CURRENT POSITION TO THE
4296                         *              ; TOP OF UNORGANIZED STRING SPACE
4297 dd89 9e 4b                        LDX  V4B            ; POINT X TO STRING DESCRIPTOR
4298 dd8b dc 45                        LDD  V45            ; * GET NEW STARTING ADDRESS OF STRING AND
4299 dd8d ed 02                        STD  2,X            ; * SAVE IT IN DESCRIPTOR
4300 dd8f 9e 45                        LDX  V45            ; GET NEW TOP OF UNORGANIZED STRING SPACE
4301 dd91 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
4302 dd93 7e dd 1a                     JMP  LB593          ; JUMP BACK AND REORGANIZE SOME MORE
4303                         
4304                         
4305 dd96 dc 52              LB60F     LDD  FPA0+2         ; * GET DESCRIPTOR ADDRESS OF STRING A
4306 dd98 34 06                        PSHS B,A            ; * AND SAVE IT ON THE STACK
4307 dd9a bd d9 af                     JSR  LB223          ; GET DESCRIPTOR ADDRESS OF STRING B
4308 dd9d bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
4309 dda0 35 10                        PULS X              ; * POINT X TO STRING A DESCRIPTOR
4310 dda2 9f 62                        STX  RESSGN         ; * ADDRESS AND SAVE IT IN RESSGN
4311 dda4 e6 84                        LDB  ,X             ; GET LENGTH OF STRING A
4312 dda6 9e 52                        LDX  FPA0+2         ; POINT X TO DESCRIPTOR OF STRING B
4313 dda8 eb 84                        ADDB ,X             ; ADD LENGTH OF STRING B TO STR1NG A
4314 ddaa 24 05                        BCC  LB62A          ; BRANCH IF LENGTH < 256
4315 ddac c6 1c                        LDB  #2*14          ; 'STRING TOO LONG' ERROR IF LENGTH > 255
4316 ddae 7e d4 06                     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
4317 ddb1 bd dc 94           LB62A     JSR  LB50D          ; RESERVE ROOM IN STRING SPACE FOR NEW STRING
4318 ddb4 9e 62                        LDX  RESSGN         ; GET DESCRIPTOR ADDRESS OF STRING A
4319 ddb6 e6 84                        LDB  ,X             ; GET LENGTH OF STRING A
4320 ddb8 8d 10                        BSR  LB643          ; MOVE STRING A INTO RESERVED BUFFER IN STRING SPACE
4321 ddba 9e 4d                        LDX  V4D            ; GET DESCRIPTOR ADDRESS OF STRING B
4322 ddbc 8d 22                        BSR  LB659          ; GET LENGTH AND ADDRESS OF STRING B
4323 ddbe 8d 0c                        BSR  LB645          ; MOVE STRING B INTO REST OF RESERVED BUFFER
4324 ddc0 9e 62                        LDX  RESSGN         ; POINT X TO DESCRIPTOR OF STRING A
4325 ddc2 8d 1c                        BSR  LB659          ; DELETE STRING A IF LAST STRING ON STRING STACK
4326 ddc4 bd dc d3                     JSR  LB54C          ; PUT STRING DESCRIPTOR ON THE STRING STACK
4327 ddc7 7e d8 f4                     JMP  LB168          ; BRANCH BACK TO EXPRESSION EVALUATION
4328                         
4329                         * MOVE (B) BYTES FROM 2,X TO FRESPC
4330 ddca ae 02              LB643     LDX  2,X            ; POINT X TO SOURCE ADDRESS
4331 ddcc de 25              LB645     LDU  FRESPC         ; POINT U TO DESTINATION ADDRESS
4332 ddce 5c                           INCB                ; COMPENSATION FOR THE DECB BELOW
4333 ddcf 20 04                        BRA  LB64E          ; GO MOVE THE BYTES
4334                         * MOVE B BYTES FROM (X) TO (U)
4335 ddd1 a6 80              LB64A     LDA  ,X+            ; * GET A SOURCE BYTE AND MOVE IT
4336 ddd3 a7 c0                        STA  ,U+            ; * TO THE DESTINATION
4337 ddd5 5a                 LB64E     DECB                ; DECREMENT BYTE COUNTER
4338 ddd6 26 f9                        BNE  LB64A          ; BRANCH IF ALL BYTES NOT MOVED
4339 ddd8 df 25                        STU  FRESPC         ; SAVE ENDING ADDRESS IN FRESPC
4340 ddda 39                           RTS
4341                         * RETURN LENGTH (ACCB) AND ADDRESS (X) OF
4342                         * STRING WHOSE DESCRIPTOR IS IN FPA0+2
4343                         * DELETE THE STRING IF IT IS THE LAST ONE
4344                         * PUT ON THE STRING STACK. REMOVE STRING FROM STRING
4345                         * SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.
4346 dddb bd d8 d2           LB654     JSR  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
4347 ddde 9e 52              LB657     LDX  FPA0+2         ; GET ADDRESS OF SELECTED STRING DESCRIPTOR
4348 dde0 e6 84              LB659     LDB  ,X             ; GET LENGTH OF STRING
4349 dde2 8d 18                        BSR  LB675          ; * CHECK TO SEE IF THIS STRING DESCRIPTOR WAS
4350 dde4 26 13                        BNE  LB672          ; * THE LAST ONE PUT ON THE STRING STACK AND
4351                         *                             ; * BRANCH IF NOT
4352 dde6 ae 07                        LDX  5+2,X          ; GET START ADDRESS OF STRING JUST REMOVED
4353 dde8 30 1f                        LEAX -1,X           ; MOVE POINTER DOWN ONE
4354 ddea 9c 23                        CMPX STRTAB         ; COMPARE TO START OF STRING VARIABLES
4355 ddec 26 08                        BNE  LB66F          ; BRANCH IF THIS STRING IS NOT AT THE BOTTOM
4356                         *                             ; OF STRING VARIABLES
4357 ddee 34 04                        PSHS B              ; SAVE LENGTH; ACCA WAS CLEARED
4358 ddf0 d3 23                        ADDD STRTAB         ; * ADD THE LENGTH OF THE JUST REMOVED STRING
4359 ddf2 dd 23                        STD  STRTAB         ; * TO THE START OF STRING VARIABLES - THIS WILL
4360                         *                             ; * REMOVE THE STRING FROM THE STRING SPACE
4361 ddf4 35 04                        PULS B              ; RESTORE LENGTH
4362 ddf6 30 01              LB66F     LEAX 1,X            ; ADD ONE TO POINTER
4363 ddf8 39                           RTS
4364 ddf9 ae 02              LB672     LDX  2,X            ; *POINT X TO ADDRESS OF STRING NOT
4365 ddfb 39                           RTS                 ; *ON THE STRING STACK
4366                         * REMOVE STRING FROM STRING STACK. ENTER WITH X
4367                         * POINTING TO A STRING DESCRIPTOR - DELETE THE
4368                         * STRING FROM STACK IF IT IS ON TOP OF THE
4369                         * STACK. IF THE STRING IS DELETED, SET THE ZERO FLAG
4370 ddfc 9c 0d              LB675     CMPX LASTPT         ; *COMPARE TO LAST USED DESCRIPTOR ADDRESS
4371 ddfe 26 07                        BNE  LB680          ; *ON THE STRING STACK, RETURN IF DESCRIPTOR
4372                         *                             ; *ADDRESS NOT ON THE STRING STACK
4373 de00 9f 0b                        STX  TEMPPT         ; SAVE LAST USED DESCRIPTOR AS NEXT AVAILABLE
4374 de02 30 1b                        LEAX -5,X           ; * MOVE LAST USED DESCRIPTOR BACK 5 BYTES
4375 de04 9f 0d                        STX  LASTPT         ; * AND SAVE AS THE LAST USED DESCRIPTOR ADDR
4376 de06 4f                           CLRA                ; SET ZERO FLAG
4377 de07 39                 LB680     RTS
4378                         
4379                         * LEN
4380 de08 8d 03              LEN       BSR  LB686          ; POINT X TO PROPER STRING AND GET LENGTH
4381 de0a 7e dc 7a           LB683     JMP  LB4F3          ; CONVERT ACCB TO FP NUMBER IN FPA0
4382                         * POINT X TO STRING ADDRESS LOAD LENGTH INTO
4383                         * ACCB. ENTER WITH THE STRING DESCRIPTOR IN
4384                         * BOTTOM TWO BYTES OF FPA0
4385 de0d 8d cc              LB686     BSR  LB654          ; GET LENGTH AND ADDRESS OF STRING
4386 de0f 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
4387 de11 5d                           TSTB                ; SET FLAGS ACCORDING TO LENGTH
4388 de12 39                           RTS
4389                         
4390                         * CHR$
4391 de13 bd de 95           CHR       JSR  LB70E          ; CONVERT FPA0 TO AN INTEGER IN ACCD
4392 de16 c6 01              LB68F     LDB  #1             ; * RESERVE ONE BYTE IN
4393 de18 bd dc f4                     JSR  LB56D          ; * THE STRING SPACE
4394 de1b 96 53                        LDA  FPA0+3         ; GET ASCII STRING VALUE
4395 de1d bd dc 98                     JSR  LB511          ; SAVE RESERVED STRING DESCRIPTOR IN TEMP DESCRIPTOR
4396 de20 a7 84                        STA  ,X             ; SAVE THE STRING (IT'S ONLY ONE BYTE)
4397 de22 32 62              LB69B     LEAS 2,S            ; PURGE THE RETURN ADDRESS OFF OF THE STACK
4398 de24 7e dc d3           LB69D     JMP  LB54C          ; PUT TEMP DESCRIPTOR DATA ONTO STRING STACK
4399                         
4400                         
4401 de27 8d 02              ASC       BSR  LB6A4          ; PUT 1ST CHARACTER OF STRING INTO ACCB
4402 de29 20 df                        BRA  LB683          ; CONVERT ACCB INTO FP NUMBER IN FPA0
4403 de2b 8d e0              LB6A4     BSR  LB686          ; POINT X TO STRING DESCRIPTOR
4404 de2d 27 5e                        BEQ  LB706          ; 'FC' ERROR IF NULL STRING
4405 de2f e6 84                        LDB  ,X             ; GET FIRST BYTE OF STRING
4406 de31 39                           RTS
4407                         
4408                         
4409 de32 8d 48              LEFT      BSR  LB6F5          ; GET ARGUMENTS FROM STACK
4410 de34 4f                 LB6AD     CLRA                ; CLEAR STRING POINTER OFFSET - OFFSET = 0 FOR LEFT$
4411 de35 e1 84              LB6AE     CMPB ,X             ; * COMPARE LENGTH PARAMETER TO LENGTH OF
4412 de37 23 03                        BLS  LB6B5          ; * STRING AND BRANCH IF LENGTH OF STRING
4413                         *                             ; >= LENGTH PARAMETER
4414 de39 e6 84                        LDB  ,X             ; USE LENGTH OF STRING OTHERWISE
4415 de3b 4f                           CLRA                ; CLEAR STRING POINTER OFFSET (0 FOR LEFT$)
4416 de3c 34 06              LB6B5     PSHS B,A            ; PUSH PARAMETERS ONTO STACK
4417 de3e bd dc 96                     JSR  LB50F          ; RESERVE ACCB BYTES IN THE STRING SPACE
4418 de41 9e 4d                        LDX  V4D            ; POINT X TO STRING DESCRIPTOR
4419 de43 8d 9b                        BSR  LB659          ; GET ADDRESS OF OLD STRING (X=ADDRESS)
4420 de45 35 04                        PULS B              ; * PULL STRING POINTER OFFSET OFF OF THE STACK
4421 de47 3a                           ABX                 ; * AND ADD IT TO STRING ADDRESS
4422 de48 35 04                        PULS B              ; PULL LENGTH PARAMETER OFF OF THE STACK
4423 de4a bd dd cc                     JSR  LB645          ; MOVE ACCB BYTES FROM (X) TO [FRESPC]
4424 de4d 20 d5                        BRA  LB69D          ; PUT TEMP STRING DESCRIPTOR ONTO THE STRING STACK
4425                         
4426                         * RIGHT$
4427 de4f 8d 2b              RIGHT     BSR  LB6F5          ; GET ARGUMENTS FROM STACK
4428 de51 a0 84                        SUBA ,X             ; ACCA=LENGTH PARAMETER - LENGTH OF OLD STRING
4429 de53 40                           NEGA                ; NOW ACCA = LENGTH OF OLD STRING
4430 de54 20 df                        BRA  LB6AE          ; PUT NEW STRING IN THE STRING SPACE
4431                         
4432                         * MID$
4433 de56 c6 ff              MID       LDB  #$FF           ; * GET DEFAULT VALUE OF LENGTH AND
4434 de58 d7 53                        STB  FPA0+3         ; * SAVE IT IN FPA0
4435 de5a 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
4436 de5c 81 29                        CMPA #')            ; ARGUMENT DELIMITER?
4437 de5e 27 05                        BEQ  LB6DE          ; YES - NO LENGTH PARAMETER GIVEN
4438 de60 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4439 de63 8d 2d                        BSR  LB70B          ; EVALUATE NUMERIC EXPRESSION (LENGTH)
4440 de65 8d 15              LB6DE     BSR  LB6F5          ; GET ARGUMENTS FROM STACK
4441 de67 27 24                        BEQ  LB706          ; 'FC' ERROR IF NULL STRING
4442 de69 5f                           CLRB                ; CLEAR LENGTH COUNTER (DEFAULT VALUE)
4443 de6a 4a                           DECA                ; *SUOTRACT ONE FROM POSITION PARAMETER (THESE
4444 de6b a1 84                        CMPA ,X             ; *ROUTINES EXPECT 1ST POSITION TO BE ZERO, NOT ONE)
4445                         *                             ; *AND COMPARE IT TO LENGTH OF OLD STRING
4446 de6d 24 cd                        BCC  LB6B5          ; IF POSITION > LENGTH OF OLD STRING, THEN NEW
4447                         *                             ; STRING WILL BE A NULL STRING
4448 de6f 1f 89                        TFR  A,B            ; SAVE ABSOLUTE POSITION PARAMETER IN ACCB
4449 de71 e0 84                        SUBB ,X             ; ACCB=POSITION-LENGTH OF OLD STRING
4450 de73 50                           NEGB                ; NOW ACCB=LENGTH OF OLDSTRING-POSITION
4451 de74 d1 53                        CMPB FPA0+3         ; *IF THE AMOUNT OF OLD STRING TO THE RIGHT OF
4452 de76 23 c4                        BLS  LB6B5          ; *POSITION IS <= THE LENGTH PARAMETER, BRANCH AND
4453                         * USE ALL OF THE STRING TO THE RIGHT OF THE POSITION
4454                         * INSTEAD OF THE LENGTH PARAMETER
4455 de78 d6 53                        LDB  FPA0+3         ; GET LENGTH OF NEW STRING
4456 de7a 20 c0                        BRA  LB6B5          ; PUT NEW STRING IN STRING SPACE
4457                         * DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY CALCULATED NUMERIC
4458                         * ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR OFF OF THE STACK
4459 de7c bd d9 f3           LB6F5     JSR  LB267          ; SYNTAX CHECK FOR A ")"
4460 de7f ee e4                        LDU  ,S             ; LOAD THE RETURN ADDRESS INTO U REGISTER
4461 de81 ae 65                        LDX  5,S            ; * GET ADDRESS OF STRING AND
4462 de83 9f 4d                        STX  V4D            ; * SAVE IT IN V4D
4463 de85 a6 64                        LDA  4,S            ; = PUT LENGTH OF STRING IN
4464 de87 e6 64                        LDB  4,S            ; = BOTH ACCA AND ACCB
4465 de89 32 67                        LEAS 7,S            ; REMOVE DESCRIPTOR AND RETURN ADDRESS FROM STACK
4466 de8b 1f 35                        TFR  U,PC           ; JUMP TO ADDRESS IN U REGISTER
4467 de8d 7e db d1           LB706     JMP  LB44A          ; 'ILLEGAL FUNCTION CALL'
4468                         * EVALUATE AN EXPRESSION - RETURN AN INTEGER IN
4469                         * ACCB - 'FC' ERROR IF EXPRESSION > 255
4470 de90 9d 7c              LB709     JSR  GETNCH         ; GET NEXT BASIC INPUT CHARACTER
4471 de92 bd d8 cd           LB70B     JSR  LB141          ; EVALUATE A NUMERIC EXPRESSION
4472 de95 bd db 70           LB70E     JSR  LB3E9          ; CONVERT FPA0 TO INTEGER IN ACCD
4473 de98 4d                           TSTA                ; TEST MS BYTE OF INTEGER
4474 de99 26 f2                        BNE  LB706          ; 'FC' ERROR IF EXPRESSION > 255
4475 de9b 0e 82                        JMP  GETCCH         ; GET CURRENT INPUT CHARACTER FROM BASIC
4476                         
4477                         * VAL
4478 de9d bd de 0d           VAL       JSR  LB686          ; POINT X TO STRING ADDRESS
4479 dea0 10 27 02 e1                  LBEQ LBA39          ; IF NULL STRING SET FPA0
4480 dea4 de 83                        LDU  CHARAD         ; SAVE INPUT POINTER IN REGISTER U
4481 dea6 9f 83                        STX  CHARAD         ; POINT INPUT POINTER TO ADDRESS OF STRING
4482 dea8 3a                           ABX                 ; MOVE POINTER TO END OF STRING TERMINATOR
4483 dea9 a6 84                        LDA  ,X             ; GET LAST BYTE OF STRING
4484 deab 34 52                        PSHS U,X,A          ; SAVE INPUT POINTER, STRING TERMINATOR
4485                         *         ADDRESS AND CHARACTER
4486 dead 6f 84                        CLR  ,X             ; CLEAR STRING TERMINATOR : FOR ASCII - FP CONVERSION
4487 deaf 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
4488 deb1 bd e4 5e                     JSR  LBD12          ; CONVERT AN ASCII STRING TO FLOATING POINT
4489 deb4 35 52                        PULS A,X,U          ; RESTORE CHARACTERS AND POINTERS
4490 deb6 a7 84                        STA  ,X             ; REPLACE STRING TERMINATOR
4491 deb8 df 83                        STU  CHARAD         ; RESTORE INPUT CHARACTER
4492 deba 39                           RTS
4493                         
4494 debb 8d 07              LB734     BSR  LB73D          ; * EVALUATE AN EXPRESSION, RETURN
4495 debd 9f 2b                        STX  BINVAL         ; * THE VALUE IN X; STORE IT IN BINVAL
4496 debf bd d9 f9           LB738     JSR  LB26D          ; SYNTAX CHECK FOR A COMMA
4497 dec2 20 ce                        BRA  LB70B          ; EVALUATE EXPRESSION IN RANGE 0 <= X < 256
4498                         * EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 'FC' ERROR IF
4499                         
4500 dec4 bd d8 cd           LB73D     JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
4501 dec7 96 54              LB740     LDA  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
4502 dec9 2b c2                        BMI  LB706          ; ILLEGAL FUNCTION CALL' IF NEGATIVE
4503 decb 96 4f                        LDA  FP0EXP         ; GET EXPONENT OF FPA0
4504 decd 81 90                        CMPA #$90           ; COMPARE TO LARGEST POSITIVE INTEGER
4505 decf 22 bc                        BHI  LB706          ; ILLEGAL FUNCTION CALL' IF TOO LARGE
4506 ded1 bd e4 14                     JSR  LBCC8          ; SHIFT BINARY POINT TO EXTREME RIGHT OF FPA0
4507 ded4 9e 52                        LDX  FPA0+2         ; LOAD X WITH LOWER TWO BYTES OF FPA0
4508 ded6 39                           RTS
4509                         
4510                         * PEEK
4511 ded7 8d ee              PEEK      BSR  LB740          ; CONVERT FPA0 TO INTEGER IN REGISTER X
4512 ded9 e6 84                        LDB  ,X             ; GET THE VALUE BEING 'PEEK'ED
4513 dedb 7e dc 7a                     JMP  LB4F3          ; CONVERT ACCB INTO A FP NUMBER
4514                         
4515                         * POKE
4516 dede 8d db              POKE      BSR  LB734          ; EVALUATE 2 EXPRESSIONS
4517 dee0 9e 2b                        LDX  BINVAL         ; GET THE ADDRESS TO BE 'POKE'ED
4518 dee2 e7 84                        STB  ,X             ; STORE THE DATA IN THAT ADDRESS
4519 dee4 39                           RTS
4520                         
4521                         
4522                         * LIST
4523 dee5 34 01              LIST      PSHS CC             ; SAVE ZERO FLAG ON STACK
4524 dee7 bd d7 17                     JSR  LAF67          ; CONVERT DECIMAL LINE NUMBER TO BINARY
4525 deea bd d4 a5                     JSR  LAD01          ; * FIND RAM ADDRESS OF THAT LINE NUMBER AND
4526 deed 9f 66                        STX  LSTTXT         ; * SAVE IT IN LSTTXT
4527 deef 35 01                        PULS CC             ; GET ZERO FLAG FROM STACK
4528 def1 27 12                        BEQ  LB784          ; BRANCH IF END OF LINE
4529 def3 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
4530 def5 27 13                        BEQ  LB789          ; BRANCH IF END OF LINE
4531 def7 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN (IS IT A RANGE OF LINE NUMBERS?)
4532 def9 26 09                        BNE  LB783          ; NO - RETURN
4533 defb 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
4534 defd 27 06                        BEQ  LB784          ; BRANCH IF END OF LINE
4535 deff bd d7 17                     JSR  LAF67          ; GET ENDING LINE NUMBER
4536 df02 27 06                        BEQ  LB789          ; BRANCH IF LEGAL LINE NUMBER
4537 df04 39                 LB783 RTS
4538                         * LIST THE ENTIRE PROGRAM
4539 df05 ce ff ff           LB784     LDU  #$FFFF         ; * SET THE DEFAULT ENDING LINE NUMBER
4540 df08 df 2b                        STU  BINVAL         ; * TO $FFFF
4541 df0a 32 62              LB789     LEAS 2,S            ; PURGE RETURN ADDRESS FROM THE STACK
4542 df0c 9e 66                        LDX  LSTTXT         ; POINT X TO STARTING LINE ADDRESS
4543 df0e bd e0 ac           LB78D     JSR  LB95C          ; MOVE CURSOR TO START OF A NEW LINE
4544 df11 bd d1 9a                     JSR  LA549          ; CHECK FOR A BREAK OR PAUSE
4545 df14 ec 84                        LDD  ,X             ; GET ADDRESS OF NEXT BASIC LINE
4546 df16 26 03                        BNE  LB79F          ; BRANCH IF NOT END OF PROGRAM
4547                         LB797
4548 df18 7e d4 25                     JMP  LAC73          ; RETURN TO BASIC'S MAIN INPUT LOOP
4549 df1b 9f 66              LB79F     STX  LSTTXT         ; SAVE NEW STARTING LINE ADDRESS
4550 df1d ec 02                        LDD  2,X            ; * GET THE LINE NUMBER OF THIS LINE AND
4551 df1f 10 93 2b                     CMPD BINVAL         ; * COMPARE IT TO ENDING LINE NUMBER
4552 df22 22 f4                        BHI  LB797          ; EXIT IF LINE NUMBER > ENDING LINE NUMBER
4553 df24 bd e5 18                     JSR  LBDCC          ; PRINT THE NUMBER IN ACCD ON SCREEN IN DECIMAL
4554 df27 bd e0 f8                     JSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
4555 df2a 9e 66                        LDX  LSTTXT         ; GET RAM ADDRESS OF THIS LINE
4556 df2c 8d 10                        BSR  LB7C2          ; UNCRUNCH A LINE
4557 df2e ae 9f 00 66                  LDX  [LSTTXT]       ; POINT X TO START OF NEXT LINE
4558 df32 ce 00 f4                     LDU  #LINBUF+1      ; POINT U TO BUFFER FULL OF UNCRUNCHED LINE
4559 df35 a6 c0              LB7B9     LDA  ,U+            ; GET A BYTE FROM THE BUFFER
4560 df37 27 d5                        BEQ  LB78D          ; BRANCH IF END OF BUFFER
4561 df39 bd e0 fd                     JSR  LB9B1          ; SEND CHARACTER TO CONSOLE OUT
4562 df3c 20 f7                        BRA  LB7B9          ; GET ANOTHER CHARACTER
4563                         
4564                         * UNCRUNCH A LINE INTO BASIC'S LINE INPUT BUFFER
4565 df3e 30 04              LB7C2     LEAX 4,X            ; MOVE POINTER PAST ADDRESS OF NEXT LINE AND LINE NUMBER
4566 df40 10 8e 00 f4                  LDY  #LINBUF+1      ; UNCRUNCH LINE INTO LINE INPUT BUFFER
4567 df44 a6 80              LB7CB     LDA  ,X+            ; GET A CHARACTER
4568 df46 27 51                        BEQ  LB820          ; BRANCH IF END OF LINE
4569 df48 2b 15                        BMI  LB7E6          ; BRANCH IF IT'S A TOKEN
4570 df4a 81 3a                        CMPA #':            ; CHECK FOR END OF SUB LINE
4571 df4c 26 0d                        BNE  LB7E2          ; BRNCH IF NOT END OF SUB LINE
4572 df4e e6 84                        LDB  ,X             ; GET CHARACTER FOLLOWING COLON
4573 df50 c1 84                        CMPB #TOK_ELSE      ; TOKEN FOR ELSE?
4574 df52 27 f0                        BEQ  LB7CB          ; YES - DON'T PUT IT IN BUFFER
4575 df54 c1 83                        CMPB #TOK_SNGL_Q    ; TOKEN FOR REMARK?
4576 df56 27 ec                        BEQ  LB7CB          ; YES - DON'T PUT IT IN BUFFER
4577 df58 8c                           FCB  SKP2           ; SKIP TWO BYTES
4578 df59 86 21              LB7E0     LDA  #'!            ; EXCLAMATION POINT
4579 df5b 8d 30              LB7E2     BSR  LB814          ; PUT CHARACTER IN BUFFER
4580 df5d 20 e5                        BRA  LB7CB          ; GET ANOTHER CHARACTER
4581                         
4582 df5f ce d0 e7           LB7E6     LDU  #COMVEC-10     ; FIRST DO COMMANDS
4583 df62 81 ff                        CMPA #$FF           ; CHECK FOR SECONDARY TOKEN
4584 df64 26 04                        BNE  LB7F1          ; BRANCH IF NON SECONDARY TOKEN
4585 df66 a6 80                        LDA  ,X+            ; GET SECONDARY TOKEN
4586 df68 33 45                        LEAU 5,U            ; BUMP IT UP TO SECONDARY FUNCTIONS
4587 df6a 84 7f              LB7F1     ANDA #$7F           ; MASK OFF BIT 7 OF TOKEN
4588 df6c 33 4a              LB7F3     LEAU 10,U           ; MOVE TO NEXT COMMAND TABLE
4589 df6e 6d c4                        TST  ,U             ; IS THIS TABLE ENABLED?
4590 df70 27 e7                        BEQ  LB7E0          ; NO - ILLEGAL TOKEN
4591 df72 a0 c4                        SUBA ,U             ; SUBTRACT THE NUMBER OF TOKENS FROM THE CURRENT TOKEN NUMBER
4592 df74 2a f6                        BPL  LB7F3          ; BRANCH IF TOKEN NOT IN THIS TABLE
4593 df76 ab c4                        ADDA ,U             ; RESTORE TOKEN NUMBER RELATIVE TO THIS TABLE
4594 df78 ee 41                        LDU  1,U            ; POINT U TO COMMAND DICTIONARY TABLE
4595 df7a 4a                 LB801     DECA                ; DECREMENT TOKEN NUMBER
4596 df7b 2b 06                        BMI  LB80A          ; BRANCH IF THIS IS THE CORRECT TOKEN
4597                         * SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN
4598 df7d 6d c0              LB804     TST  ,U+            ; GRAB A BYTE
4599 df7f 2a fc                        BPL  LB804          ; BRANCH IF BIT 7 NOT SET
4600 df81 20 f7                        BRA  LB801          ; GO SEE IF THIS IS THE CORRECT TOKEN
4601 df83 a6 c4              LB80A     LDA  ,U             ; GET A CHARACTER FROM DICTIONARY TABLE
4602 df85 8d 06                        BSR  LB814          ; PUT CHARACTER IN BUFFER
4603 df87 6d c0                        TST  ,U+            ; CHECK FOR START OF NEXT TOKEN
4604 df89 2a f8                        BPL  LB80A          ; BRANCH IF NOT DONE WITH THIS TOKEN
4605 df8b 20 b7                        BRA  LB7CB          ; GO GET ANOTHER CHARACTER
4606 df8d 10 8c 01 ed        LB814     CMPY #LINBUF+LBUFMX ; TEST FOR END OF LINE INPUT BUFFER
4607 df91 24 06                        BCC  LB820          ; BRANCH IF AT END OF BUFFER
4608 df93 84 7f                        ANDA #$7F           ; MASK OFF BIT 7
4609 df95 a7 a0                        STA  ,Y+            ; * SAVE CHARACTER IN BUFFER AND
4610 df97 6f a4                        CLR  ,Y             ; * CLEAR NEXT CHARACTER SLOT IN BUFFER
4611 df99 39                 LB820     RTS
4612                         *
4613                         * CRUNCH THE LINE THAT THE INPUT POINTER IS
4614                         * POINTING TO INTO THE LINE INPUT BUFFER
4615                         * RETURN LENGTH OF CRUNCHED LINE IN ACCD
4616                         *
4617 df9a 9e 83              LB821     LDX  CHARAD         ; GET BASIC'S INPUT POINTER ADDRESS
4618 df9c ce 00 f3                     LDU  #LINBUF        ; POINT X TO LINE INPUT BUFFER
4619 df9f 0f 43              LB829     CLR  V43            ; CLEAR ILLEGAL TOKEN FLAG
4620 dfa1 0f 44                        CLR  V44            ; CLEAR DATA FLAG
4621 dfa3 a6 80              LB82D     LDA  ,X+            ; GET INPUT CHAR
4622 dfa5 27 21                        BEQ  LB852          ; BRANCH IF END OF LINE
4623 dfa7 0d 43                        TST  V43            ; * CHECK ILLEGAL TOKEN FLAG & BRANCH IF NOT
4624 dfa9 27 0f                        BEQ  LB844          ; * PROCESSING AN ILLEGAL TOKEN
4625 dfab bd db 29                     JSR  LB3A2          ; SET CARRY IF NOT UPPER CASE ALPHA
4626 dfae 24 18                        BCC  LB852          ; BRANCH IF UPPER CASE ALPHA
4627 dfb0 81 30                        CMPA #'0            ; * DON'T CRUNCH ASCII NUMERIC CHARACTERS
4628 dfb2 25 04                        BLO  LB842          ; * BRANCH IF NOT NUMERIC
4629 dfb4 81 39                        CMPA #'9            ; *
4630 dfb6 23 10                        BLS  LB852          ; * BRANCH IF NUMERIC
4631                         * END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC
4632 dfb8 0f 43              LB842     CLR  V43            ; CLEAR ILLEGAL TOKEN FLAG
4633 dfba 81 20              LB844     CMPA #SPACE         ; SPACE?
4634 dfbc 27 0a                        BEQ  LB852          ; DO NOT REMOVE SPACES
4635 dfbe 97 42                        STA  V42            ; SAVE INPUT CHARACTER AS SCAN DELIMITER
4636 dfc0 81 22                        CMPA #'"            ; CHECK FOR STRING DELIMITER
4637 dfc2 27 38                        BEQ  LB886          ; BRANCH IF STRING
4638 dfc4 0d 44                        TST  V44            ; * CHECK DATA FLAG AND BRANCH IF CLEAR
4639 dfc6 27 19                        BEQ  LB86B          ; * DO NOT CRUNCH DATA
4640 dfc8 a7 c0              LB852     STA  ,U+            ; SAVE CHARACTER IN BUFFER
4641 dfca 27 06                        BEQ  LB85C          ; BRANCH IF END OF LINE
4642 dfcc 81 3a                        CMPA #':            ; * CHECK FOR END OF SUBLINE
4643 dfce 27 cf                        BEQ  LB829          ; * AND RESET FLAGS IF END OF SUBLINE
4644 dfd0 20 d1              LB85A     BRA  LB82D          ; GO GET ANOTHER CHARACTER
4645 dfd2 6f c0              LB85C     CLR  ,U+            ; * DOUBLE ZERO AT END OF LINE
4646 dfd4 6f c0                        CLR  ,U+            ; *
4647 dfd6 1f 30                        TFR  U,D            ; SAVE ADDRESS OF END OF LINE IN ACCD
4648 dfd8 83 00 f1                     SUBD #LINHDR        ; LENGTH OF LINE IN ACCD
4649 dfdb 8e 00 f2                     LDX  #LINBUF-1      ; * SET THE INPUT POINTER TO ONE BEFORE
4650 dfde 9f 83                        STX  CHARAD         ; * THE START OF THE CRUNCHED LINE
4651 dfe0 39                           RTS                 ; EXIT 'CRUNCH'
4652 dfe1 81 3f              LB86B     CMPA #'?            ; CHECK FOR "?" - PRINT ABBREVIATION
4653 dfe3 26 04                        BNE  LB873          ; BRANCH IF NOT PRINT ABBREVIATION
4654 dfe5 86 87                        LDA  #TOK_PRINT     ; * GET THE PRINT TOKEN AND SAVE IT
4655 dfe7 20 df                        BRA  LB852          ; * IN BUFFER
4656 dfe9 81 27              LB873     CMPA #''            ; APOSTROPHE IS SAME AS REM
4657 dfeb 26 13                        BNE  LB88A          ; BRANCH IF NOT REMARK
4658 dfed cc 3a 83                     LDD  #$3A00+TOK_SNGL_Q ; COLON, REM TOKEN
4659 dff0 ed c1                        STD  ,U++           ; SAVE IN BUFFER
4660 dff2 0f 42              LB87C     CLR  V42            ; SET DELIMITER = 0 (END OF LINE)
4661 dff4 a6 80              LB87E     LDA  ,X+            ; SCAN TILL WE MATCH [V42]
4662 dff6 27 d0                        BEQ  LB852          ; BRANCH IF END OF LINE
4663 dff8 91 42                        CMPA V42            ; DELIMITER?
4664 dffa 27 cc                        BEQ  LB852          ; BRANCH OUT IF SO
4665 dffc a7 c0              LB886     STA  ,U+            ; DON'T CRUNCH REMARKS OR STRINGS
4666 dffe 20 f4                        BRA  LB87E          ; GO GET MORE STRING OR REMARK
4667 e000 81 30              LB88A     CMPA #'0            ; * LESS THAN ASCII ZERO?
4668 e002 25 04                        BCS  LB892          ; * BRANCH IF SO
4669 e004 81 3c                        CMPA #';+1          ; = CHECK FOR NUMERIC VALUE, COLON OR SEMICOLON
4670 e006 25 c0                        BCS  LB852          ; = AND INSERT IN BUFFER IF SO
4671 e008 30 1f              LB892     LEAX -1,X           ; MOVE INPUT POINTER BACK ONE
4672 e00a 34 50                        PSHS U,X            ; SAVE POINTERS TO INPUT STRING, OUTPUT STRING
4673 e00c 0f 41                        CLR  V41            ; TOKEN FLAG 0 = COMMAND, FF = SECONDARY
4674 e00e ce d0 e7                     LDU  #COMVEC-10     ; POINT U TO COMMAND INTERPRETATION
4675                         *                             ; TABLE FOR BASIC - 10
4676 e011 0f 42              LB89B     CLR  V42            ; INITIALIZE V42 AS TOKEN COUNTER
4677 e013 33 4a              LB89D     LEAU 10,U           ; MOVE TO NEXT COMMAND INTERPRETATION TABLE
4678 e015 a6 c4                        LDA  ,U             ; GET NUMBER OF COMMANDS
4679 e017 27 31                        BEQ  LB8D4          ; GO DO SECONDARY FUNCTIONS IF NO COMMAND TABLE
4680 e019 10 ae 41                     LDY  1,U            ; POINT Y TO COMMAND DICTIONARY TABLE
4681 e01c ae e4              LB8A6     LDX  ,S             ; GET POINTER TO INPUT STRING
4682 e01e e6 a0              LB8A8     LDB  ,Y+            ; GET A BYTE FROM DICTIONARY TABLE
4683 e020 e0 80                        SUBB ,X+            ; SUBTRACT INPUT CHARACTER
4684 e022 27 fa                        BEQ  LB8A8          ; LOOP IF SAME
4685 e024 c1 80                        CMPB #$80           ; LAST CHAR IN RESERVED WORD TABLE HAD
4686                         *                             ; BIT 7 SET, SO IF WE HAVE $80 HERE
4687                         *                             ; THEN IT IS A GOOD COMPARE
4688 e026 26 38                        BNE  LB8EA          ; BRANCH IF NO MATCH - CHECK ANOTHER COMMAND
4689 e028 32 62                        LEAS 2,S            ; DELETE OLD INPUT POINTER FROM STACK
4690 e02a 35 40                        PULS U              ; GET POINTER TO OUTPUT STRING
4691 e02c da 42                        ORB  V42            ; OR IN THE TABLE POSITION TO MAKE THE TOKEN
4692                         *                             ; - NOTE THAT B ALREADY HAD $80 IN IT -
4693 e02e 96 41                        LDA  V41            ; * CHECK TOKEN FLAG AND BRANCH
4694 e030 26 06                        BNE  LB8C2          ; * IF SECONDARY
4695 e032 c1 84                        CMPB #TOK_ELSE      ; IS IT ELSE TOKEN?
4696 e034 26 06                        BNE  LB8C6          ; NO
4697 e036 86 3a                        LDA  #':            ; PUT A COLON (SUBLINE) BEFORE ELSE TOKEN
4698 e038 ed c1              LB8C2     STD  ,U++           ; SECONDARY TOKENS PRECEEDED BY $FF
4699 e03a 20 94                        BRA  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
4700 e03c e7 c0              LB8C6     STB  ,U+            ; SAVE THIS TOKEN
4701 e03e c1 86                        CMPB #TOK_DATA      ; DATA TOKEN?
4702 e040 26 02                        BNE  LB8CE          ; NO
4703 e042 0c 44                        INC  V44            ; SET DATA FLAG
4704 e044 c1 82              LB8CE     CMPB #TOK_REM       ; REM TOKEN?
4705 e046 27 aa                        BEQ  LB87C          ; YES
4706 e048 20 86              LB8D2     BRA  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
4707                         * CHECK FOR A SECONDARY TOKEN
4708 e04a ce d0 ec           LB8D4     LDU  #COMVEC-5      ; NOW DO SECONDARY FUNCTIONS
4709 e04d 03 41                        COM  V41            ; TOGGLE THE TOKEN FLAG
4710 e04f 26 c0                        BNE  LB89B          ; BRANCH IF NOW CHECKING SECONDARY COMMANDS
4711                         
4712                         * THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CRUNCHED AND SO
4713                         * IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN
4714 e051 35 50                        PULS X,U            ; RESTORE INPUT AND OUTPUT POINTERS
4715 e053 a6 80                        LDA  ,X+            ; * MOVE THE FIRST CHARACTER OF AN
4716 e055 a7 c0                        STA  ,U+            ; * ILLEGAL TOKEN
4717 e057 bd db 29                     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
4718 e05a 25 ec                        BCS  LB8D2          ; BRANCH IF NOT ALPHA
4719 e05c 03 43                        COM  V43            ; SET ILLEGAL TOKEN FLAG IF UPPER CASE ALPHA
4720 e05e 20 e8                        BRA  LB8D2          ; PROCESS MORE INPUT CHARACTERS
4721 e060 0c 42              LB8EA     INC  V42            ; INCREMENT TOKEN COUNTER
4722 e062 4a                           DECA                ; DECR COMMAND COUNTER
4723 e063 27 ae                        BEQ  LB89D          ; GET ANOTHER COMMAND TABLE IF DONE W/THIS ONE
4724 e065 31 3f                        LEAY -1,Y           ; MOVE POINTER BACK ONE
4725 e067 e6 a0              LB8F1     LDB  ,Y+            ; * GET TO NEXT
4726 e069 2a fc                        BPL  LB8F1          ; * RESERVED WORD
4727 e06b 20 af                        BRA  LB8A6          ; GO SEE IF THIS WORD IS A MATCH
4728                         
4729                         * PRINT
4730 e06d 27 39              PRINT     BEQ  LB958          ; BRANCH IF NO ARGUMENT
4731 e06f 8d 01                        BSR  LB8FE          ; CHECK FOR ALL PRINT OPTIONS
4732 e071 39                           RTS
4733                         LB8FE
4734 e072 bd ef d2           LB918     JSR  XVEC9          ; CALL EXTENDED BASIC ADD-IN
4735 e075 27 3e              LB91B     BEQ  LB965          ; RETURN IF END OF LINE
4736 e077 81 9f              LB91D     CMPA #TOK_TAB       ; TOKEN FOR TAB( ?
4737 e079 27 53                        BEQ  LB97E          ; YES
4738 e07b 81 2c                        CMPA #',            ; COMMA?
4739 e07d 27 37                        BEQ  LB966          ; YES - ADVANCE TO NEXT TAB FIELD
4740 e07f 81 3b                        CMPA #';            ; SEMICOLON?
4741 e081 27 60                        BEQ  LB997          ; YES - DO NOT ADVANCE CURSOR
4742 e083 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
4743 e086 96 06                        LDA  VALTYP         ; * GET VARIABLE TYPE AND
4744 e088 34 02                        PSHS A              ; * SAVE IT ON THE STACK
4745 e08a 26 06                        BNE  LB938          ; BRANCH IF STRING VARIABLE
4746 e08c bd e5 25                     JSR  LBDD9          ; CONVERT FP NUMBER TO AN ASCII STRING
4747 e08f bd dc 9d                     JSR  LB516          ; PARSE A STRING FROM (X-1) AND PUT
4748                         *                             ; DESCRIPTOR ON STRING STACK
4749 e092 8d 57              LB938     BSR  LB99F          ; PRINT STRING POINTED TO BY X
4750 e094 35 04                        PULS B              ; GET VARIABLE TYPE BACK
4751 e096 bd d1 33                     JSR  LA35F          ; SET UP TAB WIDTH ZONE, ETC
4752 e099 5d                 LB949     TSTB                ; CHECK CURRENT PRINT POSITION
4753 e09a 26 08                        BNE  LB954          ; BRANCH IF NOT AT START OF LINE
4754 e09c 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4755 e09e 81 2c                        CMPA #',            ; COMMA?
4756 e0a0 27 14                        BEQ  LB966          ; SKIP TO NEXT TAB FIELD
4757 e0a2 8d 54                        BSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
4758 e0a4 9d 82              LB954     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4759 e0a6 26 cf                        BNE  LB91D          ; BRANCH IF NOT END OF LINE
4760 e0a8 86 0d              LB958     LDA  #CR            ; * SEND A CR TO
4761 e0aa 20 51                        BRA  LB9B1          ; * CONSOLE OUT
4762 e0ac bd d1 33           LB95C     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
4763 e0af 27 f7                        BEQ  LB958          ; BRANCH IF WIDTH = ZERO
4764 e0b1 96 6c                        LDA  DEVPOS         ; GET PRINT POSITION
4765 e0b3 26 f3                        BNE  LB958          ; BRANCH IF NOT AT START OF LINE
4766 e0b5 39                 LB965     RTS
4767                         * SKIP TO NEXT TAB FIELD
4768 e0b6 bd d1 33           LB966     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
4769 e0b9 27 0a                        BEQ  LB975          ; BRANCH IF LINE WIDTH = 0 (CASSETTE)
4770 e0bb d6 6c                        LDB  DEVPOS         ; GET CURRENT POSITION
4771 e0bd d1 6b                        CMPB DEVLCF         ; COMPARE TO LAST TAB ZONE
4772 e0bf 25 06                        BCS  LB977          ; BRANCH IF < LAST TAB ZONE
4773 e0c1 8d e5                        BSR  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
4774 e0c3 20 1e                        BRA  LB997          ; GET MORE DATA
4775 e0c5 d6 6c              LB975     LDB  DEVPOS         ; *
4776 e0c7 d0 6a              LB977     SUBB DEVCFW         ; * SUBTRACT TAB FIELD WIDTH FROM CURRENT
4777 e0c9 24 fc                        BCC  LB977          ; * POSITION UNTIL CARRY SET - NEGATING THE
4778 e0cb 50                           NEGB                ; * REMAINDER LEAVES THE NUMBER OF SPACES TO NEXT
4779                         *              ; * TAB ZONE IN ACCB
4780 e0cc 20 10                        BRA  LB98E          ; GO ADVANCE TO NEXT TAB ZONE
4781                         
4782                         * PRINT TAB(
4783 e0ce bd de 90           LB97E     JSR  LB709          ; EVALUATE EXPRESSION - RETURN VALUE IN B
4784 e0d1 81 29                        CMPA #')            ; * 'SYNTAX' ERROR IF NOT ')'
4785 e0d3 10 26 f9 2c                  LBNE LB277          ; *
4786 e0d7 bd d1 33                     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
4787 e0da d0 6c                        SUBB DEVPOS         ; GET DIFFERENCE OF PRINT POSITION & TAB POSITION
4788 e0dc 23 05                        BLS  LB997          ; BRANCH IF TAB POSITION < CURRENT POSITION
4789                         LB98E
4790 e0de 8d 18              LB992     BSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
4791 e0e0 5a                           DECB                ; DECREMENT DIFFERENCE COUNT
4792 e0e1 26 fb                        BNE  LB992          ; BRANCH UNTIL CURRENT POSITION = TAB POSITION
4793 e0e3 9d 7c              LB997     JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
4794 e0e5 7e e0 75                     JMP  LB91B          ; LOOK FOR MORE PRINT DATA
4795                         * COPY A STRING FROM (X) TO CONSOLE OUT
4796 e0e8 bd dc 9f           LB99C     JSR  LB518          ; PARSE A STRING FROM X AND PUT
4797                         *         DESCRIPTOR ON STRING STACK
4798 e0eb bd dd de           LB99F     JSR  LB657          ; GET LENGTH OF STRING AND REMOVE
4799                         *         DESCRIPTOR FROM STRING STACK
4800 e0ee 5c                           INCB                ; COMPENSATE FOR DECB BELOW
4801 e0ef 5a                 LB9A3     DECB                ; DECREMENT COUNTER
4802 e0f0 27 c3                        BEQ  LB965          ; EXIT ROUTINE
4803 e0f2 a6 80                        LDA  ,X+            ; GET A CHARACTER FROM X
4804 e0f4 8d 07                        BSR  LB9B1          ; SEND TO CONSOLE OUT
4805 e0f6 20 f7                        BRA  LB9A3          ; KEEP LOOPING
4806 e0f8 86 20              LB9AC     LDA  #SPACE         ; SPACE TO CONSOLE OUT
4807 e0fa 8c                           FCB  SKP2           ; SKIP NEXT TWO BYTES
4808 e0fb 86 3f              LB9AF     LDA  #'?            ; QUESTION MARK TO CONSOLE OUT
4809 e0fd 7e d0 17           LB9B1     JMP  PUTCHR         ; JUMP TO CONSOLE OUT
4810                         
4811                         * FLOATING POINT MATH PACKAGE
4812                         
4813                         * ADD .5 TO FPA0
4814 e100 8e e6 0c           LB9B4     LDX  #LBEC0         ; FLOATING POINT CONSTANT (.5)
4815 e103 20 09                        BRA  LB9C2          ; ADD .5 TO FPA0
4816                         * SUBTRACT FPA0 FROM FP NUMBER POINTED
4817                         * TO BY (X), LEAVE RESULT IN FPA0
4818 e105 bd e2 7b           LB9B9     JSR  LBB2F          ; COPY PACKED FP DATA FROM (X) TO FPA1
4819                         
4820                         * ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 FROM FPA1 (ENTER
4821                         * WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 IN ACCA)
4822 e108 03 54              LB9BC     COM  FP0SGN         ; CHANGE MANTISSA SIGN OF FPA0
4823 e10a 03 62                        COM  RESSGN         ; REVERSE RESULT SIGN FLAG
4824 e10c 20 03                        BRA  LB9C5          ; GO ADD FPA1 AND FPA0
4825                         * ADD FP NUMBER POINTED TO BY
4826                         * (X) TO FPA0 - LEAVE RESULT IN FPA0
4827 e10e bd e2 7b           LB9C2     JSR  LBB2F          ; UNPACK PACKED FP DATA FROM (X) TO
4828                         *         FPA1; RETURN EXPONENT OF FPA1 IN ACCA
4829                         
4830                         * ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO
4831                         
4832 e111 5d                 LB9C5     TSTB                ; CHECK EXPONENT OF FPA0
4833 e112 10 27 02 80                  LBEQ LBC4A          ; COPY FPA1 TO FPA0 IF FPA0 =
4834 e116 8e 00 5c                     LDX  #FP1EXP        ; POINT X TO FPA1
4835 e119 1f 89              LB9CD     TFR  A,B            ; PUT EXPONENT OF FPA1 INTO ACCB
4836 e11b 5d                           TSTB                ; CHECK EXPONENT
4837 e11c 27 6c                        BEQ  LBA3E          ; RETURN IF EXPONENT = 0 (ADDING 0 TO FPA0)
4838 e11e d0 4f                        SUBB FP0EXP         ; SUBTRACT EXPONENT OF FPA0 FROM EXPONENT OF FPA1
4839 e120 27 69                        BEQ  LBA3F          ; BRANCH IF EXPONENTS ARE EQUAL
4840 e122 25 0a                        BCS  LB9E2          ; BRANCH IF EXPONENT FPA0 > FPA1
4841 e124 97 4f                        STA  FP0EXP         ; REPLACE FPA0 EXPONENT WITH FPA1 EXPONENT
4842 e126 96 61                        LDA  FP1SGN         ; * REPLACE FPA0 MANTISSA SIGN
4843 e128 97 54                        STA  FP0SGN         ; * WITH FPA1 MANTISSA SIGN
4844 e12a 8e 00 4f                     LDX  #FP0EXP        ; POINT X TO FPA0
4845 e12d 50                           NEGB                ; NEGATE DIFFERENCE OF EXPONENTS
4846 e12e c1 f8              LB9E2     CMPB #-8            ; TEST DIFFERENCE OF EXPONENTS
4847 e130 2f 59                        BLE  LBA3F          ; BRANCH IF DIFFERENCE OF EXPONENTS <= 8
4848 e132 4f                           CLRA                ; CLEAR OVERFLOW BYTE
4849 e133 64 01                        LSR  1,X            ; SHIFT MS BYTE OF MANTISSA; BIT 7 = 0
4850 e135 bd e2 06                     JSR  LBABA          ; GO SHIFT MANTISSA OF (X) TO THE RIGHT (B) TIMES
4851 e138 d6 62              LB9EC     LDB  RESSGN         ; GET SIGN FLAG
4852 e13a 2a 0b                        BPL  LB9FB          ; BRANCH IF FPA0 AND FPA1 SIGNS ARE THE SAME
4853 e13c 63 01                        COM  1,X            ; * COMPLEMENT MANTISSA POINTED
4854 e13e 63 02                        COM  2,X            ; * TO BY (X) THE
4855 e140 63 03                        COM  3,X            ; * ADCA BELOW WILL
4856 e142 63 04                        COM  4,X            ; * CONVERT THIS OPERATION
4857 e144 43                           COMA                ; * INTO A NEG (MANTISSA)
4858 e145 89 00                        ADCA #0             ; ADD ONE TO ACCA - COMA ALWAYS SETS THE CARRY FLAG
4859                         * THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA
4860                         *
4861                         * ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0
4862 e147 97 63              LB9FB     STA  FPSBYT         ; SAVE FPA SUB BYTE
4863 e149 96 53                        LDA  FPA0+3         ; * ADD LS BYTE
4864 e14b 99 60                        ADCA FPA1+3         ; * OF MANTISSA
4865 e14d 97 53                        STA  FPA0+3         ; SAVE IN FPA0 LSB
4866 e14f 96 52                        LDA  FPA0+2         ; * ADD NEXT BYTE
4867 e151 99 5f                        ADCA FPA1+2         ; * OF MANTISSA
4868 e153 97 52                        STA  FPA0+2         ; SAVE IN FPA0
4869 e155 96 51                        LDA  FPA0+1         ; * ADD NEXT BYTE
4870 e157 99 5e                        ADCA FPA1+1         ; * OF MANTISSA
4871 e159 97 51                        STA  FPA0+1         ; SAVE IN FPA0
4872 e15b 96 50                        LDA  FPA0           ; * ADD MS BYTE
4873 e15d 99 5d                        ADCA FPA1           ; * OF MANTISSA
4874 e15f 97 50                        STA  FPA0           ; SAVE IN FPA0
4875 e161 5d                           TSTB                ; TEST SIGN FLAG
4876 e162 2a 44                        BPL  LBA5C          ; BRANCH IF FPA0 & FPA1 SIGNS WERE ALIKE
4877 e164 25 02              LBA18     BCS  LBA1C          ; BRANCH IF POSITIVE MANTISSA
4878 e166 8d 5d                        BSR  LBA79          ; NEGATE FPA0 MANTISSA
4879                         
4880                         * NORMALIZE FPA0
4881 e168 5f                 LBA1C     CLRB                ; CLEAR TEMPORARY EXPONENT ACCUMULATOR
4882 e169 96 50              LBA1D     LDA  FPA0           ; TEST MSB OF MANTISSA
4883 e16b 26 2e                        BNE  LBA4F          ; BRANCH IF <> 0
4884 e16d 96 51                        LDA  FPA0+1         ; * IF THE MSB IS
4885 e16f 97 50                        STA  FPA0           ; * 0, THEN SHIFT THE
4886 e171 96 52                        LDA  FPA0+2         ; * MANTISSA A WHOLE BYTE
4887 e173 97 51                        STA  FPA0+1         ; * AT A TIME. THIS
4888 e175 96 53                        LDA  FPA0+3         ; * IS FASTER THAN ONE
4889 e177 97 52                        STA  FPA0+2         ; * BIT AT A TIME
4890 e179 96 63                        LDA  FPSBYT         ; * BUT USES MORE MEMORY.
4891 e17b 97 53                        STA  FPA0+3         ; * FPSBYT, THE CARRY IN
4892 e17d 0f 63                        CLR  FPSBYT         ; * BYTE, REPLACES THE MATISSA LSB.
4893 e17f cb 08                        ADDB #8             ; SHIFTING ONE BYTE = 8 BIT SHIFTS; ADD 8 TO EXPONENT
4894 e181 c1 28                        CMPB #5*8           ; CHECK FOR 5 SHIFTS
4895 e183 2d e4                        BLT  LBA1D          ; BRANCH IF < 5 SHIFTS, IF > 5, THEN MANTISSA = 0
4896 e185 4f                 LBA39     CLRA                ; A ZERO EXPONENT = 0 FLOATING POINT
4897 e186 97 4f              LBA3A     STA  FP0EXP         ; ZERO OUT THE EXPONENT
4898 e188 97 54                        STA  FP0SGN         ; ZERO OUT THE MANTISSA SIGN
4899 e18a 39                 LBA3E     RTS
4900 e18b 8d 6d              LBA3F     BSR  LBAAE          ; SHIFT FPA0 MANTISSA TO RIGHT
4901 e18d 5f                           CLRB                ; CLEAR CARRY FLAG
4902 e18e 20 a8                        BRA  LB9EC
4903                         * SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7
4904                         * OF MATISSA MS BYTE = 1
4905 e190 5c                 LBA44     INCB                ; ADD ONE TO EXPONENT ACCUMULATOR
4906 e191 08 63                        ASL  FPSBYT         ; SHIFT SUB BYTE ONE LEFT
4907 e193 09 53                        ROL  FPA0+3         ; SHIFT LS BYTE
4908 e195 09 52                        ROL  FPA0+2         ; SHIFT NS BYTE
4909 e197 09 51                        ROL  FPA0+1         ; SHIFT NS BYTE
4910 e199 09 50                        ROL  FPA0           ; SHIFT MS BYTE
4911 e19b 2a f3              LBA4F     BPL  LBA44          ; BRANCH IF NOT YET NORMALIZED
4912 e19d 96 4f                        LDA  FP0EXP         ; GET CURRENT EXPONENT
4913 e19f 34 04                        PSHS B              ; SAVE EXPONENT MODIFIER CAUSED BY NORMALIZATION
4914 e1a1 a0 e0                        SUBA ,S+            ; SUBTRACT ACCUMULATED EXPONENT MODIFIER
4915 e1a3 97 4f                        STA  FP0EXP         ; SAVE AS NEW EXPONENT
4916 e1a5 23 de                        BLS  LBA39          ; SET FPA0 = 0 IF THE NORMALIZATION CAUSED
4917                         *         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE
4918                         *         SIZE OF THE EXPONENT
4919 e1a7 8c                           FCB  SKP2           ; SKIP 2 BYTES
4920 e1a8 25 08              LBA5C     BCS  LBA66          ; BRANCH IF MANTISSA OVERFLOW
4921 e1aa 08 63                        ASL  FPSBYT         ; SUB BYTE BIT 7 TO CARRY - USE AS ROUND-OFF
4922                         *                             ; FLAG (TRUNCATE THE REST OF SUB BYTE)
4923 e1ac 86 00                        LDA  #0             ; CLRA, BUT DO NOT CHANGE CARRY FLAG
4924 e1ae 97 63                        STA  FPSBYT         ; CLEAR THE SUB BYTE
4925 e1b0 20 0c                        BRA  LBA72          ; GO ROUND-OFF RESULT
4926 e1b2 0c 4f              LBA66     INC  FP0EXP         ; INCREMENT EXPONENT - MULTIPLY BY 2
4927 e1b4 27 28                        BEQ  LBA92          ; OVERFLOW ERROR IF CARRY PAST $FF
4928 e1b6 06 50                        ROR  FPA0           ; * SHIFT MANTISSA
4929 e1b8 06 51                        ROR  FPA0+1         ; * ONE TO
4930 e1ba 06 52                        ROR  FPA0+2         ; * THE RIGHT -
4931 e1bc 06 53                        ROR  FPA0+3         ; * DIVIDE BY TWO
4932 e1be 24 04              LBA72     BCC  LBA78          ; BRANCH IF NO ROUND-OFF NEEDED
4933 e1c0 8d 0d                        BSR  LBA83          ; ADD ONE TO MANTISSA - ROUND OFF
4934 e1c2 27 ee                        BEQ  LBA66          ; BRANCH iF OVERFLOW - MANTISSA = 0
4935 e1c4 39                 LBA78     RTS
4936                         * NEGATE FPA0 MANTISSA
4937 e1c5 03 54              LBA79     COM  FP0SGN         ; TOGGLE SIGN OF MANTISSA
4938 e1c7 03 50              LBA7B     COM  FPA0           ; * COMPLEMENT ALL 4 MANTISSA BYTES
4939 e1c9 03 51                        COM  FPA0+1         ; *
4940 e1cb 03 52                        COM  FPA0+2         ; *
4941 e1cd 03 53                        COM  FPA0+3         ; *
4942                         * ADD ONE TO FPA0 MANTISSA
4943 e1cf 9e 52              LBA83     LDX  FPA0+2         ; * GET BOTTOM 2 MANTISSA
4944 e1d1 30 01                        LEAX 1,X            ; * BYTES, ADD ONE TO
4945 e1d3 9f 52                        STX  FPA0+2         ; * THEM AND SAVE THEM
4946 e1d5 26 06                        BNE  LBA91          ; BRANCH IF NO OVERFLOW
4947 e1d7 9e 50                        LDX  FPA0           ; * IF OVERFLOW ADD ONE
4948 e1d9 30 01                        LEAX 1,X            ; * TO TOP 2 MANTISSA
4949 e1db 9f 50                        STX  FPA0           ; * BYTES AND SAVE THEM
4950 e1dd 39                 LBA91     RTS
4951 e1de c6 0a              LBA92     LDB  #2*5           ; OV' OVERFLOW ERROR
4952 e1e0 7e d4 06                     JMP  LAC46          ; PROCESS AN ERROR
4953 e1e3 8e 00 12           LBA97     LDX  #FPA2-1        ; POINT X TO FPA2
4954                         * SHIFT FPA POINTED TO BY (X) TO
4955                         * THE RIGHT -(B) TIMES. EXIT WITH
4956                         * ACCA CONTAINING DATA SHIFTED OUT
4957                         * TO THE RIGHT (SUB BYTE) AND THE DATA
4958                         * SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY
4959 e1e6 a6 04              LBA9A     LDA  4,X            ; GET LS BYTE OF MANTISSA (X)
4960 e1e8 97 63                        STA  FPSBYT         ; SAVE IN FPA SUB BYTE
4961 e1ea a6 03                        LDA  3,X            ; * SHIFT THE NEXT THREE BYTES OF THE
4962 e1ec a7 04                        STA  4,X            ; * MANTISSA RIGHT ONE COMPLETE BYTE.
4963 e1ee a6 02                        LDA  2,X            ; *
4964 e1f0 a7 03                        STA  3,X            ; *
4965 e1f2 a6 01                        LDA  1,X            ; *
4966 e1f4 a7 02                        STA  2,X            ; *
4967 e1f6 96 5b                        LDA  FPCARY         ; GET THE CARRY IN BYTE
4968 e1f8 a7 01                        STA  1,X            ; STORE AS THE MS MANTISSA BYTE OF (X)
4969 e1fa cb 08              LBAAE     ADDB #8             ; ADD 8 TO DIFFERENCE OF EXPONENTS
4970 e1fc 2f e8                        BLE  LBA9A          ; BRANCH IF EXPONENT DIFFERENCE < -8
4971 e1fe 96 63                        LDA  FPSBYT         ; GET FPA SUB BYTE
4972 e200 c0 08                        SUBB #8             ; CAST OUT THE 8 ADDED IN ABOVE
4973 e202 27 0c                        BEQ  LBAC4          ; BRANCH IF EXPONENT DIFFERENCE = 0
4974                         
4975                         
4976 e204 67 01              LBAB8     ASR  1,X            ; * SHIFT MANTISSA AND SUB BYTE ONE BIT TO THE RIGHT
4977 e206 66 02              LBABA     ROR  2,X            ; *
4978 e208 66 03                        ROR  3,X            ; *
4979 e20a 66 04                        ROR  4,X            ; *
4980 e20c 46                           RORA                ; *
4981 e20d 5c                           INCB                ; ADD ONE TO EXPONENT DIFFERENCE
4982 e20e 26 f4                        BNE  LBAB8          ; BRANCH IF EXPONENTS NOT =
4983 e210 39                 LBAC4     RTS
4984 e211 81 00 00 00 00     LBAC5     FCB  $81,$00,$00,$00,$00 ; FLOATING POINT CONSTANT 1.0
4985                         
4986                         * ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY
4987                         * FPA0 BY (X) - RETURN PRODUCT IN FPA0
4988 e216 8d 63              LBACA     BSR  LBB2F          ; MOVE PACKED FPA FROM (X) TO FPA1
4989 e218 27 60              LBACC     BEQ  LBB2E          ; BRANCH IF EXPONENT OF FPA0 = 0
4990 e21a 8d 78                        BSR  LBB48          ; CALCULATE EXPONENT OF PRODUCT
4991                         * MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE
4992                         * HIGH ORDER BYTES OF PRODUCT IN FPA0. THE
4993                         * LOW ORDER FOUR BYTES OF THE PRODUCT WILL
4994                         * BE STORED IN VAB-VAE.
4995 e21c 86 00              LBAD0     LDA  #0             ; * ZERO OUT MANTISSA OF FPA2
4996 e21e 97 13                        STA  FPA2           ; *
4997 e220 97 14                        STA  FPA2+1         ; *
4998 e222 97 15                        STA  FPA2+2         ; *
4999 e224 97 16                        STA  FPA2+3         ; *
5000 e226 d6 53                        LDB  FPA0+3         ; GET LS BYTE OF FPA0
5001 e228 8d 22                        BSR  LBB00          ; MULTIPLY BY FPA1
5002 e22a d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 4
5003 e22c d7 8b                        STB  VAE            ; *
5004 e22e d6 52                        LDB  FPA0+2         ; GET NUMBER 3 MANTISSA BYTE OF FPA0
5005 e230 8d 1a                        BSR  LBB00          ; MULTIPLY BY FPA1
5006 e232 d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 3
5007 e234 d7 8a                        STB  VAD            ; *
5008 e236 d6 51                        LDB  FPA0+1         ; GET NUMBER 2 MANTISSA BYTE OF FPA0
5009 e238 8d 12                        BSR  LBB00          ; MULTIPLY BY FPA1
5010 e23a d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 2
5011 e23c d7 89                        STB  VAC            ; *
5012 e23e d6 50                        LDB  FPA0           ; GET MS BYTE OF FPA0 MANTISSA
5013 e240 8d 0c                        BSR  LBB02          ; MULTIPLY BY FPA1
5014 e242 d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 1
5015 e244 d7 88                        STB  VAB            ; *
5016 e246 bd e3 57                     JSR  LBC0B          ; COPY MANTISSA FROM FPA2 TO FPA0
5017 e249 7e e1 68                     JMP  LBA1C          ; NORMALIZE FPA0
5018 e24c 27 95              LBB00     BEQ  LBA97          ; SHIFT FPA2 ONE BYTE TO RIGHT
5019 e24e 43                 LBB02     COMA                ; SET CARRY FLAG
5020                         * MULTIPLY FPA1 MANTISSA BY ACCB AND
5021                         * ADD PRODUCT TO FPA2 MANTISSA
5022 e24f 96 13              LBB03     LDA  FPA2           ; GET FPA2 MS BYTE
5023 e251 56                           RORB                ; ROTATE CARRY FLAG INTO SHIFT COUNTER;
5024                         *         DATA BIT INTO CARRY
5025 e252 27 26                        BEQ  LBB2E          ; BRANCH WHEN 8 SHIFTS DONE
5026 e254 24 16                        BCC  LBB20          ; DO NOT ADD FPA1 IF DATA BIT = 0
5027 e256 96 16                        LDA  FPA2+3         ; * ADD MANTISSA LS BYTE
5028 e258 9b 60                        ADDA FPA1+3         ; *
5029 e25a 97 16                        STA  FPA2+3         ; *
5030 e25c 96 15                        LDA  FPA2+2         ; = ADD MANTISSA NUMBER 3 BYTE
5031 e25e 99 5f                        ADCA FPA1+2         ; =
5032 e260 97 15                        STA  FPA2+2         ; =
5033 e262 96 14                        LDA  FPA2+1         ; * ADD MANTISSA NUMBER 2 BYTE
5034 e264 99 5e                        ADCA FPA1+1         ; *
5035 e266 97 14                        STA  FPA2+1         ; *
5036 e268 96 13                        LDA  FPA2           ; = ADD MANTISSA MS BYTE
5037 e26a 99 5d                        ADCA FPA1           ; =
5038 e26c 46                 LBB20     RORA                ; * ROTATE CARRY INTO MS BYTE
5039 e26d 97 13                        STA  FPA2           ; *
5040 e26f 06 14                        ROR  FPA2+1         ; = ROTATE FPA2 ONE BIT TO THE RIGHT
5041 e271 06 15                        ROR  FPA2+2         ; =
5042 e273 06 16                        ROR  FPA2+3         ; =
5043 e275 06 63                        ROR  FPSBYT         ; =
5044 e277 4f                           CLRA                ; CLEAR CARRY FLAG
5045 e278 20 d5                        BRA  LBB03          ; KEEP LOOPING
5046 e27a 39                 LBB2E     RTS
5047                         * UNPACK A FP NUMBER FROM (X) TO FPA1
5048 e27b ec 01              LBB2F     LDD  1,X            ; GET TWO MSB BYTES OF MANTISSA FROM
5049                         *         FPA  POINTED TO BY X
5050 e27d 97 61                        STA  FP1SGN         ; SAVE PACKED MANTISSA SIGN BYTE
5051 e27f 8a 80                        ORA  #$80           ; FORCE BIT 7 OF MSB MANTISSA = 1
5052 e281 dd 5d                        STD  FPA1           ; SAVE 2 MSB BYTES IN FPA1
5053 e283 d6 61                        LDB  FP1SGN         ; * GET PACKED MANTISSA SIGN BYTE. EOR W/FPA0
5054 e285 d8 54                        EORB FP0SGN         ; * SIGN - NEW SIGN POSITION IF BOTH OLD SIGNS ALIKE,
5055 e287 d7 62                        STB  RESSGN         ; * NEG IF BOTH OLD SIGNS DIFF. SAVE ADJUSTED
5056                         *                             ; * MANTISSA SIGN BYTE
5057 e289 ec 03                        LDD  3,X            ; = GET 2 LSB BYTES OF MANTISSA
5058 e28b dd 5f                        STD  FPA1+2         ; = AND PUT IN FPA1
5059 e28d a6 84                        LDA  ,X             ; * GET EXPONENT FROM (X) AND
5060 e28f 97 5c                        STA  FP1EXP         ; * PUT IN EXPONENT OF FPA1
5061 e291 d6 4f                        LDB  FP0EXP         ; GET EXPONENT OF FPA0
5062 e293 39                           RTS
5063                         * CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1
5064                         * ENTER WITH EXPONENT OF FPA1 IN ACCA
5065 e294 4d                 LBB48     TSTA                ; TEST EXPONENT OF FPA1
5066 e295 27 16                        BEQ  LBB61          ; PURGE RETURN ADDRESS & SET FPA0 = 0
5067 e297 9b 4f                        ADDA FP0EXP         ; ADD FPA1 EXPONENT TO FPA0 EXPONENT
5068 e299 46                           RORA                ; ROTATE CARRY INTO BIT 7; BIT 0 INTO CARRY
5069 e29a 49                           ROLA                ; SET OVERFLOW FLAG
5070 e29b 28 10                        BVC  LBB61          ; BRANCH IF EXPONENT TOO LARGE OR SMALL
5071 e29d 8b 80                        ADDA #$80           ; ADD $80 BIAS TO EXPONENT
5072 e29f 97 4f                        STA  FP0EXP         ; SAVE NEW EXPONENT
5073 e2a1 27 0c                        BEQ  LBB63          ; SET FPA0
5074 e2a3 96 62                        LDA  RESSGN         ; GET MANTISSA SIGN
5075 e2a5 97 54                        STA  FP0SGN         ; SAVE AS MANTISSA SIGN OF FPA0
5076 e2a7 39                           RTS
5077                         * IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0
5078                         * = IS NEGATIVE THEN FPA0 = 0
5079 e2a8 96 54              LBB5C     LDA  FP0SGN         ; GET MANTISSA SIGN OF FPA0
5080 e2aa 43                           COMA                ; CHANGE SIGN OF FPA0 MANTISSA
5081 e2ab 20 02                        BRA  LBB63
5082 e2ad 32 62              LBB61     LEAS 2,S            ; PURGE RETURN ADDRESS FROM STACK
5083 e2af 10 2a fe d2        LBB63     LBPL LBA39          ; ZERO FPA0 MANTISSA SIGN & EXPONENT
5084 e2b3 7e e1 de           LBB67     JMP  LBA92          ; 'OV' OVERFLOW ERROR
5085                         * FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0
5086 e2b6 bd e3 ab           LBB6A     JSR  LBC5F          ; TRANSFER FPA0 TO FPA1
5087 e2b9 27 0d                        BEQ  LBB7C          ; BRANCH IF EXPONENT = 0
5088 e2bb 8b 02                        ADDA #2             ; ADD 2 TO EXPONENT (TIMES 4)
5089 e2bd 25 f4                        BCS  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
5090 e2bf 0f 62                        CLR  RESSGN         ; CLEAR RESULT SIGN BYTE
5091 e2c1 bd e1 19                     JSR  LB9CD          ; ADD FPA1 TO FPA0 (TIMES 5)
5092 e2c4 0c 4f                        INC  FP0EXP         ; ADD ONE TO EXPONENT (TIMES 10)
5093 e2c6 27 eb                        BEQ  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
5094 e2c8 39                 LBB7C     RTS
5095 e2c9 84 20 00 00 00     LBB7D     FCB  $84,$20,$00,$00,$00 ; FLOATING POINT CONSTANT 10
5096                         * DIVIDE FPA0 BY 10
5097 e2ce bd e3 ab           LBB82     JSR  LBC5F          ; MOVE FPA0 TO FPA1
5098 e2d1 8e e2 c9                     LDX  #LBB7D         ; POINT TO FLOATING POINT CONSTANT 10
5099 e2d4 5f                           CLRB                ; ZERO MANTISSA SIGN BYTE
5100 e2d5 d7 62              LBB89     STB  RESSGN         ; STORE THE QUOTIENT MANTISSA SIGN BYTE
5101 e2d7 bd e3 60                     JSR  LBC14          ; UNPACK AN FP NUMBER FROM (X) INTO FPA0
5102 e2da 8c                           FCB  SKP2           ; SKIP TWO BYTES
5103                         * DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0
5104 e2db 8d 9e              LBB8F     BSR  LBB2F          ; GET FP NUMBER FROM (X) TO FPA1
5105                         
5106                         * ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY FPA0 (ENTER WITH
5107                         * EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY TSTA)
5108                         
5109                         * DIVIDE FPA1 BY FPA0
5110 e2dd 27 73              LBB91     BEQ  LBC06          ; '/0' DIVIDE BY ZERO ERROR
5111 e2df 00 4f                        NEG  FP0EXP         ; GET EXPONENT OF RECIPROCAL OF DIVISOR
5112 e2e1 8d b1                        BSR  LBB48          ; CALCULATE EXPONENT OF QUOTIENT
5113 e2e3 0c 4f                        INC  FP0EXP         ; INCREMENT EXPONENT
5114 e2e5 27 cc                        BEQ  LBB67          ; 'OV' OVERFLOW ERROR
5115 e2e7 8e 00 13                     LDX  #FPA2          ; POINT X TO MANTISSA OF FPA2 - HOLD
5116                         *                             ; TEMPORARY QUOTIENT IN FPA2
5117 e2ea c6 04                        LDB  #4             ; 5 BYTE DIVIDE
5118 e2ec d7 03                        STB  TMPLOC         ; SAVE BYTE COUNTER
5119 e2ee c6 01                        LDB  #1             ; SHIFT COUNTER-AND TEMPORARY QUOTIENT BYTE
5120                         * COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -
5121                         * SET CARRY FLAG IF FPA1 >= FPA0
5122 e2f0 96 50              LBBA4     LDA  FPA0           ; * COMPARE THE TWO MS BYTES
5123 e2f2 91 5d                        CMPA FPA1           ; * OF FPA0 AND FPA1 AND
5124 e2f4 26 13                        BNE  LBBBD          ; * BRANCH IF <>
5125 e2f6 96 51                        LDA  FPA0+1         ; = COMPARE THE NUMBER 2
5126 e2f8 91 5e                        CMPA FPA1+1         ; = BYTES AND
5127 e2fa 26 0d                        BNE  LBBBD          ; = BRANCH IF <>
5128 e2fc 96 52                        LDA  FPA0+2         ; * COMPARE THE NUMBER 3
5129 e2fe 91 5f                        CMPA FPA1+2         ; * BYTES AND
5130 e300 26 07                        BNE  LBBBD          ; * BRANCH IF <>
5131 e302 96 53                        LDA  FPA0+3         ; = COMPARE THE LS BYTES
5132 e304 91 60                        CMPA FPA1+3         ; = AND BRANCH
5133 e306 26 01                        BNE  LBBBD          ; = IF <>
5134 e308 43                           COMA                ; SET CARRY FLAG IF FPA0 = FPA1
5135 e309 1f a8              LBBBD     TFR  CC,A           ; SAVE CARRY FLAG STATUS IN ACCA; CARRY
5136                         *         CLEAR IF FPA0 > FPA1
5137 e30b 59                           ROLB                ; ROTATE CARRY INTO TEMPORARY QUOTIENT BYTE
5138 e30c 24 0a                        BCC  LBBCC          ; CARRY WILL BE SET AFTER 8 SHIFTS
5139 e30e e7 80                        STB  ,X+            ; SAVE TEMPORARY QUOTIENT
5140 e310 0a 03                        DEC  TMPLOC         ; DECREMENT BYTE COUNTER
5141 e312 2b 34                        BMI  LBBFC          ; BRANCH IF DONE
5142 e314 27 2e                        BEQ  LBBF8          ; BRANCH IF LAST BYTE
5143 e316 c6 01                        LDB  #1             ; RESET SHIFT COUNTER AND TEMPORARY QUOTIENT BYTE
5144 e318 1f 8a              LBBCC     TFR  A,CC           ; RESTORE CARRY FLAG AND
5145 e31a 25 0e                        BCS  LBBDE          ; BRANCH IF FPA0 =< FPA1
5146 e31c 08 60              LBBD0     ASL  FPA1+3         ; * SHIFT FPA1 MANTISSA 1 BIT TO LEFT
5147 e31e 09 5f                        ROL  FPA1+2         ; *
5148 e320 09 5e                        ROL  FPA1+1         ; *
5149 e322 09 5d                        ROL  FPA1           ; *
5150 e324 25 e3                        BCS  LBBBD          ; BRANCH IF CARRY - ADD ONE TO PARTIAL QUOTIENT
5151 e326 2b c8                        BMI  LBBA4          ; IF MSB OF HIGH ORDER MANTISSA BYTE IS
5152                         *         SET, CHECK THE MAGNITUDES OF FPA0, FPA1
5153 e328 20 df                        BRA  LBBBD          ; CARRY IS CLEAR, CHECK ANOTHER BIT
5154                         * SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1
5155 e32a 96 60              LBBDE     LDA  FPA1+3         ; * SUBTRACT THE LS BYTES OF MANTISSA
5156 e32c 90 53                        SUBA FPA0+3         ; *
5157 e32e 97 60                        STA  FPA1+3         ; *
5158 e330 96 5f                        LDA  FPA1+2         ; = THEN THE NEXT BYTE
5159 e332 92 52                        SBCA FPA0+2         ; =
5160 e334 97 5f                        STA  FPA1+2         ; =
5161 e336 96 5e                        LDA  FPA1+1         ; * AND THE NEXT
5162 e338 92 51                        SBCA FPA0+1         ; *
5163 e33a 97 5e                        STA  FPA1+1         ; *
5164 e33c 96 5d                        LDA  FPA1           ; = AND FINALLY, THE MS BYTE OF MANTISSA
5165 e33e 92 50                        SBCA FPA0           ; =
5166 e340 97 5d                        STA  FPA1           ; =
5167 e342 20 d8                        BRA  LBBD0          ; GO SHIFT FPA1
5168 e344 c6 40              LBBF8     LDB  #$40           ; USE ONLY TWO BITS OF THE LAST BYTE (FIFTH)
5169 e346 20 d0                        BRA  LBBCC          ; GO SHIFT THE LAST BYTE
5170 e348 56                 LBBFC     RORB                ; * SHIFT CARRY (ALWAYS SET HERE) INTO
5171 e349 56                           RORB                ; * BIT 5 AND MOVE
5172 e34a 56                           RORB                ; * BITS 1,0 TO BITS 7,6
5173 e34b d7 63                        STB  FPSBYT         ; SAVE SUB BYTE
5174 e34d 8d 08                        BSR  LBC0B          ; MOVE MANTISSA OF FPA2 TO FPA0
5175 e34f 7e e1 68                     JMP  LBA1C          ; NORMALIZE FPA0
5176 e352 c6 14              LBC06     LDB  #2*10          ; /0' ERROR
5177 e354 7e d4 06                     JMP  LAC46          ; PROCESS THE ERROR
5178                         * COPY MANTISSA FROM FPA2 TO FPA0
5179 e357 9e 13              LBC0B     LDX  FPA2           ; * MOVE TOP 2 BYTES
5180 e359 9f 50                        STX  FPA0           ; *
5181 e35b 9e 15                        LDX  FPA2+2         ; = MOVE BOTTOM 2 BYTES
5182 e35d 9f 52                        STX  FPA0+2         ; =
5183 e35f 39                           RTS
5184                         * COPY A PACKED FP NUMBER FROM (X) TO FPA0
5185 e360 34 02              LBC14     PSHS A              ; SAVE ACCA
5186 e362 ec 01                        LDD  1,X            ; GET TOP TWO MANTISSA BYTES
5187 e364 97 54                        STA  FP0SGN         ; SAVE MS BYTE OF MANTISSA AS MANTISSA SIGN
5188 e366 8a 80                        ORA  #$80           ; UNPACK MS BYTE
5189 e368 dd 50                        STD  FPA0           ; SAVE UNPACKED TOP 2 MANTISSA BYTES
5190 e36a 0f 63                        CLR  FPSBYT         ; CLEAR MANTISSA SUB BYTE
5191 e36c e6 84                        LDB  ,X             ; GET EXPONENT TO ACCB
5192 e36e ae 03                        LDX  3,X            ; * MOVE LAST 2
5193 e370 9f 52                        STX  FPA0+2         ; * MANTISSA BYTES
5194 e372 d7 4f                        STB  FP0EXP         ; SAVE EXPONENT
5195 e374 35 82                        PULS A,PC           ; RESTORE ACCA AND RETURN
5196                         
5197 e376 8e 00 45           LBC2A     LDX  #V45           ; POINT X TO MANTISSA OF FPA4
5198 e379 20 06                        BRA  LBC35          ; MOVE FPA0 TO FPA4
5199 e37b 8e 00 40           LBC2F     LDX  #V40           ; POINT X TO MANTISSA OF FPA3
5200 e37e 8c                           FCB  SKP2           ; SKIP TWO BYTES
5201 e37f 9e 3b              LBC33     LDX  VARDES         ; POINT X TO VARIABLE DESCRIPTOR IN VARDES
5202                         * PACK FPA0 AND MOVE IT TO ADDRESS IN X
5203 e381 96 4f              LBC35     LDA  FP0EXP         ; * COPY EXPONENT
5204 e383 a7 84                        STA  ,X             ; *
5205 e385 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN BIT
5206 e387 8a 7f                        ORA  #$7F           ; MASK THE BOTTOM 7 BITS
5207 e389 94 50                        ANDA FPA0           ; AND BIT 7 OF MANTISSA SIGN INTO BIT 7 OF MS BYTE
5208 e38b a7 01                        STA  1,X            ; SAVE MS BYTE
5209 e38d 96 51                        LDA  FPA0+1         ; * MOVE 2ND MANTISSA BYTE
5210 e38f a7 02                        STA  2,X            ; *
5211 e391 de 52                        LDU  FPA0+2         ; = MOVE BOTTOM 2 MANTISSA BYTES
5212 e393 ef 03                        STU  3,X            ; =
5213 e395 39                           RTS
5214                         * MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA
5215 e396 96 61              LBC4A     LDA  FP1SGN         ; * COPY MANTISSA SIGN FROM
5216 e398 97 54              LBC4C     STA  FP0SGN         ; * FPA1 TO FPA0
5217 e39a 9e 5c                        LDX  FP1EXP         ; = COPY EXPONENT + MS BYTE FROM
5218 e39c 9f 4f                        STX  FP0EXP         ; = FPA1 TO FPA0
5219 e39e 0f 63                        CLR  FPSBYT         ; CLEAR MANTISSA SUB BYTE
5220 e3a0 96 5e                        LDA  FPA1+1         ; * COPY 2ND MANTISSA BYTE
5221 e3a2 97 51                        STA  FPA0+1         ; * FROM FPA1 TO FPA0
5222 e3a4 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN
5223 e3a6 9e 5f                        LDX  FPA1+2         ; * COPY 3RD AND 4TH MANTISSA BYTE
5224 e3a8 9f 52                        STX  FPA0+2         ; * FROM FPA1 TO FPA0
5225 e3aa 39                           RTS
5226                         * TRANSFER FPA0 TO FPA1
5227 e3ab dc 4f              LBC5F     LDD  FP0EXP         ; * TRANSFER EXPONENT & MS BYTE
5228 e3ad dd 5c                        STD  FP1EXP         ; *
5229 e3af 9e 51                        LDX  FPA0+1         ; = TRANSFER MIDDLE TWO BYTES
5230 e3b1 9f 5e                        STX  FPA1+1         ; =
5231 e3b3 9e 53                        LDX  FPA0+3         ; * TRANSFER BOTTOM TWO BYTES
5232 e3b5 9f 60                        STX  FPA1+3         ; *
5233 e3b7 4d                           TSTA                ; SET FLAGS ACCORDING TO EXPONENT
5234 e3b8 39                           RTS
5235                         * CHECK FPA0; RETURN ACCB = 0 IF FPA0 = 0,
5236                         * ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = POSITIVE
5237 e3b9 d6 4f              LBC6D     LDB  FP0EXP         ; GET EXPONENT
5238 e3bb 27 08                        BEQ  LBC79          ; BRANCH IF FPA0 = 0
5239 e3bd d6 54              LBC71     LDB  FP0SGN         ; GET SIGN OF MANTISSA
5240 e3bf 59                 LBC73     ROLB                ; BIT 7 TO CARRY
5241 e3c0 c6 ff                        LDB  #$FF           ; NEGATIVE FLAG
5242 e3c2 25 01                        BCS  LBC79          ; BRANCH IF NEGATIVE MANTISSA
5243 e3c4 50                           NEGB                ; ACCB = 1 IF POSITIVE MANTISSA
5244 e3c5 39                 LBC79     RTS
5245                         
5246                         * SGN
5247 e3c6 8d f1              SGN       BSR  LBC6D          ; SET ACCB ACCORDING TO SIGN OF FPA0
5248                         * CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POINT NUMBER
5249 e3c8 d7 50              LBC7C     STB  FPA0           ; SAVE ACCB IN FPA0
5250 e3ca 0f 51                        CLR  FPA0+1         ; CLEAR NUMBER 2 MANTISSA BYTE OF FPA0
5251 e3cc c6 88                        LDB  #$88           ; EXPONENT REQUIRED IF FPA0 IS TO BE AN INTEGER
5252 e3ce 96 50              LBC82     LDA  FPA0           ; GET MS BYTE OF MANTISSA
5253 e3d0 80 80                        SUBA #$80           ; SET CARRY IF POSITIVE MANTISSA
5254 e3d2 d7 4f              LBC86     STB  FP0EXP         ; SAVE EXPONENT
5255 e3d4 dc 74                        LDD  ZERO           ; * ZERO OUT ACCD AND
5256 e3d6 dd 52                        STD  FPA0+2         ; * BOTTOM HALF OF FPA0
5257 e3d8 97 63                        STA  FPSBYT         ; CLEAR SUB BYTE
5258 e3da 97 54                        STA  FP0SGN         ; CLEAR SIGN OF FPA0 MANTISSA
5259 e3dc 7e e1 64                     JMP  LBA18          ; GO NORMALIZE FPA0
5260                         
5261                         * ABS
5262 e3df 0f 54              ABS       CLR  FP0SGN         ; FORCE MANTISSA SIGN OF FPA0 POSITIVE
5263 e3e1 39                           RTS
5264                         * COMPARE A PACKED FLOATING POINT NUMBER POINTED TO
5265                         * BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN
5266                         * ZERO FLAG SET AND ACCB = 0, IF EQUAL; ACCB = 1 IF
5267                         * FPA0 > (X); ACCB = $FF IF FPA0 < (X)
5268 e3e2 e6 84              LBC96     LDB  ,X             ; CHECK EXPONENT OF (X)
5269 e3e4 27 d3                        BEQ  LBC6D          ; BRANCH IF FPA = 0
5270 e3e6 e6 01                        LDB  1,X            ; GET MS BYTE OF MANTISSA OF (X)
5271 e3e8 d8 54                        EORB FP0SGN         ; EOR WITH SIGN OF FPA0
5272 e3ea 2b d1                        BMI  LBC71          ; BRANCH IF SIGNS NOT =
5273                         * COMPARE FPA0 WITH FP NUMBER POINTED TO BY (X).
5274                         * FPA0 IS NORMALIZED, (X) IS PACKED.
5275 e3ec d6 4f              LBCA0     LDB  FP0EXP         ; * GET EXPONENT OF
5276 e3ee e1 84                        CMPB ,X             ; * FPA0, COMPARE TO EXPONENT OF
5277 e3f0 26 1d                        BNE  LBCC3          ; * (X) AND BRANCH IF <>.
5278 e3f2 e6 01                        LDB  1,X            ; * GET MS BYTE OF (X), KEEP ONLY
5279 e3f4 ca 7f                        ORB  #$7F           ; * THE SIGN BIT - 'AND' THE BOTTOM 7
5280 e3f6 d4 50                        ANDB FPA0           ; * BITS OF FPA0 INTO ACCB
5281 e3f8 e1 01                        CMPB 1,X            ; = COMPARE THE BOTTOM 7 BITS OF THE MANTISSA
5282 e3fa 26 13                        BNE  LBCC3          ; = MS BYTE AND BRANCH IF <>
5283 e3fc d6 51                        LDB  FPA0+1         ; * COMPARE 2ND BYTE
5284 e3fe e1 02                        CMPB 2,X            ; * OF MANTISSA,
5285 e400 26 0d                        BNE  LBCC3          ; * BRANCH IF <>
5286 e402 d6 52                        LDB  FPA0+2         ; = COMPARE 3RD BYTE
5287 e404 e1 03                        CMPB 3,X            ; = OF MANTISSA,
5288 e406 26 07                        BNE  LBCC3          ; = BRANCH IF <>
5289 e408 d6 53                        LDB  FPA0+3         ; * SUBTRACT LS BYTE
5290 e40a e0 04                        SUBB 4,X            ; * OF (X) FROM LS BYTE OF
5291 e40c 26 01                        BNE  LBCC3          ; * FPA0, BRANCH IF <>
5292 e40e 39                           RTS                 ; RETURN IF FP (X) = FPA0
5293 e40f 56                 LBCC3     RORB                ; SHIFT CARRY TO BIT 7; CARRY SET IF FPA0 < (X)
5294 e410 d8 54                        EORB FP0SGN         ; TOGGLE SIZE COMPARISON BIT IF FPA0 IS NEGATIVE
5295 e412 20 ab                        BRA  LBC73          ; GO SET ACCB ACCORDING TO COMPARISON
5296                         * DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BINARY POINT IS TO THE RIGHT
5297                         * OF THE LEAST SIGNIFICANT BYTE OF THE MANTISSA
5298 e414 d6 4f              LBCC8     LDB  FP0EXP         ; GET EXPONENT OF FPA0
5299 e416 27 3d                        BEQ  LBD09          ; ZERO MANTISSA IF FPA0 = 0
5300 e418 c0 a0                        SUBB #$A0           ; SUBTRACT $A0 FROM FPA0 EXPONENT T THIS WILL YIELD
5301                         *                             ; THE NUMBER OF SHIFTS REQUIRED TO DENORMALIZE FPA0. WHEN
5302                         *                             ; THE EXPONENT OF FPA0 IS = ZERO, THEN THE BINARY POINT
5303                         *                             ; WILL BE TO THE RIGHT OF THE MANTISSA
5304 e41a 96 54                        LDA  FP0SGN         ; TEST SIGN OF FPA0 MANTISSA
5305 e41c 2a 05                        BPL  LBCD7          ; BRANCH IF POSITIVE
5306 e41e 03 5b                        COM  FPCARY         ; COMPLEMENT CARRY IN BYTE
5307 e420 bd e1 c7                     JSR  LBA7B          ; NEGATE MANTISSA OF FPA0
5308 e423 8e 00 4f           LBCD7     LDX  #FP0EXP        ; POINT X TO FPA0
5309 e426 c1 f8                        CMPB #-8            ; EXPONENT DIFFERENCE < -8?
5310 e428 2e 06                        BGT  LBCE4          ; YES
5311 e42a bd e1 fa                     JSR  LBAAE          ; SHIFT FPA0 RIGHT UNTIL FPA0 EXPONENT = $A0
5312 e42d 0f 5b                        CLR  FPCARY         ; CLEAR CARRY IN BYTE
5313 e42f 39                           RTS
5314 e430 0f 5b              LBCE4     CLR  FPCARY         ; CLEAR CARRY IN BYTE
5315 e432 96 54                        LDA  FP0SGN         ; * GET SIGN OF FPA0 MANTISSA
5316 e434 49                           ROLA                ; * ROTATE IT INTO THE CARRY FLAG
5317 e435 06 50                        ROR  FPA0           ; ROTATE CARRY (MANTISSA SIGN) INTO BIT 7
5318                         *                             ; OF LS BYTE OF MANTISSA
5319 e437 7e e2 06                     JMP  LBABA          ; DE-NORMALIZE FPA0
5320                         
5321                         * INT
5322                         * THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS IT WILL SHIFT THE BINARY POINT
5323                         * TO THE EXTREME RIGHT OF THE MANTISSA TO FORCE ITS EXPONENT TO BE $AO. ONCE
5324                         * THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE FOUR LEAST SIGNIFICANT
5325                         * BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUSION OF THE DE-NORMALIZATION
5326                         * ONLY THE INTEGER PORTION OF FPA0 WILL REMAIN.
5327                         *
5328 e43a d6 4f              INT       LDB  FP0EXP         ; GET EXPONENT OF FPA0
5329 e43c c1 a0                        CMPB #$A0           ; LARGEST POSSIBLE INTEGER EXPONENT
5330 e43e 24 1d                        BCC  LBD11          ; RETURN IF FPA0 >= 32768
5331 e440 8d d2                        BSR  LBCC8          ; SHIFT THE BINARY POINT ONE TO THE RIGHT OF THE
5332                         *                             ; LS BYTE OF THE FPA0 MANTISSA
5333 e442 d7 63                        STB  FPSBYT         ; ACCB = 0: ZERO OUT THE SUB BYTE
5334 e444 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN
5335 e446 d7 54                        STB  FP0SGN         ; FORCE MANTISSA SIGN TO BE POSITIVE
5336 e448 80 80                        SUBA #$80           ; SET CARRY IF MANTISSA
5337 e44a 86 a0                        LDA  #$A0           ; * GET DENORMALIZED EXPONENT AND
5338 e44c 97 4f                        STA  FP0EXP         ; * SAVE IT IN FPA0 EXPONENT
5339 e44e 96 53                        LDA  FPA0+3         ; = GET LS BYTE OF FPA0 AND
5340 e450 97 01                        STA  CHARAC         ; = SAVE IT IN CHARAC
5341 e452 7e e1 64                     JMP  LBA18          ; NORMALIZE FPA0
5342                         
5343 e455 d7 50              LBD09     STB  FPA0           ; * LOAD MANTISSA OF FPA0 WITH CONTENTS OF ACCB
5344 e457 d7 51                        STB  FPA0+1         ; *
5345 e459 d7 52                        STB  FPA0+2         ; *
5346 e45b d7 53                        STB  FPA0+3         ; *
5347 e45d 39                 LBD11     RTS                 ; *
5348                         
5349                         * CONVERT ASCII STRING TO FLOATING POINT
5350 e45e 9e 74              LBD12     LDX  ZERO           ; (X) = 0
5351 e460 9f 54                        STX  FP0SGN         ; * ZERO OUT FPA0 & THE SIGN FLAG (COEFCT)
5352 e462 9f 4f                        STX  FP0EXP         ; *
5353 e464 9f 51                        STX  FPA0+1         ; *
5354 e466 9f 52                        STX  FPA0+2         ; *
5355 e468 9f 47                        STX  V47            ; INITIALIZE EXPONENT & EXPONENT SIGN FLAG TO ZERO
5356 e46a 9f 45                        STX  V45            ; INITIALIZE RIGHT DECIMAL CTR & DECIMAL PT FLAG TO 0
5357 e46c 25 64                        BCS  LBD86          ; IF CARRY SET (NUMERIC CHARACTER), ASSUME ACCA CONTAINS FIRST
5358                         *         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE RAM HOOK
5359 e46e bd eb 9b                     JSR  XVEC19         ; CALL EXTENDED BASIC ADD-IN
5360 e471 81 2d              LBD25     CMPA #'-            ; * CHECK FOR A LEADING MINUS SIGN AND BRANCH
5361 e473 26 04                        BNE  LBD2D          ; * IF NO MINUS SIGN
5362 e475 03 55                        COM  COEFCT         ; TOGGLE SIGN; 0 = +; FF = -
5363 e477 20 04                        BRA  LBD31          ; INTERPRET THE REST OF THE STRING
5364 e479 81 2b              LBD2D     CMPA #'+            ; * CHECK FOR LEADING PLUS SlGN AND BRANCH
5365 e47b 26 04                        BNE  LBD35          ; * IF NOT A PLUS SIGN
5366 e47d 9d 7c              LBD31     JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
5367 e47f 25 51                        BCS  LBD86          ; BRANCH IF NUMERIC CHARACTER
5368 e481 81 2e              LBD35     CMPA #'.            ; DECIMAL POlNT?
5369 e483 27 28                        BEQ  LBD61          ; YES
5370 e485 81 45                        CMPA #'E            ; "E" SHORTHAND FORM (SCIENTIFIC NOTATION)?
5371 e487 26 28                        BNE  LBD65          ; NO
5372                         * EVALUATE EXPONENT OF EXPONENTIAL FORMAT
5373 e489 9d 7c                        JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
5374 e48b 25 64                        BCS  LBDA5          ; BRANCH IF NUMERIC
5375 e48d 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN?
5376 e48f 27 0e                        BEQ  LBD53          ; YES
5377 e491 81 2d                        CMPA #'-            ; ASCII MINUS?
5378 e493 27 0a                        BEQ  LBD53          ; YES
5379 e495 81 a6                        CMPA #TOK_PLUS      ; PLUS TOKEN?
5380 e497 27 08                        BEQ  LBD55          ; YES
5381 e499 81 2b                        CMPA #'+            ; ASCII PLUS?
5382 e49b 27 04                        BEQ  LBD55          ; YES
5383 e49d 20 06                        BRA  LBD59          ; BRANCH IF NO SIGN FOUND
5384 e49f 03 48              LBD53     COM  V48            ; SET EXPONENT SIGN FLAG TO NEGATIVE
5385                         * STRIP A DECIMAL NUMBER FROM BASIC LINE, CONVERT IT TO BINARY IN V47
5386 e4a1 9d 7c              LBD55     JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
5387 e4a3 25 4c                        BCS  LBDA5          ; IF NUMERIC CHARACTER, CONVERT TO BINARY
5388 e4a5 0d 48              LBD59     TST  V48            ; * CHECK EXPONENT SIGN FLAG
5389 e4a7 27 08                        BEQ  LBD65          ; * AND BRANCH IF POSITIVE
5390 e4a9 00 47                        NEG  V47            ; NEGATE VALUE OF EXPONENT
5391 e4ab 20 04                        BRA  LBD65
5392 e4ad 03 46              LBD61     COM  V46            ; *TOGGLE DECIMAL PT FLAG AND INTERPRET ANOTHER
5393 e4af 26 cc                        BNE  LBD31          ; *CHARACTER IF <> 0 - TERMINATE INTERPRETATION
5394                         *         IF   SECOND DECIMAL POINT
5395                         * ADJUST FPA0 FOR THE DECIMAL EXPONENT IN V47
5396 e4b1 96 47              LBD65     LDA  V47            ; * GET EXPONENT, SUBTRACT THE NUMBER OF
5397 e4b3 90 45                        SUBA V45            ; * PLACES TO THE RIGHT OF DECIMAL POINT
5398 e4b5 97 47                        STA  V47            ; * AND RESAVE IT.
5399 e4b7 27 12                        BEQ  LBD7F          ; EXIT ROUTINE IF ADJUSTED EXPONENT = ZERO
5400 e4b9 2a 09                        BPL  LBD78          ; BRANCH IF POSITIVE EXPONENT
5401 e4bb bd e2 ce           LBD6F     JSR  LBB82          ; DIVIDE FPA0 BY 10
5402 e4be 0c 47                        INC  V47            ; INCREMENT EXPONENT COUNTER (MULTIPLY BY 10)
5403 e4c0 26 f9                        BNE  LBD6F          ; KEEP MULTIPLYING
5404 e4c2 20 07                        BRA  LBD7F          ; EXIT ROUTINE
5405 e4c4 bd e2 b6           LBD78     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
5406 e4c7 0a 47                        DEC  V47            ; DECREMENT EXPONENT COUNTER (DIVIDE BY 10)
5407 e4c9 26 f9                        BNE  LBD78          ; KEEP MULTIPLYING
5408 e4cb 96 55              LBD7F     LDA  COEFCT         ; GET THE SIGN FLAG
5409 e4cd 2a 8e                        BPL  LBD11          ; RETURN IF POSITIVE
5410 e4cf 7e e6 35                     JMP  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0, IF NEGATIVE
5411                         *MULTIPLY FPA0 BY TEN AND ADD ACCA TO THE RESULT
5412 e4d2 d6 45              LBD86     LDB  V45            ; *GET THE RIGHT DECIMAL COUNTER AND SUBTRACT
5413 e4d4 d0 46                        SUBB V46            ; *THE DECIMAL POINT FLAG FROM IT. IF DECIMAL POINT
5414 e4d6 d7 45                        STB  V45            ; *FLAG=0, NOTHING HAPPENS. IF DECIMAL POINT FLAG IS
5415                         *                             -1, THEN RIGHT DECIMAL COUNTER IS INCREMENTED BY ONE
5416 e4d8 34 02                        PSHS A              ; SAVE NEW DIGIT ON STACK
5417 e4da bd e2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
5418 e4dd 35 04                        PULS B              ; GET NEW DIGIT BACK
5419 e4df c0 30                        SUBB #'0            ; MASK OFF ASCII
5420 e4e1 8d 02                        BSR  LBD99          ; ADD ACCB TO FPA0
5421 e4e3 20 98                        BRA  LBD31          ; GET ANOTHER CHARACTER FROM BASIC
5422 e4e5 bd e3 7b           LBD99     JSR  LBC2F          ; PACK FPA0 AND SAVE IT IN FPA3
5423 e4e8 bd e3 c8                     JSR  LBC7C          ; CONVERT ACCB TO FP NUMBER IN FPA0
5424 e4eb 8e 00 40                     LDX  #V40           ; * ADD FPA0 TO
5425 e4ee 7e e1 0e                     JMP  LB9C2          ; * FPA3
5426                         
5427                         
5428 e4f1 d6 47              LBDA5     LDB  V47
5429 e4f3 58                           ASLB                ; TIMES 2
5430 e4f4 58                           ASLB                ; TIMES 4
5431 e4f5 db 47                        ADDB V47            ; ADD 1 = TIMES 5
5432 e4f7 58                           ASLB                ; TIMES 10
5433 e4f8 80 30                        SUBA #'0            ; *MASK OFF ASCII FROM ACCA, PUSH
5434 e4fa 34 04                        PSHS B              ; *RESULT ONTO THE STACK AND
5435 e4fc ab e0                        ADDA ,S+            ; ADD lT TO ACCB
5436 e4fe 97 47                        STA  V47            ; SAVE IN V47
5437 e500 20 9f                        BRA  LBD55          ; INTERPRET ANOTHER CHARACTER
5438                         *
5439 e502 9b 3e bc 1f fd     LBDB6     FCB  $9B,$3E,$BC,$1F,$FD ; * 99999999.9
5440 e507 9e 6e 6b 27 fd     LBDBB     FCB  $9E,$6E,$6B,$27,$FD ; * 999999999
5441 e50c 9e 6e 6b 28 00     LBDC0     FCB  $9E,$6E,$6B,$28,$00 ; * 1E + 09
5442                         *
5443 e511 8e d3 a7           LBDC5     LDX  #LABE8-1       ; POINT X TO " IN " MESSAGE
5444 e514 8d 0c                        BSR  LBDD6          ; COPY A STRING FROM (X) TO CONSOLE OUT
5445 e516 dc 68                        LDD  CURLIN         ; GET CURRENT BASIC LINE NUMBER TO ACCD
5446                         * CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER
5447                         * AND PRINT IT TO CONSOLE OUT
5448 e518 dd 50              LBDCC     STD  FPA0           ; SAVE ACCD IN TOP HALF OF FPA0
5449 e51a c6 90                        LDB  #$90           ; REQ'D EXPONENT IF TOP HALF OF ACCD = INTEGER
5450 e51c 43                           COMA                ; SET CARRY FLAG - FORCE POSITIVE MANTISSA
5451 e51d bd e3 d2                     JSR  LBC86          ; ZERO BOTTOM HALF AND SIGN OF FPA0, THEN
5452                         *         SAVE EXPONENT AND NORMALIZE IT
5453 e520 8d 03                        BSR  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
5454 e522 7e e0 e8           LBDD6     JMP  LB99C          ; COPY A STRING FROM (X) TO CONSOLE OUT
5455                         
5456                         * CONVERT FP NUMBER TO ASCII STRING
5457 e525 ce 01 f1           LBDD9     LDU  #STRBUF+3      ; POINT U TO BUFFER WHICH WILL NOT CAUSE
5458                         *                             ; THE STRING TO BE STORED IN STRING SPACE
5459 e528 86 20              LBDDC     LDA  #SPACE         ; SPACE = DEFAULT SIGN FOR POSITIVE #
5460 e52a d6 54                        LDB  FP0SGN         ; GET SIGN OF FPA0
5461 e52c 2a 02                        BPL  LBDE4          ; BRANCH IF POSITIVE
5462 e52e 86 2d                        LDA  #'-            ; ASCII MINUS SIGN
5463 e530 a7 c0              LBDE4     STA  ,U+            ; STORE SIGN OF NUMBER
5464 e532 df 64                        STU  COEFPT         ; SAVE BUFFER POINTER
5465 e534 97 54                        STA  FP0SGN         ; SAVE SIGN (IN ASCII)
5466 e536 86 30                        LDA  #'0            ; ASCII ZERO IF EXPONENT = 0
5467 e538 d6 4f                        LDB  FP0EXP         ; GET FPA0 EXPONENT
5468 e53a 10 27 00 c6                  LBEQ LBEB8          ; BRANCH IF FPA0 = 0
5469 e53e 4f                           CLRA                ; BASE 10 EXPONENT=0 FOR FP NUMBER > 1
5470 e53f c1 80                        CMPB #$80           ; CHECK EXPONENT
5471 e541 22 08                        BHI  LBDFF          ; BRANCH IF FP NUMBER > 1
5472                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE CONVERSION PROCESS
5473 e543 8e e5 0c                     LDX  #LBDC0         ; POINT X TO FP 1E+09
5474 e546 bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY (X)
5475 e549 86 f7                        LDA  #-9            ; BASE 10 EXPONENT = -9
5476 e54b 97 45              LBDFF     STA  V45            ; BASE 10 EXPONENT
5477                         * PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE RANGE
5478                         * OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST
5479                         * NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE
5480                         * SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING
5481                         * SCIENTIFIC NOTATION
5482 e54d 8e e5 07           LBE01     LDX  #LBDBB         ; POINT X TO FP 999,999,999
5483 e550 bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO 999,999,999
5484 e553 2e 0f                        BGT  LBE18          ; BRANCH IF > 999,999,999
5485 e555 8e e5 02           LBE09     LDX  #LBDB6         ; POINT X TO FP 99,999,999.9
5486 e558 bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO 99,999,999.9
5487 e55b 2e 0e                        BGT  LBE1F          ; BRANCH IF > 99,999,999.9 (IN RANGE)
5488 e55d bd e2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
5489 e560 0a 45                        DEC  V45            ; SUBTRACT ONE FROM DECIMAL OFFSET
5490 e562 20 f1                        BRA  LBE09          ; PSEUDO - NORMALIZE SOME MORE
5491 e564 bd e2 ce           LBE18     JSR  LBB82          ; DIVIDE FPA0 BY 10
5492 e567 0c 45                        INC  V45            ; ADD ONE TO BASE 10 EXPONENT
5493 e569 20 e2                        BRA  LBE01          ; PSEUDO - NORMALIZE SOME MORE
5494 e56b bd e1 00           LBE1F     JSR  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
5495 e56e bd e4 14                     JSR  LBCC8          ; CONVERT FPA0 TO AN INTEGER
5496 e571 c6 01                        LDB  #1             ; DEFAULT DECIMAL POINT FLAG (FORCE IMMED DECIMAL PT)
5497 e573 96 45                        LDA  V45            ; * GET BASE 10 EXPONENT AND ADD TEN TO IT
5498 e575 8b 0a                        ADDA #9+1           ; * (NUMBER 'NORMALIZED' TO 9 PLACES & DECIMAL PT)
5499 e577 2b 09                        BMI  LBE36          ; BRANCH IF NUMBER < 1.0
5500 e579 81 0b                        CMPA #9+2           ; NINE PLACES MAY BE DISPLAYED WITHOUT
5501                         *         USING SCIENTIFIC NOTATION
5502 e57b 24 05                        BCC  LBE36          ; BRANCH IF SCIENTIFIC NOTATION REQUIRED
5503 e57d 4a                           DECA                ; * SUBTRACT 1 FROM MODIFIED BASE 10 EXPONENT CTR
5504 e57e 1f 89                        TFR  A,B            ; * AND SAVE IT IN ACCB (DECiMAL POINT FLAG)
5505 e580 86 02                        LDA  #2             ; FORCE EXPONENT = 0 - DON'T USE SCIENTIFIC NOTATION
5506 e582 4a                 LBE36     DECA                ; * SUBTRACT TWO (WITHOUT AFFECTING CARRY)
5507 e583 4a                           DECA                ; * FROM BASE 10 EXPONENT
5508 e584 97 47                        STA  V47            ; SAVE EXPONENT - ZERO EXPONENT = DO NOT DISPLAY
5509                         *         IN   SCIENTIFIC NOTATION
5510 e586 d7 45                        STB  V45            ; DECIMAL POINT FLAG - NUMBER OF PLACES TO
5511                         *         LEFT OF DECIMAL POINT
5512 e588 2e 0d                        BGT  LBE4B          ; BRANCH IF >= 1
5513 e58a de 64                        LDU  COEFPT         ; POINT U TO THE STRING BUFFER
5514 e58c 86 2e                        LDA  #'.            ; * STORE A PERIOD
5515 e58e a7 c0                        STA  ,U+            ; * IN THE BUFFER
5516 e590 5d                           TSTB                ; CHECK DECIMAL POINT FLAG
5517 e591 27 04                        BEQ  LBE4B          ; BRANCH IF NOTHING TO LEFT OF DECIMAL POINT
5518 e593 86 30                        LDA  #'0            ; * STORE A ZERO
5519 e595 a7 c0                        STA  ,U+            ; * IN THE BUFFER
5520                         
5521                         * CONVERT FPA0 INTO A STRING OF ASCII DIGITS
5522 e597 8e e6 11           LBE4B     LDX  #LBEC5         ; POINT X TO FP POWER OF 10 MANTISSA
5523 e59a c6 80                        LDB  #0+$80         ; INITIALIZE DIGIT COUNTER TO 0+$80
5524                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
5525                         * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
5526                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB IS HOW
5527                         * THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.
5528 e59c 96 53              LBE50     LDA  FPA0+3         ; * ADD MANTISSA LS
5529 e59e ab 03                        ADDA 3,X            ; * BYTE OF FPA0
5530 e5a0 97 53                        STA  FPA0+3         ; * AND (X)
5531 e5a2 96 52                        LDA  FPA0+2         ; = ADD MANTISSA
5532 e5a4 a9 02                        ADCA 2,X            ; = NUMBER 3 BYTE OF
5533 e5a6 97 52                        STA  FPA0+2         ; = FPA0 AND (X)
5534 e5a8 96 51                        LDA  FPA0+1         ; * ADD MANTISSA
5535 e5aa a9 01                        ADCA 1,X            ; * NUMBER 2 BYTE OF
5536 e5ac 97 51                        STA  FPA0+1         ; * FPA0 AND (X)
5537 e5ae 96 50                        LDA  FPA0           ; = ADD MANTISSA
5538 e5b0 a9 84                        ADCA ,X             ; = MS BYTE OF
5539 e5b2 97 50                        STA  FPA0           ; = FPA0 AND (X)
5540 e5b4 5c                           INCB                ; ADD ONE TO DIGIT COUNTER
5541 e5b5 56                           RORB                ; ROTATE CARRY INTO BIT 7
5542 e5b6 59                           ROLB                ; *SET OVERFLOW FLAG AND BRANCH IF CARRY = 1 AND
5543 e5b7 28 e3                        BVC  LBE50          ; *POSITIVE MANTISSA OR CARRY = 0 AND NEG MANTISSA
5544 e5b9 24 03                        BCC  LBE72          ; BRANCH IF NEGATIVE MANTISSA
5545 e5bb c0 0b                        SUBB #10+1          ; * TAKE THE 9'S COMPLEMENT IF
5546 e5bd 50                           NEGB                ; * ADDING MANTISSA
5547 e5be cb 2f              LBE72     ADDB #'0-1          ; ADD ASCII OFFSET TO DIGIT
5548 e5c0 30 04                        LEAX 4,X            ; MOVE TO NEXT POWER OF 10 MANTISSA
5549 e5c2 1f 98                        TFR  B,A            ; SAVE DIGIT IN ACCA
5550 e5c4 84 7f                        ANDA #$7F           ; MASK OFF BIT 7 (ADD/SUBTRACT FLAG)
5551 e5c6 a7 c0                        STA  ,U+            ; STORE DIGIT IN STRING BUFFER
5552 e5c8 0a 45                        DEC  V45            ; DECREMENT DECIMAL POINT FLAG
5553 e5ca 26 04                        BNE  LBE84          ; BRANCH IF NOT TIME FOR DECIMAL POINT
5554 e5cc 86 2e                        LDA  #'.            ; * STORE DECIMAL POINT IN
5555 e5ce a7 c0                        STA  ,U+            ; * STRING BUFFER
5556 e5d0 53                 LBE84     COMB                ; TOGGLE BIT 7 (ADD/SUBTRACT FLAG)
5557 e5d1 c4 80                        ANDB #$80           ; MASK OFF ALL BUT ADD/SUBTRACT FLAG
5558 e5d3 8c e6 35                     CMPX #LBEC5+36      ; COMPARE X TO END OF MANTISSA TABLE
5559 e5d6 26 c4                        BNE  LBE50          ; BRANCH IF NOT AT END OF TABLE
5560                         * BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY
5561 e5d8 a6 c2              LBE8C     LDA  ,-U            ; GET THE LAST CHARACTER; MOVE POINTER BACK
5562 e5da 81 30                        CMPA #'0            ; WAS IT A ZERO?
5563 e5dc 27 fa                        BEQ  LBE8C          ; IGNORE TRAILING ZEROS IF SO
5564 e5de 81 2e                        CMPA #'.            ; CHECK FOR DECIMAL POINT
5565 e5e0 26 02                        BNE  LBE98          ; BRANCH IF NOT DECIMAL POINT
5566 e5e2 33 5f                        LEAU -1,U           ; STEP OVER THE DECIMAL POINT
5567 e5e4 86 2b              LBE98     LDA  #'+            ; ASCII PLUS SIGN
5568 e5e6 d6 47                        LDB  V47            ; GET SCIENTIFIC NOTATION EXPONENT
5569 e5e8 27 1c                        BEQ  LBEBA          ; BRANCH IF NOT SCIENTIFIC NOTATION
5570 e5ea 2a 03                        BPL  LBEA3          ; BRANCH IF POSITIVE EXPONENT
5571 e5ec 86 2d                        LDA  #'-            ; ASCII MINUS SIGN
5572 e5ee 50                           NEGB                ; NEGATE EXPONENT IF NEGATIVE
5573 e5ef a7 42              LBEA3     STA  2,U            ; STORE EXPONENT SIGN IN STRING
5574 e5f1 86 45                        LDA  #'E            ; * GET ASCII 'E' (SCIENTIFIC NOTATION
5575 e5f3 a7 41                        STA  1,U            ; * FLAG) AND SAVE IT IN THE STRING
5576 e5f5 86 2f                        LDA  #'0-1          ; INITIALIZE ACCA TO ASCII ZERO
5577                         
5578                         
5579 e5f7 4c                 LBEAB     INCA                ; ADD ONE TO 10'S DIGIT OF EXPONENT
5580 e5f8 c0 0a                        SUBB #10            ; SUBTRACT 10 FROM ACCB
5581 e5fa 24 fb                        BCC  LBEAB          ; ADD 1 TO 10'S DIGIT IF NO CARRY
5582 e5fc cb 3a                        ADDB #'9+1          ; CONVERT UNITS DIGIT TO ASCII
5583 e5fe ed 43                        STD  3,U            ; SAVE EXPONENT IN STRING
5584 e600 6f 45                        CLR  5,U            ; CLEAR LAST BYTE (TERMINATOR)
5585 e602 20 04                        BRA  LBEBC          ; GO RESET POINTER
5586 e604 a7 c4              LBEB8     STA  ,U             ; STORE LAST CHARACTER
5587 e606 6f 41              LBEBA     CLR  1,U            ; CLEAR LAST BYTE (TERMINATOR - REQUIRED BY
5588                         *         PRINT SUBROUTINES)
5589 e608 8e 01 f1           LBEBC     LDX  #STRBUF+3      ; RESET POINTER TO START OF BUFFER
5590 e60b 39                           RTS
5591                         *
5592 e60c 80 00 00 00 00     LBEC0     FCB  $80,$00,$00,$00,$00 ; FLOATING POINT .5
5593                         *
5594                         *** TABLE OF UNNORMALIZED POWERS OF 10
5595 e611 fa 0a 1f 00        LBEC5     FCB  $FA,$0A,$1F,$00 ; -100000000
5596 e615 00 98 96 80        LBEC9     FCB  $00,$98,$96,$80 ; 10000000
5597 e619 ff f0 bd c0        LBECD     FCB  $FF,$F0,$BD,$C0 ; -1000000
5598 e61d 00 01 86 a0        LBED1     FCB  $00,$01,$86,$A0 ; 100000
5599 e621 ff ff d8 f0        LBED5     FCB  $FF,$FF,$D8,$F0 ; -10000
5600 e625 00 00 03 e8        LBED9     FCB  $00,$00,$03,$E8 ; 1000
5601 e629 ff ff ff 9c        LBEDD     FCB  $FF,$FF,$FF,$9C ; -100
5602 e62d 00 00 00 0a        LBEE1     FCB  $00,$00,$00,$0A ; 10
5603 e631 ff ff ff ff        LBEE5     FCB  $FF,$FF,$FF,$FF ; -1
5604                         *
5605                         *
5606 e635 96 4f              LBEE9     LDA  FP0EXP         ; GET EXPONENT OF FPA0
5607 e637 27 02                        BEQ  LBEEF          ; BRANCH IF FPA0 = 0
5608 e639 03 54                        COM  FP0SGN         ; TOGGLE MANTISSA SIGN OF FPA0
5609 e63b 39                 LBEEF     RTS
5610                         * EXPAND A POLYNOMIAL OF THE FORM
5611                         * AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0
5612                         * AND THE X REGISTER POINTS TO A TABLE OF
5613                         * COEFFICIENTS A,B,C,D....
5614 e63c 9f 64              LBEF0     STX  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
5615 e63e bd e3 7b                     JSR  LBC2F          ; MOVE FPA0 TO FPA3
5616 e641 8d 05                        BSR  LBEFC          ; MULTIPLY FPA3 BY FPA0
5617 e643 8d 08                        BSR  LBF01          ; EXPAND POLYNOMIAL
5618 e645 8e 00 40                     LDX  #V40           ; POINT X TO FPA3
5619 e648 7e e2 16           LBEFC     JMP  LBACA          ; MULTIPLY (X) BY FPA0
5620                         
5621                         * CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL
5622                         * EXPRESSION. ENTER WITH (X) POINTING TO A TABLE
5623                         * OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE
5624                         * NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER
5625                         * OF PACKED FLOATING POINT NUMBERS. THE
5626                         * POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =
5627                         * (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0...YN)
5628 e64b 9f 64              LBEFF     STX  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
5629 e64d bd e3 76           LBF01     JSR  LBC2A          ; MOVE FPA0 TO FPA4
5630 e650 9e 64                        LDX  COEFPT         ; GET THE COEFFICIENT POINTER
5631 e652 e6 80                        LDB  ,X+            ; GET THE TOP OF COEFFICIENT TABLE TO
5632 e654 d7 55                        STB  COEFCT         ; * USE AND STORE IT IN TEMPORARY COUNTER
5633 e656 9f 64                        STX  COEFPT         ; SAVE NEW COEFFICIENT POINTER
5634 e658 8d ee              LBF0C     BSR  LBEFC          ; MULTIPLY (X) BY FPA0
5635 e65a 9e 64                        LDX  COEFPT         ; *GET COEFFICIENT POINTER
5636 e65c 30 05                        LEAX 5,X            ; *MOVE TO NEXT FP NUMBER
5637 e65e 9f 64                        STX  COEFPT         ; *SAVE NEW COEFFICIENT POINTER
5638 e660 bd e1 0e                     JSR  LB9C2          ; ADD (X) AND FPA0
5639 e663 8e 00 45                     LDX  #V45           ; POINT (X) TO FPA4
5640 e666 0a 55                        DEC  COEFCT         ; DECREMENT TEMP COUNTER
5641 e668 26 ee                        BNE  LBF0C          ; BRANCH IF MORE COEFFICIENTS LEFT
5642 e66a 39                           RTS
5643                         
5644                         * RND
5645 e66b bd e3 b9           RND       JSR  LBC6D          ; TEST FPA0
5646 e66e 2b 1f                        BMI  LBF45          ; BRANCH IF FPA0 = NEGATIVE
5647 e670 27 15                        BEQ  LBF3B          ; BRANCH IF FPA0 = 0
5648 e672 8d 10                        BSR  LBF38          ; CONVERT FPA0 TO AN INTEGER
5649 e674 bd e3 7b                     JSR  LBC2F          ; PACK FPA0 TO FPA3
5650 e677 8d 0e                        BSR  LBF3B          ; GET A RANDOM NUMBER: FPA0 < 1.0
5651 e679 8e 00 40                     LDX  #V40           ; POINT (X) TO FPA3
5652 e67c 8d ca                        BSR  LBEFC          ; MULTIPLY (X) BY FPA0
5653 e67e 8e e2 11                     LDX  #LBAC5         ; POINT (X) TO FP VALUE OF 1.0
5654 e681 bd e1 0e                     JSR  LB9C2          ; ADD 1.0 TO FPA0
5655 e684 7e e4 3a           LBF38     JMP  INT            ; CONVERT FPA0 TO AN INTEGER
5656                         * CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.0
5657 e687 9e b1              LBF3B     LDX  RVSEED+1       ; * MOVE VARIABLE
5658 e689 9f 50                        STX  FPA0           ; * RANDOM NUMBER
5659 e68b 9e b3                        LDX  RVSEED+3       ; * SEED TO
5660 e68d 9f 52                        STX  FPA0+2         ; * FPA0
5661 e68f be e6 bc           LBF45     LDX  RSEED          ; = MOVE FIXED
5662 e692 9f 5d                        STX  FPA1           ; = RANDOM NUMBER
5663 e694 be e6 be                     LDX  RSEED+2        ; = SEED TO
5664 e697 9f 5f                        STX  FPA1+2         ; = MANTISSA OF FPA0
5665 e699 bd e2 1c                     JSR  LBAD0          ; MULTIPLY FPA0 X FPA1
5666 e69c dc 8a                        LDD  VAD            ; GET THE TWO LOWEST ORDER PRODUCT BYTES
5667 e69e c3 65 8b                     ADDD #$658B         ; ADD A CONSTANT
5668 e6a1 dd b3                        STD  RVSEED+3       ; SAVE NEW LOW ORDER VARIABLE RANDOM # SEED
5669 e6a3 dd 52                        STD  FPA0+2         ; SAVE NEW LOW ORDER BYTES OF FPA0 MANTISSA
5670 e6a5 dc 88                        LDD  VAB            ; GET 2 MORE LOW ORDER PRODUCT BYTES
5671 e6a7 c9 b0                        ADCB #$B0           ; ADD A CONSTANT
5672 e6a9 89 05                        ADCA #5             ; ADD A CONSTANT
5673 e6ab dd b1                        STD  RVSEED+1       ; SAVE NEW HIGH ORDER VARIABLE RANDOM # SEED
5674 e6ad dd 50                        STD  FPA0           ; SAVE NEW HIGH ORDER FPA0 MANTISSA
5675 e6af 0f 54                        CLR  FP0SGN         ; FORCE FPA0 MANTISSA = POSITIVE
5676 e6b1 86 80                        LDA  #$80           ; * SET FPA0 BIASED EXPONENT
5677 e6b3 97 4f                        STA  FP0EXP         ; * TO 0 1 < FPA0 < 0
5678 e6b5 96 15                        LDA  FPA2+2         ; GET A BYTE FROM FPA2 (MORE RANDOMNESS)
5679 e6b7 97 63                        STA  FPSBYT         ; SAVE AS SUB BYTE
5680 e6b9 7e e1 68                     JMP  LBA1C          ; NORMALIZE FPA0
5681                         *
5682 e6bc 40 e6              RSEED     FDB  $40E6          ; *CONSTANT RANDOM NUMBER GENERATOR SEED
5683 e6be 4d ab                        FDB  $4DAB          ; *
5684                         
5685                         * SIN
5686                         * THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND WILL REPEAT ITSELF EVERY
5687                         * 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ONLY THE FRACTIONAL PART IS
5688                         * RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, THE COEFFICIENTS MUST BE
5689                         * MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.
5690                         
5691                         * SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES BELOW:
5692                         * SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)
5693 e6c0 bd e3 ab           SIN       JSR  LBC5F          ; COPY FPA0 TO FPA1
5694 e6c3 8e e7 05                     LDX  #LBFBD         ; POINT (X) TO 2*PI
5695 e6c6 d6 61                        LDB  FP1SGN         ; *GET MANTISSA SIGN OF FPA1
5696 e6c8 bd e2 d5                     JSR  LBB89          ; *AND DIVIDE FPA0 BY 2*PI
5697 e6cb bd e3 ab                     JSR  LBC5F          ; COPY FPA0 TO FPA1
5698 e6ce 8d b4                        BSR  LBF38          ; CONVERT FPA0 TO AN INTEGER
5699 e6d0 0f 62                        CLR  RESSGN         ; SET RESULT SIGN = POSITIVE
5700 e6d2 96 5c                        LDA  FP1EXP         ; *GET EXPONENT OF FPA1
5701 e6d4 d6 4f                        LDB  FP0EXP         ; *GET EXPONENT OF FPA0
5702 e6d6 bd e1 08                     JSR  LB9BC          ; *SUBTRACT FPA0 FROM FPA1
5703                         * NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUMENT/2*PI
5704 e6d9 8e e7 0a                     LDX  #LBFC2         ; POINT X TO FP (.25)
5705 e6dc bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM .25 (PI/2)
5706 e6df 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN OF FPA0
5707 e6e1 34 02                        PSHS A              ; SAVE IT ON STACK
5708 e6e3 2a 09                        BPL  LBFA6          ; BRANCH IF MANTISSA POSITIVE
5709 e6e5 bd e1 00                     JSR  LB9B4          ; ADD .5 (PI) TO FPA0
5710 e6e8 96 54                        LDA  FP0SGN         ; GET SIGN OF FPA0
5711 e6ea 2b 05                        BMI  LBFA9          ; BRANCH IF NEGATIVE
5712 e6ec 03 0a                        COM  RELFLG         ; COM IF +(3*PI)/2 >= ARGUMENT >+ PI/2 (QUADRANT FLAG)
5713 e6ee bd e6 35           LBFA6     JSR  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0
5714 e6f1 8e e7 0a           LBFA9     LDX  #LBFC2         ; POINT X TO FP (.25)
5715 e6f4 bd e1 0e                     JSR  LB9C2          ; ADD .25 (PI/2) TO FPA0
5716 e6f7 35 02                        PULS A              ; GET OLD MANTISSA SIGN
5717 e6f9 4d                           TSTA                ; * BRANCH IF OLD
5718 e6fa 2a 03                        BPL  LBFB7          ; * SIGN WAS POSITIVE
5719 e6fc bd e6 35                     JSR  LBEE9          ; TOGGLE MANTISSA SIGN
5720 e6ff 8e e7 0f           LBFB7     LDX  #LBFC7         ; POINT X TO TABLE OF COEFFICIENTS
5721 e702 7e e6 3c                     JMP  LBEF0          ; GO CALCULATE POLYNOMIAL VALUE
5722                         
5723 e705 83 49 0f da a2     LBFBD     FCB  $83,$49,$0F,$DA,$A2 ; 6.28318531 (2*PI)
5724 e70a 7f 00 00 00 00     LBFC2     FCB  $7F,$00,$00,$00,$00 ; .25
5725                         
5726                         
5727 e70f 05                 LBFC7     FCB  6-1            ; SIX COEFFICIENTS
5728 e710 84 e6 1a 2d 1b     LBFC8     FCB  $84,$E6,$1A,$2D,$1B ; * -((2*PI)**11)/11!
5729 e715 86 28 07 fb f8     LBFCD     FCB  $86,$28,$07,$FB,$F8 ; * ((2*PI)**9)/9!
5730 e71a 87 99 68 89 01     LBFD2     FCB  $87,$99,$68,$89,$01 ; * -((2*PI)**7)/7!
5731 e71f 87 23 35 df e1     LBFD7     FCB  $87,$23,$35,$DF,$E1 ; * ((2*PI)**5)/5!
5732 e724 86 a5 5d e7 28     LBFDC     FCB  $86,$A5,$5D,$E7,$28 ; * -((2*PI)**3)/3!
5733 e729 83 49 0f da a2     LBFE1     FCB  $83,$49,$0F,$DA,$A2 ; *
5734                         
5735 e72e a1 54 46 8f 13               FCB  $A1,$54,$46,$8F,$13 ; UNUSED GARBAGE BYTES
5736 e733 8f 52 43 89 cd               FCB  $8F,$52,$43,$89,$CD ; UNUSED GARBAGE BYTES
5737                         * EXTENDED BASIC
5738                         
5739                         * COS
5740                         * THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTITY COS(X)=SIN((PI/2)+X)
5741 e738 8e e7 6b           COS       LDX  #L83AB         ; POINT X TO FP CONSTANT (P1/2)
5742 e73b bd e1 0e                     JSR  LB9C2          ; ADD FPA0 TO (X)
5743 e73e 7e e6 c0           L837E     JMP  SIN            ; JUMP TO SIN ROUTINE
5744                         
5745                         * TAN
5746                         * THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTITY TAN(X)=SIN(X)/COS(X)
5747 e741 bd e3 7b           TAN       JSR  LBC2F          ; PACK FPA0 AND MOVE IT TO FPA3
5748 e744 0f 0a                        CLR  RELFLG         ; RESET QUADRANT FLAG
5749 e746 8d f6                        BSR  L837E          ; CALCULATE SIN OF ARGUMENT
5750 e748 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5
5751 e74b bd e3 81                     JSR  LBC35          ; PACK FPA0 AND MOVE IT TO FPA5
5752 e74e 8e 00 40                     LDX  #V40           ; POINT X TO FPA3
5753 e751 bd e3 60                     JSR  LBC14          ; MOVE FPA3 TO FPA0
5754 e754 0f 54                        CLR  FP0SGN         ; FORCE FPA0 MANTISSA TO BE POSITIVE
5755 e756 96 0a                        LDA  RELFLG         ; GET THE QUADRANT FLAG - COS NEGATIVE IN QUADS 2,3
5756 e758 8d 0c                        BSR  L83A6          ; CALCULATE VALUE OF COS(FPA0)
5757 e75a 0d 4f                        TST  FP0EXP         ; CHECK EXPONENT OF FPA0
5758 e75c 10 27 fa 7e                  LBEQ LBA92          ; ''OV' ERROR IF COS(X)=0
5759 e760 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5
5760 e763 7e e2 db           L83A3     JMP  LBB8F          ; DIVIDE (X) BY FPA0 - SIN(X)/COS(X)
5761 e766 34 02              L83A6     PSHS A              ; SAVE SIGN FLAG ON STACK
5762 e768 7e e6 ee                     JMP  LBFA6          ; EXPAND POLYNOMIAL
5763                         
5764 e76b 81 49 0f da a2     L83AB     FCB  $81,$49,$0F,$DA,$A2 ; 1.57079633 (PI/2)
5765                         
5766                         * ATN
5767                         * A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE
5768                         * ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED
5769                         * TO EVALUATE THE EXPRESSION DEPENDING UPON
5770                         * WHETHER OR NOT THE ARGUMENT SQUARED IS > OR < 1.0
5771                         
5772                         * IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .
5773                         * IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5)*5)-. . .)
5774                         
5775 e770 96 54              ATN       LDA  FP0SGN         ; * GET THE SIGN OF THE MANTISSA AND
5776 e772 34 02                        PSHS A              ; * SAVE IT ON THE STACK
5777 e774 2a 02                        BPL  L83B8          ; BRANCH IF POSITIVE MANTISSA
5778 e776 8d 24                        BSR  L83DC          ; CHANGE SIGN OF FPA0
5779 e778 96 4f              L83B8     LDA  FP0EXP         ; * GET EXPONENT OF FPA0 AND
5780 e77a 34 02                        PSHS A              ; * SAVE IT ON THE STACK
5781 e77c 81 81                        CMPA #$81           ; IS FPAO < 1.0?
5782 e77e 25 05                        BLO  L83C5          ; YES
5783 e780 8e e2 11                     LDX  #LBAC5         ; POINT X TO FP CONSTANT 1.0
5784 e783 8d de                        BSR  L83A3          ; GET RECIPROCAL OF FPA0
5785 e785 8e e7 a0           L83C5     LDX  #L83E0         ; POINT (X) TO TAYLOR SERIES COEFFICIENTS
5786 e788 bd e6 3c                     JSR  LBEF0          ; EXPAND POLYNOMIAL
5787 e78b 35 02                        PULS A              ; GET EXPONENT OF ARGUMENT
5788 e78d 81 81                        CMPA #$81           ; WAS ARGUMENT < 1.0?
5789 e78f 25 06                        BLO  L83D7          ; YES
5790 e791 8e e7 6b                     LDX  #L83AB         ; POINT (X) TO FP NUMBER (PI/2)
5791 e794 bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (PI/2)
5792 e797 35 02              L83D7     PULS A              ; * GET SIGN OF INITIAL ARGUMENT MANTISSA
5793 e799 4d                           TSTA                ; * AND SET FLAGS ACCORDING TO IT
5794 e79a 2a 03                        BPL  L83DF          ; RETURN IF ARGUMENT WAS POSITIVE
5795 e79c 7e e6 35           L83DC     JMP  LBEE9          ; CHANGE MANTISSA SIGN OF FPA0
5796 e79f 39                 L83DF     RTS
5797                         *
5798                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR ARCTANGENT
5799 e7a0 0b                 L83E0     FCB  $0B            ; TWELVE COEFFICIENTS
5800 e7a1 76 b3 83 bd d3     L83E1     FCB  $76,$B3,$83,$BD,$D3 ; -6.84793912E-04 1/23
5801 e7a6 79 1e f4 a6 f5     L83E6     FCB  $79,$1E,$F4,$A6,$F5 ; +4.85094216E-03 1/21
5802 e7ab 7b 83 fc b0 10     L83EB     FCB  $7B,$83,$FC,$B0,$10 ; -0.0161117018
5803 e7b0 7c 0c 1f 67 ca     L83F0     FCB  $7C,$0C,$1F,$67,$CA ; 0.0342096381
5804 e7b5 7c de 53 cb c1     L83F5     FCB  $7C,$DE,$53,$CB,$C1 ; -0.0542791328
5805 e7ba 7d 14 64 70 4c     L83FA     FCB  $7D,$14,$64,$70,$4C ; 0.0724571965
5806 e7bf 7d b7 ea 51 7a     L83FF     FCB  $7D,$B7,$EA,$51,$7A ; -0.0898023954
5807 e7c4 7d 63 30 88 7e     L8404     FCB  $7D,$63,$30,$88,$7E ; 0.110932413
5808 e7c9 7e 92 44 99 3a     L8409     FCB  $7E,$92,$44,$99,$3A ; -0.142839808
5809 e7ce 7e 4c cc 91 c7     L840E     FCB  $7E,$4C,$CC,$91,$C7 ; 0.199999121
5810 e7d3 7f aa aa aa 13     L8413     FCB  $7F,$AA,$AA,$AA,$13 ; -0.333333316
5811 e7d8 81 00 00 00 00     L8418     FCB  $81,$00,$00,$00,$00 ; 1
5812                         *
5813                         *** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR LN(X)
5814                         *
5815 e7dd 03                 L841D     FCB  3              ; FOUR COEFFICIENTS
5816 e7de 7f 5e 56 cb 79     L841E     FCB  $7F,$5E,$56,$CB,$79 ; 0.434255942
5817 e7e3 80 13 9b 0b 64     L8423     FCB  $80,$13,$9B,$0B,$64 ; 0.576584541
5818 e7e8 80 76 38 93 16     L8428     FCB  $80,$76,$38,$93,$16 ; 0.961800759
5819 e7ed 82 38 aa 3b 20     L842D     FCB  $82,$38,$AA,$3B,$20 ; 2.88539007
5820                         
5821 e7f2 80 35 04 f3 34     L8432     FCB  $80,$35,$04,$F3,$34 ; 1/SQR(2)
5822                         
5823 e7f7 81 35 04 f3 34     L8437     FCB  $81,$35,$04,$F3,$34 ; SQR(2)
5824                         
5825 e7fc 80 80 00 00 00     L843C     FCB  $80,$80,$00,$00,$00 ; -0.5
5826                         
5827 e801 80 31 72 17 f8     L8441     FCB  $80,$31,$72,$17,$F8 ; LN(2)
5828                         *
5829                         * LOG - NATURAL LOGARITHM (LN)
5830                         
5831                         * THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USING
5832                         * MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*(2**B) (SCIENTIFIC
5833                         * NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE VALUE OF
5834                         * LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WILL EXPAND THIS
5835                         * TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)*LN(2). ALL OF
5836                         * THE TERMS OF THE LATTER EXPRESSION ARE CONSTANTS EXCEPT FOR THE
5837                         * LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLOR SERIES EXPANSION
5838 e806 bd e3 b9           LOG       JSR  LBC6D          ; CHECK STATUS OF FPA0
5839 e809 10 2f f3 c4                  LBLE LB44A          ; 'FC' ERROR IF NEGATIVE OR ZERO
5840 e80d 8e e7 f2                     LDX  #L8432         ; POINT (X) TO FP NUMBER (1/SQR(2))
5841 e810 96 4f                        LDA  FP0EXP         ; *GET EXPONENT OF ARGUMENT
5842 e812 80 80                        SUBA #$80           ; *SUBTRACT OFF THE BIAS AND
5843 e814 34 02                        PSHS A              ; *SAVE IT ON THE STACK
5844 e816 86 80                        LDA  #$80
5845 e818 97 4f                        STA  FP0EXP
5846 e81a bd e1 0e                     JSR  LB9C2          ; ADD FPA0 TO (X)
5847 e81d 8e e7 f7                     LDX  #L8437         ; POINT X TO SQR(2)
5848 e820 bd e2 db                     JSR  LBB8F          ; DIVIDE SQR(2) BY FPA0
5849 e823 8e e2 11                     LDX  #LBAC5         ; POINT X TO FP VALUE OF 1.00
5850 e826 bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (X)
5851                         *         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE X IS ARGUMENT
5852 e829 8e e7 dd                     LDX  #L841D         ; POINT X TO TABLE OF COEFFICIENTS
5853 e82c bd e6 3c                     JSR  LBEF0          ; EXPAND POLYNOMIAL
5854 e82f 8e e7 fc                     LDX  #L843C         ; POINT X TO FP VALUE OF (-.5)
5855 e832 bd e1 0e                     JSR  LB9C2          ; ADD FPA0 TO X
5856 e835 35 04                        PULS B              ; GET EXPONENT OF ARGUMENT BACK (WITHOUT BIAS)
5857 e837 bd e4 e5                     JSR  LBD99          ; ADD ACCB TO FPA0
5858 e83a 8e e8 01                     LDX  #L8441         ; POINT X TO LN(2)
5859 e83d 7e e2 16                     JMP  LBACA          ; MULTIPLY FPA0 * LN(2)
5860                         
5861                         * SQR
5862 e840 bd e3 ab           SQR       JSR  LBC5F          ; MOVE FPA0 TO FPA1
5863 e843 8e e6 0c                     LDX  #LBEC0         ; POINT (X) TO FP NUMBER (.5)
5864 e846 bd e3 60                     JSR  LBC14          ; COPY A PACKED NUMBER FROM (X) TO FPA0
5865                         
5866                         * ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS
5867                         * HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION
5868                         * IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.7182818
5869 e849 27 67              L8489     BEQ  EXP            ; DO A NATURAL EXPONENTIATION IF EXPONENT = 0
5870 e84b 4d                           TSTA                ; *CHECK VALUE BEING EXPONENTIATED
5871 e84c 26 03                        BNE  L8491          ; *AND BRANCH IF IT IS <> 0
5872 e84e 7e e1 86                     JMP  LBA3A          ; FPA0=0 IF RAISING ZERO TO A POWER
5873 e851 8e 00 4a           L8491     LDX  #V4A           ; * PACK FPA0 AND SAVE
5874 e854 bd e3 81                     JSR  LBC35          ; * IT IN FPA5 (ARGUMENT'S EXPONENT)
5875 e857 5f                           CLRB                ; ACCB=DEFAULT RESULT SIGN FLAG; 0=POSITIVE
5876 e858 96 61                        LDA  FP1SGN         ; *CHECK THE SIGN OF ARGUMENT
5877 e85a 2a 10                        BPL  L84AC          ; *BRANCH IF POSITIVE
5878 e85c bd e4 3a                     JSR  INT            ; CONVERT EXPONENT INTO AN INTEGER
5879 e85f 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5 (ORIGINAL EXPONENT)
5880 e862 96 61                        LDA  FP1SGN         ; GET MANTISSA SIGN OF FPA1 (ARGUMENT)
5881 e864 bd e3 ec                     JSR  LBCA0          ; *COMPARE FPA0 TO (X) AND
5882 e867 26 03                        BNE  L84AC          ; *BRANCH IF NOT EQUAL
5883 e869 43                           COMA                ; TOGGLE FPA1 MANTISSA SIGN - FORCE POSITIVE
5884 e86a d6 01                        LDB  CHARAC         ; GET LS BYTE OF INTEGER VALUE OF EXPONENT (RESULT SIGN FLAG)
5885 e86c bd e3 98           L84AC     JSR  LBC4C          ; COPY FPA1 TO FPA0; ACCA = MANTISSA SIGN
5886 e86f 34 04                        PSHS B              ; PUT RESULT SIGN FLAG ON THE STACK
5887 e871 bd e8 06                     JSR  LOG
5888 e874 8e 00 4a                     LDX  #V4A           ; POINT (X) TO FPA5
5889 e877 bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY FPA5
5890 e87a 8d 36                        BSR  EXP            ; CALCULATE E**(FPA0)
5891 e87c 35 02                        PULS A              ; * GET RESULT SIGN FLAG FROM THE STACK
5892 e87e 46                           RORA                ; * AND BRANCH IF NEGATIVE
5893 e87f 10 25 fd b2                  LBCS LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
5894 e883 39                           RTS
5895                         
5896                         * CORRECTION FACTOR FOR EXPONENTIAL FUNCTION
5897 e884 81 38 aa 3b 29     L84C4     FCB  $81,$38,$AA,$3B,$29 ; 1.44269504 ( CF )
5898                         *
5899                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E**X
5900                         *
5901 e889 07                 L84C9     FCB  7              ; EIGHT COEFFICIENTS
5902 e88a 71 34 58 3e 56     L84CA     FCB  $71,$34,$58,$3E,$56 ; 2.14987637E-05: 1/(7!*(CF**7))
5903 e88f 74 16 7e b3 1b     L84CF     FCB  $74,$16,$7E,$B3,$1B ; 1.4352314E-04 : 1/(6!*(CF**6))
5904 e894 77 2f ee e3 85     L84D4     FCB  $77,$2F,$EE,$E3,$85 ; 1.34226348E-03: 1/(5!*(CF**5))
5905 e899 7a 1d 84 1c 2a     L84D9     FCB  $7A,$1D,$84,$1C,$2A ; 9.61401701E-03: 1/(4!*(CF**4))
5906 e89e 7c 63 59 58 0a     L84DE     FCB  $7C,$63,$59,$58,$0A ; 0.0555051269
5907 e8a3 7e 75 fd e7 c6     L84E3     FCB  $7E,$75,$FD,$E7,$C6 ; 0.240226385
5908 e8a8 80 31 72 18 10     L84E8     FCB  $80,$31,$72,$18,$10 ; 0.693147186
5909 e8ad 81 00 00 00 00     L84ED     FCB  $81,$00,$00,$00,$00 ; 1
5910                         *
5911                         * EXP ( E**X)
5912                         * THE EXPONENTIAL FUNCTION IS EVALUATED BY FIRST MULTIPLYING THE
5913                         * ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS DONE, AN
5914                         * ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFLOW) FOR A
5915                         * NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A POSITIVE
5916                         * ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED TO REFLECT
5917                         * THE CF MULTIPLICATION AT THE START OF THE EVALUATION PROCESS.
5918                         
5919 e8b2 8e e8 84           EXP       LDX  #L84C4         ; POINT X TO THE CORRECTION FACTOR
5920 e8b5 bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY (X)
5921 e8b8 bd e3 7b                     JSR  LBC2F          ; PACK FPA0 AND STORE IT IN FPA3
5922 e8bb 96 4f                        LDA  FP0EXP         ; *GET EXPONENT OF FPA0 AND
5923 e8bd 81 88                        CMPA #$88           ; *COMPARE TO THE MAXIMUM VALUE
5924 e8bf 25 03                        BLO  L8504          ; BRANCH IF FPA0 < 128
5925 e8c1 7e e2 a8           L8501     JMP  LBB5C          ; SET FPA0 = 0 OR 'OV' ERROR
5926 e8c4 bd e4 3a           L8504     JSR  INT            ; CONVERT FPA0 TO INTEGER
5927 e8c7 96 01                        LDA  CHARAC         ; GET LS BYTE OF INTEGER
5928 e8c9 8b 81                        ADDA #$81           ; * WAS THE ARGUMENT =127, IF SO
5929 e8cb 27 f4                        BEQ  L8501          ; * THEN 'OV' ERROR; THIS WILL ALSO ADD THE $80 BIAS
5930                         *              ; * REQUIRED WHEN THE NEW EXPONENT IS CALCULATED BELOW
5931 e8cd 4a                           DECA                ; DECREMENT ONE FROM THE EXPONENT, BECAUSE $81, NOT $80 WAS USED ABOVE
5932 e8ce 34 02                        PSHS A              ; SAVE EXPONENT OF INTEGER PORTION ON STACK
5933 e8d0 8e 00 40                     LDX  #V40           ; POINT (X) TO FPA3
5934 e8d3 bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (X) - GET FRACTIONAL PART OF ARGUMENT
5935 e8d6 8e e8 89                     LDX  #L84C9         ; POINT X TO COEFFICIENTS
5936 e8d9 bd e6 4b                     JSR  LBEFF          ; EVALUATE POLYNOMIAL FOR FRACTIONAL PART
5937 e8dc 0f 62                        CLR  RESSGN         ; FORCE THE MANTISSA TO BE POSITIVE
5938 e8de 35 02                        PULS A              ; GET INTEGER EXPONENT FROM STACK
5939 e8e0 bd e2 94                     JSR  LBB48          ; * CALCULATE EXPONENT OF NEW FPA0 BY ADDING THE EXPONENTS OF THE
5940                         *              ; * INTEGER AND FRACTIONAL PARTS
5941 e8e3 39                           RTS
5942                         
5943                         * FIX
5944 e8e4 bd e3 b9           FIX       JSR  LBC6D          ; CHECK STATUS OF FPA0
5945 e8e7 2b 03                        BMI  L852C          ; BRANCH IF FPA0 = NEGATIVE
5946 e8e9 7e e4 3a           L8529     JMP  INT            ; CONVERT FPA0 TO INTEGER
5947 e8ec 03 54              L852C     COM  FP0SGN         ; TOGGLE SIGN OF FPA0 MANTISSA
5948 e8ee 8d f9                        BSR  L8529          ; CONVERT FPA0 TO INTEGER
5949 e8f0 7e e6 35                     JMP  LBEE9          ; TOGGLE SIGN OF FPA0
5950                         
5951                         * EDIT
5952 e8f3 bd ed 21           EDIT      JSR  L89AE          ; GET LINE NUMBER FROM BASIC
5953 e8f6 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF THE STACK
5954 e8f8 86 01              L8538     LDA  #$01           ; 'LIST' FLAG
5955 e8fa 97 98                        STA  VD8            ; SET FLAG TO LIST LINE
5956 e8fc bd d4 a5                     JSR  LAD01          ; GO FIND THE LINE NUMBER IN PROGRAM
5957 e8ff 10 25 ed 7f                  LBCS LAED2          ; ERROR #7 'UNDEFINED LINE #'
5958 e903 bd df 3e                     JSR  LB7C2          ; GO UNCRUNCH LINE INTO BUFFER AT LINBUF+1
5959 e906 1f 20                        TFR  Y,D            ; PUT ABSOLUTE ADDRESS OF END OF LINE TO ACCD
5960 e908 83 00 f5                     SUBD #LINBUF+2      ; SUBTRACT OUT THE START OF LINE
5961 e90b d7 97                        STB  VD7            ; SAVE LENGTH OF LINE
5962 e90d dc 2b              L854D     LDD  BINVAL         ; GET THE HEX VALUE OF LINE NUMBER
5963 e90f bd e5 18                     JSR  LBDCC          ; LIST THE LINE NUMBER ON THE SCREEN
5964 e912 bd e0 f8                     JSR  LB9AC          ; PRINT A SPACE
5965 e915 8e 00 f4                     LDX  #LINBUF+1      ; POINT X TO BUFFER
5966 e918 d6 98                        LDB  VD8            ; * CHECK TO SEE IF LINE IS TO BE
5967 e91a 26 25                        BNE  L8581          ; * LISTED TO SCREEN - BRANCH IF IT IS
5968 e91c 5f                 L855C     CLRB                ; RESET DIGIT ACCUMULATOR - DEFAULT VALUE
5969 e91d bd ea 47           L855D     JSR  L8687          ; GET KEY STROKE
5970 e920 bd f1 ec                     JSR  L90AA          ; SET CARRY IF NOT NUMERIC
5971 e923 25 0b                        BLO  L8570          ; BRANCH IF NOT NUMERIC
5972 e925 80 30                        SUBA #'0            ; MASK OFF ASCII
5973 e927 34 02                        PSHS A              ; SAVE IT ON STACK
5974 e929 86 0a                        LDA  #10            ; NUMBER BEING CONVERTED IS BASE 10
5975 e92b 3d                           MUL                 ; MULTIPLY ACCUMULATED VALUE BY BASE (10)
5976 e92c eb e0                        ADDB ,S+            ; ADD DIGIT TO ACCUMULATED VALUE
5977 e92e 20 ed                        BRA  L855D          ; CHECK FOR ANOTHER DIGIT
5978 e930 c0 01              L8570     SUBB #$01           ; * REPEAT PARAMETER IN ACCB; IF IT
5979 e932 c9 01                        ADCB #$01           ; *IS 0, THEN MAKE IT '1'
5980 e934 81 41                        CMPA #'A            ; ABORT?
5981 e936 26 05                        BNE  L857D          ; NO
5982 e938 bd e0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
5983 e93b 20 bb                        BRA  L8538          ; RESTART EDIT PROCESS - CANCEL ALL CHANGES
5984 e93d 81 4c              L857D     CMPA #'L            ; LIST?
5985 e93f 26 0b                        BNE  L858C          ; NO
5986 e941 8d 31              L8581     BSR  L85B4          ; LIST THE LINE
5987 e943 0f 98                        CLR  VD8            ; RESET THE LIST FLAG TO 'NO LIST'
5988 e945 bd e0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN
5989 e948 20 c3                        BRA  L854D          ; GO INTERPRET ANOTHER EDIT COMMAND
5990 e94a 32 62              L858A     LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF THE STACK
5991 e94c 81 0d              L858C     CMPA #CR            ; ENTER KEY?
5992 e94e 26 0d                        BNE  L859D          ; NO
5993 e950 8d 22                        BSR  L85B4          ; ECHO THE LINE TO THE SCREEN
5994 e952 bd e0 a8           L8592     JSR  LB958          ; PRINT CARRIAGE RETURN
5995 e955 8e 00 f4                     LDX  #LINBUF+1      ; * RESET BASIC'S INPUT POINTER
5996 e958 9f 83                        STX  CHARAD         ; * TO THE LINE INPUT BUFFER
5997 e95a 7e d4 4e                     JMP  LACA8          ; GO PUT LINE BACK IN PROGRAM
5998 e95d 81 45              L859D     CMPA #'E            ; EXIT?
5999 e95f 27 f1                        BEQ  L8592          ; YES - SAME AS ENTER EXCEPT NO ECHO
6000 e961 81 51                        CMPA #'Q            ; QUIT?
6001 e963 26 06                        BNE  L85AB          ; NO
6002 e965 bd e0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
6003 e968 7e d4 25                     JMP  LAC73          ; GO TO COMMAND LEVEL - MAKE NO CHANGES
6004 e96b 8d 02              L85AB     BSR  L85AF          ; INTERPRET THE REMAINING COMMANDS AS SUBROUTINES
6005 e96d 20 ad                        BRA  L855C          ; GO INTERPRET ANOTHER EDIT COMMAND
6006 e96f 81 20              L85AF     CMPA #SPACE         ; SPACE BAR?
6007 e971 26 10                        BNE  L85C3          ; NO
6008 e973 8c                 L85B3     FCB  SKP2           ; SKIP TWO BYTES
6009                         * DISPLAY THE NEXT ACCB BYTES OF THE LINE IN THE BUFFER TO THE SCREEN
6010                         *
6011 e974 c6 f9              L85B4     LDB  #LBUFMX-1      ; 250 BYTES MAX IN BUFFER
6012 e976 a6 84              L85B6     LDA  ,X             ; GET A CHARACTER FROM BUFFER
6013 e978 27 08                        BEQ  L85C2          ; EXIT IF IT'S A 0
6014 e97a bd d0 17                     JSR  PUTCHR         ; SEND CHAR TO CONSOLE OUT
6015 e97d 30 01                        LEAX $01,X          ; MOVE POINTER UP ONE
6016 e97f 5a                           DECB                ; DECREMENT CHARACTER COUNTER
6017 e980 26 f4                        BNE  L85B6          ; LOOP IF NOT DONE
6018 e982 39                 L85C2     RTS
6019 e983 81 44              L85C3     CMPA #'D            ; DELETE?
6020 e985 26 48                        BNE  L860F          ; NO
6021 e987 6d 84              L85C7     TST  ,X             ; * CHECK FOR END OF LINE
6022 e989 27 f7                        BEQ  L85C2          ; * AND BRANCH IF SO
6023 e98b 8d 04                        BSR  L85D1          ; REMOVE A CHARACTER
6024 e98d 5a                           DECB                ; DECREMENT REPEAT PARAMETER
6025 e98e 26 f7                        BNE  L85C7          ; BRANCH IF NOT DONE
6026 e990 39                           RTS
6027                         * REMOVE ONE CHARACTER FROM BUFFER
6028 e991 0a 97              L85D1     DEC  VD7            ; DECREMENT LENGTH OF BUFFER
6029 e993 31 1f                        LEAY -1,X           ; POINT Y TO ONE BEFORE CURRENT BUFFER POINTER
6030 e995 31 21              L85D5     LEAY $01,Y          ; INCREMENT TEMPORARY BUFFER POINTER
6031 e997 a6 21                        LDA  $01,Y          ; GET NEXT CHARACTER
6032 e999 a7 a4                        STA  ,Y             ; PUT IT IN CURRENT POSITION
6033 e99b 26 f8                        BNE  L85D5          ; BRANCH IF NOT END OF LINE
6034 e99d 39                           RTS
6035 e99e 81 49              L85DE     CMPA #'I            ;  INSERT?
6036 e9a0 27 13                        BEQ  L85F5          ; YES
6037 e9a2 81 58                        CMPA #'X            ; EXTEND?
6038 e9a4 27 0d                        BEQ  L85F3          ; YES
6039 e9a6 81 48                        CMPA #'H            ; HACK?
6040 e9a8 26 5c                        BNE  L8646          ; NO
6041 e9aa 6f 84                        CLR  ,X             ; TURN CURRENT BUFFER POINTER INTO END OF LINE FLAG
6042 e9ac 1f 10                        TFR  X,D            ; PUT CURRENT BUFFER POINTER IN ACCD
6043 e9ae 83 00 f5                     SUBD #LINBUF+2      ; SUBTRACT INITIAL POINTER POSITION
6044 e9b1 d7 97                        STB  VD7            ; SAVE NEW BUFFER LENGTH
6045 e9b3 8d bf              L85F3     BSR  L85B4          ; DISPLAY THE LINE ON THE SCREEN
6046 e9b5 bd ea 47           L85F5     JSR  L8687          ; GET A KEYSTROKE
6047 e9b8 81 0d                        CMPA #CR            ; ENTER KEY?
6048 e9ba 27 8e                        BEQ  L858A          ; YES - INTERPRET ANOTHER COMMAND - PRINT LINE
6049 e9bc 81 1b                        CMPA #ESC           ; ESCAPE?
6050 e9be 27 25                        BEQ  L8625          ; YES - RETURN TO COMMAND LEVEL - DON'T PRINT LINE
6051 e9c0 81 08                        CMPA #BS            ; BACK SPACE?
6052 e9c2 26 22                        BNE  L8626          ; NO
6053 e9c4 8c 00 f4                     CMPX #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
6054 e9c7 27 ec                        BEQ  L85F5          ; DO NOT ALLOW BS IF AT START
6055 e9c9 8d 45                        BSR  L8650          ; MOVE POINTER BACK ONE, BS TO SCREEN
6056 e9cb 8d c4                        BSR  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
6057 e9cd 20 e6                        BRA  L85F5          ; GET INSERT SUB COMMAND
6058 e9cf 81 43              L860F     CMPA #'C            ; CHANGE?
6059 e9d1 26 cb                        BNE  L85DE          ; NO
6060 e9d3 6d 84              L8613     TST  ,X             ; CHECK CURRENT BUFFER CHARACTER
6061 e9d5 27 0e                        BEQ  L8625          ; BRANCH IF END OF LINE
6062 e9d7 bd ea 47                     JSR  L8687          ; GET A KEYSTROKE
6063 e9da 25 02                        BLO  L861E          ; BRANCH IF LEGITIMATE KEY
6064 e9dc 20 f5                        BRA  L8613          ; TRY AGAIN IF ILLEGAL KEY
6065 e9de a7 80              L861E     STA  ,X+            ; INSERT NEW CHARACTER INTO BUFFER
6066 e9e0 8d 37                        BSR  L8659          ; SEND NEW CHARACTER TO SCREEN
6067 e9e2 5a                           DECB                ; DECREMENT REPEAT PARAMETER
6068 e9e3 26 ee                        BNE  L8613          ; BRANCH IF NOT DONE
6069 e9e5 39                 L8625     RTS
6070 e9e6 d6 97              L8626     LDB  VD7            ; GET LENGTH OF LINE
6071 e9e8 c1 f9                        CMPB #LBUFMX-1      ; COMPARE TO MAXIMUM LENGTH
6072 e9ea 26 02                        BNE  L862E          ; BRANCH IF NOT AT MAXIMUM
6073 e9ec 20 c7                        BRA  L85F5          ; IGNORE INPUT IF LINE AT MAXIMUM LENGTH
6074 e9ee 34 10              L862E     PSHS X              ; SAVE CURRENT BUFFER POINTER
6075 e9f0 6d 80              L8630     TST  ,X+            ; * SCAN THE LINE UNTIL END OF
6076 e9f2 26 fc                        BNE  L8630          ; * LINE (0) IS FOUND
6077 e9f4 e6 82              L8634     LDB  ,-X            ; DECR TEMP LINE POINTER AND GET A CHARACTER
6078 e9f6 e7 01                        STB  $01,X          ; PUT CHARACTER BACK DOWN ONE SPOT
6079 e9f8 ac e4                        CMPX ,S             ; HAVE WE REACHED STARTING POINT?
6080 e9fa 26 f8                        BNE  L8634          ; NO - KEEP GOING
6081 e9fc 32 62                        LEAS $02,S          ; PURGE BUFFER POINTER FROM STACK
6082 e9fe a7 80                        STA  ,X+            ; INSERT NEW CHARACTER INTO THE LINE
6083 ea00 8d 17                        BSR  L8659          ; SEND A CHARACTER TO CONSOLE OUT
6084 ea02 0c 97                        INC  VD7            ; ADD ONE TO BUFFER LENGTH
6085 ea04 20 af                        BRA  L85F5          ; GET INSERT SUB COMMAND
6086 ea06 81 08              L8646     CMPA #BS            ; BACKSPACE?
6087 ea08 26 12                        BNE  L865C          ; NO
6088 ea0a 8d 04              L864A     BSR  L8650          ; MOVE POINTER BACK 1, SEND BS TO SCREEN
6089 ea0c 5a                           DECB                ; DECREMENT REPEAT PARAMETER
6090 ea0d 26 fb                        BNE  L864A          ; LOOP UNTIL DONE
6091 ea0f 39                           RTS
6092 ea10 8c 00 f4           L8650     CMPX #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
6093 ea13 27 d0                        BEQ  L8625          ; DO NOT ALLOW BS IF AT START
6094 ea15 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
6095 ea17 86 08                        LDA  #BS            ; BACK SPACE
6096 ea19 7e d0 17           L8659     JMP  PUTCHR         ; SEND TO CONSOLE OUT
6097 ea1c 81 4b              L865C     CMPA #'K            ; KILL?
6098 ea1e 27 05                        BEQ  L8665          ; YES
6099 ea20 80 53                        SUBA #'S            ; SEARCH?
6100 ea22 27 01                        BEQ  L8665          ; YES
6101 ea24 39                           RTS
6102 ea25 34 02              L8665     PSHS A              ; SAVE KILL/SEARCH FLAG ON STACK
6103 ea27 8d 1e                        BSR  L8687          ; * GET A KEYSTROKE (TARGET CHARACTER)
6104 ea29 34 02                        PSHS A              ; * AND SAVE IT ON STACK
6105 ea2b a6 84              L866B     LDA  ,X             ; GET CURRENT BUFFER CHARACTER
6106 ea2d 27 16                        BEQ  L8685          ; AND RETURN IF END OF LINE
6107 ea2f 6d 61                        TST  $01,S          ; CHECK KILL/SEARCH FLAG
6108 ea31 26 06                        BNE  L8679          ; BRANCH IF KILL
6109 ea33 8d e4                        BSR  L8659          ; SEND A CHARACTER TO CONSOLE OUT
6110 ea35 30 01                        LEAX $01,X          ; INCREMENT BUFFER POINTER
6111 ea37 20 03                        BRA  L867C          ; CHECK NEXT INPUT CHARACTER
6112 ea39 bd e9 91           L8679     JSR  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
6113 ea3c a6 84              L867C     LDA  ,X             ; GET CURRENT INPUT CHARACTER
6114 ea3e a1 e4                        CMPA ,S             ; COMPARE TO TARGET CHARACTER
6115 ea40 26 e9                        BNE  L866B          ; BRANCH IF NO MATCH
6116 ea42 5a                           DECB                ; DECREMENT REPEAT PARAMETER
6117 ea43 26 e6                        BNE  L866B          ; BRANCH IF NOT DONE
6118 ea45 35 a0              L8685     PULS Y,PC           ; THE Y PULL WILL CLEAN UP THE STACK FOR THE 2 PSHS A
6119                         *
6120                         * GET A KEYSTRKE
6121 ea47 bd d0 03           L8687     JSR  LA171          ; CALL CONSOLE IN : DEV NBR=SCREEN
6122 ea4a 81 7f                        CMPA #$7F           ; GRAPHIC CHARACTER?
6123 ea4c 24 f9                        BCC  L8687          ; YES - GET ANOTHER CHAR
6124 ea4e 81 5f                        CMPA #$5F           ; SHIFT UP ARROW (QUIT INSERT)
6125 ea50 26 02                        BNE  L8694          ; NO
6126 ea52 86 1b                        LDA  #ESC           ; REPLACE W/ESCAPE CODE
6127 ea54 81 0d              L8694     CMPA #CR            ; ENTER KEY
6128 ea56 27 0e                        BEQ  L86A6          ; YES
6129 ea58 81 1b                        CMPA #ESC           ; ESCAPE?
6130 ea5a 27 0a                        BEQ  L86A6          ; YES
6131 ea5c 81 08                        CMPA #BS            ; BACKSPACE?
6132 ea5e 27 06                        BEQ  L86A6          ; YES
6133 ea60 81 20                        CMPA #SPACE         ; SPACE
6134 ea62 25 e3                        BLO  L8687          ; GET ANOTHER CHAR IF CONTROL CHAR
6135 ea64 1a 01                        ORCC #$01           ; SET CARRY
6136 ea66 39                 L86A6     RTS
6137                         
6138                         * TRON
6139 ea67 86                 TRON      FCB  SKP1LD         ; SKIP ONE BYTE AND LDA #$4F
6140                         
6141                         * TROFF
6142 ea68 4f                 TROFF     CLRA                ; TROFF FLAG
6143 ea69 97 8c                        STA  TRCFLG         ; TRON/TROFF FLAG:0=TROFF, <> 0=TRON
6144 ea6b 39                           RTS
6145                         
6146                         * POS
6147                         
6148 ea6c 86 00              POS       LDA  #0             ; GET DEVICE NUMBER
6149 ea6e d6 79                        LDB  LPTPOS         ; GET PRINT POSITION
6150 ea70 1d                 LA5E8     SEX                 ; CONVERT ACCB TO 2 DIGIT SIGNED INTEGER
6151 ea71 7e dc 7b                     JMP  GIVABF         ; CONVERT ACCD TO FLOATING POINT
6152                         
6153                         
6154                         * VARPTR
6155 ea74 bd d9 f6           VARPT     JSR  LB26A          ; SYNTAX CHECK FOR '('
6156 ea77 dc 1f                        LDD  ARYEND         ; GET ADDR OF END OF ARRAYS
6157 ea79 34 06                        PSHS B,A            ; SAVE IT ON STACK
6158 ea7b bd da de                     JSR  LB357          ; GET VARIABLE DESCRIPTOR
6159 ea7e bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6160 ea81 35 06                        PULS A,B            ; GET END OF ARRAYS ADDR BACK
6161 ea83 1e 10                        EXG  X,D            ; SWAP END OF ARRAYS AND VARIABLE DESCRIPTOR
6162 ea85 9c 1f                        CMPX ARYEND         ; COMPARE TO NEW END OF ARRAYS
6163 ea87 26 51                        BNE  L8724          ; 'FC' ERROR IF VARIABLE WAS NOT DEFINED PRIOR TO CALLING VARPTR
6164 ea89 7e dc 7b                     JMP  GIVABF         ; CONVERT VARIABLE DESCRIPTOR INTO A FP NUMBER
6165                         
6166                         * MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT
6167 ea8c 9d 7c              L86D6     JSR  GETNCH         ; GET INPUT CHAR FROM BASIC
6168 ea8e bd d9 f6                     JSR  LB26A          ; SYNTAX CHECK FOR '('
6169 ea91 bd da de                     JSR  LB357          ; * GET VARIABLE DESCRIPTOR ADDRESS AND
6170 ea94 34 10                        PSHS X              ; * SAVE IT ON THE STACK
6171 ea96 ec 02                        LDD  $02,X          ; POINT ACCD TO START OF OLDSTRING
6172 ea98 10 93 21                     CMPD FRETOP         ; COMPARE TO START OF CLEARED SPACE
6173 ea9b 23 04                        BLS  L86EB          ; BRANCH IF <=
6174 ea9d 93 27                        SUBD MEMSIZ         ; SUBTRACT OUT TOP OF CLEARED SPACE
6175 ea9f 23 12                        BLS  L86FD          ; BRANCH IF STRING IN STRING SPACE
6176 eaa1 e6 84              L86EB     LDB  ,X             ; GET LENGTH OF OLDSTRING
6177 eaa3 bd dc f4                     JSR  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
6178 eaa6 34 10                        PSHS X              ; SAVE RESERVED SPACE STRING ADDRESS ON STACK
6179 eaa8 ae 62                        LDX  $02,S          ; POINT X TO OLDSTRING DESCRIPTOR
6180 eaaa bd dd ca                     JSR  LB643          ; MOVE OLDSTRING INTO STRING SPACE
6181 eaad 35 50                        PULS X,U            ; * GET OLDSTRING DESCRIPTOR ADDRESS AND RESERVED STRING
6182 eaaf af 42                        STX  $02,U          ; * ADDRESS AND SAVE RESERVED ADDRESS AS OLDSTRING ADDRESS
6183 eab1 34 40                        PSHS U              ; SAVE OLDSTRING DESCRIPTOR ADDRESS
6184 eab3 bd de bf           L86FD     JSR  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
6185 eab6 34 04                        PSHS B              ; SAVE POSITION PARAMETER ON STACK
6186 eab8 5d                           TSTB                ; * CHECK POSITION PARAMETER AND BRANCH
6187 eab9 27 1f                        BEQ  L8724          ; * IF START OF STRING
6188 eabb c6 ff                        LDB  #$FF           ; DEFAULT REPLACEMENT LENGTH = $FF
6189 eabd 81 29                        CMPA #')            ; * CHECK FOR END OF MID$ STATEMENT AND
6190 eabf 27 03                        BEQ  L870E          ; * BRANCH IF AT END OF STATEMENT
6191 eac1 bd de bf                     JSR  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
6192 eac4 34 04              L870E     PSHS B              ; SAVE LENGTH PARAMETER ON STACK
6193 eac6 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6194 eac9 c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR =
6195 eacb bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR '='
6196 eace 8d 2e                        BSR  L8748          ; EVALUATE REPLACEMENT STRING
6197 ead0 1f 13                        TFR  X,U            ; SAVE REPLACEMENT STRING ADDRESS IN U
6198 ead2 ae 62                        LDX  $02,S          ; POINT X TO OLOSTRING DESCRIPTOR ADDRESS
6199 ead4 a6 84                        LDA  ,X             ; GET LENGTH OF OLDSTRING
6200 ead6 a0 61                        SUBA $01,S          ; SUBTRACT POSITION PARAMETER
6201 ead8 24 03                        BCC  L8727          ; INSERT REPLACEMENT STRING INTO OLDSTRING
6202 eada 7e db d1           L8724     JMP  LB44A          ; 'FC' ERROR IF POSITION > LENGTH OF OLDSTRING
6203 eadd 4c                 L8727     INCA                ; * NOW ACCA = NUMBER OF CHARACTERS TO THE RIGHT
6204                         *                             ; * (INCLUSIVE) OF THE POSITION PARAMETER
6205 eade a1 e4                        CMPA ,S
6206 eae0 24 02                        BCC  L872E          ; BRANCH IF NEW STRING WILL FIT IN OLDSTRING
6207 eae2 a7 e4                        STA  ,S             ; IF NOT, USE AS MUCH OF LENGTH PARAMETER AS WILL FIT
6208 eae4 a6 61              L872E     LDA  $01,S          ; GET POSITION PARAMETER
6209 eae6 1e 89                        EXG  A,B            ; ACCA=LENGTH OF REPL STRING, ACCB=POSITION PARAMETER
6210 eae8 ae 02                        LDX  $02,X          ; POINT X TO OLDSTRING ADDRESS
6211 eaea 5a                           DECB                ; * BASIC'S POSITION PARAMETER STARTS AT 1; THIS ROUTINE
6212                         *                             ; * WANTS IT TO START AT ZERO
6213 eaeb 3a                           ABX                 ; POINT X TO POSITION IN OLDSTRING WHERE THE REPLACEMENT WILL GO
6214 eaec 4d                           TSTA                ; * IF THE LENGTH OF THE REPLACEMENT STRING IS ZERO
6215 eaed 27 0d                        BEQ  L8746          ; * THEN RETURN
6216 eaef a1 e4                        CMPA ,S
6217 eaf1 23 02                        BLS  L873F          ; ADJUSTED LENGTH PARAMETER, THEN BRANCH
6218 eaf3 a6 e4                        LDA  ,S             ; OTHERWISE USE AS MUCH ROOM AS IS AVAILABLE
6219 eaf5 1f 89              L873F     TFR  A,B            ; SAVE NUMBER OF BYTES TO MOVE IN ACCB
6220 eaf7 1e 31                        EXG  U,X            ; SWAP SOURCE AND DESTINATION POINTERS
6221 eaf9 bd d1 b1                     JSR  LA59A          ; MOVE (B) BYTES FROM (X) TO (U)
6222 eafc 35 96              L8746     PULS A,B,X,PC
6223 eafe bd d8 e2           L8748     JSR  LB156          ; EVALUATE EXPRESSION
6224 eb01 7e dd db                     JMP  LB654          ; *'TM' ERROR IF NUMERIC; RETURN WITH X POINTING
6225                         *                             ; *TO STRING, ACCB = LENGTH
6226                         
6227                         * STRING
6228 eb04 bd d9 f6           STRING    JSR  LB26A          ; SYNTAX CHECK FOR '('
6229 eb07 bd de 92                     JSR  LB70B          ; EVALUATE EXPRESSION; ERROR IF > 255
6230 eb0a 34 04                        PSHS B              ; SAVE LENGTH OF STRING
6231 eb0c bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6232 eb0f bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
6233 eb12 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6234 eb15 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
6235 eb17 26 05                        BNE  L8768          ; BRANCH IF STRING
6236 eb19 bd de 95                     JSR  LB70E          ; CONVERT FPA0 INTO AN INTEGER IN ACCB
6237 eb1c 20 03                        BRA  L876B          ; SAVE THE STRING IN STRING SPACE
6238 eb1e bd de 2b           L8768     JSR  LB6A4          ; GET FIRST BYTE OF STRING
6239 eb21 34 04              L876B     PSHS B              ; SAVE FIRST BYTE OF EXPRESSION
6240 eb23 e6 61                        LDB  $01,S          ; GET LENGTH OF STRING
6241 eb25 bd dc 96                     JSR  LB50F          ; RESERVE ACCB BYTES IN STRING SPACE
6242 eb28 35 06                        PULS A,B            ; GET LENGTH OF STRING AND CHARACTER
6243 eb2a 27 05                        BEQ  L877B          ; BRANCH IF NULL STRING
6244 eb2c a7 80              L8776     STA  ,X+            ; SAVE A CHARACTER IN STRING SPACE
6245 eb2e 5a                           DECB                ; DECREMENT LENGTH
6246 eb2f 26 fb                        BNE  L8776          ; BRANCH IF NOT DONE
6247 eb31 7e de 22           L877B     JMP  LB69B          ; PUT STRING DESCRIPTOR ONTO STRING STACK
6248                         
6249                         * INSTR
6250 eb34 bd d9 f6           INSTR     JSR  LB26A          ; SYNTAX CHECK FOR '('
6251 eb37 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
6252 eb3a c6 01                        LDB  #$01           ; DEFAULT POSITION = 1 (SEARCH START)
6253 eb3c 34 04                        PSHS B              ; SAVE START
6254 eb3e 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
6255 eb40 26 10                        BNE  L879C          ; BRANCH IF STRING
6256 eb42 bd de 95                     JSR  LB70E          ; CONVERT FPA0 TO INTEGER IN ACCB
6257 eb45 e7 e4                        STB  ,S             ; SAVE START SEARCH VALUE
6258 eb47 27 91                        BEQ  L8724          ; BRANCH IF START SEARCH AT ZERO
6259 eb49 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6260 eb4c bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION - SEARCH STRING
6261 eb4f bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC
6262 eb52 9e 52              L879C     LDX  FPA0+2         ; SEARCH STRING DESCRIPTOR ADDRESS
6263 eb54 34 10                        PSHS X              ; SAVE ON THE STACK
6264 eb56 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6265 eb59 bd ea fe                     JSR  L8748          ; EVALUATE TARGET STRING EXPRESSION
6266 eb5c 34 14                        PSHS X,B            ; SAVE ADDRESS AND LENGTH ON STACK
6267 eb5e bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6268 eb61 ae 63                        LDX  $03,S          ; * LOAD X WITH SEARCH STRING DESCRIPTOR ADDRESS
6269 eb63 bd dd e0                     JSR  LB659          ; * AND GET THE LENGTH ANDADDRESS OF SEARCH STRING
6270 eb66 34 04                        PSHS B              ; SAVE LENGTH ON STACK
6271                         *
6272                         * AT THIS POINT THE STACK HAS THE FOLLOWING INFORMATION
6273                         * ON IT: 0,S-SEARCH LENGTH; 1,S-TARGET LENGTH; 2 3,S-TARGET
6274                         * ADDRESS; 4 5,S-SEARCH DESCRIPTOR ADDRESS; 6,S-SEARCH POSITION
6275 eb68 e1 66                        CMPB $06,S          ; COMPARE LENGTH OF SEARCH STRING TO START
6276 eb6a 25 23                        BLO  L87D9          ; POSITION; RETURN 0 IF LENGTH < START
6277 eb6c a6 61                        LDA  $01,S          ; GET LENGTH OF TARGET STRING
6278 eb6e 27 1c                        BEQ  L87D6          ; BRANCH IF TARGET STRING = NULL
6279 eb70 e6 66                        LDB  $06,S          ; GET START POSITION
6280 eb72 5a                           DECB                ; MOVE BACK ONE
6281 eb73 3a                           ABX                 ; POINT X TO POSITION IN SEARCH STRING WHERE SEARCHING WILL START
6282 eb74 31 84              L87BE     LEAY ,X             ; POINT Y TO SEARCH POSITION
6283 eb76 ee 62                        LDU  $02,S          ; POINT U TO START OF TARGET
6284 eb78 e6 61                        LDB  $01,S          ; LOAD ACCB WITH LENGTH OF TARGET
6285 eb7a a6 e4                        LDA  ,S             ; LOAD ACCA WITH LENGTH OF SEARCH
6286 eb7c a0 66                        SUBA $06,S          ; SUBTRACT SEARCH POSITION FROM SEARCH LENGTH
6287 eb7e 4c                           INCA                ; ADD ONE
6288 eb7f a1 61                        CMPA $01,S          ; COMPARE TO TARGET LENGTH
6289 eb81 25 0c                        BLO  L87D9          ; RETURN 0 IF TARGET LENGTH > WHAT'S LEFT OF SEARCH STRING
6290 eb83 a6 80              L87CD     LDA  ,X+            ; GET A CHARACTER FROM SEARCH STRING
6291 eb85 a1 c0                        CMPA ,U+            ; COMPARE IT TO TARGET STRING
6292 eb87 26 0c                        BNE  L87DF          ; BRANCH IF NO MATCH
6293 eb89 5a                           DECB                ; DECREMENT TARGET LENGTH
6294 eb8a 26 f7                        BNE  L87CD          ; CHECK ANOTHER CHARACTER
6295 eb8c e6 66              L87D6     LDB  $06,S          ; GET MATCH POSITION
6296 eb8e 21                 L87D8     FCB  SKP1           ; SKIP NEXT BYTE
6297 eb8f 5f                 L87D9     CLRB                ; MATCH ADDRESS = 0
6298 eb90 32 67                        LEAS $07,S          ; CLEAN UP THE STACK
6299 eb92 7e dc 7a                     JMP  LB4F3          ; CONVERT ACCB TO FP NUMBER
6300 eb95 6c 66              L87DF     INC  $06,S          ; INCREMENT SEARCH POSITION
6301 eb97 30 21                        LEAX $01,Y          ; MOVE X TO NEXT SEARCH POSITION
6302 eb99 20 d9                        BRA  L87BE          ; KEEP LOOKING FOR A MATCH
6303                         
6304                         * EXTENDED BASIC RVEC19 HOOK CODE
6305 eb9b 81 26              XVEC19    CMPA #'&            ; *
6306 eb9d 26 5c                        BNE  L8845          ; * RETURN IF NOT HEX OR OCTAL VARIABLE
6307 eb9f 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS FROM STACK
6308                         * PROCESS A VARIABLE PRECEEDED BY A '&' (&H,&O)
6309 eba1 0f 52              L87EB     CLR  FPA0+2         ; * CLEAR BOTTOM TWO
6310 eba3 0f 53                        CLR  FPA0+3         ; * BYTES OF FPA0
6311 eba5 8e 00 52                     LDX  #FPA0+2        ; BYTES 2,3 OF FPA0 = (TEMPORARY ACCUMULATOR)
6312 eba8 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6313 ebaa 81 4f                        CMPA #'O
6314 ebac 27 12                        BEQ  L880A          ; YES
6315 ebae 81 48                        CMPA #'H
6316 ebb0 27 23                        BEQ  L881F          ; YES
6317 ebb2 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6318 ebb4 20 0c                        BRA  L880C          ; DEFAULT TO OCTAL (&O)
6319 ebb6 81 38              L8800     CMPA #'8
6320 ebb8 10 22 ee 47                  LBHI LB277
6321 ebbc c6 03                        LDB  #$03           ; BASE 8 MULTIPLIER
6322 ebbe 8d 2a                        BSR  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
6323                         * EVALUATE AN &O VARIABLE
6324 ebc0 9d 7c              L880A     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6325 ebc2 25 f2              L880C     BLO  L8800          ; BRANCH IF NUMERIC
6326 ebc4 0f 50              L880E     CLR  FPA0           ; * CLEAR 2 HIGH ORDER
6327 ebc6 0f 51                        CLR  FPA0+1         ; * BYTES OF FPA0
6328 ebc8 0f 06                        CLR  VALTYP         ; SET VARXABLE TYPE TO NUMERIC
6329 ebca 0f 63                        CLR  FPSBYT         ; ZERO OUT SUB BYTE OF FPA0
6330 ebcc 0f 54                        CLR  FP0SGN         ; ZERO OUT MANTISSA SIGN OF FPA0
6331 ebce c6 a0                        LDB  #$A0           ; * SET EXPONENT OF FPA0
6332 ebd0 d7 4f                        STB  FP0EXP         ; *
6333 ebd2 7e e1 68                     JMP  LBA1C          ; GO NORMALIZE FPA0
6334                         * EVALUATE AN &H VARIABLE
6335 ebd5 9d 7c              L881F     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6336 ebd7 25 0b                        BLO  L882E          ; BRANCH IF NUMERIC
6337 ebd9 bd db 29                     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
6338 ebdc 25 e6                        BLO  L880E          ; BRANCH IF NOT ALPHA OR NUMERIC
6339 ebde 81 47                        CMPA #'G            ; CHECK FOR LETTERS A-F
6340 ebe0 24 e2                        BCC  L880E          ; BRANCH IF >= G (ILLEGAL HEX LETTER)
6341 ebe2 80 07                        SUBA #7             ; SUBTRACT ASCII DIFFERENCE BETWEEN A AND 9
6342 ebe4 c6 04              L882E     LDB  #$04           ; BASE 16 DIGIT MULTIPLIER = 2**4
6343 ebe6 8d 02                        BSR  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
6344 ebe8 20 eb                        BRA  L881F          ; KEEP EVALUATING VARIABLE
6345 ebea 68 01              L8834     ASL  $01,X          ; * MULTIPLY TEMPORARY
6346 ebec 69 84                        ROL  ,X             ; * ACCUMULATOR BY TWO
6347 ebee 10 25 f5 ec                  LBCS LBA92          ; 'OV' OVERFLOW ERROR
6348 ebf2 5a                           DECB                ; DECREMENT SHIFT COUNTER
6349 ebf3 26 f5                        BNE  L8834          ; MULTIPLY TEMPORARY ACCUMULATOR AGAIN
6350 ebf5 80 30                        SUBA #'0            ; MASK OFF ASCII
6351 ebf7 ab 01                        ADDA $01,X          ; * ADD DIGIT TO TEMPORARY
6352 ebf9 a7 01                        STA  $01,X          ; * ACCUMULATOR AND SAVE IT
6353 ebfb 39                 L8845     RTS
6354                         
6355 ebfc 35 40              XVEC15    PULS U              ; PULL RETURN ADDRESS AND SAVE IN U REGISTER
6356 ebfe 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
6357 ec00 9e 83                        LDX  CHARAD         ; CURRENT INPUT POINTER TO X
6358 ec02 9d 7c                        JSR  GETNCH         ; GET CHARACTER FROM BASIC
6359 ec04 81 26                        CMPA #'&            ; HEX AND OCTAL VARIABLES ARE PRECEEDED BY &
6360 ec06 27 99                        BEQ  L87EB          ; PROCESS A '&' VARIABLE
6361 ec08 81 b0                        CMPA #TOK_FN        ; TOKEN FOR FN
6362 ec0a 27 5e                        BEQ  L88B4          ; PROCESS FN CALL
6363 ec0c 81 ff                        CMPA #$FF           ; CHECK FOR SECONDARY TOKEN
6364 ec0e 26 08                        BNE  L8862          ; NOT SECONDARY
6365 ec10 9d 7c                        JSR  GETNCH         ; GET CHARACTER FROM BASIC
6366 ec12 81 83                        CMPA #TOK_USR       ; TOKEN FOR USR
6367 ec14 10 27 00 ab                  LBEQ L892C          ; PROCESS USR CALL
6368 ec18 9f 83              L8862     STX  CHARAD         ; RESTORE BASIC'S INPUT POINTER
6369 ec1a 6e c4                        JMP  ,U             ; RETURN TO CALLING ROUTINE
6370 ec1c 9e 68              L8866     LDX  CURLIN         ; GET CURRENT LINE NUMBER
6371 ec1e 30 01                        LEAX $01,X          ; IN DIRECT MODE?
6372 ec20 26 d9                        BNE  L8845          ; RETURN IF NOT IN DIRECT MODE
6373 ec22 c6 16                        LDB  #2*11          ; 'ILLEGAL DIRECT STATEMENT' ERROR
6374 ec24 7e d4 06           L886E     JMP  LAC46          ; PROCESS ERROR
6375                         
6376 ec27 ae 9f 00 83        DEF       LDX  [CHARAD]       ; GET TWO INPUT CHARS
6377 ec2b 8c ff 83                     CMPX #TOK_FF_USR    ; TOKEN FOR USR
6378 ec2e 10 27 00 74                  LBEQ L890F          ; BRANCH IF DEF USR
6379 ec32 8d 23                        BSR  L88A1          ; GET DESCRIPTOR ADDRESS FOR FN VARIABLE NAME
6380 ec34 8d e6                        BSR  L8866          ; DON'T ALLOW DEF FN IF IN DIRECT MODE
6381 ec36 bd d9 f6                     JSR  LB26A          ; SYNTAX CHECK FOR '('
6382 ec39 c6 80                        LDB  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE
6383 ec3b d7 08                        STB  ARYDIS         ; * AND SAVE IT IN THE ARRAY DISABLE FLAG
6384 ec3d bd da de                     JSR  LB357          ; GET VARIABLE DESCRIPTOR
6385 ec40 8d 25                        BSR  L88B1          ; 'TM' ERROR IF STRING
6386 ec42 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6387 ec45 c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR '='
6388 ec47 bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR =
6389 ec4a 9e 4b                        LDX  V4B            ; GET THE ADDRESS OF THE FN NAME DESCRIPTOR
6390 ec4c dc 83                        LDD  CHARAD         ; * GET THE CURRENT INPUT POINTER ADDRESS AND
6391 ec4e ed 84                        STD  ,X             ; * SAVE IT IN FIRST 2 BYTES OF THE DESCRIPTOR
6392 ec50 dc 39                        LDD  VARPTR         ; = GET THE DESCRIPTOR ADDRESS OF THE ARGUMENT
6393 ec52 ed 02                        STD  $02,X          ; = VARIABLE AND SAVE IT IN THE DESCRIPTOR OF THE FN NAME
6394 ec54 7e d6 90                     JMP  DATA           ; MOVE INPUT POINTER TO END OF LINE OR SUBLINE
6395 ec57 c6 b0              L88A1     LDB  #TOK_FN        ; TOKEN FOR FN
6396 ec59 bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR FN
6397 ec5c c6 80                        LDB  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE FLAG
6398 ec5e d7 08                        STB  ARYDIS         ; * AND SAVE IT IN ARRAY VARIABLE FLAG
6399 ec60 8a 80                        ORA  #$80           ; SET BIT 7 OF CURRENT INPUT CHARACTER TO INDICATE AN FN VARIABLE
6400 ec62 bd da e3                     JSR  LB35C          ; * GET THE DESCRIPTOR ADDRESS OF THIS
6401 ec65 9f 4b                        STX  V4B            ; * VARIABLE AND SAVE IT IN V4B
6402 ec67 7e d8 cf           L88B1     JMP  LB143          ; 'TM' ERROR IF STRING VARIABLE
6403                         * EVALUATE AN FN CALL
6404 ec6a 8d eb              L88B4     BSR  L88A1          ; * GET THE DESCRIPTOR OF THE FN NAME
6405 ec6c 34 10                        PSHS X              ; * VARIABLE AND SAVE IT ON THE STACK
6406 ec6e bd d9 ee                     JSR  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
6407 ec71 8d f4                        BSR  L88B1          ; 'TM' ERROR IF STRING VARIABLE
6408 ec73 35 40                        PULS U              ; POINT U TO FN NAME DESCRIPTOR
6409 ec75 c6 32                        LDB  #2*25          ; 'UNDEFINED FUNCTION CALL' ERROR
6410 ec77 ae 42                        LDX  $02,U          ; POINT X TO ARGUMENT VARIABLE DESCRIPTOR
6411 ec79 27 a9                        BEQ  L886E          ; BRANCH TO ERROR HANDLER
6412 ec7b 10 9e 83                     LDY  CHARAD         ; SAVE CURRENT INPUT POINTER IN Y
6413 ec7e ee c4                        LDU  ,U             ; * POINT U TO START OF FN FORMULA AND
6414 ec80 df 83                        STU  CHARAD         ; * SAVE IT IN INPUT POINTER
6415 ec82 a6 04                        LDA  $04,X          ; = GET FP VALUE OF
6416 ec84 34 02                        PSHS A              ; = ARGUMENT VARIABLE, CURRENT INPUT
6417 ec86 ec 84                        LDD  ,X             ; = POINTER, AND ADDRESS OF START
6418 ec88 ee 02                        LDU  $02,X          ; = OF FN FORMULA AND SAVE
6419 ec8a 34 76                        PSHS U,Y,X,B,A      ; = THEM ON THE STACK
6420 ec8c bd e3 81                     JSR  LBC35          ; PACK FPA0 AND SAVE IT IN (X)
6421 ec8f bd d8 cd           L88D9     JSR  LB141          ; EVALUATE FN EXPRESSION
6422 ec92 35 76                        PULS A,B,X,Y,U      ; RESTORE REGISTERS
6423 ec94 ed 84                        STD  ,X             ; * GET THE FP
6424 ec96 ef 02                        STU  $02,X          ; * VALUE OF THE ARGUMENT
6425 ec98 35 02                        PULS A              ; * VARIABLE OFF OF THE
6426 ec9a a7 04                        STA  $04,X          ; * STACK AND RE-SAVE IT
6427 ec9c 9d 82                        JSR  GETCCH         ; GET FINAL CHARACTER OF THE FN FORMULA
6428 ec9e 10 26 ed 61                  LBNE LB277          ; 'SYNTAX' ERROR IF NOT END OF LINE
6429 eca2 10 9f 83                     STY  CHARAD         ; RESTORE INPUT POINTER
6430 eca5 39                 L88EF     RTS
6431                         
6432                         
6433                         
6434                         * DEF USR
6435 eca6 9d 7c              L890F     JSR  GETNCH         ; SKIP PAST SECOND BYTE OF DEF USR TOKEN
6436 eca8 8d 09                        BSR  L891C          ; GET FN NUMBER
6437 ecaa 34 10                        PSHS X              ; SAVE FN EXEC ADDRESS STORAGE LOC
6438 ecac 8d 2d                        BSR  L8944          ; CALCULATE EXEC ADDRESS
6439 ecae 35 40                        PULS U              ; GET FN EXEC ADDRESS STORAGE LOC
6440 ecb0 af c4                        STX  ,U             ; SAVE EXEC ADDRESS
6441 ecb2 39                           RTS
6442 ecb3 5f                 L891C     CLRB                ; DEFAULT TO USR0 IF NO ARGUMENT
6443 ecb4 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6444 ecb6 24 06                        BCC  L8927          ; BRANCH IF NOT NUMERIC
6445 ecb8 80 30                        SUBA #'0            ; MASK OFF ASCII
6446 ecba 1f 89                        TFR  A,B            ; SAVE USR NUMBER IN ACCB
6447 ecbc 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6448 ecbe 9e 8d              L8927     LDX  USRADR         ; GET ADDRESS OF STORAGE LOCs FOR USR ADDRESS
6449 ecc0 58                           ASLB                ; X2 - 2 BYTES/USR ADDRESS
6450 ecc1 3a                           ABX                 ; ADD OFFSET TO START ADDRESS OF STORAGE LOCs
6451 ecc2 39                           RTS
6452                         * PROCESS A USR CALL
6453 ecc3 8d ee              L892C     BSR  L891C          ; GET STORAGE LOC OF EXEC ADDRESS FOR USR N
6454 ecc5 ae 84                        LDX  ,X             ; * GET EXEC ADDRESS AND
6455 ecc7 34 10                        PSHS X              ; * PUSH IT ONTO STACK
6456 ecc9 bd d9 ee                     JSR  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
6457 eccc 8e 00 4f                     LDX  #FP0EXP        ; POINT X TO FPA0
6458 eccf 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
6459 ecd1 27 07                        BEQ  L8943          ; BRANCH IF NUMERIC, STRING IF <> 0
6460 ecd3 bd dd de                     JSR  LB657          ; GET LENGTH & ADDRESS OF STRING VARIABLE
6461 ecd6 9e 52                        LDX  FPA0+2         ; GET POINTER TO STRING DESCRIPTOR
6462 ecd8 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
6463 ecda 39                 L8943     RTS                 ; JUMP TO USR ROUTINE (PSHS X ABOVE)
6464 ecdb c6 ae              L8944     LDB  #TOK_EQUALS    ; TOKEN FOR '='
6465 ecdd bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR =
6466 ece0 7e de c4                     JMP  LB73D          ; EVALUATE EXPRESSION, RETURN VALUE IN X
6467                         
6468                         
6469                         
6470                         * DEL
6471 ece3 10 27 ee ea        DEL       LBEQ LB44A          ; 'FC' ERROR IF NO ARGUMENT
6472 ece7 bd d7 17                     JSR  LAF67          ; CONVERT A DECIMAL BASiC NUMBER TO BINARY
6473 ecea bd d4 a5                     JSR  LAD01          ; FIND RAM ADDRESS OF START OF A BASIC LINE
6474 eced 9f 93                        STX  VD3            ; SAVE RAM ADDRESS OF STARTING LINE NUMBER
6475 ecef 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6476 ecf1 27 10                        BEQ  L8990          ; BRANCH IF END OF LINE
6477 ecf3 81 a7                        CMPA #TOK_MINUS     ; TOKEN FOR '-'
6478 ecf5 26 3b                        BNE  L89BF          ; TERMINATE COMMAND IF LINE NUMBER NOT FOLLOWED BY '-'
6479 ecf7 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6480 ecf9 27 04                        BEQ  L898C          ; IF END OF LINE, USE DEFAULT ENDING LINE NUMBER
6481 ecfb 8d 24                        BSR  L89AE          ; * CONVERT ENDING LINE NUMBER TO BINARY
6482 ecfd 20 04                        BRA  L8990          ; * AND SAVE IT IN BINVAL
6483 ecff 86 ff              L898C     LDA  #$FF           ; = USE $FFXX AS DEFAULT ENDING
6484 ed01 97 2b                        STA  BINVAL         ; = LINE NUMBER - SAVE IT IN BINVAL
6485 ed03 de 93              L8990     LDU  VD3            ; POINT U TO STARTING LINE NUMBER ADDRESS
6486 ed05 8c                 L8992     FCB  SKP2           ; SKIP TWO BYTES
6487 ed06 ee c4              L8993     LDU  ,U             ; POINT U TO START OF NEXT LINE
6488 ed08 ec c4                        LDD  ,U             ; CHECK FOR END OF PROGRAM
6489 ed0a 27 06                        BEQ  L899F          ; BRANCH IF END OF PROGRAM
6490 ed0c ec 42                        LDD  $02,U          ; LOAD ACCD WITH THIS LINE'S NUMBER
6491 ed0e 93 2b                        SUBD BINVAL         ; SUBTRACT ENDING LINE NUMBER ADDRESS
6492 ed10 23 f4                        BLS  L8993          ; BRANCH IF = < ENDING LINE NUMBER
6493 ed12 9e 93              L899F     LDX  VD3            ; GET STARTING LINE NUMBER
6494 ed14 8d 15                        BSR  L89B8          ; MOVE (U) TO (X) UNTIL END OF PROGRAM
6495 ed16 bd d4 c5                     JSR  LAD21          ; RESET BASIC'S INPUT POINTER AND ERASE VARIABLES
6496 ed19 9e 93                        LDX  VD3            ; GET STARTING LINE NUMBER ADDRESS
6497 ed1b bd d4 95                     JSR  LACF1          ; RECOMPUTE START OF NEXT LINE ADDRESSES
6498 ed1e 7e d4 25                     JMP  LAC73          ; JUMP TO BASIC'S MAIN COMMAND LOOP
6499 ed21 bd d7 17           L89AE     JSR  LAF67          ; GO GET LINE NUMBER CONVERTED TO BINARY
6500 ed24 7e d1 ba                     JMP  LA5C7          ; MAKE SURE THERE'S NO MORE ON THIS LINE
6501 ed27 a6 c0              L89B4     LDA  ,U+            ; GET A BYTE FROM (U)
6502 ed29 a7 80                        STA  ,X+            ; MOVE THE BYTE TO (X)
6503 ed2b 11 93 1b           L89B8     CMPU VARTAB         ; COMPARE TO END OF BASIC
6504 ed2e 26 f7                        BNE  L89B4          ; BRANCH IF NOT AT END
6505 ed30 9f 1b                        STX  VARTAB         ; SAVE (X) AS NEW END OF BASIC
6506 ed32 39                 L89BF     RTS
6507                         
6508                         
6509 ed33 bd ec 1c           L89C0     JSR  L8866          ; 'BS' ERROR IF IN DIRECT MODE
6510 ed36 9d 7c                        JSR  GETNCH         ; GET A CHAR FROM BASIC
6511 ed38 81 22              L89D2     CMPA #'"            ; CHECK FOR PROMPT STRING
6512 ed3a 26 0b                        BNE  L89E1          ; BRANCH IF NO PROMPT STRING
6513 ed3c bd d9 d0                     JSR  LB244          ; STRIP OFF PROMPT STRING & PUT IT ON STRING STACK
6514 ed3f c6 3b                        LDB  #';            ; *
6515 ed41 bd d9 fb                     JSR  LB26F          ; * DO A SYNTAX CHECK FOR;
6516 ed44 bd e0 eb                     JSR  LB99F          ; REMOVE PROMPT STRING FROM STRING STACK & SEND TO CONSOLE OUT
6517 ed47 32 7e              L89E1     LEAS -2,S           ; RESERVE TWO STORAGE SLOTS ON STACK
6518 ed49 bd d7 cc                     JSR  LB035          ; INPUT A LINE FROM CURRENT INPUT DEVICE
6519 ed4c 32 62                        LEAS $02,S          ; CLEAN UP THE STACK
6520 ed4e bd da de                     JSR  LB357          ; SEARCH FOR A VARIABLE
6521 ed51 9f 3b                        STX  VARDES         ; SAVE POINTER TO VARIABLE DESCRIPTOR
6522 ed53 bd d8 d2                     JSR  LB146          ; ''TM' ERROR IF VARIABLE TYPE = NUMERIC
6523 ed56 8e 00 f3                     LDX  #LINBUF        ; POINT X TO THE STRING BUFFER WHERE THE INPUT STRING WAS STORED
6524 ed59 4f                           CLRA                ; TERMINATOR CHARACTER 0 (END OF LINE)
6525 ed5a bd dc a3                     JSR  LB51A          ; PARSE THE INPUT STRING AND STORE IT IN THE STRING SPACE
6526 ed5d 7e d7 54                     JMP  LAFA4          ; REMOVE DESCRIPTOR FROM STRING STACK
6527 ed60 bd d7 17           L89FC     JSR  LAF67          ; STRIP A DECIMAL NUMBER FROM BASIC INPUT LINE
6528 ed63 9e 2b                        LDX  BINVAL         ; GET BINARY VALUE
6529 ed65 39                           RTS
6530 ed66 9e 91              L8A02     LDX  VD1            ; GET CURRENT OLD NUMBER BEING RENUMBERED
6531 ed68 9f 2b              L8A04     STX  BINVAL         ; SAVE THE LINE NUMBER BEING SEARCHED FOR
6532 ed6a 7e d4 a5                     JMP  LAD01          ; GO FIND THE LINE NUMBER IN BASIC PROGRAM
6533                         
6534                         * RENUM
6535 ed6d bd d4 ca           RENUM     JSR  LAD26          ; ERASE VARIABLES
6536 ed70 cc 00 0a                     LDD  #10            ; DEFAULT LINE NUMBER INTERVAL
6537 ed73 dd 95                        STD  VD5            ; SAVE DEFAULT RENUMBER START LINE NUMBER
6538 ed75 dd 8f                        STD  VCF            ; SAVE DEFAULT INTERVAL
6539 ed77 5f                           CLRB                ; NOW ACCD = 0
6540 ed78 dd 91                        STD  VD1            ; DEFAULT LINE NUMBER OF WHERE TO START RENUMBERING
6541 ed7a 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6542 ed7c 24 06                        BCC  L8A20          ; BRANCH IF NOT NUMERIC
6543 ed7e 8d e0                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
6544 ed80 9f 95                        STX  VD5            ; SAVE LINE NUMBER WHERE RENUMBERING STARTS
6545 ed82 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6546 ed84 27 1b              L8A20     BEQ  L8A3D          ; BRANCH IF END OF LINE
6547 ed86 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6548 ed89 24 06                        BCC  L8A2D          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
6549 ed8b 8d d3                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
6550 ed8d 9f 91                        STX  VD1            ; SAVE NEW RENUMBER LINE
6551 ed8f 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6552 ed91 27 0e              L8A2D     BEQ  L8A3D          ; BRANCH IF END OF LINE
6553 ed93 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6554 ed96 24 06                        BCC  L8A3A          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
6555 ed98 8d c6                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
6556 ed9a 9f 8f                        STX  VCF            ; SAVE NEW INTERVAL
6557 ed9c 27 49                        BEQ  L8A83          ; 'FC' ERROR
6558 ed9e bd d1 ba           L8A3A     JSR  LA5C7          ; CHECK FOR MORE CHARACTERS ON LINE - 'SYNTAX' ERROR IF ANY
6559 eda1 8d c3              L8A3D     BSR  L8A02          ; GO GET ADDRESS OF OLD NUMBER BEING RENUMBERED
6560 eda3 9f 93                        STX  VD3            ; SAVE ADDRESS
6561 eda5 9e 95                        LDX  VD5            ; GET NEXT RENUMBERED LINE NUMBER TO USE
6562 eda7 8d bf                        BSR  L8A04          ; FIND THE LINE NUMBER IN THE BASIC PROGRAM
6563 eda9 9c 93                        CMPX VD3            ; COMPARE TO ADDRESS OF OLD LINE NUMBER
6564 edab 25 3a                        BLO  L8A83          ; 'FC' ERROR IF NEW ADDRESS < OLD ADDRESS
6565 edad 8d 1c                        BSR  L8A67          ; MAKE SURE RENUMBERED LINE NUMBERS WILL BE IN RANGE
6566 edaf bd ee 41                     JSR  L8ADD          ; CONVERT ASCII LINE NUMBERS TO 'EXPANDED' BINARY
6567 edb2 bd d4 93                     JSR  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESSES
6568 edb5 8d af                        BSR  L8A02          ; GET RAM ADDRESS OF FIRST LINE TO BE RENUMBERED
6569 edb7 9f 93                        STX  VD3            ; SAVE IT
6570 edb9 8d 3a                        BSR  L8A91          ; MAKE SURE LINE NUMBERS EXIST
6571 edbb 8d 0f                        BSR  L8A68          ; INSERT NEW LINE NUMBERS IN LINE HEADERS
6572 edbd 8d 36                        BSR  L8A91          ; INSERT NEW LINE NUMBERS IN PROGRAM STATEMENTS
6573 edbf bd ee dc                     JSR  L8B7B          ; CONVERT PACKED BINARY LINE NUMBERS TO ASCII
6574 edc2 bd d4 ca                     JSR  LAD26          ; ERASE VARIABLES
6575 edc5 bd d4 93                     JSR  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESS
6576 edc8 7e d4 25                     JMP  LAC73          ; GO BACK TO BASIC'S MAIN LOOP
6577 edcb 86                 L8A67     FCB  SKP1LD         ; SKIP ONE BYTE - LDA #$4F
6578 edcc 4f                 L8A68     CLRA                ; NEW LINE NUMBER FLAG - 0; INSERT NEW LINE NUMBERS
6579 edcd 97 98                        STA  VD8            ; SAVE NEW LINE NUMBER FLAG; 0 = INSERT NEW NUMBERS
6580 edcf 9e 93                        LDX  VD3            ; GET ADDRESS OF OLD LINE NUMBER BEING RENUMBERED
6581 edd1 dc 95                        LDD  VD5            ; GET THE CURRENT RENUMBERED LINE NUMBER
6582 edd3 8d 15                        BSR  L8A86          ; RETURN IF END OF PROGRAM
6583 edd5 0d 98              L8A71     TST  VD8            ; CHECK NEW LINE NUMBER FLAG
6584 edd7 26 02                        BNE  L8A77          ; BRANCH IF NOT INSERTING NEW LINE NUMBERS
6585 edd9 ed 02                        STD  $02,X          ; STORE THE NEW LINE NUMBER IN THE BASIC PROGRAM
6586 eddb ae 84              L8A77     LDX  ,X             ; POINT X TO THE NEXT LINE IN BASIC
6587 eddd 8d 0b                        BSR  L8A86          ; RETURN IF END OF PROGRAM
6588 eddf d3 8f                        ADDD VCF            ; ADD INTERVAL TO CURRENT RENUMBERED LINE NUMBER
6589 ede1 25 04                        BLO  L8A83          ; 'FC' ERROR IF LINE NUMBER > $FFFF
6590 ede3 81 fa                        CMPA #MAXLIN        ; LARGEST LINE NUMBER = $F9FF
6591 ede5 25 ee                        BLO  L8A71          ; BRANCH IF LEGAL LINE NUMBER
6592 ede7 7e db d1           L8A83     JMP  LB44A          ; 'FC' ERROR IF LINE NUMBER MS BYTE > $F9
6593                         * TEST THE TWO BYTES POINTED TO BY (X).
6594                         * NORMAL RETURN IF <> 0. IF = 0 (END OF
6595                         * PROGRAM) RETURN IS PULLED OFF STACK AND
6596                         * YOU RETURN TO PREVIOUS SUBROUTINE CALL.
6597 edea 34 06              L8A86     PSHS B,A            ; SAVE ACCD
6598 edec ec 84                        LDD  ,X             ; TEST THE 2 BYTES POINTED TO BY X
6599 edee 35 06                        PULS A,B            ; RESTORE ACCD
6600 edf0 26 02                        BNE  L8A90          ; BRANCH IF NOT END OF PROGRAM
6601 edf2 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS FROM STACK
6602 edf4 39                 L8A90     RTS
6603 edf5 9e 19              L8A91     LDX  TXTTAB         ; GET START OF BASIC PROGRAM
6604 edf7 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
6605 edf9 30 01              L8A95     LEAX $01,X          ; MOVE POINTER UP ONE
6606 edfb 8d ed                        BSR  L8A86          ; RETURN IF END OF PROGRAM
6607 edfd 30 03              L8A99     LEAX $03,X          ; SKIP OVER NEXT LINE ADDRESS AND LINE NUMBER
6608 edff 30 01              L8A9B     LEAX $01,X          ; MOVE POINTER TO NEXT CHARACTER
6609 ee01 a6 84                        LDA  ,X             ; CHECK CURRENT CHARACTER
6610 ee03 27 f4                        BEQ  L8A95          ; BRANCH IF END OF LINE
6611 ee05 9f 0f                        STX  TEMPTR         ; SAVE CURRENT POINTER
6612 ee07 4a                           DECA                ; =
6613 ee08 27 0c                        BEQ  L8AB2          ; =BRANCH IF START OF PACKED NUMERIC LINE
6614 ee0a 4a                           DECA                ; *
6615 ee0b 27 2a                        BEQ  L8AD3          ; *BRANCH IF LINE NUMBER EXISTS
6616 ee0d 4a                           DECA                ; =
6617 ee0e 26 ef                        BNE  L8A9B          ; =MOVE TO NEXT CHARACTER IF > 3
6618 ee10 86 03              L8AAC     LDA  #$03           ; * SET 1ST BYTE = 3 TO INDICATE LINE
6619 ee12 a7 80                        STA  ,X+            ; * NUMBER DOESN'T CURRENTLY EXIST
6620 ee14 20 e7                        BRA  L8A99          ; GO GET ANOTHER CHARACTER
6621 ee16 ec 01              L8AB2     LDD  $01,X          ; GET MS BYTE OF LINE NUMBER
6622 ee18 6a 02                        DEC  $02,X          ; DECREMENT ZERO CHECK BYTE
6623 ee1a 27 01                        BEQ  L8AB9          ; BRANCH IF MS BYTE <> 0
6624 ee1c 4f                           CLRA                ; CLEAR MS BYTE
6625 ee1d e6 03              L8AB9     LDB  $03,X          ; GET LS BYTE OF LINE NUMBER
6626 ee1f 6a 04                        DEC  $04,X          ; DECREMENT ZERO CHECK FLAG
6627 ee21 27 01                        BEQ  L8AC0          ; BRANCH IF IS BYTE <> 0
6628 ee23 5f                           CLRB                ; CLEAR LS BYTE
6629 ee24 ed 01              L8AC0     STD  $01,X          ; SAVE BINARY LINE NUMBER
6630 ee26 dd 2b                        STD  BINVAL         ; SAVE TRIAL LINE NUMBER
6631 ee28 bd d4 a5                     JSR  LAD01          ; FIND RAM ADDRESS OF A BASIC LINE NUMBER
6632 ee2b 9e 0f              L8AC7     LDX  TEMPTR         ; GET BACK POINTER TO START OF PACKED LINE NUMBER
6633 ee2d 25 e1                        BLO  L8AAC          ; BRANCH IF NO LINE NUMBER MATCH FOUND
6634 ee2f dc 47                        LDD  V47            ; GET START ADDRESS OF LINE NUMBER
6635 ee31 6c 80                        INC  ,X+            ; * SET 1ST BYTE = 2, TO INDICATE LINE NUMBER EXISTS IF CHECKING FOR
6636                         *              ; * EXISTENCE OF LINE NUMBER, SET IT = 1 IF INSERTING LINE NUMBERS
6637                         
6638 ee33 ed 84                        STD  ,X             ; SAVE RAM ADDRESS OF CORRECT LINE NUMBER
6639 ee35 20 c6                        BRA  L8A99          ; GO GET ANOTHER CHARACTER
6640 ee37 6f 84              L8AD3     CLR  ,X             ; CLEAR CARRY FLAG AND 1ST BYTE
6641 ee39 ae 01                        LDX  $01,X          ; POINT X TO RAM ADDRESS OF CORRECT LINE NUMBER
6642 ee3b ae 02                        LDX  $02,X          ; PUT CORRECT LINE NUMBER INTO (X)
6643 ee3d 9f 47                        STX  V47            ; SAVE IT TEMPORARILY
6644 ee3f 20 ea                        BRA  L8AC7          ; GO INSERT IT INTO BASIC LINE
6645 ee41 9e 19              L8ADD     LDX  TXTTAB         ; GET BEGINNING OF BASIC PROGRAM
6646 ee43 20 04                        BRA  L8AE5
6647 ee45 9e 83              L8AE1     LDX  CHARAD         ; *GET CURRENT INPUT POINTER
6648 ee47 30 01                        LEAX $01,X          ; *AND BUMP IT ONE
6649 ee49 8d 9f              L8AE5     BSR  L8A86          ; RETURN IF END OF PROGRAM
6650 ee4b 30 02                        LEAX $02,X          ; SKIP PAST NEXT LINE ADDRESS
6651 ee4d 30 01              L8AE9     LEAX $01,X          ; ADVANCE POINTER BY ONE
6652 ee4f 9f 83              L8AEB     STX  CHARAD         ; SAVE NEW BASIC INPUT POINTER
6653 ee51 9d 7c              L8AED     JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
6654 ee53 4d                 L8AEF     TSTA                ; CHECK THE CHARACTER
6655 ee54 27 ef                        BEQ  L8AE1          ; BRANCH IF END OF LINE
6656 ee56 2a f9                        BPL  L8AED          ; BRANCH IF NOT A TOKEN
6657 ee58 9e 83                        LDX  CHARAD         ; GET CURRENT INPUT POINTER
6658 ee5a 81 ff                        CMPA #$FF           ; IS THIS A SECONDARY TOKEN?
6659 ee5c 27 ef                        BEQ  L8AE9          ; YES - IGNORE IT
6660 ee5e 81 a2                        CMPA #TOK_THEN      ; TOKEN FOR THEN?
6661 ee60 27 12                        BEQ  L8B13          ; YES
6662 ee62 81 84                        CMPA #TOK_ELSE      ; TOKEN FOR ELSE?
6663 ee64 27 0e                        BEQ  L8B13          ; YES
6664 ee66 81 81                        CMPA #TOK_GO        ; TOKEN FOR GO?
6665 ee68 26 e7                        BNE  L8AED          ; NO
6666 ee6a 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6667 ee6c 81 a0                        CMPA #TOK_TO        ; TOKEN FOR TO?
6668 ee6e 27 04                        BEQ  L8B13          ; YES
6669 ee70 81 a1                        CMPA #TOK_SUB       ; TOKEN FOR SUB?
6670 ee72 26 db                        BNE  L8AEB          ; NO
6671 ee74 9d 7c              L8B13     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6672 ee76 25 04                        BLO  L8B1B          ; BRANCH IF NUMERIC
6673 ee78 9d 82              L8B17     JSR  GETCCH         ; GET CURRENT BASIC INPUT CHARRACTER
6674 ee7a 20 d7                        BRA  L8AEF          ; KEEP CHECKING THE LINE
6675 ee7c 9e 83              L8B1B     LDX  CHARAD         ; GET CURRENT INPUT ADDRESS
6676 ee7e 34 10                        PSHS X              ; SAVE IT ON THE STACK
6677 ee80 bd d7 17                     JSR  LAF67          ; CONVERT DECIMAL BASIC NUMBER TO BINARY
6678 ee83 9e 83                        LDX  CHARAD         ; GET CURRENT INPUT POINTER
6679 ee85 a6 82              L8B24     LDA  ,-X            ; GET PREVIOUS INPUT CHARACTER
6680 ee87 bd f1 ec                     JSR  L90AA          ; CLEAR CARRY IF NUMERIC INPUT VALUE
6681 ee8a 25 f9                        BLO  L8B24          ; BRANCH IF NON-NUMERIC
6682 ee8c 30 01                        LEAX $01,X          ; MOVE POINTER UP ONE
6683 ee8e 1f 10                        TFR  X,D            ; NOW ACCD POINTS TO ONE PAST END OF LINE NUMBER
6684 ee90 e0 61                        SUBB $01,S          ; SUBTRACT PRE-NUMERIC POINTER LS BYTE
6685 ee92 c0 05                        SUBB #$05           ; MAKE SURE THERE ARE AT LEAST 5 CHARACTERS IN THE NUMERIC LINE
6686                         *
6687 ee94 27 20                        BEQ  L8B55          ; BRANCH IF EXACTLY 5
6688 ee96 25 0a                        BLO  L8B41          ; BRANCH IF < 5
6689 ee98 33 84                        LEAU ,X             ; TRANSFER X TO U
6690 ee9a 50                           NEGB                ; NEGATE B
6691 ee9b 30 85                        LEAX B,X            ; MOVE X BACK B BYTES
6692 ee9d bd ed 2b                     JSR  L89B8          ; *MOVE BYTES FROM (U) TO (X) UNTIL
6693                         *         *U   = END OF BASIC; (I) = NEW END OF BASIC
6694 eea0 20 14                        BRA  L8B55
6695                         * FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER
6696 eea2 9f 47              L8B41     STX  V47            ; SAVE END OF NUMERIC VALUE
6697 eea4 9e 1b                        LDX  VARTAB         ; GET END OF BASIC PROGRAM
6698 eea6 9f 43                        STX  V43            ; SAVE IT
6699 eea8 50                           NEGB                ; NEGATE B
6700 eea9 30 85                        LEAX B,X            ; ADD IT TO END OF NUMERIC POiNTER
6701 eeab 9f 41                        STX  V41            ; SAVE POINTER
6702 eead 9f 1b                        STX  VARTAB         ; STORE END OF BASIC PROGRAM
6703 eeaf bd d3 de                     JSR  LAC1E          ; ACCD = TOP OF ARRAYS - CHECK FOR ENOUGH ROOM
6704 eeb2 9e 45                        LDX  V45            ; * GET AND SAVE THE
6705 eeb4 9f 83                        STX  CHARAD         ; * NEW CURRENT INPUT POINTER
6706 eeb6 35 10              L8B55     PULS X              ; RESTORE POINTER TO START OF NUMERIC VALUE
6707 eeb8 86 01                        LDA  #$01           ; NEW LINE NUMBER FLAG
6708 eeba a7 84                        STA  ,X             ; * SAVE NEW LINE FLAG
6709 eebc a7 02                        STA  $02,X          ; *
6710 eebe a7 04                        STA  $04,X          ; *
6711 eec0 d6 2b                        LDB  BINVAL         ; GET MS BYTE OF BINARY LINE NUMBER
6712 eec2 26 04                        BNE  L8B67          ; BRANCH IF IT IS NOT ZERO
6713 eec4 c6 01                        LDB  #$01           ; ; SAVE A 1 IF BYTE IS 0; OTHERWISE, BASIC WILL
6714                         *              ; THINK IT IS THE END OF A LINE
6715 eec6 6c 02                        INC  $02,X          ; IF 2,X = 2, THEN PREVIOUS BYTE WAS A ZERO
6716 eec8 e7 01              L8B67     STB  $01,X          ; SAVE MS BYTE OF BINARY LINE NUMBER
6717 eeca d6 2c                        LDB  BINVAL+1       ; GET IS BYTE OF BINARY LINE NUMBER
6718 eecc 26 04                        BNE  L8B71          ; BRANCH IF NOT A ZERO BYTE
6719 eece c6 01                        LDB  #$01           ; SAVE A 1 IF BYTE IS A 0
6720 eed0 6c 04                        INC  $04,X          ; IF 4,X = 2, THEN PREVIOUS BYTE WAS A 0
6721 eed2 e7 03              L8B71     STB  $03,X          ; SAVE LS BYTE OF BINARY LINE NUMBER
6722 eed4 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6723 eed6 81 2c                        CMPA #',            ; IS IT A COMMA?
6724 eed8 27 9a                        BEQ  L8B13          ; YES - PROCESS ANOTHER NUMERIC VALUE
6725 eeda 20 9c                        BRA  L8B17          ; NO - GO GET AND PROCESS AN INPUT CHARACTER
6726 eedc 9e 19              L8B7B     LDX  TXTTAB         ; POINT X TO START OF BASIC PROGRAM
6727 eede 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
6728 eee0 30 01              L8B7F     LEAX $01,X          ; MOVE POINTER UP ONE
6729 eee2 ec 02                        LDD  $02,X          ; GET ADDRESS OF NEXT LINE
6730 eee4 dd 68                        STD  CURLIN         ; SAVE IT IN CURLIN
6731 eee6 bd ed ea                     JSR  L8A86          ; RETURN IF END OF PROGRAM
6732 eee9 30 03                        LEAX $03,X          ; SKIP OVER ADDRESS OF NEXT LINE AND 1ST BYTE OF LINE NUMBER
6733 eeeb 30 01              L8B8A     LEAX $01,X          ; MOVE POINTER UP ONE
6734 eeed a6 84              L8B8C     LDA  ,X             ; GET CURRENT CHARACTER
6735 eeef 27 ef                        BEQ  L8B7F          ; BRANCH IF END OF LINE
6736 eef1 4a                           DECA                ; INPUT CHARACTER = 1? - VALID LINE NUMBER
6737 eef2 27 1b                        BEQ  L8BAE          ; YES
6738 eef4 80 02                        SUBA #$02           ; INPUT CHARACTER 3? - UL LINE NUMBER
6739 eef6 26 f3                        BNE  L8B8A          ; NO
6740 eef8 34 10                        PSHS X              ; SAVE CURRENT POSITION OF INPUT POINTER
6741 eefa 8e ef 39                     LDX  #L8BD9-1       ; POINT X TO 'UL' MESSAGE
6742 eefd bd e0 e8                     JSR  LB99C          ; PRINT STRING TO THE SCREEN
6743 ef00 ae e4                        LDX  ,S             ; GET INPUT POINTER
6744 ef02 ec 01                        LDD  $01,X          ; GET THE UNDEFINED LINE NUMBER
6745 ef04 bd e5 18                     JSR  LBDCC          ; CONVERT NUMBER IN ACCD TO DECIMAL AND DISPLAY IT
6746 ef07 bd e5 11                     JSR  LBDC5          ; PRINT 'IN XXXX' XXXX = CURRENT LINE NUMBER
6747 ef0a bd e0 a8                     JSR  LB958          ; SEND A CR TO CONSOLE OUT
6748 ef0d 35 10                        PULS X              ; GET INPUT POINTER BACK
6749 ef0f 34 10              L8BAE     PSHS X              ; SAVE CURRENT POSITION OF INPUT POINTER
6750 ef11 ec 01                        LDD  $01,X          ; LOAD ACCD WITH BINARY VALUE OF LINE NUMBER
6751 ef13 dd 52                        STD  FPA0+2         ; SAVE IN BOTTOM 2 BYTES OF FPA0
6752 ef15 bd eb c4                     JSR  L880E          ; ADJUST REST OF FPA0 AS AN INTEGER
6753 ef18 bd e5 25                     JSR  LBDD9          ; CONVERT FPA0 TO ASCII, STORE IN LINE NUMBER
6754 ef1b 35 40                        PULS U              ; LOAD U WITH PREVIOUS ADDRESS OF INPUT POINTER
6755 ef1d c6 05                        LDB  #$05           ; EACH EXPANDED LINE NUMBER USES 5 BYTES
6756 ef1f 30 01              L8BBE     LEAX $01,X          ; MOVE POINTER FORWARD ONE
6757 ef21 a6 84                        LDA  ,X             ; GET AN ASCII BYTE
6758 ef23 27 05                        BEQ  L8BC9          ; BRANCH IF END OF NUMBER
6759 ef25 5a                           DECB                ; DECREMENT BYTE COUNTER
6760 ef26 a7 c0                        STA  ,U+            ; STORE ASCII NUMBER IN BASIC LINE
6761 ef28 20 f5                        BRA  L8BBE          ; CHECK FOR ANOTHER DIGIT
6762 ef2a 30 c4              L8BC9     LEAX ,U             ; TRANSFER NEW LINE POINTER TO (X)
6763 ef2c 5d                           TSTB                ; DOES THE NEW LINE NUMBER REQUIRE 5 BYTES?
6764 ef2d 27 be                        BEQ  L8B8C          ; YES - GO GET ANOTHER INPUT CHARACTER
6765 ef2f 31 c4                        LEAY ,U             ; SAVE NEW LINE POINTER IN Y
6766 ef31 33 c5                        LEAU B,U            ; POINT U TO END OF 5 BYTE PACKED LINE NUMBER BLOCK
6767 ef33 bd ed 2b                     JSR  L89B8          ; MOVE BYTES FROM (U) TO (X) UNTIL END OF PROGRAM
6768 ef36 30 a4                        LEAX ,Y             ; LOAD (X) WITH NEW LINE POINTER
6769 ef38 20 b3                        BRA  L8B8C          ; GO GET ANOTHER INPUT CHARACTER
6770                         
6771 ef3a 55 4c 20           L8BD9     FCC  "UL "          ; UNKNOWN LINE NUMBER MESSAGE
6772 ef3d 00                           FCB  0
6773                         
6774                         
6775 ef3e bd de c7           HEXDOL    JSR  LB740          ; CONVERT FPA0 INTO A POSITIVE 2 BYTE INTEGER
6776 ef41 8e 01 f0                     LDX  #STRBUF+2      ; POINT TO TEMPORARY BUFFER
6777 ef44 c6 04                        LDB  #$04           ; CONVERT 4 NIBBLES
6778 ef46 34 04              L8BE5     PSHS B              ; SAVE NIBBLE COUNTER
6779 ef48 5f                           CLRB                ; CLEAR CARRY FLAG
6780 ef49 86 04                        LDA  #$04           ; 4 SHIFTS
6781 ef4b 08 53              L8BEA     ASL  FPA0+3         ; * SHIFT BOTTOM TWO BYTES OF
6782 ef4d 09 52                        ROL  FPA0+2         ; * FPA0 LEFT ONE BIT (X2)
6783 ef4f 59                           ROLB                ; IF OVERFLOW, ACCB <> 0
6784 ef50 4a                           DECA                ; * DECREMENT SHIFT COUNTER AND
6785 ef51 26 f8                        BNE  L8BEA          ; * BRANCH IF NOT DONE
6786 ef53 5d                           TSTB                ; CHECK FOR OVERFLOW
6787 ef54 26 0a                        BNE  L8BFF          ; BRANCH IF OVERFLOW
6788 ef56 a6 e4                        LDA  ,S             ; * GET NIBBLE COUNTER,
6789 ef58 4a                           DECA                ; * DECREMENT IT AND
6790 ef59 27 05                        BEQ  L8BFF          ; * BRANCH IF DONE
6791 ef5b 8c 01 f0                     CMPX #STRBUF+2      ; DO NOT DO A CONVERSION UNTIL A NON-ZERO
6792 ef5e 27 0c                        BEQ  L8C0B          ; BYTE IS FOUND - LEADING ZERO SUPPRESSION
6793 ef60 cb 30              L8BFF     ADDB #'0            ; ADD IN ASCII ZERO
6794 ef62 c1 39                        CMPB #'9            ; COMPARE TO ASCII 9
6795 ef64 23 02                        BLS  L8C07          ; BRANCH IF < 9
6796 ef66 cb 07                        ADDB #7             ; ADD ASCII OFFSET IF HEX LETTER
6797 ef68 e7 80              L8C07     STB  ,X+            ; STORE HEX VALUE AND ADVANCE POINTER
6798 ef6a 6f 84                        CLR  ,X             ; CLEAR NEXT BYTE - END OF STRING FLAG
6799 ef6c 35 04              L8C0B     PULS B              ; * GET NIBBLE COUNTER,
6800 ef6e 5a                           DECB                ; * DECREMENT IT AND
6801 ef6f 26 d5                        BNE  L8BE5          ; * BRANCH IF NOT DONE
6802 ef71 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF STACK
6803 ef73 8e 01 ef                     LDX  #STRBUF+1      ; RESET POINTER
6804 ef76 7e dc 9f                     JMP  LB518          ; SAVE STRING ON STRING STACK
6805                         * PROCESS EXCLAMATION POINT
6806 ef79 86 01              L8E37     LDA  #$01           ; * SET SPACES
6807 ef7b 97 99                        STA  VD9            ; * COUNTER = 1
6808                         * PROCESS STRING ITEM - LIST
6809 ef7d 5a                 L8E3B     DECB                ; DECREMENT FORMAT STRING LENGTH COUNTER
6810 ef7e bd f1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <>0
6811 ef81 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6812 ef83 10 27 00 93                  LBEQ L8ED8          ; EXIT PRINT USING IF END OF LINE
6813 ef87 d7 93                        STB  VD3            ; SAVE REMAINDER FORMAT STRING LENGTH
6814 ef89 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
6815 ef8c bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
6816 ef8f 9e 52                        LDX  FPA0+2         ; * GET ITEM - LIST DESCRIPTOR ADDRESS
6817 ef91 9f 4d                        STX  V4D            ; * AND SAVE IT IN V4D
6818 ef93 d6 99                        LDB  VD9            ; GET SPACES COUNTER
6819 ef95 bd de 34                     JSR  LB6AD          ; PUT ACCB BYTES INTO STRING SPACE & PUT DESCRIPTOR ON STRING STACK
6820 ef98 bd e0 eb                     JSR  LB99F          ; PRINT THE FORMATTED STRING TO CONSOLE OUT
6821                         * PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING < FORMAT STRING LENGTH
6822 ef9b 9e 52                        LDX  FPA0+2         ; POINT X TO FORMATTED STRING DESCRIPTOR ADDRESS
6823 ef9d d6 99                        LDB  VD9            ; GET SPACES COUNTER
6824 ef9f e0 84                        SUBB ,X             ; SUBTRACT LENGTH OF FORMATTED STRING
6825 efa1 5a                 L8E5F     DECB                ; DECREMENT DIFFERENCE
6826 efa2 10 2b 01 4f                  LBMI L8FB3          ; GO INTERPRET ANOTHER ITEM - LIST
6827 efa6 bd e0 f8                     JSR  LB9AC          ; PAD FORMAT STRING WITH A SPACE
6828 efa9 20 f6                        BRA  L8E5F          ; KEEP PADDING
6829                         * PERCENT SIGN - PROCESS A %SPACES% COMMAND
6830 efab d7 93              L8E69     STB  VD3            ; * SAVE THE CURRENT FORMAT STRING
6831 efad 9f 0f                        STX  TEMPTR         ; * COUNTER AND POINTER
6832 efaf 86 02                        LDA  #$02           ; INITIAL SPACES COUNTER = 2
6833 efb1 97 99                        STA  VD9            ; SAVE IN SPACES COUNTER
6834 efb3 a6 84              L8E71     LDA  ,X             ; GET A CHARACTER FROM FORMAT STRING
6835 efb5 81 25                        CMPA #'%            ; COMPARE TO TERMINATOR CHARACTER
6836 efb7 27 c4                        BEQ  L8E3B          ; BRANCH IF END OF SPACES COMMAND
6837 efb9 81 20                        CMPA #'             ; BLANK
6838 efbb 26 07                        BNE  L8E82          ; BRANCH IF ILLEGAL CHARACTER
6839 efbd 0c 99                        INC  VD9            ; ADD ONE TO SPACES COUNTER
6840 efbf 30 01                        LEAX $01,X          ; MOVE FORMAT POINTER UP ONE
6841 efc1 5a                           DECB                ; DECREMENT LENGTH COUNTER
6842 efc2 26 ef                        BNE  L8E71          ; BRANCH IF NOT END OF FORMAT STRING
6843 efc4 9e 0f              L8E82     LDX  TEMPTR         ; * RESTORE CURRENT FORMAT STRING COUNTER
6844 efc6 d6 93                        LDB  VD3            ; * AND POINTER TO POSITION BEFORE SPACES COMMAND
6845 efc8 86 25                        LDA  #'%            ; SEND A '%' TO CONSOLE OUT AS A DEBUGGING AID
6846                         * ERROR PROCESSOR - ILLEGAL CHARACTER OR BAD SYNTAX IN FORMAT STRING
6847 efca bd f1 1a           L8E88     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
6848 efcd bd d0 17                     JSR  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
6849 efd0 20 29                        BRA  L8EB9          ; GET NEXT CHARACTER IN FORMAT STRING
6850                         
6851                         * PRINT RAM HOOK
6852 efd2 81 b1              XVEC9     CMPA #TOK_USING     ; USING TOKEN
6853 efd4 27 01                        BEQ  L8E95          ; BRANCH IF PRINT USING
6854 efd6 39                           RTS
6855                         
6856                         * PRINT USING
6857                         * VDA IS USED AS A STATUS BYTE: BIT 6 = COMMA FORCE
6858                         * BIT 5=LEADING ASTERISK FORCE; BIT 4 = FLOATING $ FORCE
6859                         * BIT 3 = PRE SIGN FORCE; BIT 2 = POST SIGN FORCE; BIT 0 = EXPONENTIAL FORCE
6860 efd7 32 62              L8E95     LEAS $02,S          ; PURGE RETURN ADDRESS OFF THE STACK
6861 efd9 bd d8 e4                     JSR  LB158          ; EVALUATE FORMAT STRING
6862 efdc bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
6863 efdf c6 3b                        LDB  #';            ; CHECK FOR ITEM LIST SEPARATOR
6864 efe1 bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR ;
6865 efe4 9e 52                        LDX  FPA0+2         ; * GET FORMAT STRING DESCRIPTOR ADDRESS
6866 efe6 9f 95                        STX  VD5            ; * AND SAVE IT IN VD5
6867 efe8 20 06                        BRA  L8EAE          ; GO PROCESS FORMAT STRING
6868 efea 96 97              L8EA8     LDA  VD7            ; *CHECK NEXT PRINT ITEM FLAG AND
6869 efec 27 08                        BEQ  L8EB4          ; *'FC' ERROR IF NO FURTHER PRINT ITEMS
6870 efee 9e 95                        LDX  VD5            ; RESET FORMAT STRING POINTER TO START OF STRING
6871 eff0 0f 97              L8EAE     CLR  VD7            ; RESET NEXT PRINT ITEM FLAG
6872 eff2 e6 84                        LDB  ,X             ; GET LENGTH OF FORMAT STRING
6873 eff4 26 03                        BNE  L8EB7          ; INTERPRET FORMAT STRING IF LENGTH > 0
6874 eff6 7e db d1           L8EB4     JMP  LB44A          ; 'FC' ERROR IF FORMAT STRING = NULL
6875 eff9 ae 02              L8EB7     LDX  $02,X          ; POINT X TO START OF FORMAT STRING
6876                         * INTERPRET THE FORMAT STRING
6877 effb 0f 9a              L8EB9     CLR  VDA            ; CLEAR THE STATUS BYTE
6878 effd 0f 99              L8EBB     CLR  VD9            ; CLEAR LEFT DIGIT COUNTER
6879 efff a6 80                        LDA  ,X+            ; GET A CHARACTER FROM FORMAT STRING
6880 f001 81 21                        CMPA #'!            ; EXCLAMATION POINT?
6881 f003 10 27 ff 72                  LBEQ L8E37          ; YES - STRING TYPE FORMAT
6882 f007 81 23                        CMPA #'#            ; NUMBER SIGN? (DIGIT LOCATOR)
6883 f009 27 5b                        BEQ  L8F24          ; YES - NUMERIC TYPE FORMAT
6884 f00b 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH
6885 f00c 26 16                        BNE  L8EE2          ; BRANCH IF NOT DONE
6886 f00e bd f1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
6887 f011 bd d0 17                     JSR  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
6888 f014 9d 82              L8ED2     JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
6889 f016 26 d2                        BNE  L8EA8          ; BRANCH IF NOT END OF LINE
6890 f018 96 97                        LDA  VD7            ; GET NEXT PRINT ITEM FLAG
6891 f01a 26 03              L8ED8     BNE  L8EDD          ; BRANCH IF MORE PRINT ITEMS
6892 f01c bd e0 a8                     JSR  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
6893 f01f 9e 95              L8EDD     LDX  VD5            ; POINT X TO FORMAT STRING DESCRIPTOR
6894 f021 7e dd e0                     JMP  LB659          ; RETURN ADDRESS AND LENGTH OF FORMAT STRING - EXIT PRINT USING
6895 f024 81 2b              L8EE2     CMPA #'+            ; CHECK FOR '+' (PRE-SIGN FORCE)
6896 f026 26 09                        BNE  L8EEF          ; NO PLUS
6897 f028 bd f1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
6898 f02b 86 08                        LDA  #$08           ; * LOAD THE STATUS BYTE WITH 8;
6899 f02d 97 9a                        STA  VDA            ; * PRE-SIGN FORCE FLAG
6900 f02f 20 cc                        BRA  L8EBB          ; INTERPRET THE REST OF THE FORMAT STRING
6901 f031 81 2e              L8EEF     CMPA #'.            ; DECIMAL POINT?
6902 f033 27 4e                        BEQ  L8F41          ; YES
6903 f035 81 25                        CMPA #'%            ; PERCENT SIGN?
6904 f037 10 27 ff 70                  LBEQ L8E69          ; YES
6905 f03b a1 84                        CMPA ,X             ; COMPARE THE PRESENT FORMAT STRING INPUT
6906                         *              ; CHARACTER TO THE NEXT ONE IN THE STRING
6907 f03d 26 8b              L8EFB     BNE  L8E88          ; NO MATCH - ILLEGAL CHARACTER
6908                         * TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING
6909 f03f 81 24                        CMPA #'$            ; DOLLAR SIGN?
6910 f041 27 19                        BEQ  L8F1A          ; YES - MAKE THE DOLLAR SIGN FLOAT
6911 f043 81 2a                        CMPA #'*            ; ASTERISK?
6912 f045 26 f6                        BNE  L8EFB          ; NO - ILLEGAL CHARACTER
6913 f047 96 9a                        LDA  VDA            ; * GRAB THE STATUS BYTE AND BET BIT 5
6914 f049 8a 20                        ORA  #$20           ; * TO INDICATE THAT THE OUTPUT WILL
6915 f04b 97 9a                        STA  VDA            ; * BE LEFT PADDED WITH ASTERISKS
6916 f04d c1 02                        CMPB #2             ; * CHECK TO SEE IF THE $$ ARE THE LAST TWO
6917 f04f 25 11                        BLO  L8F20          ; * CHARACTERS IN THE FORMAT STRING AND BRANCH IF SO
6918 f051 a6 01                        LDA  $01,X          ; GET THE NEXT CHARACTER AFTER **
6919 f053 81 24                        CMPA #'$            ; CHECK FOR **$
6920 f055 26 0b                        BNE  L8F20          ; CHECK FOR MORE CHARACTERS
6921 f057 5a                           DECB                ; DECREMENT STRING LENGTH COUNTER
6922 f058 30 01                        LEAX $01,X          ; MOVE FORMAT STRING POINTER UP ONE
6923 f05a 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER - FOR ASTERISK PAD AND
6924                         *              ; FLOATING DOLLAR SIGN COMBINATION
6925 f05c 96 9a              L8F1A     LDA  VDA            ; * GET THE STATUS BYTE AND SET
6926 f05e 8a 10                        ORA  #$10           ; * BIT 4 TO INDICATE A
6927 f060 97 9a                        STA  VDA            ; * FLOATING DOLLAR SIGN
6928 f062 30 01              L8F20     LEAX $01,X          ; MOVE FORMAT STRING POINTER UP ONE
6929 f064 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT (FLOATING $ OR ASTERISK PAD)
6930                         * PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT IN THE FORMAT STRING
6931 f066 0f 98              L8F24     CLR  VD8            ; CLEAR THE RIGHT DIGIT COUNTER
6932 f068 0c 99              L8F26     INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER
6933 f06a 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH COUNTER
6934 f06b 27 49                        BEQ  L8F74          ; BRANCH IF END OF FORMAT STRING
6935 f06d a6 80                        LDA  ,X+            ; GET THE NEXT FORMAT CHARACTER
6936 f06f 81 2e                        CMPA #'.            ; DECIMAL POINT?
6937 f071 27 1e                        BEQ  L8F4F          ; YES
6938 f073 81 23                        CMPA #'#            ; NUMBER SIGN?
6939 f075 27 f1                        BEQ  L8F26          ; YES
6940 f077 81 2c                        CMPA #',            ; COMMA?
6941 f079 26 21                        BNE  L8F5A          ; NO
6942 f07b 96 9a                        LDA  VDA            ; * GET THE STATUS BYTE
6943 f07d 8a 40                        ORA  #$40           ; * AND SET BIT 6 WHICH IS THE
6944 f07f 97 9a                        STA  VDA            ; * COMMA SEPARATOR FLAG
6945 f081 20 e5                        BRA  L8F26          ; PROCESS MORE CHARACTERS TO LEFT OF DECIMAL POINT
6946                         * PROCESS DECIMAL POINT IF NO DIGITS TO LEFT OF IT
6947 f083 a6 84              L8F41     LDA  ,X             ; GET NEXT FORMAT CHARACTER
6948 f085 81 23                        CMPA #'#            ; IS IT A NUMBER SIGN?
6949 f087 10 26 ff 3f                  LBNE L8E88          ; NO
6950 f08b 86 01                        LDA  #1             ; * SET THE RIGHT DIGIT COUNTER TO 1 -
6951 f08d 97 98                        STA  VD8            ; * ALLOW ONE SPOT FOR DECIMAL POINT
6952 f08f 30 01                        LEAX $01,X          ; MOVE FORMAT POINTER UP ONE
6953                         * PROCESS DIGITS TO RIGHT OF DECIMAL POINT
6954 f091 0c 98              L8F4F     INC  VD8            ; ADD ONE TO RIGHT DIGIT COUNTER
6955 f093 5a                           DECB                ; DECREMENT FORMAT LENGTH COUNTER
6956 f094 27 20                        BEQ  L8F74          ; BRANCH IF END OF FORMAT STRING
6957 f096 a6 80                        LDA  ,X+            ; GET A CHARACTER FROM FORMAT STRING
6958 f098 81 23                        CMPA #'#            ; IS IT NUMBER SIGN?
6959 f09a 27 f5                        BEQ  L8F4F          ; YES - KEEP CHECKING
6960                         * CHECK FOR EXPONENTIAL FORCE
6961 f09c 81 5e              L8F5A     CMPA #$5E           ; CHECK FOR UP ARROW
6962 f09e 26 16                        BNE  L8F74          ; NO UP ARROW
6963 f0a0 a1 84                        CMPA ,X             ; IS THE NEXT CHARACTER AN UP ARROW?
6964 f0a2 26 12                        BNE  L8F74          ; NO
6965 f0a4 a1 01                        CMPA $01,X          ; AND THE NEXT CHARACTER?
6966 f0a6 26 0e                        BNE  L8F74          ; NO
6967 f0a8 a1 02                        CMPA $02,X          ; HOW ABOUT THE 4TH CHARACTER?
6968 f0aa 26 0a                        BNE  L8F74          ; NO, ALSO
6969 f0ac c1 04                        CMPB #4             ; * CHECK TO SEE IF THE 4 UP ARROWS ARE IN THE
6970 f0ae 25 06                        BLO  L8F74          ; * FORMAT STRING AND BRANCH IF NOT
6971 f0b0 c0 04                        SUBB #4             ; * MOVE POINTER UP 4 AND SUBTRACT
6972 f0b2 30 04                        LEAX $04,X          ; * FOUR FROM LENGTH
6973 f0b4 0c 9a                        INC  VDA            ; INCREMENT STATUS BYTE - EXPONENTIAL FORM
6974                         
6975                         * CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMAT STRING
6976 f0b6 30 1f              L8F74     LEAX -1,X           ; MOVE POINTER BACK ONE
6977 f0b8 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER FOR PRE-SIGN FORCE
6978 f0ba 96 9a                        LDA  VDA            ; * PRE-SIGN
6979 f0bc 85 08                        BITA #$08           ; * FORCE AND
6980 f0be 26 18                        BNE  L8F96          ; * BRANCH IF SET
6981 f0c0 0a 99                        DEC  VD9            ; DECREMENT LEFT DIGIT - NO PRE-SIGN FORCE
6982 f0c2 5d                           TSTB                ; * CHECK LENGTH COUNTER AND BRANCH
6983 f0c3 27 13                        BEQ  L8F96          ; * IF END OF FORMAT STRING
6984 f0c5 a6 84                        LDA  ,X             ; GET NEXT FORMAT STRING CHARACTER
6985 f0c7 80 2d                        SUBA #'-            ; CHECK FOR MINUS SIGN
6986 f0c9 27 06                        BEQ  L8F8F          ; BRANCH IF MINUS SIGN
6987 f0cb 81 fe                        CMPA #$FE           ; * WAS CMPA #('+')-('-')
6988 f0cd 26 09                        BNE  L8F96          ; BRANCH IF NO PLUS SIGN
6989 f0cf 86 08                        LDA  #$08           ; GET THE PRE-SIGN FORCE FLAG
6990 f0d1 8a 04              L8F8F     ORA  #$04           ; 'OR' IN POST-SIGN FORCE FLAG
6991 f0d3 9a 9a                        ORA  VDA            ; 'OR' IN THE STATUS BYTE
6992 f0d5 97 9a                        STA  VDA            ; SAVE THE STATUS BYTE
6993 f0d7 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH
6994                         
6995                         * EVALUATE NUMERIC ITEM-LIST
6996 f0d8 9d 82              L8F96     JSR  GETCCH         ; GET CURRENT CHARACTER
6997 f0da 10 27 ff 3c                  LBEQ L8ED8          ; BRANCH IF END OF LINE
6998 f0de d7 93                        STB  VD3            ; SAVE FORMAT STRING LENGTH WHEN FORMAT EVALUATION ENDED
6999 f0e0 bd d8 cd                     JSR  LB141          ; EVALUATE EXPRESSION
7000 f0e3 96 99                        LDA  VD9            ; GET THE LEFT DIGIT COUNTER
7001 f0e5 9b 98                        ADDA VD8            ; ADD IT TO THE RIGHT DIGIT COUNTER
7002 f0e7 81 11                        CMPA #17            ; *
7003 f0e9 10 22 ea e4                  LBHI LB44A          ; *'FC' ERROR IF MORE THAN 16 DIGITS AND DECIMAL POiNT
7004 f0ed bd f1 27                     JSR  L8FE5          ; CONVERT ITEM-LIST TO FORMATTED ASCII STRING
7005 f0f0 30 1f                        LEAX -1,X           ; MOVE BUFFER POINTER BACK ONE
7006 f0f2 bd e0 e8                     JSR  LB99C          ; DISPLAY THE FORMATTED STRING TO CONSOLE OUT
7007 f0f5 0f 97              L8FB3     CLR  VD7            ; RESET NEXT PRINT ITEM FLAG
7008 f0f7 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
7009 f0f9 27 0d                        BEQ  L8FC6          ; BRANCH IF END OF LINE
7010 f0fb 97 97                        STA  VD7            ; SAVE CURRENT CHARACTER (<>0) IN NEXT PRINT ITEM FLAG
7011 f0fd 81 3b                        CMPA #';            ; * CHECK FOR ; - ITEM-LIST SEPARATOR AND
7012 f0ff 27 05                        BEQ  L8FC4          ; * BRANCH IF SEMICOLON
7013 f101 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
7014 f104 20 02                        BRA  L8FC6          ; PROCESS NEXT PRINT ITEM
7015 f106 9d 7c              L8FC4     JSR  GETNCH         ; GET NEXT INPUT CHARACTER
7016 f108 9e 95              L8FC6     LDX  VD5            ; GET FORMAT STRING DESCRIPTOR ADDRESS
7017 f10a e6 84                        LDB  ,X             ; GET LENGTH OF FORMAT STRING
7018 f10c d0 93                        SUBB VD3            ; SUBTRACT AMOUNT OF FORMAT STRING LEFT AFTER LAST PRINT ITEM
7019 f10e ae 02                        LDX  $02,X          ; *GET FORMAT STRING START ADDRESS AND ADVANCE
7020 f110 3a                           ABX                 ; *POINTER TO START OF UNUSED FORMAT STRING
7021 f111 d6 93                        LDB  VD3            ; * GET AMOUNT OF UNUSED FORMAT STRING
7022 f113 10 26 fe e4                  LBNE L8EB9          ; * REINTERPRET FORMAT STRING FROM THAT POINT
7023 f117 7e f0 14                     JMP  L8ED2          ; REINTERPRET FORMAT STRING FROM THE START IF ENTIRELY
7024                         *         USED ON LAST PRINT ITEM
7025                         
7026                         * PRINT A '+' TO CONSOLE OUT IF THE STATUS BYTE <> 0
7027 f11a 34 02              L8FD8     PSHS A              ; RESTORE ACCA AND RETURN
7028 f11c 86 2b                        LDA  #'+            ; GET ASCII PLUS SIGN
7029 f11e 0d 9a                        TST  VDA            ; * CHECK THE STATUS BYTE AND
7030 f120 27 03                        BEQ  L8FE3          ; * RETURN IF = 0
7031 f122 bd d0 17                     JSR  PUTCHR         ; SEND A CHARACTER TO CONSOLE OUT
7032 f125 35 82              L8FE3     PULS A,PC           ; RETURN ACCA AND RETURN
7033                         
7034                         * CONVERT ITEM-LIST TO DECIMAL ASCII STRING
7035 f127 ce 01 f2           L8FE5     LDU  #STRBUF+4      ; POINT U TO STRING BUFFER
7036 f12a c6 20                        LDB  #SPACE         ; BLANK
7037 f12c 96 9a                        LDA  VDA            ; * GET THE STATUS FLAG AND
7038 f12e 85 08                        BITA #$08           ; * CHECK FOR A PRE-SIGN FORCE
7039 f130 27 02                        BEQ  L8FF2          ; * BRANCH IF NO PRE-SIGN FORCE
7040 f132 c6 2b                        LDB  #'+            ; PLUS SIGN
7041 f134 0d 54              L8FF2     TST  FP0SGN         ; CHECK THE SIGN OF FPA0
7042 f136 2a 04                        BPL  L8FFA          ; BRANCH IF POSITIVE
7043 f138 0f 54                        CLR  FP0SGN         ; FORCE FPA0 SIGN TO BE POSITIVE
7044 f13a c6 2d                        LDB  #'-            ; MINUS SIGN
7045 f13c e7 c0              L8FFA     STB  ,U+            ; SAVE THE SIGN IN BUFFER
7046 f13e c6 30                        LDB  #'0            ; * PUT A ZERO INTO THE BUFFER
7047 f140 e7 c0                        STB  ,U+            ; *
7048 f142 84 01                        ANDA #$01           ; * CHECK THE EXPONENTIAL FORCE FLAG IN
7049 f144 10 26 01 07                  LBNE L910D          ; * THE STATUS BYTE - BRANCH IF ACTIVE
7050 f148 8e e5 0c                     LDX  #LBDC0         ; POINT X TO FLOATING POINT 1E + 09
7051 f14b bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO (X)
7052 f14e 2b 15                        BMI  L9023          ; BRANCH IF FPA0 < 1E+09
7053 f150 bd e5 25                     JSR  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
7054 f153 a6 80              L9011     LDA  ,X+            ; * ADVANCE POINTER TO END OF
7055 f155 26 fc                        BNE  L9011          ; * ASCII STRING (ZERO BYTE)
7056 f157 a6 82              L9015     LDA  ,-X            ; MOVE THE
7057 f159 a7 01                        STA  $01,X          ; ENTIRE STRING
7058 f15b 8c 01 f1                     CMPX #STRBUF+3      ; UP ONE
7059 f15e 26 f7                        BNE  L9015          ; BYTE
7060 f160 86 25                        LDA  #'%            ; * INSERT A % SIGN AT START OF
7061 f162 a7 84                        STA  ,X             ; * STRING - OVERFLOW ERROR
7062 f164 39                           RTS
7063                         
7064 f165 96 4f              L9023     LDA  FP0EXP         ; GET EXPONENT OF FPA0
7065 f167 97 47                        STA  V47            ; AND SAVE IT IN V74
7066 f169 27 03                        BEQ  L902C          ; BRANCH IF FPA0 = 0
7067 f16b bd f3 0f                     JSR  L91CD          ; CONVERT FPA0 TO NUMBER WITH 9 SIGNIFICANT
7068                         *              ; PLACES TO LEFT OF DECIMAL POINT
7069 f16e 96 47              L902C     LDA  V47            ; GET BASE 10 EXPONENT OFFSET
7070 f170 10 2b 00 81                  LBMI L90B3          ; BRANCH IF FPA0 < 100,000,000
7071 f174 40                           NEGA                ; * CALCULATE THE NUMBER OF LEADING ZEROES TO INSERT -
7072 f175 9b 99                        ADDA VD9            ; * SUBTRACT BASE 10 EXPONENT OFFSET AND 9 (FPA0 HAS
7073 f177 80 09                        SUBA #$09           ; * 9 PLACES TO LEFT OF EXPONENT) FROM LEFT DIGIT COUNTER
7074 f179 bd f2 2c                     JSR  L90EA          ; PUT ACCA ZEROES IN STRING BUFFER
7075 f17c bd f3 a5                     JSR  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
7076 f17f bd f3 44                     JSR  L9202          ; CONVERT FPA0 TO DECIMAL ASCII IN THE STRING BUFFER
7077 f182 96 47                        LDA  V47            ; * GET BASE 10 EXPONENT AND PUT THAT MANY
7078 f184 bd f3 c3                     JSR  L9281          ; * ZEROES IN STRING BUFFER - STOP AT DECIMAL POINT
7079 f187 96 47                        LDA  V47            ; WASTED INSTRUCTION - SERVES NO PURPOSE
7080 f189 bd f3 8b                     JSR  L9249          ; CHECK FOR DECIMAL POINT
7081 f18c 96 98                        LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
7082 f18e 26 02                        BNE  L9050          ; BRANCH IF RIGHT DIGlT COUNTER <> 0
7083 f190 33 5f                        LEAU -1,U           ; * MOVE BUFFER POINTER BACK ONE - DELETE
7084                         *                             ; * DECIMAL POINT IF NO RIGHT DIGITS SPECiFIED
7085 f192 4a                 L9050     DECA                ; SUBTRACT ONE (DECIMAL POINT)
7086 f193 bd f2 2c                     JSR  L90EA          ; PUT ACCA ZEROES INTO BUFFER (TRAILING ZEROES)
7087 f196 bd f2 c7           L9054     JSR  L9185          ; INSERT ASTERISK PADDING, FLOATING $, AND POST-SIGN
7088 f199 4d                           TSTA                ; WAS THERE A POST-SIGN?
7089 f19a 27 06                        BEQ  L9060          ; NO
7090 f19c c1 2a                        CMPB #'*            ; IS THE FIRST CHARACTER AN $?
7091 f19e 27 02                        BEQ  L9060          ; YES
7092 f1a0 e7 c0                        STB  ,U+            ; STORE THE POST-SIGN
7093 f1a2 6f c4              L9060     CLR  ,U             ; CLEAR THE LAST CHARACTER IN THE BUFFER
7094                         *
7095                         * REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE
7096                         * STRING BUFFER TO THE LEFT OF THE DECIMAL POINT
7097 f1a4 8e 01 f1                     LDX  #STRBUF+3      ; POINT X TO THE START OF THE BUFFER
7098 f1a7 30 01              L9065     LEAX $01,X          ; MOVE BUFFER POINTER UP ONE
7099 f1a9 9f 0f                        STX  TEMPTR         ; SAVE BUFFER POINTER IN TEMPTR
7100 f1ab 96 3a                        LDA  VARPTR+1       ; * GET ADDRESS OF DECIMAL POINT IN BUFFER, SUBTRACT
7101 f1ad 90 10                        SUBA TEMPTR+1       ; * CURRENT POSITION AND SUBTRACT LEFT DIGIT COUNTER -
7102 f1af 90 99                        SUBA VD9            ; * THE RESULT WILL BE ZERO WHEN TEMPTR+1 IS POINTING
7103                         *              ; * TO THE FIRST DIGIT OF THE FORMAT STRING
7104 f1b1 27 38                        BEQ  L90A9          ; RETURN IF NO DIGITS TO LEFT OF THE DECiMAL POINT
7105 f1b3 a6 84                        LDA  ,X             ; GET THE CURRENT BUFFER CHARACTER
7106 f1b5 81 20                        CMPA #SPACE         ; SPACE?
7107 f1b7 27 ee                        BEQ  L9065          ; YES - ADVANCE POINTER
7108 f1b9 81 2a                        CMPA #'*            ; ASTERISK?
7109 f1bb 27 ea                        BEQ  L9065          ; YES - ADVANCE POINTER
7110 f1bd 4f                           CLRA                ; A ZERO ON THE STACK IS END OF DATA POINTER
7111 f1be 34 02              L907C     PSHS A              ; PUSH A CHARACTER ONTO THE STACK
7112 f1c0 a6 80                        LDA  ,X+            ; GET NEXT CHARACTER FROM BUFFER
7113 f1c2 81 2d                        CMPA #'-            ; MINUS SIGN?
7114 f1c4 27 f8                        BEQ  L907C          ; YES
7115 f1c6 81 2b                        CMPA #'+            ; PLUS SIGN?
7116 f1c8 27 f4                        BEQ  L907C          ; YES
7117 f1ca 81 24                        CMPA #'$            ; DOLLAR SIGN?
7118 f1cc 27 f0                        BEQ  L907C          ; YES
7119 f1ce 81 30                        CMPA #'0            ; ZERO?
7120 f1d0 26 0e                        BNE  L909E          ; NO - ERROR
7121 f1d2 a6 01                        LDA  $01,X          ; GET CHARACTER FOLLOWING ZERO
7122 f1d4 8d 16                        BSR  L90AA          ; CLEAR CARRY IF NUMERIC
7123 f1d6 25 08                        BLO  L909E          ; BRANCH IF NOT A NUMERIC CHARACTER - ERROR
7124 f1d8 35 02              L9096     PULS A              ; * PULL A CHARACTER OFF OF THE STACK
7125 f1da a7 82                        STA  ,-X            ; * AND PUT IT BACK IN THE STRING BUFFER
7126 f1dc 26 fa                        BNE  L9096          ; * KEEP GOING UNTIL ZERO FLAG
7127 f1de 20 c7                        BRA  L9065          ; KEEP CLEANING UP THE INPUT BUFFER
7128 f1e0 35 02              L909E     PULS A              ;
7129 f1e2 4d                           TSTA                ; * THE STACK AND EXIT WHEN
7130 f1e3 26 fb                        BNE  L909E          ; * ZERO FLAG FOUND
7131 f1e5 9e 0f                        LDX  TEMPTR         ; GET THE STRING BUFFER START POINTER
7132 f1e7 86 25                        LDA  #'%            ; * PUT A % SIGN BEFORE THE ERROR POSITION TO
7133 f1e9 a7 82                        STA  ,-X            ; * INDICATE AN ERROR
7134 f1eb 39                 L90A9     RTS
7135                         *
7136                         * CLEAR CARRY IF NUMERIC
7137 f1ec 81 30              L90AA     CMPA #'0            ; ASCII ZERO
7138 f1ee 25 04                        BLO  L90B2          ; RETURN IF ACCA < ASCII 0
7139 f1f0 80 3a                        SUBA #$3A           ; *  #'9'+1
7140 f1f2 80 c6                        SUBA #$C6           ; * #-('9'+1)  CARRY CLEAR IF NUMERIC
7141 f1f4 39                 L90B2     RTS
7142                         *
7143                         * PROCESS AN ITEM-LIST WHICH IS < 100,000,000
7144 f1f5 96 98              L90B3     LDA  VD8            ; GET RIGHT DIGIT COUNTER
7145 f1f7 27 01                        BEQ  L90B8          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT OF DECIMAL PT
7146 f1f9 4a                           DECA                ; SUBTRACT ONE FOR DECIMAL POINT
7147 f1fa 9b 47              L90B8     ADDA V47            ; *ADD THE BASE 10 EXPONENT OFFSET - ACCA CONTAINS THE
7148                         *         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO THE SPECIFIED
7149                         *         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMAL POINT
7150 f1fc 2b 01                        BMI  L90BD          ; IF ACCA >= 0 THEN NO SHIFTS ARE REQUIRED
7151 f1fe 4f                           CLRA                ; FORCE SHIFT COUNTER = 0
7152 f1ff 34 02              L90BD     PSHS A              ; SAVE INITIAL SHIFT COUNTER ON THE STACK
7153 f201 2a 0a              L90BF     BPL  L90CB          ; EXIT ROUTINE IF POSITIVE
7154 f203 34 02                        PSHS A              ; SAVE SHIFT COUNTER ON STACK
7155 f205 bd e2 ce                     JSR  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT ONE DIGIT TO RIGHT
7156 f208 35 02                        PULS A              ; GET SHIFT COUNTER FROM THE STACK
7157 f20a 4c                           INCA                ; BUMP SHIFT COUNTER UP BY ONE
7158 f20b 20 f4                        BRA  L90BF          ; CHECK FOR FURTHER DIVISION
7159 f20d 96 47              L90CB     LDA  V47            ; * GET BASE 10 EXPONENT OFFSET, ADD INITIAL SHIFT COUNTER
7160 f20f a0 e0                        SUBA ,S+            ; * AND SAVE NEW BASE 10 EXPONENT OFFSET - BECAUSE
7161 f211 97 47                        STA  V47            ; * FPA0 WAS SHIFTED ABOVE
7162 f213 8b 09                        ADDA #$09           ; * ADD NINE (SIGNIFICANT PLACES) AND BRANCH IF THERE ARE NO
7163 f215 2b 19                        BMI  L90EE          ; * ZEROES TO THE LEFT OF THE DECIMAL POINT IN THIS PRINT ITEM
7164 f217 96 99                        LDA  VD9            ; *DETERMINE HOW MANY FILLER ZEROES TO THE LEFT OF THE DECIMAL
7165 f219 80 09                        SUBA #$09           ; *POINT. GET THE NUMBER OF FORMAT PLACES TO LEFT OF DECIMAL
7166 f21b 90 47                        SUBA V47            ; *POINT, SUBTRACT THE BASE 10 EXPONENT OFFSET AND THE CONSTANT 9
7167 f21d 8d 0d                        BSR  L90EA          ; *(UNNORMALIZATION)-THEN OUTPUT THAT MANY ZEROES TO THE BUFFER
7168 f21f bd f3 a5                     JSR  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
7169 f222 20 1d                        BRA  L90FF          ; PROCESS THE REMAINDER OF THE PRINT ITEM
7170                         *
7171                         * PUT (ACCA+1) ASCII ZEROES IN BUFFER
7172 f224 34 02              L90E2     PSHS A              ; SAVE ZERO COUNTER
7173 f226 86 30                        LDA  #'0            ; * INSERT A ZERO INTO
7174 f228 a7 c0                        STA  ,U+            ; * THE BUFFER
7175 f22a 35 02                        PULS A              ; RESTORE ZERO COUNTER
7176                         
7177                         * PUT ACCA ASCII ZEROES INTO THE BUFFER
7178 f22c 4a                 L90EA     DECA                ; DECREMENT ZERO COUNTER
7179 f22d 2a f5                        BPL  L90E2          ; BRANCH IF NOT DONE
7180 f22f 39                           RTS
7181                         
7182 f230 96 99              L90EE     LDA  VD9            ; * GET THE LEFT DIGIT COUNTER AND PUT
7183 f232 8d f8                        BSR  L90EA          ; * THAT MANY ZEROES IN THE STRiNG BUFFER
7184 f234 bd f3 8f                     JSR  L924D          ; PUT THE DECIMAL POINT IN THE STRING BUFFER
7185 f237 86 f7                        LDA  #-9            ; *DETERMINE HOW MANY FILLER ZEROES BETWEEN THE DECIMAL POINT
7186 f239 90 47                        SUBA V47            ; *AND SIGNIFICANT DATA. SUBTRACT BASE 10 EXPONENT FROM -9
7187 f23b 8d ef                        BSR  L90EA          ; *(UNNORMALIZATION) AND OUTPUT THAT MANY ZEROES TO BUFFER
7188 f23d 0f 45                        CLR  V45            ; CLEAR THE DECIMAL POINT COUNTER - SUPPRESS THE DECIMAL POINT
7189 f23f 0f 97                        CLR  VD7            ; CLEAR THE COMMA COUNTER - SUPPRESS COMMAS
7190 f241 bd f3 44           L90FF     JSR  L9202          ; DECODE FPA0 INTO A DECIMAL ASCII STRING
7191 f244 96 98                        LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
7192 f246 26 02                        BNE  L9108          ; BRANCH IF RIGHT DIGIT COUNTER <> 0
7193 f248 de 39                        LDU  VARPTR         ; RESET BUFFER PTR TO THE DECIMAL POINT IF NO DIGITS TO RIGHT
7194 f24a 9b 47              L9108     ADDA V47            ; *ADD BASE 10 EXPONENT - A POSITIVE ACCA WILL CAUSE THAT MANY
7195                         * *FILLER ZEROES TO BE OUTPUT ; TO THE RIGHT OF LAST SIGNIFICANT DATA
7196                         *         *SIGNIFICANT DATA
7197 f24c 16 ff 43                     LBRA L9050          ; INSERT LEADING ASTERISKS, FLOATING DOLLAR SIGN, ETC
7198                         *
7199                         * FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FORMAT
7200 f24f 96 4f              L910D     LDA  FP0EXP         ; * GET EXPONENT OF FPA0 AND
7201 f251 34 02                        PSHS A              ; * SAVE IT ON THE STACK
7202 f253 27 03                        BEQ  L9116          ; BRANCH IF FPA0 = 0
7203 f255 bd f3 0f                     JSR  L91CD          ; *CONVERT FPA0 INTO A NUMBER WITH 9 SIGNIFICANT
7204                         *         *DIGITS TO THE LEFT OF THE DECIMAL POINT
7205 f258 96 98              L9116     LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
7206 f25a 27 01                        BEQ  L911B          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT
7207 f25c 4a                           DECA                ; SUBTRACT ONE FOR THE DECIMAL POINT
7208 f25d 9b 99              L911B     ADDA VD9            ; ADD TO THE LEFT DIGIT COUNTER
7209 f25f 7f 01 f1                     CLR  STRBUF+3       ; CLEAR BUFFER BYTE AS TEMPORARY STORAGE LOCATION
7210 f262 d6 9a                        LDB  VDA            ; * GET THE STATUS BYTE FOR A
7211 f264 c4 04                        ANDB #$04           ; * POST-BYTE FORCE; BRANCH IF
7212 f266 26 03                        BNE  L9129          ; * A POST-BYTE FORCE
7213 f268 73 01 f1                     COM  STRBUF+3       ; TOGGLE BUFFER BYTE TO -1 IF NO POST-BYTE FORCE
7214 f26b bb 01 f1           L9129     ADDA STRBUF+3       ; SUBTRACT 1 IF NO POST BYTE FORCE
7215 f26e 80 09                        SUBA #$09           ; *SUBTRACT 9 (DUE TO THE CONVERSION TO 9
7216                         *         *SIGNIFICANT DIGITS TO LEFT OF DECIMAL POINT)
7217 f270 34 02                        PSHS A              ; * SAVE SHIFT COUNTER ON THE STACK - ACCA CONTAINS THE NUMBER
7218                         *         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE NUMBER OF
7219                         *         FORMATTED PLACES TO THE RIGHT OF THE DECIMAL POINT.
7220 f272 2a 0a              L9130     BPL  L913C          ; NO MORE SHIFTS WHEN ACCA >= 0
7221 f274 34 02                        PSHS A              ; SAVE SHIFT COUNTER
7222 f276 bd e2 ce                     JSR  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT TO RIGHT ONE
7223 f279 35 02                        PULS A              ; RESTORE THE SHIFT COUNTER
7224 f27b 4c                           INCA                ; ADD 1 TO SHIFT COUNTER
7225 f27c 20 f4                        BRA  L9130          ; CHECK FOR FURTHER SHIFTING (DIVISION)
7226 f27e a6 e4              L913C     LDA  ,S             ; *GET THE INITIAL VALUE OF THE SHIFT COUNTER
7227 f280 2b 01                        BMI  L9141          ; *AND BRANCH IF SHIFTING HAS TAKEN PLACE
7228 f282 4f                           CLRA                ; RESET ACCA IF NO SHIFTING HAS TAKEN PLACE
7229 f283 40                 L9141     NEGA                ; *CALCULATE THE POSITION OF THE DECIMAL POINT BY
7230 f284 9b 99                        ADDA VD9            ; *NEGATING SHIFT COUNTER, ADDING THE LEFT DIGIT COUNTER
7231 f286 4c                           INCA                ; *PLUS ONE AND THE POST-BYTE POSlTION, IF USED
7232 f287 bb 01 f1                     ADDA STRBUF+3       ; *
7233 f28a 97 45                        STA  V45            ; SAVE DECIMAL POINT COUNTER
7234 f28c 0f 97                        CLR  VD7            ; CLEAR COMMA COUNTER - NO COMMAS INSERTED
7235 f28e bd f3 44                     JSR  L9202          ; CONVERT FPA0 INTO ASCII DECIMAL STRING
7236 f291 35 02                        PULS A              ; * GET THE INITIAL VALUE OF SHIFT COUNTER AND
7237 f293 bd f3 c3                     JSR  L9281          ; * INSERT THAT MANY ZEROES INTO THE BUFFER
7238 f296 96 98                        LDA  VD8            ; *GET THE RIGHT DIGIT COUNTER AND BRANCH
7239 f298 26 02                        BNE  L915A          ; *IF NOT ZERO
7240 f29a 33 5f                        LEAU -1,U           ; MOVE BUFFER POINTER BACK ONE
7241                         
7242                         * CALCULATE VALUE OF EXPONENT AND PUT IN STRING BUFFER
7243 f29c e6 e0              L915A     LDB  ,S+            ; GET ORIGINAL EXPONENT OF FPA0
7244 f29e 27 09                        BEQ  L9167          ; BRANCH IF EXPONENT = 0
7245 f2a0 d6 47                        LDB  V47            ; GET BASE 10 EXPONENT
7246 f2a2 cb 09                        ADDB #$09           ; ADD 9 FOR 9 SIGNIFICANT DIGIT CONVERSION
7247 f2a4 d0 99                        SUBB VD9            ; SUBTRACT LEFT DIGIT COUNTER
7248 f2a6 f0 01 f1                     SUBB STRBUF+3       ; ADD ONE TO EXPONENT IF POST-SIGN FORCE
7249 f2a9 86 2b              L9167     LDA  #'+            ; PLUS SIGN
7250 f2ab 5d                           TSTB                ; TEST EXPONENT
7251 f2ac 2a 03                        BPL  L916F          ; BRANCH IF POSITIVE EXPONENT
7252 f2ae 86 2d                        LDA  #'-            ; MINUS SIGN
7253 f2b0 50                           NEGB                ; CONVERT EXPONENT TO POSITIVE NUMBER
7254 f2b1 a7 41              L916F     STA  $01,U          ; PUT SIGN OF EXPONENT IN STRING BUFFER
7255 f2b3 86 45                        LDA  #'E            ; * PUT AN 'E' (EXPONENTIATION FLAG) IN
7256 f2b5 a7 c1                        STA  ,U++           ; * BUFFER AND SKIP OVER THE SIGN
7257 f2b7 86 2f                        LDA  #$2F           ; * WAS LDA #'0'-1
7258                         *CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACCA
7259 f2b9 4c                 L9177     INCA                ; ADD ONE TO TENS DIGIT COUNTER
7260 f2ba c0 0a                        SUBB #10            ; *SUBTRACT 10 FROM EXPONENT AND ADD ONE TO TENS
7261 f2bc 24 fb                        BCC  L9177          ; * DIGIT IF NO CARRY. TENS DIGIT DONE IF THERE IS A CARRY
7262 f2be cb 3a                        ADDB #$3A           ; WAS ADDB #'9'+1
7263 f2c0 ed c1                        STD  ,U++           ; SAVE EXPONENT IN BUFFER
7264 f2c2 6f c4                        CLR  ,U             ; CLEAR FINAL BYTE IN BUFFER - PRINT TERMINATOR
7265 f2c4 7e f1 96                     JMP  L9054          ; INSERT ASTERISK PADDING, FLOATING DOLLAR SIGN, ETC.
7266                         
7267                         * INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN
7268 f2c7 8e 01 f2           L9185     LDX  #STRBUF+4      ; POINT X TO START OF PRINT ITEM BUFFER
7269 f2ca e6 84                        LDB  ,X             ; * GET SIGN BYTE OF ITEM-LIST BUFFER
7270 f2cc 34 04                        PSHS B              ; * AND SAVE IT ON THE STACK
7271 f2ce 86 20                        LDA  #SPACE         ; DEFAULT PAD WITH BLANKS
7272 f2d0 d6 9a                        LDB  VDA            ; * GET STATUS BYTE AND CHECK FOR
7273 f2d2 c5 20                        BITB #$20           ; * ASTERISK LEFT PADDING
7274 f2d4 35 04                        PULS B              ; GET SIGN BYTE AGAIN
7275 f2d6 27 08                        BEQ  L919E          ; BRANCH IF NO PADDING
7276 f2d8 86 2a                        LDA  #'*            ; PAD WITH ASTERISK
7277 f2da c1 20                        CMPB #SPACE         ; WAS THE FIRST BYTE A BLANK (POSITIVE)?
7278 f2dc 26 02                        BNE  L919E          ; NO
7279 f2de 1f 89                        TFR  A,B            ; TRANSFER PAD CHARACTER TO ACCB
7280 f2e0 34 04              L919E     PSHS B              ; SAVE FIRST CHARACTER ON STACK
7281 f2e2 a7 80              L91A0     STA  ,X+            ; STORE PAD CHARACTER IN BUFFER
7282 f2e4 e6 84                        LDB  ,X             ; GET NEXT CHARACTER IN BUFFER
7283 f2e6 27 10                        BEQ  L91B6          ; INSERT A ZERO IF END OF BUFFER
7284 f2e8 c1 45                        CMPB #'E            ; * CHECK FOR AN 'E' AND
7285 f2ea 27 0c                        BEQ  L91B6          ; * PUT A ZERO BEFORE IT
7286 f2ec c1 30                        CMPB #'0            ; * REPLACE LEADING ZEROES WITH
7287 f2ee 27 f2                        BEQ  L91A0          ; * PAD CHARACTERS
7288 f2f0 c1 2c                        CMPB #',            ; * REPLACE LEADING COMMAS
7289 f2f2 27 ee                        BEQ  L91A0          ; * WITH PAD CHARACTERS
7290 f2f4 c1 2e                        CMPB #'.            ; * CHECK FOR DECIMAL POINT
7291 f2f6 26 04                        BNE  L91BA          ; * AND DON'T PUT A ZERO BEFORE IT
7292 f2f8 86 30              L91B6     LDA  #'0            ; * REPLACE PREVIOUS CHARACTER
7293 f2fa a7 82                        STA  ,-X            ; * WITH A ZERO
7294 f2fc 96 9a              L91BA     LDA  VDA            ; * GET STATUS BYTE, CHECK
7295 f2fe 85 10                        BITA #$10           ; * FOR FLOATING $
7296 f300 27 04                        BEQ  L91C4          ; * BRANCH IF NO FLOATING $
7297 f302 c6 24                        LDB  #'$            ; * STORE A $ IN
7298 f304 e7 82                        STB  ,-X            ; * BUFFER
7299 f306 84 04              L91C4     ANDA #$04           ; CHECK PRE-SIGN FLAG
7300 f308 35 04                        PULS B              ; GET SIGN CHARACTER
7301 f30a 26 02                        BNE  L91CC          ; RETURN IF POST-SIGN REQUIRED
7302 f30c e7 82                        STB  ,-X            ; STORE FIRST CHARACTER
7303 f30e 39                 L91CC     RTS
7304                         *
7305                         * CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN X 10**M.
7306                         * THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPONENT).
7307 f30f 34 40              L91CD     PSHS U              ; SAVE BUFFER POINTER
7308 f311 4f                           CLRA                ; INITIAL EXPONENT OFFSET = 0
7309 f312 97 47              L91D0     STA  V47            ; SAVE EXPONENT OFFSET
7310 f314 d6 4f                        LDB  FP0EXP         ; GET EXPONENT OF FPA0
7311 f316 c1 80                        CMPB #$80           ; * COMPARE TO EXPONENT OF .5
7312 f318 22 11                        BHI  L91E9          ; * AND BRANCH IF FPA0 > = 1.0
7313                         
7314                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1
7315 f31a 8e e5 0c                     LDX  #LBDC0         ; POINT X TO FP NUMBER (1E+09)
7316 f31d bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY 1E+09
7317 f320 96 47                        LDA  V47            ; GET EXPONENT OFFSET
7318 f322 80 09                        SUBA #$09           ; SUBTRACT 9 (BECAUSE WE MULTIPLIED BY 1E+09 ABOVE)
7319 f324 20 ec                        BRA  L91D0          ; CHECK TO SEE IF > 1.0
7320 f326 bd e2 ce           L91E4     JSR  LBB82          ; DIVIDE FPA0 BY 10
7321 f329 0c 47                        INC  V47            ; INCREMENT EXPONENT OFFSET
7322 f32b 8e e5 07           L91E9     LDX  #LBDBB         ; POINT X TO FP NUMBER (999,999,999)
7323 f32e bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO X
7324 f331 2e f3                        BGT  L91E4          ; BRANCH IF FPA0 > 999,999,999
7325 f333 8e e5 02           L91F1     LDX  #LBDB6         ; POINT X TO FP NUMBER (99,999,999.9)
7326 f336 bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO X
7327 f339 2e 07                        BGT  L9200          ; RETURN IF 999,999,999 > FPA0 > 99,999,999.9
7328 f33b bd e2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
7329 f33e 0a 47                        DEC  V47            ; DECREMENT EXPONENT OFFSET
7330 f340 20 f1                        BRA  L91F1          ; KEEP UNNORMALIZING
7331 f342 35 c0              L9200     PULS U,PC           ; RESTORE BUFFER POINTER AND RETURN
7332                         *
7333                         * CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT
7334                         * INTO A DECIMAL ASCII STRING IN THE BUFFER
7335 f344 34 40              L9202     PSHS U              ; SAVE BUFFER POINTER
7336 f346 bd e1 00                     JSR  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
7337 f349 bd e4 14                     JSR  LBCC8          ; CONVERT FPA0 TO INTEGER FORMAT
7338 f34c 35 40                        PULS U              ; RESTORE BUFFER POINTER
7339                         *
7340                         * CONVERT FPA0 INTO A DECIMAL ASCII STRING
7341 f34e 8e e6 11                     LDX  #LBEC5         ; POINT X TO UNNORMALIZED POWERS OF 10
7342 f351 c6 80                        LDB  #$80           ; INITIALIZE DIGIT COUNTER TO 0 + $80.
7343                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
7344                         * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
7345                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB
7346                         * IS HOW THIS ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURRING.
7347 f353 8d 36              L9211     BSR  L9249          ; CHECK FOR COMMA INSERTION
7348 f355 96 53              L9213     LDA  FPA0+3         ; * 'ADD' A POWER OF 10 MANTISSA TO FPA0.
7349 f357 ab 03                        ADDA $03,X          ; * IF THE MANTISSA IS NEGATIVE, A SUBTRACTION
7350 f359 97 53                        STA  FPA0+3         ; * WILL BE WHAT REALLY TAKES PLACE.
7351 f35b 96 52                        LDA  FPA0+2         ; *
7352 f35d a9 02                        ADCA $02,X          ; *
7353 f35f 97 52                        STA  FPA0+2         ; *
7354 f361 96 51                        LDA  FPA0+1         ; *
7355 f363 a9 01                        ADCA $01,X          ; *
7356 f365 97 51                        STA  FPA0+1         ; *
7357 f367 96 50                        LDA  FPA0           ; *
7358 f369 a9 84                        ADCA ,X             ; *
7359 f36b 97 50                        STA  FPA0           ; *
7360 f36d 5c                           INCB                ; ADD ONE TO DIGIT COUNTER
7361 f36e 56                           RORB                ; ROTATE CARRY INTO BIT 7
7362 f36f 59                           ROLB                ; * SET OVERFLOW FLAG - BRANCH IF CARRY SET AND
7363 f370 28 e3                        BVC  L9213          ; * ADDING MANTISSA OR CARRY CLEAR AND SUBTRACTING MANTISSA
7364 f372 24 03                        BCC  L9235          ; BRANCH IF SUBTRACTING MANTISSA
7365 f374 c0 0b                        SUBB #10+1          ; WAS SUBB #10+1
7366 f376 50                           NEGB                ; * IF ADDING MANTISSA
7367 f377 cb 2f              L9235     ADDB #$2F           ; WAS ADDB #'0'-1
7368 f379 30 04                        LEAX $04,X          ; MOVE TO NEXT POWER OF 10 MANTISSA
7369 f37b 1f 98                        TFR  B,A            ; SAVE DIGIT IN ACCA
7370 f37d 84 7f                        ANDA #$7F           ; MASK OFF ADD/SUBTRACT FLAG (BIT 7)
7371 f37f a7 c0                        STA  ,U+            ; STORE DIGIT IN BUFFER
7372 f381 53                           COMB                ; TOGGLE ADD/SUBTRACT FLAG
7373 f382 c4 80                        ANDB #$80           ; MASK OFF EVERYTHING BUT ADD/SUB FLAG
7374 f384 8c e6 35                     CMPX #LBEE9         ; COMPARE TO END OF UNNORMALIZED POWERS OF 10
7375 f387 26 ca                        BNE  L9211          ; BRANCH IF NOT DONE
7376 f389 6f c4                        CLR  ,U             ; PUT A ZERO AT END OF INTEGER
7377                         
7378                         * DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA INSERTION
7379 f38b 0a 45              L9249     DEC  V45            ; DECREMENT DECIMAL POINT COUNTER
7380 f38d 26 09                        BNE  L9256          ; NOT TIME FOR DECIMAL POINT
7381 f38f df 39              L924D     STU  VARPTR         ; SAVE BUFFER POINTER-POSITION OF THE DECIMAL POINT
7382 f391 86 2e                        LDA  #'.            ; * STORE A DECIMAL
7383 f393 a7 c0                        STA  ,U+            ; * POINT IN THE OUTPUT BUFFER
7384 f395 0f 97                        CLR  VD7            ; * CLEAR COMMA COUNTER - NOW IT WILL TAKE 255
7385                         *                             ; * DECREMENTS BEFORE ANOTHER COMMA WILL BE INSERTED
7386 f397 39                           RTS
7387 f398 0a 97              L9256     DEC  VD7            ; DECREMENT COMMA COUNTER
7388 f39a 26 08                        BNE  L9262          ; RETURN IF NOT TIME FOR COMMA
7389 f39c 86 03                        LDA  #$03           ; * RESET COMMA COUNTER TO 3; THREE
7390 f39e 97 97                        STA  VD7            ; * DIGITS BETWEEN COMMAS
7391 f3a0 86 2c                        LDA  #',            ; * PUT A COMMA INTO
7392 f3a2 a7 c0                        STA  ,U+            ; * THE BUFFER
7393 f3a4 39                 L9262     RTS
7394                         
7395                         * INITIALIZE DECIMAL POINT AND COMMA COUNTERS
7396 f3a5 96 47              L9263     LDA  V47            ; GET THE BASE 10 EXPONENT OFFSET
7397 f3a7 8b 0a                        ADDA #10            ; * ADD 10 (FPA0 WAS 'NORMALIZED' TO 9 PLACES LEFT
7398 f3a9 97 45                        STA  V45            ; * OF DECIMAL POINT) - SAVE IN DECIMAL POINT COUNTER
7399 f3ab 4c                           INCA                ; ADD ONE FOR THE DECIMAL POINT
7400 f3ac 80 03              L926A     SUBA #$03           ; * DIVIDE DECIMAL POINT COUNTER BY 3; LEAVE
7401 f3ae 24 fc                        BCC  L926A          ; * THE REMAINDER IN ACCA
7402 f3b0 8b 05                        ADDA #$05           ; CONVERT REMAINDER INTO A NUMBER FROM 1-3
7403 f3b2 97 97                        STA  VD7            ; SAVE COMMA COUNTER
7404 f3b4 96 9a                        LDA  VDA            ; GET STATUS BYTE
7405 f3b6 84 40                        ANDA #$40           ; CHECK FOR COMMA FLAG
7406 f3b8 26 02                        BNE  L927A          ; BRANCH IF COMMA FLAG ACTIVE
7407 f3ba 97 97                        STA  VD7            ; CLEAR COMMA COUNTER - 255 DIGITS OUTPUT BEFORE A COMMA
7408 f3bc 39                 L927A     RTS
7409                         *
7410                         * INSERT ACCA ZEROES INTO THE BUFFER
7411 f3bd 34 02              L927B     PSHS A              ; SAVE ZEROES COUNTER
7412 f3bf 8d ca                        BSR  L9249          ; CHECK FOR DECIMAL POINT
7413 f3c1 35 02                        PULS A              ; RESTORE ZEROES COUNTER
7414 f3c3 4a                 L9281     DECA                ; * DECREMENT ZEROES COUNTER AND
7415 f3c4 2b 0a                        BMI  L928E          ; * RETURN IF < 0
7416 f3c6 34 02                        PSHS A              ; SAVE ZEROES COUNTER
7417 f3c8 86 30                        LDA  #'0            ; * PUT A ZERO INTO
7418 f3ca a7 c0                        STA  ,U+            ; * THE BUFFER
7419 f3cc a6 e0                        LDA  ,S+            ; RESTORE THE ZEROES COUNTER
7420 f3ce 26 ed                        BNE  L927B          ; BRANCH IF NOT DONE
7421 f3d0 39                 L928E     RTS
7422                         
7423                         
7424                         * LINE
7425 f3d1 81 89              LINE      CMPA #TOK_INPUT     ; 'INPUT' TOKEN
7426 f3d3 10 27 f9 5c                  LBEQ L89C0          ; GO DO 'LINE INPUT' COMMAND
7427 f3d7 7e da 03                     JMP  LB277          ; 'SYNTAX ERROR' IF NOT "LINE INPUT"
7428                         
7429                         * END OF EXTENDED BASIC
7430                         
7431 f3da ff ff ff ff ff ff          FILL    $FF, $F800-*   ; Fill ROM with FFs until start of ASSIST09
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff
7432                         
7433                         *************************************
7434                         * COPYRIGHT (C) MOTOROLA, INC. 1979 *
7435                         *************************************
7436                         
7437                         *************************************
7438                         * THIS IS THE BASE ASSIST09 ROM.
7439                         * IT MAY RUN WITH OR WITHOUT THE
7440                         * EXTENSION ROM WHICH
7441                         * WHEN PRESENT WILL BE AUTOMATICALLY
7442                         * INCORPORATED BY THE BLDVTR
7443                         * SUBROUTINE.
7444                         *************************************
7445                         
7446                         *********************************************
7447                         * GLOBAL MODULE EQUATES
7448                         ********************************************
7449 f800                    ROMBEG  EQU     $F800           ; ROM START ASSEMBLY ADDRESS
7450 ffff7800                    RAMOFS  EQU     -$8800          ; ROM OFFSET TO RAM WORK PAGE
7451 0800                    ROMSIZ  EQU     2048            ; ROM SIZE
7452 f000                    ROM2OF  EQU     ROMBEG-ROMSIZ   ; START OF EXTENSION ROM
7453 a000                    ACIA    EQU     $A000           ; DEFAULT ACIA ADDRESS
7454 0000                    PTM     EQU     $0000           ; DEFAULT PTM ADDRESS
7455 0000                    DFTCHP  EQU     0               ; DEFAULT CHARACTER PAD COUNT
7456 0005                    DFTNLP  EQU     5               ; DEFAULT NEW LINE PAD COUNT
7457 003e                    PROMPT  EQU     '>              ; PROMPT CHARACTER
7458 0008                    NUMBKP  EQU     8               ; NUMBER OF BREAKPOINTS
7459                         *********************************************
7460                         
7461                         *********************************************
7462                         * MISCELANEOUS EQUATES
7463                         *********************************************
7464 0004                    EOT     EQU     $04             ; END OF TRANSMISSION
7465 0007                    BELL    EQU     $07             ; BELL CHARACTER
7466 000a                    LF      EQU     $0A             ; LINE FEED
7467                         *CR     EQU     $0D             ; CARRIAGE RETURN
7468 0010                    DLE     EQU     $10             ; DATA LINK ESCAPE
7469 0018                    CAN     EQU     $18             ; CANCEL (CTL-X)
7470                         
7471                         * PTM ACCESS DEFINITIONS
7472 0001                    PTMSTA  EQU     PTM+1           ; READ STATUS REGISTER
7473 0000                    PTMC13  EQU     PTM             ; CONTROL REGISTERS 1 AND 3
7474 0001                    PTMC2   EQU     PTM+1           ; CONTROL REGISTER 2
7475 0002                    PTMTM1  EQU     PTM+2           ; LATCH 1
7476 0004                    PTMTM2  EQU     PTM+4           ; LATCH 2
7477 0006                    PTMTM3  EQU     PTM+6           ; LATCH 3
7478 008c                    SKIP2   EQU     $8C             ; "CMPX #" OPCODE - SKIPS TWO BYTES
7479                         
7480                         *******************************************
7481                         * ASSIST09 MONITOR SWI FUNCTIONS
7482                         * THE FOLLOWING EQUATES DEFINE FUNCTIONS PROVIDED
7483                         * BY THE ASSIST09 MONITOR VIA THE SWI INSTRUCTION.
7484                         ******************************************
7485 0000                    INCHNP  EQU     0               ; INPUT CHAR IN A REG - NO PARITY
7486 0001                    OUTCH   EQU     1               ; OUTPUT CHAR FROM A REG
7487 0002                    PDATA1  EQU     2               ; OUTPUT STRING
7488 0003                    PDATA   EQU     3               ; OUTPUT CR/LF THEN STRING
7489 0004                    OUT2HS  EQU     4               ; OUTPUT TWO HEX AND SPACE
7490 0005                    OUT4HS  EQU     5               ; OUTPUT FOUR HEX AND SPACE
7491 0006                    PCRLF   EQU     6               ; OUTPUT CR/LF
7492 0007                    SPACEF  EQU     7               ; OUTPUT A SPACE
7493 0008                    MONITR  EQU     8               ; ENTER ASSIST09 MONITOR
7494 0009                    VCTRSW  EQU     9               ; VECTOR EXAMINE/SWITCH
7495 000a                    BRKPT   EQU     10              ; USER PROGRAM BREAKPOINT
7496 000b                    PAUSE   EQU     11              ; TASK PAUSE FUNCTION
7497 000b                    NUMFUN  EQU     11              ; NUMBER OF AVAILABLE FUNCTIONS
7498                         
7499                         * NEXT SUB-CODES FOR ACCESSING THE VECTOR TABLE.
7500                         * THEY ARE EQUIVALENT TO OFFSETS IN THE TABLE.
7501                         * RELATIVE POSITIONING MUST BE MAINTAINED
7502                         
7503 0000                    .AVTBL  EQU     0               ; ADDRESS OF VECTOR TABLE
7504 0002                    .CMDL1  EQU     2               ; FIRST COMMAND LIST
7505 0004                    .RSVD   EQU     4               ; RESERVED HARDWARE VECTOR
7506 0006                    .SWI3   EQU     6               ; SWI3 ROUTINE
7507 0008                    .SWI2   EQU     8               ; SWI2 ROUTINE
7508 000a                    .FIRQ   EQU     10              ; FIRQ ROUTINE
7509 000c                    .IRQ    EQU     12              ; IRQ ROUTINE
7510 000e                    .SWI    EQU     14              ; SWI ROUTINE
7511 0010                    .NMI    EQU     16              ; NMI ROUTINE
7512 0012                    .RESET  EQU     18              ; RESET ROUTINE
7513 0014                    .CION   EQU     20              ; CONSOLE ON
7514 0016                    .CIDTA  EQU     22              ; CONSOLE INPUT DATA
7515 0018                    .CIOFF  EQU     24              ; CONSOLE INPUT OFF
7516 001a                    .COON   EQU     26              ; CONSOLE OUTPUT ON
7517 001c                    .CODTA  EQU     28              ; CONSOLE OUTPUT DATA
7518 001e                    .COOFF  EQU     30              ; CONSOLE OUTPUT OFF
7519 0020                    .HSDTA  EQU     32              ; HIGH SPEED PRINTDATA
7520 0022                    .BSON   EQU     34              ; PUNCH/LOAD ON
7521 0024                    .BSDTA  EQU     36              ; PUNCH/LOAD DATA
7522 0026                    .BSOFF  EQU     38              ; PUNCH/LOAD OFF
7523 0028                    .PAUSE  EQU     40              ; TASK PAUSE ROUTINE
7524 002a                    .EXPAN  EQU     42              ; EXPRESSION ANALYZER
7525 002c                    .CMDL2  EQU     44              ; SECOND COMMAND LIST
7526 002e                    .ACIA   EQU     46              ; ACIA ADDRESS
7527 0030                    .PAD    EQU     48              ; CHARACTER PAD AND NEW LINE PAD
7528 0032                    .ECHO   EQU     50              ; ECHO/LOAD AND NULL BKPT FLAG
7529 0034                    .PTM    EQU     52              ; PTM ADDRESS
7530 001b                    NUMVTR  EQU     52/2+1          ; NUMBER OF VECTORS
7531 0034                    HIVTR   EQU     52              ; HIGHEST VECTOR OFFSET
7532                         
7533                         ******************************************
7534                         *           WORK AREA
7535                         * THIS WORK AREA IS ASSIGNED TO THE PAGE ADDRESSED BY
7536                         * -$1800,PCR FROM THE BASE ADDRESS OF THE ASSIST09
7537                         * ROM. THE DIRECT PAGE REGISTER DURING MOST ROUTINE
7538                         * OPERATIONS WILL POINT TO THIS WORK AREA. THE STACK
7539                         * INITIALLY STARTS UNDER THE RESERVED WORK AREAS AS
7540                         * DEFINED HEREIN.
7541                         ******************************************
7542 7000                    WORKPG  EQU     ROMBEG+RAMOFS   ; SETUP DIRECT PAGE ADDRESS
7543                         *       SETDP   =WORKPG         ; NOTIFY ASSEMBLER
7544 7100                            ORG     WORKPG+256      ; READY PAGE DEFINITIONS
7545                         
7546                         * THE FOLLOWING THRU BKPTOP MUST RESIDE IN THIS ORDER
7547                         * FOR PROPER INITIALIZATION
7548 70fc                            ORG     *-4
7549 70fc                    PAUSER  EQU     *               ; PAUSE ROUTINE
7550 70fb                            ORG     *-1
7551 70fb                    SWIBFL  EQU     *               ; BYPASS SWI AS BREAKPOINT FLAG
7552 70fa                            ORG     *-1
7553 70fa                    BKPTCT  EQU     *               ; BREAKPOINT COUNT
7554 70f8                            ORG     *-2             ; SLEVEL EQU
7555 70f8                    SLEVEL  EQU     *               ; STACK TRACE LEVEL
7556 70c2                            ORG     -NUMVTR*2+*
7557 70c2                    VECTAB  EQU     *               ; VECTOR TABLE
7558 70b2                            ORG     -2*NUMBKP+*
7559 70b2                    BKPTBL  EQU     *               ; BREAKPOINT TABLE
7560 70a2                            ORG     -2*NUMBKP+*
7561 70a2                    BKPTOP  EQU     *               ; BREAKPOINT OPCODE TABLE
7562 70a0                            ORG     *-2
7563 70a0                    WINDOW  EQU     *               ; WINDOW
7564 709e                            ORG     *-2
7565 709e                    ADDR    EQU     *               ; ADDRESS POINTER VALUE
7566 709d                            ORG     *-1
7567 709d                    BASEPG  EQU     *               ; BASE PAGE VALUE
7568 709b                            ORG     *-2
7569 709b                    NUMBER  EQU     *               ; BINARY BUILD AREA
7570 7099                            ORG     *-2
7571 7099                    LASTOP  EQU     *               ; LAST OPCODE TRACED
7572 7097                            ORG     *-2
7573 7097                    RSTACK  EQU     *               ; RESET STACK POINTER
7574 7095                            ORG     *-2
7575 7095                    PSTACK  EQU     *               ; COMMAND RECOVERY STACK
7576 7093                            ORG     *-2
7577 7093                    PCNTER  EQU     *               ; LAST PROGRAM COUNTER
7578 7091                            ORG     *-2
7579 7091                    TRACEC  EQU     *               ; TRACE COUNT
7580 7090                            ORG     *-1
7581 7090                    SWICNT  EQU     *               ; TRACE "SWI" NEST LEVEL COUNT
7582 708f                            ORG     *-1             ; (MISFLG MUST FOLLOW SWICNT)
7583 708f                    MISFLG  EQU     *               ; LOAD CMD/THRU BREAKPOINT FLAG
7584 708e                            ORG     *-1
7585 708e                    DELIM   EQU     *               ; EXPRESSION DELIMITER/WORK BYTE
7586 7066                            ORG     *-40
7587 7066                    ROM2WK  EQU     *               ; EXTENSION ROM RESERVED AREA
7588 7051                            ORG     *-21
7589 7051                    TSTACK  EQU     *               ; TEMPORARY STACK HOLD
7590 7051                    STACK   EQU     *               ; START OF INITIAL STACK
7591                         
7592                         ******************************************
7593                         * DEFAULT THE ROM BEGINNING ADDRESS TO 'ROMBEG'
7594                         * ASSIST09 IS POSITION ADDRESS INDEPENDENT, HOWEVER
7595                         * WE ASSEMBLE ASSUMING CONTROL OF THE HARDWARE VECTORS.
7596                         * NOTE THAT THE WORK RAM PAGE MUST BE 'RAMOFS'
7597                         * FROM THE ROM BEGINNING ADDRESS.
7598                         ********************************************
7599 f800                            ORG     ROMBEG          ; ROM ASSEMBLY/DEFAULT ADDRESS
7600                         
7601                         *****************************************************
7602                         * BLDVTR - BUILD ASSIST09 VECTOR TABLE
7603                         * HARDWARE RESET CALLS THIS SUBROUTINE TO BUILD THE
7604                         * ASSIST09 VECTOR TABLE. THIS SUBROUTINE RESIDES AT
7605                         * THE FIRST BYTE OF THE ASSIST09 ROM, AND CAN BE
7606                         * CALLED VIA EXTERNAL CONTROL CODE FOR REMOTE
7607                         * ASSIST09 EXECUTION.
7608                         * INPUT: S->VALID STACK RAM
7609                         * OUTPUT: U->VECTOR TABLE ADDRESS
7610                         * DPR->ASSIST09 WORK AREA PAGE
7611                         * THE VECTOR TABLE AND DEFAULTS ARE INITIALIZED
7612                         * ALL REGISTERS VOLATILE
7613                         *************************************************
7614 f800 30 8d 78 be        BLDVTR  LEAX    VECTAB,PCR      ; ADDRESS VECTOR TABLE
7615 f804 1f 10                      TFR     X,D             ; OBTAIN BASE PAGE ADDRESS
7616 f806 1f 8b                      TFR     A,DP            ; SETUP DPR
7617 f808 97 9d                      STA     <BASEPG         ; STORE FOR QUICK REFERENCE
7618 f80a 33 84                      LEAU    ,X              ; RETURN TABLE TO CALLER
7619 f80c 31 8c 35                   LEAY    <INITVT,PCR     ; LOAD FROM ADDR
7620 f80f ef 81                      STU     ,X++            ; INIT VECTOR TABLE ADDRESS
7621 f811 c6 16                      LDB     #NUMVTR-5       ; NUMBER RELOCATABLE VECTORS
7622 f813 34 04                      PSHS    B               ; STORE INDEX ON STACK
7623 f815 1f 20              BLD2    TFR     Y,D             ; PREPARE ADDRESS RESOLVE
7624 f817 e3 a1                      ADDD    ,Y++            ; TO ABSOLUTE ADDRESS
7625 f819 ed 81                      STD     ,X++            ; INTO VECTOR TABLE
7626 f81b 6a e4                      DEC     ,S              ; COUNT DOWN
7627 f81d 26 f6                      BNE     BLD2            ; BRANCH IF MORE TO INSERT
7628 f81f c6 0d                      LDB     #INTVE-INTVS    ; STATIC VALUE INIT LENGTH
7629 f821 a6 a0              BLD3    LDA     ,Y+             ; LOAD NEXT BYTE
7630 f823 a7 80                      STA     ,X+             ; STORE INTO POSITION
7631 f825 5a                         DECB                    ; COUNT DOWN
7632 f826 26 f9                      BNE     BLD3            ; LOOP UNTIL DONE
7633 f828 31 8d f7 d4                LEAY    ROM2OF,PCR      ; TEST POSSIBLE EXTENSION ROM
7634 f82c 8e 20 fe                   LDX     #$20FE          ; LOAD "BRA *" FLAG PATTERN
7635 f82f ac a1                      CMPX    ,Y++            ; ? EXTENDED ROM HERE
7636 f831 26 02                      BNE     BLDRTN          ; BRANCH NOT OUR ROM TO RETURN
7637 f833 ad a4                      JSR     ,Y              ; CALL EXTENDED ROM INITIALIZE
7638 f835 35 84              BLDRTN  PULS    PC,B            ; RETURN TO INITIALIZER
7639                         
7640                         *****************************************************
7641                         *                RESET ENTRY POINT
7642                         * HARDWARE RESET ENTERS HERE IF ASSIST09 IS ENABLED
7643                         * TO RECEIVE THE MC6809 HARDWARE VECTORS. WE CALL
7644                         * THE BLDVTR SUBROUTINE TO INITIALIZE THE VECTOR
7645                         * TABLE, STACK, AND THEN FIREUP THE MONITOR VIA SWI
7646                         * CALL.
7647                         *******************************************************
7648 f837 32 8d 78 16        RESET   LEAS    STACK,PCR       ; SETUP INITIAL STACK
7649 f83b 8d c3                      BSR     BLDVTR          ; BUILD VECTOR TABLE
7650 f83d 4f                 RESET2  CLRA                    ; ISSUE STARTUP MESSAGE
7651 f83e 1f 8b                      TFR     A,DP            ; DEFAULT TO PAGE ZERO
7652 f840 3f                         SWI                     ; PERFORM MONITOR FIREUP
7653 f841 08                         FCB     MONITR          ; TO ENTER COMMAND PROCESSING
7654 f842 20 f9                      BRA     RESET2          ; REENTER MONITOR IF 'CONTINUE'
7655                         
7656                         ******************************************************
7657                         *        INITVT - INITIAL VECTOR TABLE
7658                         * THIS TABLE IS RELOCATED TO RAM AND REPRESENTS THE
7659                         * INITIAL STATE OF THE VECTOR TABLE. ALL ADDRESSES
7660                         * ARE CONVERTED TO ABSOLUTE FORM. THIS TABLE STARTS
7661                         * WITH THE SECOND ENTRY, ENDS WITH STATIC CONSTANT
7662                         * INITIALIZATION DATA WHICH CARRIES BEYOND THE TABLE.
7663                         ************************************************
7664 f844 01 5c              INITVT  FDB     CMDTBL-*        ; DEFAULT FIRST COMMAND TABLE
7665 f846 02 8e                      FDB     RSRVDR-*        ; DEFAULT UNDEFINED HARDWARE VECTOR
7666 f848 02 8c                      FDB     SWI3R-*         ; DEFAULT SWI3
7667 f84a 02 8a                      FDB     SWI2R-*         ; DEFAULT SWI2
7668 f84c 02 6c                      FDB     FIRQR-*         ; DEFAULT FIRQ
7669 f84e 02 86                      FDB     IRQR-*          ; DEFAULT IRQ ROUTINE
7670 f850 00 45                      FDB     SWIR-*          ; DEFAULT SWI ROUTINE
7671 f852 02 27                      FDB     NMIR-*          ; DEFAULT NMI ROUTINE
7672 f854 ff e3                      FDB     RESET-*         ; RESTART VECTOR
7673 f856 02 8c                      FDB     CION-*          ; DEFAULT CION
7674 f858 02 80                      FDB     CIDTA-*         ; DEFAULT CIDTA
7675 f85a 02 92                      FDB     CIOFF-*         ; DEFAULT CIOFF
7676 f85c 02 86                      FDB     COON-*          ; DEFAULT COON
7677 f85e 02 8f                      FDB     CODTA-*         ; DEFAULT CODTA
7678 f860 02 8c                      FDB     COOFF-*         ; DEFAULT COOFF
7679 f862 03 96                      FDB     HSDTA-*         ; DEFAULT HSDTA
7680 f864 02 b3                      FDB     BSON-*          ; DEFAULT BSON
7681 f866 02 ce                      FDB     BSDTA-*         ; DEFAULT BSDTA
7682 f868 02 bb                      FDB     BSOFF-*         ; DEFAULT BSOFF
7683 f86a 78 92                      FDB     PAUSER-*        ; DEFAULT PAUSE ROUTINE
7684 f86c 04 79                      FDB     EXP1-*          ; DEFAULT EXPRESSION ANALYZER
7685 f86e 01 2d                      FDB     CMDTB2-*        ; DEFAULT SECOND COMMAND TABLE
7686                         * CONSTANTS
7687 f870 a0 00              INTVS   FDB     ACIA            ; DEFAULT ACIA
7688 f872 00 05                      FCB     DFTCHP,DFTNLP   ; DEFAULT NULL PADDS
7689 f874 00 00                      FDB     0               ; DEFAULT ECHO
7690 f876 00 00                      FDB     PTM             ; DEFAULT PTM
7691 f878 00 00                      FDB     0               ; INITIAL STACK TRACE LEVEL
7692 f87a 00                         FCB     0               ; INITIAL BREAKPOINT COUNT
7693 f87b 00                         FCB     0               ; SWI BREAKPOINT LEVEL
7694 f87c 39                         FCB     $39             ; DEFAULT PAUSE ROUTINE (RTS)
7695 f87d                    INTVE   EQU     *
7696                         *B
7697                         ***********************************************
7698                         *            ASSIST09 SWI HANDLER
7699                         * THE SWI HANDLER PROVIDES ALL INTERFACING NECESSARY
7700                         * FOR A USER PROGRAM. A FUNCTION BYTE IS ASSUMED TO
7701                         * FOLLOW THE SWI INSTRUCTION. IT IS BOUND CHECKED
7702                         * AND THE PROPER ROUTINE IS GIVEN CONTROL. THIS
7703                         * INVOCATION MAY ALSO BE A BREAKPOINT INTERRUPT.
7704                         * IF SO, THE BREAKPOINT HANDLER IS ENTERED.
7705                         * INPUT: MACHINE STATE DEFINED FOR SWI
7706                         * OUTPUT: VARIES ACCORDING TO FUNCTION CALLED. PC ON
7707                         * CALLERS STACK INCREMENTED BY ONE IF VALID CALL.
7708                         * VOLATILE REGISTERS: SEE FUNCTIONS CALLED
7709                         * STATE: RUNS DISABLED UNLESS FUNCTION CLEARS I FLAG.
7710                         ************************************************
7711                         * SWI FUNCTION VECTOR TABLE
7712 f87d 01 90              SWIVTB  FDB     ZINCH-SWIVTB    ; INCHNP
7713 f87f 01 ad                      FDB     ZOTCH1-SWIVTB   ; OUTCH
7714 f881 01 c7                      FDB     ZPDTA1-SWIVTB   ; PDATA1
7715 f883 01 bf                      FDB     ZPDATA-SWIVTB   ; PDATA
7716 f885 01 71                      FDB     ZOT2HS-SWIVTB   ; OUT2HS
7717 f887 01 6f                      FDB     ZOT4HS-SWIVTB   ; OUT4HS
7718 f889 01 bc                      FDB     ZPCRLF-SWIVTB   ; PCRLF
7719 f88b 01 75                      FDB     ZSPACE-SWIVTB   ; SPACE
7720 f88d 00 55                      FDB     ZMONTR-SWIVTB   ; MONITR
7721 f88f 01 79                      FDB     ZVSWTH-SWIVTB   ; VCTRSW
7722 f891 02 52                      FDB     ZBKPNT-SWIVTB   ; BREAKPOINT
7723 f893 01 cd                      FDB     ZPAUSE-SWIVTB   ; TASK PAUSE
7724                         
7725 f895 6a 8d 77 f7        SWIR    DEC     SWICNT,PCR      ; UP "SWI" LEVEL FOR TRACE
7726 f899 17 02 21                   LBSR    LDDP            ; SETUP PAGE AND VERIFY STACK
7727                         * CHECK FOR BREAKPOINT TRAP
7728 f89c ee 6a                      LDU     10,S            ; LOAD PROGRAM COUNTER
7729 f89e 33 5f                      LEAU    -1,U            ; BACK TO SWI ADDRESS
7730 f8a0 0d fb                      TST     <SWIBFL         ; ? THIS "SWI" BREAKPOINT
7731 f8a2 26 11                      BNE     SWIDNE          ; BRANCH IF SO TO LET THROUGH
7732 f8a4 17 06 97                   LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
7733 f8a7 50                         NEGB                    ; OBTAIN POSITIVE COUNT
7734 f8a8 5a                 SWILP   DECB                    ; COUNT DOWN
7735 f8a9 2b 0a                      BMI     SWIDNE          ; BRANCH WHEN DONE
7736 f8ab 11 a3 a1                   CMPU    ,Y++            ; ? WAS THIS A BREAKPOINT
7737 f8ae 26 f8                      BNE     SWILP           ; BRANCH IF NOT
7738 f8b0 ef 6a                      STU     10,S            ; SET PROGRAM COUNTER BACK
7739 f8b2 16 02 1a                   LBRA    ZBKPNT          ; GO DO BREAKPOINT
7740 f8b5 0f fb              SWIDNE  CLR     <SWIBFL         ; CLEAR IN CASE SET
7741 f8b7 37 06                      PULU    D               ; OBTAIN FUNCTION BYTE, UP PC
7742 f8b9 c1 0b                      CMPB    #NUMFUN         ; ? TOO HIGH
7743 f8bb 10 22 02 0b                LBHI    ERROR           ; YES, DO BREAKPOINT
7744 f8bf ef 6a                      STU     10,S            ; BUMP PROGRAM COUNTER PAST SWI
7745 f8c1 58                         ASLB                    ; FUNCTION CODE TIMES TWO
7746 f8c2 33 8c b8                   LEAU    SWIVTB,PCR      ; OBTAIN VECTOR BRANCH ADDRESS
7747 f8c5 ec c5                      LDD     B,U             ; LOAD OFFSET
7748 f8c7 6e cb                      JMP     D,U             ; JUMP TO ROUTINE
7749                         
7750                         **********************************************
7751                         * REGISTERS TO FUNCTION ROUTINES:
7752                         *  DP-> WORK AREA PAGE
7753                         *  D,Y,U=UNRELIABLE           X=AS CALLED FROM USER
7754                         *  S=AS FROM SWI INTERRUPT
7755                         *********************************************
7756                         
7757                         **************************************************
7758                         *            [SWI FUNCTION 8]
7759                         *              MONITOR ENTRY
7760                         *  FIREUP THE ASSIST09 MONITOR.
7761                         *  THE STACK WITH ITS VALUES FOR THE DIRECT PAGE
7762                         *  REGISTER AND CONDITION CODE FLAGS ARE USED AS IS.
7763                         *   1) INITIALIZE CONSOLE I/O
7764                         *   2) OPTIONALLY PRINT SIGNON
7765                         *   3) INITIALIZE PTM FOR SINGLE STEPPING
7766                         *   4) ENTER COMMAND PROCESSOR
7767                         * INPUT: A=0 INIT CONSOLE AND PRINT STARTUP MESSAGE
7768                         *        A#0 OMIT CONSOLE INIT AND STARTUP MESSAGE
7769                         *************************************************
7770                         
7771 f8c9 41 53 53 49 53 54  SIGNON  FCC     /ASSIST09/      ; SIGNON EYE-CATCHER
     30 39
7772 f8d1 04                         FCB     EOT
7773 f8d2 10 df 97           ZMONTR  STS     <RSTACK         ; SAVE FOR BAD STACK RECOVERY
7774 f8d5 6d 61                      TST     1,S             ; ? INIT CONSOLE AND SEND MSG
7775 f8d7 26 0d                      BNE     ZMONT2          ; BRANCH IF NOT
7776 f8d9 ad 9d 77 f9                JSR     [VECTAB+.CION,PCR] ; READY CONSOLE INPUT
7777 f8dd ad 9d 77 fb                JSR     [VECTAB+.COON,PCR] ; READY CONSOLE OUTPUT
7778 f8e1 30 8c e5                   LEAX    SIGNON,PCR         ; READY SIGNON EYE-CATCHER
7779 f8e4 3f                         SWI                     ; PERFORM
7780 f8e5 03                         FCB     PDATA           ; PRINT STRING
7781 f8e6 9e f6              ZMONT2  LDX     <VECTAB+.PTM    ; LOAD PTM ADDRESS
7782 f8e8 27 0d                      BEQ     CMD             ; BRANCH IF NOT TO USE A PTM
7783 f8ea 6f 02                      CLR     PTMTM1-PTM,X    ; SET LATCH TO CLEAR RESET
7784 f8ec 6f 03                      CLR     PTMTM1+1-PTM,X  ; AND SET GATE HIGH
7785 f8ee cc 01 a6                   LDD     #$01A6          ; SETUP TIMER 1 MODE
7786 f8f1 a7 01                      STA     PTMC2-PTM,X     ; SETUP FOR CONTROL REGISTER1
7787 f8f3 e7 84                      STB     PTMC13-PTM,X    ; SET OUTPUT ENABLED/
7788                         * SINGLE SHOT/ DUAL 8 BIT/INTERNAL MODE/OPERATE
7789 f8f5 6f 01                      CLR     PTMC2-PTM,X     ; SET CR2 BACK TO RESET FORM
7790                         * FALL INTO COMMAND PROCESSOR
7791                         
7792                         ***************************************************
7793                         *          COMMAND HANDLER
7794                         *  BREAKPOINTS ARE REMOVED AT THIS TIME.
7795                         *  PROMPT FOR A COMMAND, AND STORE ALL CHARACTERS
7796                         *  UNTIL A SEPARATOR ON THE STACK.
7797                         *  SEARCH FOR FIRST MATCHING COMMAND SUBSET,
7798                         *  CALL IT OR GIVE '?' RESPONSE.
7799                         *  DURING COMMAND SEARCH:
7800                         *      B=OFFSET TO NEXT ENTRY ON X
7801                         *      U=SAVED S
7802                         *      U-1=ENTRY SIZE+2
7803                         *      U-2=VALID NUMBER FLAG (>=0 VALID)/COMPARE CNT
7804                         *      U-3=CARRIAGE RETURN FLAG (0=CR HAS BEEN DONE)
7805                         *      U-4=START OF COMMAND STORE
7806                         *      S+0=END OF COMMAND STORE
7807                         ***********************************************
7808                         
7809 f8f7 3f                 CMD     SWI                     ; TO NEW LINE
7810 f8f8 06                         FCB     PCRLF           ; FUNCTION
7811                         * DISARM THE BREAKPOINTS
7812 f8f9 17 06 42           CMDNEP  LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
7813 f8fc 2a 0c                      BPL     CMDNOL          ; BRANCH IF NOT ARMED OR NONE
7814 f8fe 50                         NEGB                    ; MAKE POSITIVE
7815 f8ff d7 fa                      STB     <BKPTCT         ; FLAG AS DISARMED
7816 f901 5a                 CMDDDL  DECB                    ; ? FINISHED
7817 f902 2b 06                      BMI     CMDNOL          ; BRANCH IF SO
7818 f904 a6 30                      LDA     -NUMBKP*2,Y     ; LOAD OPCODE STORED
7819 f906 a7 b1                      STA     [,Y++]          ; STORE BACK OVER "SWI"
7820 f908 20 f7                      BRA     CMDDDL          ; LOOP UNTIL DONE
7821 f90a ae 6a              CMDNOL  LDX     10,S            ; LOAD USERS PROGRAM COUNTER
7822 f90c 9f 93                      STX     <PCNTER         ; SAVE FOR EXPRESSION ANALYZER
7823 f90e 86 3e                      LDA     #PROMPT         ; LOAD PROMPT CHARACTER
7824 f910 3f                         SWI                     ; SEND TO OUTPUT HANDLER
7825 f911 01                         FCB     OUTCH           ; FUNCTION
7826 f912 33 e4                      LEAU    ,S              ; REMEMBER STACK RESTORE ADDRESS
7827 f914 df 95                      STU     <PSTACK         ; REMEMBER STACK FOR ERROR USE
7828 f916 4f                         CLRA                    ; PREPARE ZERO
7829 f917 5f                         CLRB                    ; PREPARE ZERO
7830 f918 dd 9b                      STD     <NUMBER         ; CLEAR NUMBER BUILD AREA
7831 f91a dd 8f                      STD     <MISFLG         ; CLEAR MISCEL. AND SWICNT FLAGS
7832 f91c dd 91                      STD     <TRACEC         ; CLEAR TRACE COUNT
7833 f91e c6 02                      LDB     #2              ; SET D TO TWO
7834 f920 34 07                      PSHS    D,CC            ; PLACE DEFAULTS ONTO STACK
7835                         * CHECK FOR "QUICK" COMMANDS.
7836 f922 17 04 50                   LBSR    READC           ; OBTAIN FIRST CHARACTER
7837 f925 30 8d 05 7d                LEAX    CDOT+2,PCR      ; PRESET FOR SINGLE TRACE
7838 f929 81 2e                      CMPA    #'.             ; ? QUICK TRACE
7839 f92b 27 5a                      BEQ     CMDXQT          ; BRANCH EQUAL FOR TRACE ONE
7840 f92d 30 8d 04 e5                LEAX    CMPADP+2,PCR    ; READY MEMORY ENTRY POINT
7841 f931 81 2f                      CMPA    #'/             ; ? OPEN LAST USED MEMORY
7842 f933 27 52                      BEQ     CMDXQT          ; BRANCH TO DO IT IF SO
7843                         * PROCESS NEXT CHARACTER
7844 f935 81 20              CMD2    CMPA    #'              ; ? BLANK OR DELIMITER
7845 f937 23 14                      BLS    CMDGOT           ; BRANCH YES, WE HAVE IT
7846 f939 34 02                      PSHS   A                ; BUILD ONTO STACK
7847 f93b 6c 5f                      INC    -1,U             ; COUNT THIS CHARACTER
7848 f93d 81 2f                      CMPA   #'/              ; ? MEMORY COMMAND
7849 f93f 27 4f                      BEQ    CMDMEM           ; BRANCH IF SO
7850 f941 17 04 07                   LBSR   BLDHXC           ; TREAT AS HEX VALUE
7851 f944 27 02                      BEQ    CMD3             ; BRANCH IF STILL VALID NUMBER
7852 f946 6a 5e                      DEC    -2,U             ; FLAG AS INVALID NUMBER
7853 f948 17 04 2a           CMD3    LBSR   READC            ; OBTAIN NEXT CHARACTER
7854 f94b 20 e8                      BRA    CMD2             ; TEST NEXT CHARACTER
7855                         * GOT COMMAND, NOW SEARCH TABLES
7856 f94d 80 0d              CMDGOT  SUBA   #CR              ; SET ZERO IF CARRIAGE RETURN
7857 f94f a7 5d                      STA    -3,U             ; SETUP FLAG
7858 f951 9e c4                      LDX    <VECTAB+.CMDL1   ; START WITH FIRST CMD LIST
7859 f953 e6 80              CMDSCH  LDB    ,X+              ; LOAD ENTRY LENGTH
7860 f955 2a 10                      BPL    CMDSME           ; BRANCH IF NOT LIST END
7861 f957 9e ee                      LDX    <VECTAB+.CMDL2   ; NOW TO SECOND CMD LITS
7862 f959 5c                         INCB                    ; ? TO CONTINUE TO DEFAULT LIST
7863 f95a 27 f7                      BEQ     CMDSCH          ; BRANCH IF SO
7864 f95c 10 de 95           CMDBAD  LDS     <PSTACK         ; RESTORE STACK
7865 f95f 30 8d 01 56                LEAX    ERRMSG,PCR      ; POINT TO ERROR STRING
7866 f963 3f                         SWI                     ; SEND OUT
7867 f964 02                         FCB     PDATA1          ; TO CONSOLE
7868 f965 20 90                      BRA     CMD             ; AND TRY AGAIN
7869                         * SEARCH NEXT ENTRY
7870 f967 5a                 CMDSME  DECB                    ; TAKE ACCOUNT OF LENGTH BYTE
7871 f968 e1 5f                      CMPB    -1,U            ; ? ENTERED LONGER THAN ENTRY
7872 f96a 24 03                      BHS     CMDSIZ          ; BRANCH IF NOT TOO LONG
7873 f96c 3a                 CMDFLS  ABX                     ; SKIP TO NEXT ENTRY
7874 f96d 20 e4                      BRA     CMDSCH          ; AND TRY NEXT
7875 f96f 31 5d              CMDSIZ  LEAY    -3,U            ; PREPARE TO COMPARE
7876 f971 a6 5f                      LDA     -1,U            ; LOAD SIZE+2
7877 f973 80 02                      SUBA    #2              ; TO ACTUAL SIZE ENTERED
7878 f975 a7 5e                      STA     -2,U            ; SAVE SIZE FOR COUNTDOWN
7879 f977 5a                 CMDCMP  DECB                    ; DOWN ONE BYTE
7880 f978 a6 80                      LDA     ,X+             ; NEXT COMMAND CHARACTER
7881 f97a a1 a2                      CMPA    ,-Y             ; ? SAME AS THAT ENTERED
7882 f97c 26 ee                      BNE     CMDFLS          ; BRANCH TO FLUSH IF NOT
7883 f97e 6a 5e                      DEC     -2,U            ; COUNT DOWN LENGTH OF ENTRY
7884 f980 26 f5                      BNE     CMDCMP          ; BRANCH IF MORE TO TEST
7885 f982 3a                         ABX                     ; TO NEXT ENTRY
7886 f983 ec 1e                      LDD     -2,X            ; LOAD OFFSET
7887 f985 30 8b                      LEAX    D,X             ; COMPUTE ROUTINE ADDRESS+2
7888 f987 6d 5d              CMDXQT  TST     -3,U            ; SET CC FOR CARRIAGE RETURN TEST
7889 f989 32 c4                      LEAS    ,U              ; DELETE STACK WORK AREA
7890 f98b ad 1e                      JSR     -2,X            ; CALL COMMAND
7891 f98d 16 ff 7a                   LBRA    CMDNOL          ; GO GET NEXT COMMAND
7892 f990 6d 5e              CMDMEM  TST     -2,U            ; ? VALID HEX NUMBER ENTERED
7893 f992 2b c8                      BMI     CMDBAD          ; BRANCH ERROR IF NOT
7894 f994 30 88 ae                   LEAX    <CMEMN-CMPADP,X ; TO DIFFERENT ENTRY
7895 f997 dc 9b                      LDD     <NUMBER         ; LOAD NUMBER ENTERED
7896 f999 20 ec                      BRA     CMDXQT          ; AND ENTER MEMORY COMMAND
7897                         
7898                         ** COMMANDS ARE ENTERED AS A SUBROUTINE WITH:
7899                         **    DPR->ASSIST09 DIRECT PAGE WORK AREA
7900                         **    Z=1 CARRIAGE RETURN ENTERED
7901                         **    Z=0 NON CARRIAGE RETURN DELIMITER
7902                         **    S=NORMAL RETURN ADDRESS
7903                         ** THE LABEL "CMDBAD" MAY BE ENTERED TO ISSUE AN
7904                         ** AN ERROR FLAG (*).
7905                         **************************************************
7906                         *       ASSIST09 COMMAND TABLES
7907                         * THESE ARE THE DEFAULT COMMAND TABLES. EXTERNAL
7908                         * TABLES OF THE SAME FORMAT MAY EXTEND/REPLACE
7909                         * THESE BY USING THE VECTOR SWAP FUNCTION.
7910                         *
7911                         * ENTRY FORMAT:
7912                         *    +0...TOTAL SIZE OF ENTRY (INCLUDING THIS BYTE)
7913                         *    +1...COMMAND STRING
7914                         *    +N...TWO BYTE OFFSET TO COMMAND (ENTRYADDR-*)
7915                         *
7916                         * THE TABLES TERMINATE WITH A ONE BYTE -1 OR -2.
7917                         * THE -1 CONTINUES THE COMMAND SEARCH WITH THE
7918                         *        SECOND COMMAND TABLE.
7919                         * THE -2 TERMINATES COMMAND SEARCHES.
7920                         *****************************************************
7921                         
7922                         * THIS IS THE DEFAULT LIST FOR THE SECOND COMMAND
7923                         * LIST ENTRY.
7924                         
7925 f99b 04                 CMDTB2  FCB     4               ; TABLE ENTRY LENGTH
7926 f99c 55                         FCC     'U'             ; 'UNASSEMBLE' COMMAND
7927 f99d c6 63                      FDB     CUNAS-*         ; POINTER TO COMMAND (RELATIVE TO HERE)
7928 f99f fe                         FCB     -2              ; -2 INDICATES END OF TABLE
7929                         
7930                         * THIS IS THE DEFAULT LIST FOR THE FIRST COMMAND
7931                         * LIST ENTRY.
7932                         
7933 f9a0                    CMDTBL  EQU     *               ; MONITOR COMMAND TABLE
7934 f9a0 04                         FCB     4
7935 f9a1 42                         FCC     /B/             ; 'BREAKPOINT' COMMAND
7936 f9a2 05 45                      FDB     CBKPT-*
7937 f9a4 04                         FCB     4
7938 f9a5 43                         FCC     /C/             ; 'CALL' COMMAND
7939 f9a6 04 0f                      FDB     CCALL-*
7940 f9a8 04                         FCB     4
7941 f9a9 44                         FCC     /D/             ; 'DISPLAY' COMMAND
7942 f9aa 04 95                      FDB     CDISP-*
7943 f9ac 04                         FCB     4
7944 f9ad 45                         FCC     /E/             ; 'ENCODE' COMMAND
7945 f9ae 05 97                      FDB     CENCDE-*
7946 f9b0 04                         FCB     4
7947 f9b1 47                         FCC     /G/             ; 'GO' COMMAND
7948 f9b2 03 ca                      FDB     CGO-*
7949 f9b4 04                         FCB     4
7950 f9b5 4c                         FCC     /L/             ; 'LOAD' COMMAND
7951 f9b6 04 d5                      FDB     CLOAD-*
7952 f9b8 04                         FCB     4
7953 f9b9 4d                         FCC     /M/             ; 'MEMORY' COMMAND
7954 f9ba 04 05                      FDB     CMEM-*
7955 f9bc 04                         FCB     4
7956 f9bd 4e                         FCC     /N/             ; 'NULLS' COMMAND
7957 f9be 04 f5                      FDB     CNULLS-*
7958 f9c0 04                         FCB     4
7959 f9c1 4f                         FCC     /O/             ; 'OFFSET' COMMAND
7960 f9c2 05 02                      FDB     COFFS-*
7961 f9c4 04                         FCB     4
7962 f9c5 50                         FCC     /P/             ; 'PUNCH' COMMAND
7963 f9c6 04 a7                      FDB     CPUNCH-*
7964 f9c8 04                         FCB     4
7965 f9c9 52                         FCC     /R/             ; 'REGISTERS' COMMAND
7966 f9ca 02 7c                      FDB     CREG-*
7967                         ;       FCB     4
7968                         ;       FCC     /S/             ; 'STLEVEL' COMMAND - NOT SUPPORTED IN THIS VERSION
7969                         ;       FDB     CSTLEV-*
7970                         ;       FCB     4
7971                         ;       FCC     /T/             ; 'TRACE' COMMAND - NOT SUPPORTED IN THIS VERSION
7972                         ;       FDB     CTRACE-*
7973 f9cc 04                         FCB     4
7974 f9cd 56                         FCC     /V/             ; 'VERIFY' COMMAND
7975 f9ce 04 cf                      FDB     CVER-*
7976 f9d0 04                         FCB     4
7977 f9d1 57                         FCC     /W/             ; 'WINDOW' COMMAND
7978 f9d2 04 68                      FDB     CWINDO-*
7979 f9d4 ff                         FCB     -1              ; END, CONTINUE WITH THE SECOND
7980                         
7981                         *************************************************
7982                         *             [SWI FUNCTIONS 4 AND 5]
7983                         *      4 - OUT2HS - DECODE BYTE TO HEX AND ADD SPACE
7984                         *      5 - OUT4HS - DECODE WORD TO HEX AND ADD SPACE
7985                         * INPUT: X->BYTE OR WORD TO DECODE
7986                         * OUTPUT: CHARACTERS SENT TO OUTPUT HANDLER
7987                         *         X->NEXT BYTE OR WORD
7988                         *************************************************
7989 f9d5 a6 80              ZOUT2H  LDA     ,X+             ; LOAD NEXT BYTE
7990 f9d7 34 06                      PSHS    D               ; SAVE - DO NOT REREAD
7991 f9d9 c6 10                      LDB     #16             ; SHIFT BY 4 BITS
7992 f9db 3d                         MUL                     ; WITH MULTIPLY
7993 f9dc 8d 04                      BSR     ZOUTHX          ; SEND OUT AS HEX
7994 f9de 35 06                      PULS    D               ; RESTORE BYTES
7995 f9e0 84 0f                      ANDA    #$0F            ; ISOLATE RIGHT HEX
7996 f9e2 8b 90              ZOUTHX  ADDA    #$90            ; PREPARE A-F ADJUST
7997 f9e4 19                         DAA                     ; ADJUST
7998 f9e5 89 40                      ADCA    #$40            ; PREPARE CHARACTER BITS
7999 f9e7 19                         DAA                     ; ADJUST
8000 f9e8 6e 9d 76 f2        SEND    JMP     [VECTAB+.CODTA,PCR] ; SEND TO OUT HANDLER
8001                         
8002 f9ec 8d e7              ZOT4HS  BSR     ZOUT2H          ; CONVERT FIRST BYTE
8003 f9ee 8d e5              ZOT2HS  BSR     ZOUT2H          ; CONVERT BYTE TO HEX
8004 f9f0 af 64                      STX     4,S             ; UPDATE USERS X REGISTER
8005                         * FALL INTO SPACE ROUTINE
8006                         
8007                         *************************************************
8008                         *            [SWI FUNCTION 7]
8009                         *         SPACE - SEND BLANK TO OUTPUT HANDLER
8010                         * INPUT: NONE
8011                         * OUTPUT: BLANK SEND TO CONSOLE HANDLER
8012                         *************************************************
8013 f9f2 86 20              ZSPACE  LDA     #'              ; LOAD BLANK
8014 f9f4 20 3d                      BRA     ZOTCH2          ; SEND AND RETURN
8015                         
8016                         ***********************************************
8017                         *             [SWI FUNCTION 9]
8018                         *          SWAP VECTOR TABLE ENTRY
8019                         * INPUT: A=VECTOR TABLE CODE (OFFSET)
8020                         * X=0 OR REPLACEMENT VALUE
8021                         * OUTPUT: X=PREVIOUS VALUE
8022                         ***********************************************
8023 f9f6 a6 61              ZVSWTH  LDA     1,S             ; LOAD REQUESTERS A
8024 f9f8 81 34                      CMPA    #HIVTR          ; ? SUB-CODE TOO HIGH
8025 f9fa 22 39                      BHI     ZOTCH3          ; IGNORE CALL IF SO
8026 f9fc 10 9e c2                   LDY     <VECTAB+.AVTBL  ; LOAD VECTOR TABLE ADDRESS
8027 f9ff ee a6                      LDU     A,Y             ; U=OLD ENTRY
8028 fa01 ef 64                      STU     4,S             ; RETURN OLD VALUE TO CALLERS X
8029 fa03 af 7e                      STX     -2,S            ; ? X=0
8030 fa05 27 2e                      BEQ     ZOTCH3          ; YES, DO NOT CHANGE ENTRY
8031 fa07 af a6                      STX     A,Y             ; REPLACE ENTRY
8032 fa09 20 2a                      BRA     ZOTCH3          ; RETURN FROM SWI
8033                         *D
8034                         
8035                         ************************************************
8036                         *               [SWI FUNCTION 0]
8037                         *  INCHNP - OBTAIN INPUT CHAR IN A (NO PARITY)
8038                         * NULLS AND RUBOUTS ARE IGNORED.
8039                         * AUTOMATIC LINE FEED IS SENT UPON RECEIVING A
8040                         * CARRIAGE RETURN.
8041                         * UNLESS WE ARE LOADING FROM TAPE.
8042                         ************************************************
8043 fa0b 8d 5d              ZINCHP  BSR     XQPAUS          ; RELEASE PROCESSOR
8044 fa0d 8d 5f              ZINCH   BSR     XQCIDT          ; CALL INPUT DATA APPENDAGE
8045 fa0f 24 fa                      BCC     ZINCHP          ; LOOP IF NONE AVAILABLE
8046 fa11 4d                         TSTA                    ; ? TEST FOR NULL
8047 fa12 27 f9                      BEQ     ZINCH           ; IGNORE NULL
8048 fa14 81 7f                      CMPA    #$7F            ; ? RUBOUT
8049 fa16 27 f5                      BEQ     ZINCH           ; BRANCH YES TO IGNORE
8050 fa18 a7 61                      STA     1,S             ; STORE INTO CALLERS A
8051 fa1a 0d 8f                      TST     <MISFLG         ; ? LOAD IN PROGRESS
8052 fa1c 26 17                      BNE     ZOTCH3          ; BRANCH IF SO TO NOT ECHO
8053 fa1e 81 0d                      CMPA    #CR             ; ? CARRIAGE RETURN
8054 fa20 26 04                      BNE     ZIN2            ; NO, TEST ECHO BYTE
8055 fa22 86 0a                      LDA     #LF             ; LOAD LINE FEED
8056 fa24 8d c2                      BSR     SEND            ; ALWAYS ECHO LINE FEED
8057 fa26 0d f4              ZIN2    TST     <VECTAB+.ECHO   ; ? ECHO DESIRED
8058 fa28 26 0b                      BNE     ZOTCH3          ; NO, RETURN
8059                         * FALL THROUGH TO OUTCH
8060                         ************************************************
8061                         *            [SWI FUNCTION 1]
8062                         *        OUTCH - OUTPUT CHARACTER FROM A
8063                         * INPUT: NONE
8064                         * OUTPUT: IF LINEFEED IS THE OUTPUT CHARACTER THEN
8065                         * C=0 NO CTL-X RECEIVED, C=1 CTL-X RECEIVED
8066                         ************************************************
8067 fa2a a6 61              ZOTCH1  LDA     1,S             ; LOAD CHARACTER TO SEND
8068 fa2c 30 8c 09                   LEAX    <ZPCRLS,PCR     ; DEFAULT FOR LINE FEED
8069 fa2f 81 0a                      CMPA    #LF             ; ? LINE FEED
8070 fa31 27 0f                      BEQ     ZPDTLP          ; BRANCH TO CHECK PAUSE IF SO
8071 fa33 8d b3              ZOTCH2  BSR     SEND            ; SEND TO OUTPUT ROUTINE
8072 fa35 0c 90              ZOTCH3  INC     <SWICNT         ; BUMP UP "SWI" TRACE NEST LEVEL
8073 fa37 3b                         RTI                     ; RETURN FROM "SWI" FUNCTION
8074                         
8075                         **************************************************
8076                         * [SWI FUNCTION 6]
8077                         * PCRLF - SEND CR/LF TO CONSOLE HANDLER
8078                         * INPUT: NONE
8079                         * OUTPUT: CR AND LF SENT TO HANDLER
8080                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
8081                         **************************************************
8082 fa38 04                 ZPCRLS  FCB     EOT             ; NULL STRING
8083 fa39 30 8c fc           ZPCRLF LEAX     ZPCRLS,PCR      ; READY CR,LF STRING
8084                         * FALL INTO CR/LF CODE
8085                         
8086                         **************************************************
8087                         * [SWI FUNCTION 3]
8088                         * PDATA - OUTPUT CR/LF AND STRING
8089                         * INPUT: X->STRING
8090                         * OUTPUT: CR/LF AND STRING SENT TO OUTPUT CONSOLE
8091                         * HANDLER.
8092                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
8093                         * NOTE: LINE FEED MUST FOLLOW CARRIAGE RETURN FOR
8094                         * PROPER PUNCH DATA.
8095                         **************************************************
8096                         
8097 fa3c 86 0d              ZPDATA  LDA     #CR             ; LOAD CARRIAGE RETURN
8098 fa3e 8d a8                      BSR     SEND            ; SEND IT
8099 fa40 86 0a                      LDA     #LF             ; LOAD LINE FEED
8100                         * FALL INTO PDATA1
8101                         
8102                         *************************************************
8103                         * [SWI FUNCTION 2]
8104                         * PDATA1 - OUTPUT STRING TILL EOT ($04)
8105                         * THIS ROUTINE PAUSES IF AN INPUT BYTE BECOMES
8106                         * AVAILABLE DURING OUTPUT TRANSMISSION UNTIL A
8107                         * SECOND IS RECEIVED.
8108                         * INPUT: X->STRING
8109                         * OUTPUT: STRING SENT TO OUTPUT CONSOLE DRIVER
8110                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
8111                         *************************************************
8112                         
8113 fa42 8d a4              ZPDTLP  BSR     SEND            ; SEND CHARACTER TO DRIVER
8114 fa44 a6 80              ZPDTA1  LDA     ,X+             ; LOAD NEXT CHARACTER
8115 fa46 81 04                      CMPA    #EOT            ; ? EOT
8116 fa48 26 f8                      BNE     ZPDTLP          ; LOOP IF NOT
8117                         * FALL INTO PAUSE CHECK FUNCTION
8118                         
8119                         ********************************************
8120                         * [SWI FUNCTION 12]
8121                         * PAUSE - RETURN TO TASK DISPATCHING AND CHECK
8122                         * FOR FREEZE CONDITION OR CTL-X BREAK
8123                         * THIS FUNCTION ENTERS THE TASK PAUSE HANDLER SO
8124                         * OPTIONALLY OTHER 6809 PROCESSES MAY GAIN CONTROL.
8125                         * UPON RETURN, CHECK FOR A 'FREEZE' CONDITION
8126                         * WITH A RESULTING WAIT LOOP, OR CONDITION CODE
8127                         * RETURN IF A CONTROL-X IS ENTERED FROM THE INPUT
8128                         * HANDLER.
8129                         * OUTPUT: C=1 IF CTL-X HAS ENTERED, C=0 OTHERWISE
8130                         ******************************************
8131                         
8132 fa4a 8d 1e              ZPAUSE  BSR     XQPAUS          ; RELEASE CONTROL AT EVERY LINE
8133 fa4c 8d 06                      BSR     CHKABT          ; CHECK FOR FREEZE OR ABORT
8134 fa4e 1f a9                      TFR     CC,B            ; PREPARE TO REPLACE CC
8135 fa50 e7 e4                      STB     ,S              ; OVERLAY OLD ONE ON STACK
8136 fa52 20 e1                      BRA     ZOTCH3          ; RETURN FROM "SWI"
8137                         
8138                         * CHKABT - SCAN FOR INPUT PAUSE/ABORT DURING OUTPUT
8139                         * OUTPUT: C=0 OK, C=1 ABORT (CTL-X ISSUED)
8140                         * VOLATILE: U,X,D
8141 fa54 8d 18              CHKABT  BSR     XQCIDT          ; ATTEMPT INPUT
8142 fa56 24 05                      BCC     CHKRTN          ; BRANCH NO TO RETURN
8143 fa58 81 18                      CMPA    #CAN            ; ? CTL-X FOR ABORT
8144 fa5a 26 02                      BNE     CHKWT           ; BRANCH NO TO PAUSE
8145 fa5c 53                 CHKSEC  COMB                    ; SET CARRY
8146 fa5d 39                 CHKRTN  RTS                     ; RETURN TO CALLER WITH CC SET
8147 fa5e 8d 0a              CHKWT   BSR     XQPAUS          ; PAUSE FOR A MOMENT
8148 fa60 8d 0c                      BSR     XQCIDT          ; ? KEY FOR START
8149 fa62 24 fa                      BCC     CHKWT           ; LOOP UNTIL RECEIVED
8150 fa64 81 18                      CMPA    #CAN            ; ? ABORT SIGNALED FROM WAIT
8151 fa66 27 f4                      BEQ     CHKSEC          ; BRANCH YES
8152 fa68 4f                         CLRA                    ; SET C=0 FOR NO ABORT
8153 fa69 39                         RTS                     ; AND RETURN
8154                         
8155                         * SAVE MEMORY WITH JUMPS
8156 fa6a 6e 9d 76 7c        XQPAUS  JMP   [VECTAB+.PAUSE,PCR] ; TO PAUSE ROUTINE
8157 fa6e ad 9d 76 66        XQCIDT  JSR   [VECTAB+.CIDTA,PCR] ; TO INPUT ROUTINE
8158 fa72 84 7f                      ANDA  #$7F              ; STRIP PARITY
8159 fa74 39                         RTS                     ; RETURN TO CALLER
8160                         
8161                         ********************************************
8162                         * NMI DEFAULT INTERRUPT HANDLER
8163                         * THE NMI HANDLER IS USED FOR TRACING INSTRUCTIONS.
8164                         * TRACE PRINTOUTS OCCUR ONLY AS LONG AS THE STACK
8165                         * TRACE LEVEL IS NOT BREACHED BY FALLING BELOW IT.
8166                         * TRACING CONTINUES UNTIL THE COUNT TURNS ZERO OR
8167                         * A CTL-X IS ENTERED FROM THE INPUT CONSOLE DEVICE.
8168                         *********************************************
8169                         
8170 fa75 4f 50 2d 04        MSHOWP  FCB     'O,'P,'-,EOT    ; OPCODE PREP
8171                         
8172 fa79 8d 42              NMIR    BSR     LDDP            ; LOAD PAGE AND VERIFY STACK
8173 fa7b 0d 8f                      TST     <MISFLG         ; ? THRU A BREAKPOINT
8174 fa7d 26 34                      BNE     NMICON          ; BRANCH IF SO TO CONTINUE
8175 fa7f 0d 90                      TST     <SWICNT         ; ? INHIBIT "SWI" DURING TRACE
8176 fa81 2b 29                      BMI     NMITRC          ; BRANCH YES
8177 fa83 30 6c                      LEAX    12,S            ; OBTAIN USERS STACK POINTER
8178 fa85 9c f8                      CMPX    <SLEVEL         ; ? TO TRACE HERE
8179 fa87 25 23                      BLO     NMITRC          ; BRANCH IF TOO LOW TO DISPLAY
8180 fa89 30 8c e9                   LEAX    MSHOWP,PCR      ; LOAD OP PREP
8181 fa8c 3f                         SWI                     ; SEND TO CONSOLE
8182 fa8d 02                         FCB     PDATA1          ; FUNCTION
8183 fa8e 09 8e                      ROL     <DELIM          ; SAVE CARRY BIT
8184 fa90 30 8d 76 05                LEAX    LASTOP,PCR      ; POINT TO LAST OP
8185 fa94 3f                         SWI                     ; SEND OUT AS HEX
8186 fa95 05                         FCB     OUT4HS          ; FUNCTION
8187 fa96 8d 17                      BSR     REGPRS          ; FOLLOW MEMORY WITH REGISTERS
8188 fa98 25 37                      BCS     ZBKCMD          ; BRANCH IF "CANCEL"
8189 fa9a 06 8e                      ROR     <DELIM          ; RESTORE CARRY BIT
8190 fa9c 25 33                      BCS     ZBKCMD          ; BRANCH IF "CANCEL"
8191 fa9e 9e 91                      LDX     <TRACEC         ; LOAD TRACE COUNT
8192 faa0 27 2f                      BEQ     ZBKCMD          ; IF ZERO TO COMMAND HANDLER
8193 faa2 30 1f                      LEAX    -1,X            ; MINUS ONE
8194 faa4 9f 91                      STX     <TRACEC         ; REFRESH
8195 faa6 27 29                      BEQ     ZBKCMD          ; STOP TRACE WHEN ZERO
8196 faa8 8d aa                      BSR     CHKABT          ; ? ABORT THE TRACE
8197 faaa 25 25                      BCS     ZBKCMD          ; BRANCH YES TO COMMAND HANDLER
8198 faac 16 03 f7           NMITRC  LBRA    CTRCE3          ; NO, TRACE ANOTHER INSTRUCTION
8199                         
8200 faaf 17 01 b9           REGPRS  LBSR    REGPRT          ; PRINT REGISTERS AS FROM COMMAND
8201 fab2 39                         RTS                     ; RETURN TO CALLER
8202                         
8203                         * JUST EXECUTED THRU A BRKPNT. NOW CONTINUE NORMALLY
8204                         
8205 fab3 0f 8f              NMICON  CLR     <MISFLG        ; CLEAR THRU FLAG
8206 fab5 17 02 eb                   LBSR    ARMBK2         ; ARM BREAKPOINTS
8207 fab8 3b                 RTI     RTI                    ; AND CONTINUE USERS PROGRAM
8208                         
8209                         * LDDP - SETUP DIRECT PAGE REGISTER, VERIFY STACK.
8210                         * AN INVALID STACK CAUSES A RETURN TO THE COMMAND
8211                         * HANDLER.
8212                         * INPUT: FULLY STACKED REGISTERS FROM AN INTERRUPT
8213                         * OUTPUT: DPR LOADED TO WORK PAGE
8214                         
8215 fab9 3f 07 20 04        ERRMSG  FCB     '?,BELL,$20,EOT ; ERROR RESPONSE
8216                         
8217 fabd e6 8d 75 dc        LDDP    LDB     BASEPG,PCR      ; LOAD DIRECT PAGE HIGH BYTE
8218 fac1 1f 9b                      TFR     B,DP            ; SETUP DIRECT PAGE REGISTER
8219 fac3 a1 63                      CMPA    3,S             ; ? IS STACK VALID
8220 fac5 27 25                      BEQ     RTS             ; YES, RETURN
8221 fac7 10 de 97                   LDS     <RSTACK         ; RESET TO INITIAL STACK POINTER
8222 faca 30 8c ec           ERROR   LEAX    ERRMSG,PCR      ; LOAD ERROR REPORT
8223 facd 3f                         SWI                     ; SEND OUT BEFORE REGISTERS
8224 face 03                         FCB     PDATA           ; ON NEXT LINE
8225                         * FALL INTO BREAKPOINT HANDLER
8226                         
8227                         **********************************************
8228                         * [SWI FUNCTION 10]
8229                         * BREAKPOINT PROGRAM FUNCTION
8230                         * PRINT REGISTERS AND GO TO COMMAND HANLER
8231                         ***********************************************
8232                         
8233 facf 8d de              ZBKPNT  BSR     REGPRS          ; PRINT OUT REGISTERS
8234 fad1 16 fe 25           ZBKCMD  LBRA    CMDNEP          ; NOW ENTER COMMAND HANDLER
8235                         
8236                         ********************************************
8237                         * IRQ, RESERVED, SWI2 AND SWI3 INTERRUPT HANDLERS
8238                         * THE DEFAULT HANDLING IS TO CAUSE A BREAKPOINT.
8239                         ********************************************
8240 fad4                    SWI2R   EQU     *               ; SWI2 ENTRY
8241 fad4                    SWI3R   EQU     *               ; SWI3 ENTRY
8242 fad4                    IRQR    EQU     *               ; IRQ ENTRY
8243 fad4 8d e7              RSRVDR  BSR     LDDP            ; SET BASE PAGE, VALIDATE STACK
8244 fad6 20 f7                      BRA     ZBKPNT          ; FORCE A BREAKPOINT
8245                         
8246                         ******************************************
8247                         * FIRQ HANDLER
8248                         * JUST RETURN FOR THE FIRQ INTERRUPT
8249                         ******************************************
8250 fab8                    FIRQR   EQU     RTI             ; IMMEDIATE RETURN
8251                         
8252                         **************************************************
8253                         * DEFAULT I/O DRIVERS
8254                         **************************************************
8255                         * CIDTA - RETURN CONSOLE INPUT CHARACTER
8256                         * OUTPUT: C=0 IF NO DATA READY, C=1 A=CHARACTER
8257                         * U VOLATILE
8258                         
8259 fad8 de f0              CIDTA   LDU     <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
8260 fada a6 c4                      LDA     ,U              ; LOAD STATUS REGISTER
8261 fadc 44                         LSRA                    ; TEST RECEIVER REGISTER FLAG
8262 fadd 24 02                      BCC     CIRTN           ; RETURN IF NOTHING
8263 fadf a6 41                      LDA     1,U             ; LOAD DATA BYTE
8264 fae1 39                 CIRTN   RTS                     ; RETURN TO CALLER
8265                         
8266                         * CION - INPUT CONSOLE INITIALIZATION
8267                         * COON - OUTPUT CONSOLE INITIALIZATION
8268                         * A,X VOLATILE
8269 fae2                    CION   EQU      *
8270 fae2 86 13              COON   LDA      #$13            ; RESET ACIA CODE
8271 fae4 9e f0                     LDX      <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
8272 fae6 a7 84                     STA      ,X              ; STORE INTO STATUS REGISTER
8273 fae8 86 15                     LDA      #$15            ; SET CONTROL
8274 faea a7 84                     STA      ,X              ; REGISTER UP
8275 faec 39                 RTS    RTS                      ; RETURN TO CALLER
8276                         
8277                         * THE FOLLOWING HAVE NO DUTIES TO PERFORM
8278 faec                    CIOFF EQU       RTS             ; CONSOLE INPUT OFF
8279 faec                    COOFF EQU       RTS             ; CONSOLE OUTPUT OFF
8280                         
8281                         * CODTA - OUTPUT CHARACTER TO CONSOLE DEVICE
8282                         * INPUT: A=CHARACTER TO SEND
8283                         * OUTPUT: CHAR SENT TO TERMINAL WITH PROPER PADDING
8284                         * ALL REGISTERS TRANSPARENT
8285                         
8286 faed 34 47              CODTA   PSHS    U,D,CC          ; SAVE REGISTERS,WORK BYTE
8287 faef de f0                      LDU     <VECTAB+.ACIA   ; ADDRESS ACIA
8288 faf1 8d 1b                      BSR     CODTAO          ; CALL OUTPUT CHAR SUBROUTINE
8289 faf3 81 10                      CMPA    #DLE            ; ? DATA LINE ESCAPE
8290 faf5 27 12                      BEQ     CODTRT          ; YES, RETURN
8291 faf7 d6 f2                      LDB     <VECTAB+.PAD    ; DEFAULT TO CHAR PAD COUNT
8292 faf9 81 0d                      CMPA    #CR             ; ? CR
8293 fafb 26 02                      BNE     CODTPD          ; BRANCH NO
8294 fafd d6 f3                      LDB     <VECTAB+.PAD+1  ; LOAD NEW LINE PAD COUNT
8295 faff 4f                 CODTPD  CLRA                    ; CREATE NULL
8296 fb00 e7 e4                      STB     ,S              ; SAVE COUNT
8297 fb02 8c                         FCB     SKIP2           ; ENTER LOOP
8298 fb03 8d 09              CODTLP  BSR     CODTAO          ; SEND NULL
8299 fb05 6a e4                      DEC     ,S              ; ? FINISHED
8300 fb07 2a fa                      BPL     CODTLP          ; NO, CONTINUE WITH MORE
8301 fb09 35 c7              CODTRT  PULS    PC,U,D,CC       ; RESTORE REGISTERS AND RETURN
8302                         
8303 fb0b 17 ff 5c           CODTAD  LBSR    XQPAUS          ; TEMPORARY GIVE UP CONTROL
8304 fb0e e6 c4              CODTAO  LDB     ,U              ; LOAD ACIA CONTROL REGISTER
8305 fb10 c5 02                      BITB    #$02            ; ? TX REGISTER CLEAR >LSAB FIXME
8306 fb12 27 f7                      BEQ     CODTAD          ; RELEASE CONTROL IF NOT
8307 fb14 a7 41                      STA     1,U             ; STORE INTO DATA REGISTER
8308 fb16 39                         RTS                     ; RETURN TO CALLER
8309                         *E
8310                         
8311                         * BSON - TURN ON READ/VERIFY/PUNCH MECHANISM
8312                         * A IS VOLATILE
8313                         
8314 fb17 86 11              BSON    LDA     #$11            ; SET READ CODE
8315 fb19 6d 66                      TST     6,S             ; ? READ OR VERIFY
8316 fb1b 26 01                      BNE     BSON2           ; BRANCH YES
8317 fb1d 4c                         INCA                    ; SET TO WRITE
8318 fb1e 3f                 BSON2   SWI                     ; PERFORM OUTPUT
8319 fb1f 01                         FCB     OUTCH           ; FUNCTION
8320 fb20 0c 8f                      INC     <MISFLG         ; SET LOAD IN PROGRESS FLAG
8321 fb22 39                         RTS                     ; RETURN TO CALLER
8322                         
8323                         * BSOFF - TURN OFF READ/VERIFY/PUNCH MECHANISM
8324                         * A,X VOLATILE
8325                         
8326 fb23 86 14              BSOFF   LDA     #$14            ; TO DC4 - STOP
8327 fb25 3f                         SWI                     ; SEND OUT
8328 fb26 01                         FCB     OUTCH           ; FUNCTION
8329 fb27 4a                         DECA                    ; CHANGE TO DC3 (X-OFF)
8330 fb28 3f                         SWI                     ; SEND OUT
8331 fb29 01                         FCB     OUTCH           ; FUNCTION
8332 fb2a 0a 8f                      DEC     <MISFLG         ; CLEAR LOAD IN PROGRESS FLAG
8333 fb2c 8e 61 a8                   LDX     #25000          ; DELAY 1 SECOND (2MHZ CLOCK)
8334 fb2f 30 1f              BSOFLP  LEAX    -1,X            ; COUNT DOWN
8335 fb31 26 fc                      BNE     BSOFLP          ; LOOP TILL DONE
8336 fb33 39                         RTS                     ; RETURN TO CALLER
8337                         
8338                         * BSDTA - READ/VERIFY/PUNCH HANDLER
8339                         * INPUT: S+6=CODE BYTE, VERIFY(-1),PUNCH(0),LOAD(1)
8340                         * S+4=START ADDRESS
8341                         * S+2=STOP ADDRESS
8342                         * S+0=RETURN ADDRESS
8343                         * OUTPUT: Z=1 NORMAL COMPLETION, Z=0 INVALID LOAD/VER
8344                         * REGISTERS ARE VOLATILE
8345 fb34 ee 62              BSDTA   LDU     2,S             ; U=TO ADDRESS OR OFFSET
8346 fb36 6d 66                      TST     6,S             ; ? PUNCH
8347 fb38 27 54                      BEQ     BSDPUN          ; BRANCH YES
8348                         
8349                         * DURING READ/VERIFY: S+2=MSB ADDRESS SAVE BYTE
8350                         * S+1=BYTE COUNTER
8351                         * S+0=CHECKSUM
8352                         * U HOLDS OFFSET
8353 fb3a 32 7d                      LEAS    -3,S            ; ROOM FOR WORK/COUNTER/CHECKSUM
8354 fb3c 3f                 BSDLD1  SWI                     ; GET NEXT CHARACTER
8355 fb3d 00                         FCB     INCHNP          ; FUNCTION
8356 fb3e 81 53              BSDLD2  CMPA    #'S             ; ? START OF S1/S9
8357 fb40 26 fa                      BNE     BSDLD1          ; BRANCH NOT
8358 fb42 3f                         SWI                     ; GET NEXT CHARACTER
8359 fb43 00                         FCB     INCHNP          ; FUNCTION
8360 fb44 81 39                      CMPA    #'9             ; ? HAVE S9
8361 fb46 27 22                      BEQ     BSDSRT          ; YES, RETURN GOOD CODE
8362 fb48 81 31                      CMPA    #'1             ; ? HAVE NEW RECORD
8363 fb4a 26 f2                      BNE     BSDLD2          ; BRANCH IF NOT
8364 fb4c 6f e4                      CLR     ,S              ; CLEAR CHECKSUM
8365 fb4e 8d 21                      BSR     BYTE            ; OBTAIN BYTE COUNT
8366 fb50 e7 61                      STB     1,S             ; SAVE FOR DECREMENT
8367                         
8368                         * READ ADDRESS
8369 fb52 8d 1d                      BSR     BYTE            ; OBTAIN HIGH VALUE
8370 fb54 e7 62                      STB     2,S             ; SAVE IT
8371 fb56 8d 19                      BSR     BYTE            ; OBTAIN LOW VALUE
8372 fb58 a6 62                      LDA     2,S             ; MAKE D=VALUE
8373 fb5a 31 cb                      LEAY    D,U             ; Y=ADDRESS+OFFSET
8374                         * STORE TEXT
8375 fb5c 8d 13              BSDNXT  BSR     BYTE            ; NEXT BYTE
8376 fb5e 27 0c                      BEQ     BSDEOL          ; BRANCH IF CHECKSUM
8377 fb60 6d 69                      TST     9,S             ; ? VERIFY ONLY
8378 fb62 2b 02                      BMI     BSDCMP          ; YES, ONLY COMPARE
8379 fb64 e7 a4                      STB     ,Y              ; STORE INTO MEMORY
8380 fb66 e1 a0              BSDCMP  CMPB    ,Y+             ; ? VALID RAM
8381 fb68 27 f2                      BEQ     BSDNXT          ; YES, CONTINUE READING
8382 fb6a 35 92              BSDSRT  PULS    PC,X,A          ; RETURN WITH Z SET PROPER
8383 fb6c 4c                 BSDEOL  INCA                    ; ? VALID CHECKSUM
8384 fb6d 27 cd                      BEQ     BSDLD1          ; BRANCH YES
8385 fb6f 20 f9                      BRA     BSDSRT          ; RETURN Z=0 INVALID
8386                         
8387                         * BYTE BUILDS 8 BIT VALUE FROM TWO HEX DIGITS IN
8388 fb71 8d 12              BYTE    BSR     BYTHEX         ; OBTAIN FIRST HEX
8389 fb73 c6 10                      LDB     #16            ; PREPARE SHIFT
8390 fb75 3d                         MUL                    ; OVER TO A
8391 fb76 8d 0d                      BSR     BYTHEX         ; OBTAIN SECOND HEX
8392 fb78 34 04                      PSHS    B              ; SAVE HIGH HEX
8393 fb7a ab e0                      ADDA    ,S+            ; COMBINE BOTH SIDES
8394 fb7c 1f 89                      TFR     A,B            ; SEND BACK IN B
8395 fb7e ab 62                      ADDA    2,S            ; COMPUTE NEW CHECKSUM
8396 fb80 a7 62                      STA     2,S            ; STORE BACK
8397 fb82 6a 63                      DEC     3,S            ; DECREMENT BYTE COUNT
8398 fb84 39                 BYTRTS  RTS                    ; RETURN TO CALLER
8399                         
8400 fb85 3f                 BYTHEX  SWI                    ; GET NEXT HEX
8401 fb86 00                         FCB     INCHNP         ; CHARACTER
8402 fb87 17 01 d4                   LBSR    CNVHEX         ; CONVERT TO HEX
8403 fb8a 27 f8                      BEQ     BYTRTS         ; RETURN IF VALID HEX
8404 fb8c 35 f2                      PULS    PC,U,Y,X,A     ; RETURN TO CALLER WITH Z=0
8405                         
8406                         * PUNCH STACK USE: S+8=TO ADDRESS
8407                         *                  S+6=RETURN ADDRESS
8408                         *                  S+4=SAVED PADDING VALUES
8409                         *                  S+2 FROM ADDRESS
8410                         *                  S+1=FRAME COUNT/CHECKSUM
8411                         *                  S+0=BYTE COUNT
8412                         
8413 fb8e de f2              BSDPUN  LDU     <VECTAB+.PAD    ; LOAD PADDING VALUES
8414 fb90 ae 64                      LDX     4,S             ; X=FROM ADDRESS
8415 fb92 34 56                      PSHS    U,X,D           ; CREATE STACK WORK AREA
8416 fb94 cc 00 18                   LDD     #24             ; SET A=0, B=24
8417 fb97 d7 f2                      STB     <VECTAB+.PAD    ; SETUP 24 CHARACTER PADS
8418 fb99 3f                         SWI                     ; SEND NULLS OUT
8419 fb9a 01                         FCB     OUTCH           ; FUNCTION
8420 fb9b c6 04                      LDB     #4              ; SETUP NEW LINE PAD TO 4
8421 fb9d dd f2                      STD     <VECTAB+.PAD    ; SETUP PUNCH PADDING
8422                         * CALCULATE SIZE
8423 fb9f ec 68              BSPGO   LDD     8,S             ; LOAD TO
8424 fba1 a3 62                      SUBD    2,S             ; MINUS FROM=LENGTH
8425 fba3 10 83 00 18                CMPD    #24             ; ? MORE THAN 23
8426 fba7 25 02                      BLO     BSPOK           ; NO, OK
8427 fba9 c6 17                      LDB     #23             ; FORCE TO 23 MAX
8428 fbab 5c                 BSPOK   INCB                    ; PREPARE COUNTER
8429 fbac e7 e4                      STB     ,S              ; STORE BYTE COUNT
8430 fbae cb 03                      ADDB    #3              ; ADJUST TO FRAME COUNT
8431 fbb0 e7 61                      STB     1,S             ; SAVE
8432                         
8433                         *PUNCH CR,LF,NULS,S,1
8434 fbb2 30 8c 33                  LEAX     <BSPSTR,PCR     ; LOAD START RECORD HEADER
8435 fbb5 3f                        SWI                      ; SEND OUT
8436 fbb6 03                        FCB      PDATA           ; FUNCTION
8437                         * SEND FRAME COUNT
8438 fbb7 5f                        CLRB                     ; INITIALIZE CHECKSUM
8439 fbb8 30 61                     LEAX     1,S             ; POINT TO FRAME COUNT AND ADDR
8440 fbba 8d 27                     BSR      BSPUN2          ; SEND FRAME COUNT
8441                         *DATA ADDRESS
8442 fbbc 8d 25                    BSR       BSPUN2          ; SEND ADDRESS HI
8443 fbbe 8d 23                    BSR       BSPUN2          ; SEND ADDRESS LOW
8444                         *PUNCH DATA
8445 fbc0 ae 62                     LDX      2,S             ; LOAD START DATA ADDRESS
8446 fbc2 8d 1f              BSPMRE BSR      BSPUN2          ; SEND OUT NEXT BYTE
8447 fbc4 6a e4                     DEC      ,S              ; ? FINAL BYTE
8448 fbc6 26 fa                     BNE      BSPMRE          ; LOOP IF NOT DONE
8449 fbc8 af 62                     STX      2,S             ; UPDATE FROM ADDRESS VALUE
8450                         *PUNCH CHECKSUM
8451 fbca 53                        COMB                     ; COMPLEMENT
8452 fbcb e7 61                     STB      1,S             ; STORE FOR SENDOUT
8453 fbcd 30 61                     LEAX     1,S             ; POINT TO IT
8454 fbcf 8d 14                     BSR      BSPUNC          ; SEND OUT AS HEX
8455 fbd1 ae 68                     LDX      8,S             ; LOAD TOP ADDRESS
8456 fbd3 ac 62                     CMPX     2,S             ; ? DONE
8457 fbd5 24 c8                     BHS      BSPGO           ; BRANCH NOT
8458 fbd7 30 8c 11                  LEAX     <BSPEOF,PCR     ; PREPARE END OF FILE
8459 fbda 3f                        SWI                      ; SEND OUT STRING
8460 fbdb 03                        FCB      PDATA           ; FUNCTION
8461 fbdc ec 64                     LDD      4,S             ; RECOVER PAD COUNTS
8462 fbde dd f2                     STD      <VECTAB+.PAD    ; RESTORE
8463 fbe0 4f                        CLRA                     ; SET Z=1 FOR OK RETURN
8464 fbe1 35 d6                     PULS     PC,U,X,D        ; RETURN WITH OK CODE
8465 fbe3 eb 84              BSPUN2 ADDB     ,X              ; ADD TO CHECKSUM
8466 fbe5 16 fd ed           BSPUNC LBRA     ZOUT2H          ; SEND OUT AS HEX AND RETURN
8467                         
8468 fbe8 53 01 04           BSPSTR FCB      'S,1,EOT        ; CR,LF,NULLS,S,1
8469 fbeb 53 39 30 33 30 30  BSPEOF FCC      /S9030000FC/         ; EOF STRING
     30 30 46 43
8470 fbf5 0d 0a 04                  FCB      CR,LF,EOT
8471                         
8472                         * HSDTA - HIGH SPEED PRINT MEMORY
8473                         * INPUT: S+4=START ADDRESS
8474                         * S+2=STOP ADDRESS
8475                         * S+0=RETURN ADDRESS
8476                         * X,D VOLATILE
8477                         
8478                         * SEND TITLE
8479                         
8480 fbf8 3f                 HSDTA   SWI                     ; SEND NEW LINE
8481 fbf9 06                         FCB     PCRLF           ; FUNCTION
8482 fbfa c6 06                      LDB     #6              ; PREPARE 6 SPACES
8483 fbfc 3f                 HSBLNK  SWI                     ; SEND BLANK
8484 fbfd 07                         FCB     SPACEF          ; FUNCTION
8485 fbfe 5a                         DECB                    ; COUNT DOWN
8486 fbff 26 fb                      BNE     HSBLNK          ; LOOP IF MORE
8487 fc01 5f                         CLRB                    ; SETUP BYTE COUNT
8488 fc02 1f 98              HSHTTL  TFR     B,A             ; PREPARE FOR CONVERT
8489 fc04 17 fd db                   LBSR    ZOUTHX          ; CONVERT TO A HEX DIGIT
8490 fc07 3f                         SWI                     ; SEND BLANK
8491 fc08 07                         FCB     SPACEF          ; FUNCTION
8492 fc09 3f                         SWI                     ; SEND ANOTHER
8493 fc0a 07                         FCB     SPACEF          ; BLANK
8494 fc0b 5c                         INCB                    ; UP ANOTHER
8495 fc0c c1 10                      CMPB    #$10            ; ? PAST 'F'
8496 fc0e 25 f2                      BLO     HSHTTL          ; LOOP UNTIL SO
8497 fc10 3f                 HSHLNE  SWI                     ; TO NEXT LINE
8498 fc11 06                         FCB     PCRLF           ; FUNCTION
8499 fc12 25 2f                      BCS     HSDRTN          ; RETURN IF USER ENTERED CTL-X
8500 fc14 30 64                      LEAX    4,S             ; POINT AT ADDRESS TO CONVERT
8501 fc16 3f                         SWI                     ; PRINT OUT ADDRESS
8502 fc17 05                         FCB     OUT4HS          ; FUNCTION
8503 fc18 ae 64                      LDX     4,S             ; LOAD ADDRESS PROPER
8504 fc1a c6 10                      LDB     #16             ; NEXT SIXTEEN
8505 fc1c 3f                 HSHNXT  SWI                     ; CONVERT BYTE TO HEX AND SEND
8506 fc1d 04                         FCB     OUT2HS          ; FUNCTION
8507 fc1e 5a                         DECB                    ; COUNT DOWN
8508 fc1f 26 fb                      BNE     HSHNXT          ; LOOP IF NOT SIXTEENTH
8509 fc21 3f                         SWI                     ; SEND BLANK
8510 fc22 07                         FCB     SPACEF          ; FUNCTION
8511 fc23 ae 64                      LDX     4,S             ; RELOAD FROM ADDRESS
8512 fc25 c6 10                      LDB     #16             ; COUNT
8513 fc27 a6 80              HSHCHR  LDA     ,X+             ; NEXT BYTE
8514 fc29 2b 04                      BMI     HSHDOT          ; TOO LARGE, TO A DOT
8515 fc2b 81 20                      CMPA    #'              ; ? LOWER THAN A BLANK
8516 fc2d 24 02                      BHS     HSHCOK          ; NO, BRANCH OK
8517 fc2f 86 2e              HSHDOT  LDA     #'.             ; CONVERT INVALID TO A BLANK
8518 fc31 3f                 HSHCOK  SWI                     ; SEND CHARACTER
8519 fc32 01                         FCB     OUTCH           ; FUNCTION
8520 fc33 5a                         DECB                    ; ? DONE
8521 fc34 26 f1                      BNE     HSHCHR          ; BRANCH NO
8522 fc36 ac 62                      CPX     2,S             ; ? PAST LAST ADDRESS
8523 fc38 24 09                      BHS     HSDRTN          ; QUIT IF SO
8524 fc3a af 64                      STX     4,S             ; UPDATE FROM ADDRESS
8525 fc3c a6 65                      LDA     5,S             ; LOAD LOW BYTE ADDRESS
8526 fc3e 48                         ASLA                    ; ? TO SECTION BOUNDARY
8527 fc3f 26 cf                      BNE     HSHLNE          ; BRANCH IF NOT
8528 fc41 20 b5                      BRA     HSDTA           ; BRANCH IF SO
8529 fc43 3f                 HSDRTN  SWI                     ; SEND NEW LINE
8530 fc44 06                         FCB     PCRLF           ; FUNCTION
8531 fc45 39                         RTS                     ; RETURN TO CALLER
8532                         *F
8533                         
8534                         ***********************************************
8535                         *     A S S I S T 0 9    C O M M A N D S
8536                         ***********************************************
8537                         
8538                         *************REGISTERS - DISPLAY AND CHANGE REGISTERS
8539 fc46 8d 23              CREG    BSR     REGPRT          ; PRINT REGISTERS
8540 fc48 4c                         INCA                    ; SET FOR CHANGE FUNCTION
8541 fc49 8d 21                      BSR     REGCHG          ; GO CHANGE, DISPLAY REGISTERS
8542 fc4b 39                         RTS                     ; RETURN TO COMMAND PROCESSOR
8543                         
8544                         ********************************************
8545                         * REGPRT - PRINT/CHANGE REGISTERS SUBROUTINE
8546                         * WILL ABORT TO 'CMDBAD' IF OVERFLOW DETECTED DURING
8547                         * A CHANGE OPERATION. CHANGE DISPLAYS REGISTERS WHEN
8548                         * DONE.
8549                         
8550                         * REGISTER MASK LIST CONSISTS OF:
8551                         * A) CHARACTERS DENOTING REGISTER
8552                         * B) ZERO FOR ONE BYTE, -1 FOR TWO
8553                         * C) OFFSET ON STACK TO REGISTER POSITION
8554                         * INPUT: SP+4=STACKED REGISTERS
8555                         * A=0 PRINT, A#0 PRINT AND CHANGE
8556                         * OUTPUT: (ONLY FOR REGISTER DISPLAY)
8557                         * C=1 CONTROL-X ENTERED, C=0 OTHERWISE
8558                         * VOLATILE: D,X (CHANGE)
8559                         * B,X (DISPLAY)
8560                         *******************************************
8561                         
8562 fc4c 50 43 ff 13        REGMSK  FCB     'P,'C,-1,19     ; PC REG
8563 fc50 41 00 0a                   FCB     'A,0,10         ; A REG
8564 fc53 42 00 0b                   FCB     'B,0,11         ; B REG
8565 fc56 58 ff 0d                   FCB     'X,-1,13        ; X REG
8566 fc59 59 ff 0f                   FCB     'Y,-1,15        ; Y REG
8567 fc5c 55 ff 11                   FCB     'U,-1,17        ; U REG
8568 fc5f 53 ff 01                   FCB     'S,-1,1         ; S REG
8569 fc62 43 43 00 09                FCB     'C,'C,0,9       ; CC REG
8570 fc66 44 50 00 0c                FCB     'D,'P,0,12      ; DP REG
8571 fc6a 00                         FCB     0               ; END OF LIST
8572                         
8573 fc6b 4f                 REGPRT  CLRA                    ; SETUP PRINT ONLY FLAG
8574 fc6c 30 e8 10           REGCHG  LEAX    4+12,S          ; READY STACK VALUE
8575 fc6f 34 32                      PSHS    Y,X,A           ; SAVE ON STACK WITH OPTION
8576 fc71 31 8c d8                   LEAY    REGMSK,PCR      ; LOAD REGISTER MASK
8577 fc74 ec a0              REGP1   LDD     ,Y+             ; LOAD NEXT CHAR OR <=0
8578 fc76 4d                         TSTA                    ; ? END OF CHARACTERS
8579 fc77 2f 04                      BLE     REGP2           ; BRANCH NOT CHARACTER
8580 fc79 3f                         SWI                     ; SEND TO CONSOLE
8581 fc7a 01                         FCB     OUTCH           ; FUNCTION BYTE
8582 fc7b 20 f7                      BRA     REGP1           ; CHECK NEXT
8583 fc7d 86 2d              REGP2   LDA     #'-             ; READY '-'
8584 fc7f 3f                         SWI                     ; SEND OUT
8585 fc80 01                         FCB     OUTCH           ; WITH OUTCH
8586 fc81 30 e5                      LEAX    B,S             ; X->REGISTER TO PRINT
8587 fc83 6d e4                      TST     ,S              ; ? CHANGE OPTION
8588 fc85 26 12                      BNE     REGCNG          ; BRANCH YES
8589 fc87 6d 3f                      TST     -1,Y            ; ? ONE OR TWO BYTES
8590 fc89 27 03                      BEQ     REGP3           ; BRANCH ZERO MEANS ONE
8591 fc8b 3f                         SWI                     ; PERFORM WORD HEX
8592 fc8c 05                         FCB     OUT4HS          ; FUNCTION
8593 fc8d 8c                         FCB     SKIP2           ; SKIP BYTE PRINT
8594 fc8e 3f                 REGP3   SWI                     ; PERFORM BYTE HEX
8595 fc8f 04                         FCB     OUT2HS          ; FUNCTION
8596 fc90 ec a0              REG4    LDD     ,Y+             ; TO FRONT OF NEXT ENTRY
8597 fc92 5d                         TSTB                    ; ? END OF ENTRIES
8598 fc93 26 df                      BNE     REGP1           ; LOOP IF MORE
8599 fc95 3f                         SWI                     ; FORCE NEW LINE
8600 fc96 06                         FCB     PCRLF           ; FUNCTION
8601 fc97 35 b2              REGRTN  PULS    PC,Y,X,A        ; RESTORE STACK AND RETURN
8602                         
8603 fc99 8d 40              REGCNG  BSR     BLDNNB          ; INPUT BINARY NUMBER
8604 fc9b 27 10                      BEQ     REGNXC          ; IF CHANGE THEN JUMP
8605 fc9d 81 0d                      CMPA    #CR             ; ? NO MORE DESIRED
8606 fc9f 27 1e                      BEQ     REGAGN          ; BRANCH NOPE
8607 fca1 e6 3f                      LDB     -1,Y            ; LOAD SIZE FLAG
8608 fca3 5a                         DECB                    ; MINUS ONE
8609 fca4 50                         NEGB                    ; MAKE POSITIVE
8610 fca5 58                         ASLB                    ; TIMES TWO (=2 OR =4)
8611 fca6 3f                 REGSKP  SWI                     ; PERFORM SPACES
8612 fca7 07                         FCB     SPACEF          ; FUNCTION
8613 fca8 5a                         DECB
8614 fca9 26 fb                      BNE     REGSKP          ; LOOP IF MORE
8615 fcab 20 e3                      BRA     REG4            ; CONTINUE WITH NEXT REGISTER
8616 fcad a7 e4              REGNXC  STA     ,S              ; SAVE DELIMITER IN OPTION
8617                         *                               ; (ALWAYS > 0)
8618 fcaf dc 9b                      LDD     <NUMBER         ; OBTAIN BINARY RESULT
8619 fcb1 6d 3f                      TST     -1,Y            ; ? TWO BYTES WORTH
8620 fcb3 26 02                      BNE     REGTWO          ; BRANCH YES
8621 fcb5 a6 82                      LDA     ,-X             ; SETUP FOR TWO
8622 fcb7 ed 84              REGTWO  STD     ,X              ; STORE IN NEW VALUE
8623 fcb9 a6 e4                      LDA     ,S              ; RECOVER DELIMITER
8624 fcbb 81 0d                      CMPA    #CR             ; ? END OF CHANGES
8625 fcbd 26 d1                      BNE     REG4            ; NO, KEEP ON TRUCK'N
8626                         * MOVE STACKED DATA TO NEW STACK IN CASE STACK
8627                         * POINTER HAS CHANGED
8628 fcbf 30 8d 73 8e        REGAGN  LEAX    TSTACK,PCR      ; LOAD TEMP AREA
8629 fcc3 c6 15                      LDB     #21             ; LOAD COUNT
8630 fcc5 35 02              REGTF1  PULS    A               ; NEXT BYTE
8631 fcc7 a7 80                      STA     ,X+             ; STORE INTO TEMP
8632 fcc9 5a                         DECB                    ; COUNT DOWN
8633 fcca 26 f9                      BNE     REGTF1          ; LOOP IF MORE
8634 fccc 10 ee 88 ec                LDS     -20,X           ; LOAD NEW STACK POINTER
8635 fcd0 c6 15                      LDB     #21             ; LOAD COUNT AGAIN
8636 fcd2 a6 82              REGTF2 LDA      ,-X             ; NEXT TO STORE
8637 fcd4 34 02                     PSHS     A               ; BACK ONTO NEW STACK
8638 fcd6 5a                        DECB                     ; COUNT DOWN
8639 fcd7 26 f9                     BNE      REGTF2          ; LOOP IF MORE
8640 fcd9 20 bc                     BRA      REGRTN          ; GO RESTART COMMAND
8641                         
8642                         *********************************************
8643                         * BLDNUM - BUILDS BINARY VALUE FROM INPUT HEX
8644                         * THE ACTIVE EXPRESSION HANDLER IS USED.
8645                         * INPUT: S=RETURN ADDRESS
8646                         * OUTPUT: A=DELIMITER WHICH TERMINATED VALUE
8647                         * (IF DELM NOT ZERO)
8648                         * "NUMBER"=WORD BINARY RESULT
8649                         * Z=1 IF INPUT RECEIVED, Z=0 IF NO HEX RECEIVED
8650                         * REGISTERS ARE TRANSPARENT
8651                         **********************************************
8652                         * EXECUTE SINGLE OR EXTENDED ROM EXPRESSION HANDLER
8653                         *
8654                         * THE FLAG "DELIM" IS USED AS FOLLOWS:
8655                         * DELIM=0 NO LEADING BLANKS, NO FORCED TERMINATOR
8656                         * DELIM=CHR ACCEPT LEADING 'CHR'S, FORCED TERMINATOR
8657 fcdb 4f                 BLDNNB  CLRA                    ; NO DYNAMIC DELIMITER
8658 fcdc 8c                         FCB     SKIP2           ; SKIP NEXT INSTRUCTION
8659                         * BUILD WITH LEADING BLANKS
8660 fcdd 86 20              BLDNUM  LDA     #'              ; ALLOW LEADING BLANKS
8661 fcdf 97 8e                      STA     <DELIM          ; STORE AS DELIMITER
8662 fce1 6e 9d 74 07                JMP     [VECTAB+.EXPAN,PCR]   ; TO EXP ANALYZER
8663                         * THIS IS THE DEFAULT SINGLE ROM ANALYZER. WE ACCEPT:
8664                         * 1) HEX INPUT
8665                         * 2) 'M' FOR LAST MEMORY EXAMINE ADDRESS
8666                         * 3) 'P' FOR PROGRAM COUNTER ADDRESS
8667                         * 4) 'W' FOR WINDOW VALUE
8668                         * 5) '@' FOR INDIRECT VALUE
8669                         
8670 fce5 34 14              EXP1    PSHS    X,B             ; SAVE REGISTERS
8671 fce7 8d 5c              EXPDLM  BSR     BLDHXI          ; CLEAR NUMBER, CHECK FIRST CHAR
8672 fce9 27 18                      BEQ     EXP2            ; IF HEX DIGIT CONTINUE BUILDING
8673                         * SKIP BLANKS IF DESIRED
8674 fceb 91 8e                      CMPA    <DELIM          ; ? CORRECT DELIMITER
8675 fced 27 f8                      BEQ     EXPDLM          ; YES, IGNORE IT
8676                         * TEST FOR M OR P
8677 fcef 9e 9e                      LDX     <ADDR           ; DEFAULT FOR 'M'
8678 fcf1 81 4d                      CMPA    #'M             ; ? MEMORY EXAMINE ADDR WANTED
8679 fcf3 27 16                      BEQ     EXPTDL          ; BRANCH IF SO
8680 fcf5 9e 93                      LDX     <PCNTER         ; DEFAULT FOR 'P'
8681 fcf7 81 50                      CMPA    #'P             ; ? LAST PROGRAM COUNTER WANTED
8682 fcf9 27 10                      BEQ     EXPTDL          ; BRANCH IF SO
8683 fcfb 9e a0                      LDX     <WINDOW         ; DEFAULT TO WINDOW
8684 fcfd 81 57                      CMPA    #'W             ; ? WINDOW WANTED
8685 fcff 27 0a                      BEQ     EXPTDL
8686                         
8687 fd01 35 94              EXPRTN  PULS    PC,X,B          ; RETURN AND RESTORE REGISTERS
8688                         * GOT HEX, NOW CONTINUE BUILDING
8689 fd03 8d 44              EXP2    BSR     BLDHEX          ; COMPUTE NEXT DIGIT
8690 fd05 27 fc                      BEQ     EXP2            ; CONTINUE IF MORE
8691 fd07 20 0a                      BRA     EXPCDL          ; SEARCH FOR +/-
8692                         * STORE VALUE AND CHECK IF NEED DELIMITER
8693 fd09 ae 84              EXPTDI  LDX     ,X              ; INDIRECTION DESIRED
8694 fd0b 9f 9b              EXPTDL  STX     <NUMBER         ; STORE RESULT
8695 fd0d 0d 8e                      TST     <DELIM          ; ? TO FORCE A DELIMITER
8696 fd0f 27 f0                      BEQ     EXPRTN          ; RETURN IF NOT WITH VALUE
8697 fd11 8d 62                      BSR     READC           ; OBTAIN NEXT CHARACTER
8698                         * TEST FOR + OR -
8699 fd13 9e 9b              EXPCDL  LDX     <NUMBER         ; LOAD LAST VALUE
8700 fd15 81 2b                      CMPA    #'+             ; ? ADD OPERATOR
8701 fd17 26 0e                      BNE     EXPCHM          ; BRANCH NOT
8702 fd19 8d 23                      BSR     EXPTRM          ; COMPUTE NEXT TERM
8703 fd1b 34 02                      PSHS    A               ; SAVE DELIMITER
8704 fd1d dc 9b                      LDD     <NUMBER         ; LOAD NEW TERM
8705 fd1f 30 8b              EXPADD  LEAX    D,X             ; ADD TO X
8706 fd21 9f 9b                      STX     <NUMBER         ; STORE AS NEW RESULT
8707 fd23 35 02                      PULS    A               ; RESTORE DELIMITER
8708 fd25 20 ec                      BRA     EXPCDL          ; NOW TEST IT
8709 fd27 81 2d              EXPCHM  CMPA    #'-             ; ? SUBTRACT OPERATOR
8710 fd29 27 07                      BEQ     EXPSUB          ; BRANCH IF SO
8711 fd2b 81 40                      CMPA    #'@             ; ? INDIRECTION DESIRED
8712 fd2d 27 da                      BEQ     EXPTDI          ; BRANCH IF SO
8713 fd2f 5f                         CLRB                    ; SET DELIMITER RETURN
8714 fd30 20 cf                      BRA     EXPRTN          ; AND RETURN TO CALLER
8715 fd32 8d 0a              EXPSUB  BSR     EXPTRM          ; OBTAIN NEXT TERM
8716 fd34 34 02                      PSHS    A               ; SAVE DELIMITER
8717 fd36 dc 9b                      LDD     <NUMBER         ; LOAD UP NEXT TERM
8718 fd38 40                         NEGA                    ; NEGATE A
8719 fd39 50                         NEGB                    ; NEGATE B
8720 fd3a 82 00                      SBCA    #0              ; CORRECT FOR A
8721 fd3c 20 e1                      BRA     EXPADD          ; GO ADD TO EXPRESSION
8722                         * COMPUTE NEXT EXPRESSION TERM
8723                         * OUTPUT: X=OLD VALUE
8724                         * 'NUMBER'=NEXT TERM
8725 fd3e 8d 9d              EXPTRM  BSR     BLDNUM          ; OBTAIN NEXT VALUE
8726 fd40 27 32                      BEQ     CNVRTS          ; RETURN IF VALID NUMBER
8727 fd42 16 fc 17           BLDBAD  LBRA    CMDBAD          ; ABORT COMMAND IF INVALID
8728                         
8729                         *********************************************
8730                         * BUILD BINARY VALUE USING INPUT CHARACTERS.
8731                         * INPUT: A=ASCII HEX VALUE OR DELIMITER
8732                         * SP+0=RETURN ADDRESS
8733                         * SP+2=16 BIT RESULT AREA
8734                         * OUTPUT: Z=1 A=BINARY VALUE
8735                         * Z=0 IF INVALID HEX CHARACTER (A UNCHANGED)
8736                         * VOLATILE: D
8737                         ****************************************
8738 fd45 0f 9b              BLDHXI  CLR     <NUMBER         ; CLEAR NUMBER
8739 fd47 0f 9c                      CLR     <NUMBER+1       ; CLEAR NUMBER
8740 fd49 8d 2a              BLDHEX  BSR     READC           ; GET INPUT CHARACTER
8741 fd4b 8d 11              BLDHXC  BSR     CNVHEX          ; CONVERT AND TEST CHARACTER
8742 fd4d 26 25                      BNE     CNVRTS          ; RETURN IF NOT A NUMBER
8743 fd4f c6 10                      LDB     #16             ; PREPARE SHIFT
8744 fd51 3d                         MUL                     ; BY FOUR PLACES
8745 fd52 86 04                      LDA     #4              ; ROTATE BINARY INTO VALUE
8746 fd54 58                 BLDSHF  ASLB                    ; OBTAIN NEXT BIT
8747 fd55 09 9c                      ROL     <NUMBER+1       ; INTO LOW BYTE
8748 fd57 09 9b                      ROL     <NUMBER         ; INTO HI BYTE
8749 fd59 4a                         DECA                    ; COUNT DOWN
8750 fd5a 26 f8                      BNE     BLDSHF          ; BRANCH IF MORE TO DO
8751 fd5c 20 14                      BRA     CNVOK           ; SET GOOD RETURN CODE
8752                         
8753                         ****************************************
8754                         * CONVERT ASCII CHARACTER TO BINARY BYTE
8755                         * INPUT: A=ASCII
8756                         * OUTPUT: Z=1 A=BINARY VALUE
8757                         * Z=0 IF INVALID
8758                         * ALL REGISTERS TRANSPARENT
8759                         * (A UNALTERED IF INVALID HEX)
8760                         **************************************
8761 fd5e 81 30              CNVHEX  CMPA    #'0             ; ? LOWER THAN A ZERO
8762 fd60 25 12                      BLO     CNVRTS          ; BRANCH NOT VALUE
8763 fd62 81 39                      CMPA    #'9             ; ? POSSIBLE A-F
8764 fd64 2f 0a                      BLE     CNVGOT          ; BRANCH NO TO ACCEPT
8765 fd66 81 41                      CMPA    #'A             ; ? LESS THEN TEN
8766 fd68 25 0a                      BLO     CNVRTS          ; RETURN IF MINUS (INVALID)
8767 fd6a 81 46                      CMPA    #'F             ; ? NOT TOO LARGE
8768 fd6c 22 06                      BHI     CNVRTS          ; NO, RETURN TOO LARGE
8769 fd6e 80 07                      SUBA    #7              ; DOWN TO BINARY
8770 fd70 84 0f              CNVGOT  ANDA    #$0F            ; CLEAR HIGH HEX
8771 fd72 1a 04              CNVOK   ORCC    #4              ; FORCE ZERO ON FOR VALID HEX
8772 fd74 39                 CNVRTS  RTS                     ; RETURN TO CALLER
8773                         
8774                         * GET INPUT CHAR, ABORT COMMAND IF CONTROL-X (CANCEL)
8775 fd75 3f                 READC    SWI                    ; GET NEXT CHARACTER
8776 fd76 00                          FCB    INCHNP          ; FUNCTION
8777 fd77 81 18                       CMPA   #CAN            ; ? ABORT COMMAND
8778 fd79 27 c7                       BEQ    BLDBAD          ; BRANCH TO ABORT IF SO
8779 fd7b 39                          RTS                    ; RETURN TO CALLER
8780                         *G
8781                         
8782                         ***************GO - START PROGRAM EXECUTION
8783 fd7c 8d 01              CGO      BSR    GOADDR          ; BUILD ADDRESS IF NEEDED
8784 fd7e 3b                          RTI                    ; START EXECUTING
8785                         
8786                         * FIND OPTIONAL NEW PROGRAM COUNTER. ALSO ARM THE
8787                         * BREAKPOINTS.
8788 fd7f 35 30              GOADDR   PULS   Y,X             ; RECOVER RETURN ADDRESS
8789 fd81 34 10                       PSHS   X               ; STORE RETURN BACK
8790 fd83 26 19                       BNE    GONDFT          ; IF NO CARRIAGE RETURN THEN NEW PC
8791                         
8792                         * DEFAULT PROGRAM COUNTER, SO FALL THROUGH IF
8793                         * IMMEDIATE BREAKPOINT.
8794 fd85 17 01 b6                    LBSR   CBKLDR          ; SEARCH BREAKPOINTS
8795 fd88 ae 6c                       LDX    12,S            ; LOAD PROGRAM COUNTER
8796 fd8a 5a                 ARMBLP  DECB                    ; COUNT DOWN
8797 fd8b 2b 16                      BMI     ARMBK2          ; DONE, NONE TO SINGLE TRACE
8798 fd8d a6 30                      LDA     -NUMBKP*2,Y     ; PRE-FETCH OPCODE
8799 fd8f ac a1                      CMPX    ,Y++            ; ? IS THIS A BREAKPOINT
8800 fd91 26 f7                      BNE     ARMBLP          ; LOOP IF NOT
8801 fd93 81 3f                      CMPA    #$3F            ; ? SWI BREAKPOINTED
8802 fd95 26 02                      BNE     ARMNSW          ; NO, SKIP SETTING OF PASS FLAG
8803 fd97 97 fb                      STA     <SWIBFL         ; SHOW UPCOMING SWI NOT BRKPNT
8804 fd99 0c 8f              ARMNSW  INC     <MISFLG         ; FLAG THRU A BREAKPOINT
8805 fd9b 16 01 06                   LBRA    CDOT            ; DO SINGLE TRACE W/O BREAKPOINTS
8806                         
8807                         * OBTAIN NEW PROGRAM COUNTER
8808 fd9e 17 00 bb           GONDFT  LBSR    CDNUM           ; OBTAIN NEW PROGRAM COUNTER
8809 fda1 ed 6c                      STD     12,S            ; STORE INTO STACK
8810 fda3 17 01 98           ARMBK2  LBSR    CBKLDR          ; OBTAIN TABLE
8811 fda6 00 fa                      NEG     <BKPTCT         ; COMPLEMENT TO SHOW ARMED
8812 fda8 5a                 ARMLOP  DECB                    ; ? DONE
8813 fda9 2b c9                      BMI     CNVRTS          ; RETURN WHEN DONE
8814 fdab a6 b4                      LDA     [,Y]            ; LOAD OPCODE
8815 fdad a7 30                      STA     -NUMBKP*2,Y     ; STORE INTO OPCODE TABLE
8816 fdaf 86 3f                      LDA     #$3F            ; READY "SWI" OPCODE
8817 fdb1 a7 b1                      STA     [,Y++]          ; STORE AND MOVE UP TABLE
8818 fdb3 20 f3                      BRA     ARMLOP          ; AND CONTINUE
8819                         
8820                         *******************CALL - CALL ADDRESS AS SUBROUTINE
8821 fdb5 8d c8              CCALL   BSR     GOADDR          ; FETCH ADDRESS IF NEEDED
8822 fdb7 35 7f                      PULS    U,Y,X,DP,D,CC   ; RESTORE USERS REGISTERS
8823 fdb9 ad f1                      JSR     [,S++]          ; CALL USER SUBROUTINE
8824 fdbb 3f                 CGOBRK  SWI                     ; PERFORM BREAKPOINT
8825 fdbc 0a                         FCB     BRKPT           ; FUNCTION
8826 fdbd 20 fc                      BRA     CGOBRK          ; LOOP UNTIL USER CHANGES PC
8827                         
8828                         ****************MEMORY - DISPLAY/CHANGE MEMORY
8829                         * CMEMN AND CMPADP ARE DIRECT ENTRY POINTS FROM
8830                         * THE COMMAND HANDLER FOR QUICK COMMANDS
8831 fdbf 17 00 9a           CMEM    LBSR    CDNUM           ; OBTAIN ADDRESS
8832 fdc2 dd 9e              CMEMN   STD     <ADDR           ; STORE DEFAULT
8833 fdc4 9e 9e              CMEM2   LDX     <ADDR           ; LOAD POINTER
8834 fdc6 17 fc 0c                   LBSR    ZOUT2H          ; SEND OUT HEX VALUE OF BYTE
8835 fdc9 86 2d                      LDA     #'-             ; LOAD DELIMITER
8836 fdcb 3f                         SWI                     ; SEND OUT
8837 fdcc 01                         FCB     OUTCH           ; FUNCTION
8838 fdcd 17 ff 0b           CMEM4   LBSR    BLDNNB          ; OBTAIN NEW BYTE VALUE
8839 fdd0 27 0a                      BEQ     CMENUM          ; BRANCH IF NUMBER
8840                         * COMA - SKIP BYTE
8841 fdd2 81 2c                      CMPA    #',             ; ? COMMA
8842 fdd4 26 0e                      BNE     CMNOTC          ; BRANCH NOT
8843 fdd6 9f 9e                      STX     <ADDR           ; UPDATE POINTER
8844 fdd8 30 01                      LEAX    1,X             ; TO NEXT BYTE
8845 fdda 20 f1                      BRA     CMEM4           ; AND INPUT IT
8846 fddc d6 9c              CMENUM  LDB     <NUMBER+1       ; LOAD LOW BYTE VALUE
8847 fdde 8d 47                      BSR     MUPDAT          ; GO OVERLAY MEMORY BYTE
8848 fde0 81 2c                      CMPA    #',             ; ? CONTINUE WITH NO DISPLAY
8849 fde2 27 e9                      BEQ     CMEM4           ; BRANCH YES
8850                         * QUOTED STRING
8851 fde4 81 27              CMNOTC  CMPA    #$27            ; ? QUOTED STRING
8852 fde6 26 0c                      BNE     CMNOTQ          ; BRANCH NO
8853 fde8 8d 8b              CMESTR  BSR     READC           ; OBTAIN NEXT CHARACTER
8854 fdea 81 27                      CMPA    #$27            ; ? END OF QUOTED STRING
8855 fdec 27 0c                      BEQ     CMSPCE          ; YES, QUIT STRING MODE
8856 fdee 1f 89                      TFR     A,B             ; TO B FOR SUBROUTINE
8857 fdf0 8d 35                      BSR     MUPDAT          ; GO UPDATE BYTE
8858 fdf2 20 f4                      BRA     CMESTR          ; GET NEXT CHARACTER
8859                         * BLANK - NEXT BYTE
8860 fdf4 81 20              CMNOTQ  CMPA    #$20            ; ? BLANK FOR NEXT BYTE
8861 fdf6 26 06                      BNE     CMNOTB          ; BRANCH NOT
8862 fdf8 9f 9e                      STX     <ADDR           ; UPDATE POINTER
8863 fdfa 3f                 CMSPCE  SWI                     ; GIVE SPACE
8864 fdfb 07                         FCB     SPACEF          ; FUNCTION
8865 fdfc 20 c6                      BRA     CMEM2           ; NOW PROMPT FOR NEXT
8866                         
8867                         * LINE FEED - NEXT BYTE WITH ADDRESS
8868 fdfe 81 0a              CMNOTB  CMPA    #LF             ; ? LINE FEED FOR NEXT BYTE
8869 fe00 26 08                      BNE     CMNOTL          ; BRANCH NO
8870 fe02 86 0d                      LDA     #CR             ; GIVE CARRIAGE RETURN
8871 fe04 3f                         SWI                     ; TO CONSOLE
8872 fe05 01                         FCB     OUTCH           ; HANDLER
8873 fe06 9f 9e                      STX     <ADDR           ; STORE NEXT ADDRESS
8874 fe08 20 0a                      BRA     CMPADP          ; BRANCH TO SHOW
8875                         
8876                         * UP ARROW - PREVIOUS BYTE AND ADDRESS
8877 fe0a 81 5e              CMNOTL  CMPA    #'^             ; ? UP ARROW FOR PREVIOUS BYTE
8878 fe0c 26 0a                      BNE     CMNOTU          ; BRANCH NOT
8879 fe0e 30 1e                      LEAX    -2,X            ; DOWN TO PREVIOUS BYTE
8880 fe10 9f 9e                      STX     <ADDR           ; STORE NEW POINTER
8881 fe12 3f                 CMPADS  SWI                     ; FORCE NEW LINE
8882 fe13 06                         FCB     PCRLF           ; FUNCTION
8883 fe14 8d 07              CMPADP  BSR     PRTADR          ; GO PRINT ITS VALUE
8884 fe16 20 ac                      BRA     CMEM2           ; THEN PROMPT FOR INPUT
8885                         
8886                         * SLASH - NEXT BYTE WITH ADDRESS
8887 fe18 81 2f              CMNOTU  CMPA    #'/             ; ? SLASH FOR CURRENT DISPLAY
8888 fe1a 27 f6                      BEQ     CMPADS          ; YES, SEND ADDRESS
8889 fe1c 39                         RTS                     ; RETURN FROM COMMAND
8890                         
8891                         * PRINT CURRENT ADDRESS
8892 fe1d 9e 9e              PRTADR  LDX     <ADDR           ; LOAD POINTER VALUE
8893 fe1f 34 10                      PSHS    X               ; SAVE X ON STACK
8894 fe21 30 e4                      LEAX    ,S              ; POINT TO IT FOR DISPLAY
8895 fe23 3f                         SWI                     ; DISPLAY POINTER IN HEX
8896 fe24 05                         FCB     OUT4HS          ; FUNCTION
8897 fe25 35 90                      PULS    PC,X            ; RECOVER POINTER AND RETURN
8898                         
8899                         * UPDATE BYTE
8900 fe27 9e 9e              MUPDAT  LDX     <ADDR           ; LOAD NEXT BYTE POINTER
8901 fe29 e7 80                      STB     ,X+             ; STORE AND INCREMENT X
8902 fe2b e1 1f                      CMPB    -1,X            ; ? SUCCESFULL STORE
8903 fe2d 26 03                      BNE     MUPBAD          ; BRANCH FOR '?' IF NOT
8904 fe2f 9f 9e                      STX     <ADDR           ; STORE NEW POINTER VALUE
8905 fe31 39                         RTS                     ; BACK TO CALLER
8906 fe32 34 02              MUPBAD  PSHS    A               ; SAVE A REGISTER
8907 fe34 86 3f                      LDA     #'?             ; SHOW INVALID
8908 fe36 3f                         SWI                     ; SEND OUT
8909 fe37 01                         FCB     OUTCH           ; FUNCTION
8910 fe38 35 82                      PULS    PC,A            ; RETURN TO CALLER
8911                         
8912                         ********************WINDOW - SET WINDOW VALUE
8913 fe3a 8d 20              CWINDO  BSR     CDNUM           ; OBTAIN WINDOW VALUE
8914 fe3c dd a0                      STD     <WINDOW         ; STORE IT IN
8915 fe3e 39                         RTS                     ; END COMMAND
8916                         
8917                         ******************DISPLAY - HIGH SPEED DISPLAY MEMORY
8918 fe3f 8d 1b              CDISP   BSR     CDNUM           ; FETCH ADDRESS
8919 fe41 c4 f0                      ANDB    #$F0            ; FORCE TO 16 BOUNDARY
8920 fe43 1f 02                      TFR     D,Y             ; SAVE IN Y
8921 fe45 30 2f                      LEAX    15,Y            ; DEFAULT LENGTH
8922 fe47 25 04                      BCS     CDISPS          ; BRANCH IF END OF INPUT
8923 fe49 8d 11                      BSR     CDNUM           ; OBTAIN COUNT
8924 fe4b 30 ab                      LEAX    D,Y             ; ASSUME COUNT, COMPUTE END ADDR
8925 fe4d 34 30              CDISPS  PSHS    Y,X             ; SETUP PARAMETERS FOR HSDATA
8926 fe4f 10 a3 62                   CMPD    2,S             ; ? WAS IT COUNT
8927 fe52 23 02                      BLS     CDCNT           ; BRANCH YES
8928 fe54 ed e4                      STD     ,S              ; STORE HIGH ADDRESS
8929 fe56 ad 9d 72 88        CDCNT   JSR     [VECTAB+.HSDTA,PCR] ; CALL PRINT ROUTINE
8930 fe5a 35 e0                      PULS    PC,U,Y          ; CLEAN STACK AND END COMMAND
8931                         
8932                         * OBTAIN NUMBER - ABORT IF NONE
8933                         * ONLY DELIMITERS OF CR, BLANK, OR '/' ARE ACCEPTED
8934                         * OUTPUT: D=VALUE, C=1 IF CARRIAGE RETURN DELMITER,
8935                         * ELSE C=0
8936 fe5c 17 fe 7e           CDNUM   LBSR    BLDNUM          ; OBTAIN NUMBER
8937 fe5f 26 09                      BNE     CDBADN          ; BRANCH IF INVALID
8938 fe61 81 2f                      CMPA    #'/             ; ? VALID DELIMITER
8939 fe63 22 05                      BHI     CDBADN          ; BRANCH IF NOT FOR ERROR
8940 fe65 81 0e                      CMPA    #CR+1           ; LEAVE COMPARE FOR CARRIAGE RET
8941 fe67 dc 9b                      LDD     <NUMBER         ; LOAD NUMBER
8942 fe69 39                         RTS                     ; RETURN WITH COMPARE
8943 fe6a 16 fa ef           CDBADN  LBRA    CMDBAD          ; RETURN TO ERROR MECHANISM
8944                         
8945                         *****************PUNCH - PUNCH MEMORY IN S1-S9 FORMAT
8946 fe6d 8d ed              CPUNCH  BSR     CDNUM           ; OBTAIN START ADDRESS
8947 fe6f 1f 02                      TFR     D,Y             ; SAVE IN Y
8948 fe71 8d e9                      BSR     CDNUM           ; OBTAIN END ADDRESS
8949 fe73 6f e2                      CLR     ,-S             ; SETUP PUNCH FUNCTION CODE
8950 fe75 34 26                      PSHS    Y,D             ; STORE VALUES ON STACK
8951 fe77 ad 9d 72 69        CCALBS  JSR     [VECTAB+.BSON,PCR] ; INITIALIZE HANDLER
8952 fe7b ad 9d 72 67                JSR     [VECTAB+.BSDTA,PCR] ; PERFORM FUNCTION
8953 fe7f 34 01                      PSHS    CC              ; SAVE RETURN CODE
8954 fe81 ad 9d 72 63                JSR     [VECTAB+.BSOFF,PCR] ; TURN OFF HANDLER
8955 fe85 35 01                      PULS    CC              ; OBTAIN CONDITION CODE SAVED
8956 fe87 26 e1                      BNE     CDBADN          ; BRANCH IF ERROR
8957 fe89 35 b2                      PULS    PC,Y,X,A        ; RETURN FROM COMMAND
8958                         
8959                         *****************LOAD - LOAD MEMORY FROM S1-S9 FORMAT
8960 fe8b 8d 01              CLOAD   BSR     CLVOFS          ; CALL SETUP AND PASS CODE
8961 fe8d 01                         FCB     1               ; LOAD FUNCTION CODE FOR PACKET
8962                         
8963 fe8e 33 f1              CLVOFS  LEAU    [,S++]          ; LOAD CODE IN HIGH BYTE OF U
8964 fe90 33 d4                      LEAU    [,U]            ; NOT CHANGING CC AND RESTORE S
8965 fe92 27 03                      BEQ     CLVDFT          ; BRANCH IF CARRIAGE RETURN NEXT
8966 fe94 8d c6                      BSR     CDNUM           ; OBTAIN OFFSET
8967 fe96 8c                         FCB     SKIP2           ; SKIP DEFAULT OFFSET
8968 fe97 4f                 CLVDFT  CLRA                    ; CREATE ZERO OFFSET
8969 fe98 5f                         CLRB                    ; AS DEFAULT
8970 fe99 34 4e                      PSHS    U,DP,D          ; SETUP CODE, NULL WORD, OFFSET
8971 fe9b 20 da                      BRA     CCALBS          ; ENTER CALL TO BS ROUTINES
8972                         
8973                         ******************VERIFY - COMPARE MEMORY WITH FILES
8974 fe9d 8d ef              CVER    BSR     CLVOFS          ; COMPUTE OFFSET IF ANY
8975 fe9f ff                         FCB     -1              ; VERIFY FNCTN CODE FOR PACKET
8976                         
8977                         *******************TRACE - TRACE INSTRUCTIONS
8978                         ******************* . - SINGLE STEP TRACE
8979 fea0 8d ba              CTRACE  BSR     CDNUM           ; OBTAIN TRACE COUNT
8980 fea2 dd 91                      STD     <TRACEC         ; STORE COUNT
8981 fea4 32 62              CDOT    LEAS    2,S             ; RID COMMAND RETURN FROM STACK
8982 fea6 ee f8 0a           CTRCE3  LDU     [10,S]          ; LOAD OPCODE TO EXECUTE
8983 fea9 df 99                      STU     <LASTOP         ; STORE FOR TRACE INTERRUPT
8984 feab de f6                      LDU     <VECTAB+.PTM    ; LOAD PTM ADDRESS
8985 fead cc 07 01                   LDD     #$0701          ; 7,1 CYCLES DOWN+CYCLES UP
8986 feb0 ed 42                      STD     PTMTM1-PTM,U    ; START NMI TIMEOUT
8987 feb2 3b                         RTI                     ; RETURN FOR ONE INSTRUCTION
8988                         
8989                         *************NULLS  -  SET NEW LINE AND CHAR PADDING
8990 feb3 8d a7              CNULLS  BSR     CDNUM           ; OBTAIN NEW LINE PAD
8991 feb5 dd f2                      STD     <VECTAB+.PAD    ; RESET VALUES
8992 feb7 39                         RTS                     ; END COMMAND
8993                         
8994                         ******************STLEVEL - SET STACK TRACE LEVEL
8995 feb8 27 05              CSTLEV  BEQ     STLDFT          ; TAKE DEFAULT
8996 feba 8d a0                      BSR     CDNUM           ; OBTAIN NEW STACK LEVEL
8997 febc dd f8                      STD     <SLEVEL         ; STORE NEW ENTRY
8998 febe 39                         RTS                     ; TO COMMAND HANDLER
8999 febf 30 6e              STLDFT  LEAX    14,S            ; COMPUTE NMI COMPARE
9000 fec1 9f f8                      STX     <SLEVEL         ; AND STORE IT
9001 fec3 39                         RTS                     ; END COMMAND
9002                         
9003                         ******************OFFSET - COMPUTE SHORT AND LONG
9004                         ******************                  BRANCH OFFSETS
9005 fec4 8d 96              COFFS   BSR     CDNUM           ; OBTAIN INSTRUCTION ADDRESS
9006 fec6 1f 01                      TFR     D,X             ; USE AS FROM ADDRESS
9007 fec8 8d 92                      BSR     CDNUM           ; OBTAIN TO ADDRESS
9008                         * D=TO INSTRUCTION, X=FROM INSTRUCTION OFFSET BYTE(S)
9009 feca 30 01                      LEAX    1,X             ; ADJUST FOR *+2 SHORT BRANCH
9010 fecc 34 30                      PSHS    Y,X             ; STORE WORK WORD AND VALUE ON S
9011 fece a3 e4                      SUBD    ,S              ; FIND OFFSET
9012 fed0 ed e4                      STD     ,S              ; SAVE OVER STACK
9013 fed2 30 61                      LEAX    1,S             ; POINT FOR ONE BYTE DISPLAY
9014 fed4 1d                         SEX                     ; SIGN EXTEND LOW BYTE
9015 fed5 a1 e4                      CMPA    ,S              ; ? VALID ONE BYTE OFFSET
9016 fed7 26 02                      BNE     COFNO1          ; BRANCH IF NOT
9017 fed9 3f                         SWI                     ; SHOW ONE BYTE OFFSET
9018 feda 04                         FCB     OUT2HS          ; FUNCTION
9019 fedb ee e4              COFNO1  LDU     ,S              ; RELOAD OFFSET
9020 fedd 33 5f                      LEAU    -1,U            ; CONVERT TO LONG BRANCH OFFSET
9021 fedf ef 84                      STU     ,X              ; STORE BACK WHERE X POINTS NOW
9022 fee1 3f                         SWI                     ; SHOW TWO BYTE OFFSET
9023 fee2 05                         FCB     OUT4HS          ; FUNCTION
9024 fee3 3f                         SWI                     ; FORCE NEW LINE
9025 fee4 06                         FCB     PCRLF           ; FUNCTION
9026 fee5 35 96                      PULS    PC,X,D          ; RESTORE STACK AND END COMMAND
9027                         *H
9028                         
9029                         *************BREAKPOINT - DISPLAY/ENTER/DELETE/CLEAR
9030                         *************             BREAKPOINTS
9031 fee7 27 23              CBKPT   BEQ     CBKDSP          ; BRANCH DISPLAY OF JUST 'B'
9032 fee9 17 fd f1                   LBSR    BLDNUM          ; ATTEMPT VALUE ENTRY
9033 feec 27 2c                      BEQ     CBKADD          ; BRANCH TO ADD IF SO
9034 feee 81 2d                      CMPA    #'-             ; ? CORRECT DELIMITER
9035 fef0 26 3f                      BNE     CBKERR          ; NO, BRANCH FOR ERROR
9036 fef2 17 fd e8                   LBSR    BLDNUM          ; ATTEMPT DELETE VALUE
9037 fef5 27 03                      BEQ     CBKDLE          ; GOT ONE, GO DELETE IT
9038 fef7 0f fa                      CLR     <BKPTCT         ; WAS 'B -', SO ZERO COUNT
9039 fef9 39                 CBKRTS  RTS                     ; END COMMAND
9040                         * DELETE THE ENTRY
9041 fefa 8d 40              CBKDLE  BSR     CBKSET          ; SETUP REGISTERS AND VALUE
9042 fefc 5a                 CBKDLP  DECB                    ; ? ANY ENTRIES IN TABLE
9043 fefd 2b 32                      BMI     CBKERR          ; BRANCH NO, ERROR
9044 feff ac a1                      CMPX    ,Y++            ; ? IS THIS THE ENTRY
9045 ff01 26 f9                      BNE     CBKDLP          ; NO, TRY NEXT
9046                         * FOUND, NOW MOVE OTHERS UP IN ITS PLACE
9047 ff03 ae a1              CBKDLM  LDX     ,Y++            ; LOAD NEXT ONE UP
9048 ff05 af 3c                      STX     -4,Y            ; MOVE DOWN BY ONE
9049 ff07 5a                         DECB                    ; ? DONE
9050 ff08 2a f9                      BPL     CBKDLM          ; NO, CONTINUE MOVE
9051 ff0a 0a fa                      DEC     <BKPTCT         ; DECREMENT BREAKPOINT COUNT
9052 ff0c 8d 2e              CBKDSP  BSR     CBKSET          ; SETUP REGISTERS AND LOAD VALUE
9053 ff0e 27 e9                      BEQ     CBKRTS          ; RETURN IF NONE TO DISPLY
9054 ff10 30 a1              CBKDSL  LEAX    ,Y++            ; POINT TO NEXT ENTRY
9055 ff12 3f                         SWI                     ; DISPLAY IN HEX
9056 ff13 05                         FCB     OUT4HS          ; FUNCTION
9057 ff14 5a                         DECB                    ; COUNT DOWN
9058 ff15 26 f9                      BNE     CBKDSL          ; LOOP IF NGABLE RAM
9059 ff17 3f                         SWI                     ; SKIP TO NEW LINK
9060 ff18 06                         FCB     PCRLF           ; FUNCTIONRTS
9061 ff19 39                         RTS
9062                         
9063                         * ADD NEW ENTRY
9064 ff1a 8d 20              CBKADD  BSR     CBKSET          ; SETUP REGISTERS
9065 ff1c c1 08                      CMPB    #NUMBKP         ; ? ALREADY FULL
9066 ff1e 27 11                      BEQ     CBKERR          ; BRANCH ERROR IF SO
9067 ff20 a6 84                      LDA     ,X              ; LOAD BYTE TO TRAP
9068 ff22 e7 84                      STB     ,X              ; TRY TO CHANGE
9069 ff24 e1 84                      CMPB    ,X              ; ? CHANGEABLE RAM
9070 ff26 26 09                      BNE     CBKERR          ; BRANCH ERROR IF NOT
9071 ff28 a7 84                      STA ,X                  ; RESTORE BYTE
9072 ff2a 5a                 CBKADL  DECB                    ; COUNT DOWN
9073 ff2b 2b 07                      BMI     CBKADT          ; BRANCH IF DONE TO ADD IT
9074 ff2d ac a1                      CMPX    ,Y++            ; ? ENTRY ALREADY HERE
9075 ff2f 26 f9                      BNE     CBKADL          ; LOOP IF NOT
9076 ff31 16 fa 28           CBKERR  LBRA    CMDBAD          ; RETURN TO ERROR PRODUCE
9077 ff34 af a4              CBKADT  STX ,Y                  ; ADD THIS ENTRY
9078 ff36 6f 31                      CLR     -NUMBKP*2+1,Y   ; CLEAR OPTIONAL BYTE
9079 ff38 0c fa                      INC     <BKPTCT         ; ADD ONE TO COUNT
9080 ff3a 20 d0                      BRA     CBKDSP          ; AND NOW DISPLAY ALL OF 'EM
9081                         * SETUP REGISTERS FOR SCAN
9082 ff3c 9e 9b              CBKSET  LDX     <NUMBER         ; LOAD VALUE DESIRED
9083 ff3e 31 8d 71 70        CBKLDR  LEAY    BKPTBL,PCR      ; LOAD START OF TABLE
9084 ff42 d6 fa                      LDB     <BKPTCT         ; LOAD ENTRY COUNT
9085 ff44 39                         RTS                     ; RETURN
9086                         
9087                         *****************ENCODE  -  ENCODE A POSTBYTE
9088 ff45 6f e2              CENCDE  CLR     ,-S             ; DEFAULT TO NOT INDIRECT
9089 ff47 5f                         CLRB                    ; ZERO POSTBYTE VALUE
9090 ff48 30 8c 3f                   LEAX    <CONV1,PCR      ; START TABLE SEARCH
9091 ff4b 3f                         SWI                     ; OBTAIN FIRST CHARACTER
9092 ff4c 00                         FCB     INCHNP          ; FUNCTION
9093 ff4d 81 5b                      CMPA    #'[             ; ? INDIRECT HERE
9094 ff4f 26 06                      BNE     CEN2            ; BRANCH IF NOT
9095 ff51 86 10                      LDA     #$10            ; SET INDIRECT BIT ON
9096 ff53 a7 e4                      STA     ,S              ; SAVE FOR LATER
9097 ff55 3f                 CENGET  SWI                     ; OBTAIN NEXT CHARACTER
9098 ff56 00                         FCB     INCHNP          ; FUNCTION
9099 ff57 81 0d              CEN2    CMPA    #CR             ; ? END OF ENTRY
9100 ff59 27 0c                      BEQ     CEND1           ; BRANCH YES
9101 ff5b 6d 84              CENLP1  TST     ,X              ; ? END OF TABLE
9102 ff5d 2b d2                      BMI     CBKERR          ; BRANCH ERROR IF SO
9103 ff5f a1 81                      CMPA    ,X++            ; ? THIS THE CHARACTER
9104 ff61 26 f8                      BNE     CENLP1          ; BRANCH IF NOT
9105 ff63 eb 1f                      ADDB    -1,X            ; ADD THIS VALUE
9106 ff65 20 ee                      BRA     CENGET          ; GET NEXT INPUT
9107 ff67 30 8c 49           CEND1   LEAX    <CONV2,PCR      ; POINT AT TABLE 2
9108 ff6a 1f 98                      TFR     B,A             ; SAVE COPY IN A
9109 ff6c 84 60                      ANDA    #$60            ; ISOLATE REGISTER MASK
9110 ff6e aa e4                      ORA     ,S              ; ADD IN INDIRECTION BIT
9111 ff70 a7 e4                      STA     ,S              ; SAVE BACK AS POSTBYTE SKELETON
9112 ff72 c4 9f                      ANDB    #$9F            ; CLEAR REGISTER BITS
9113 ff74 6d 84              CENLP2  TST     ,X              ; ? END OF TABLE
9114 ff76 27 b9                      BEQ     CBKERR          ; BRANCH ERROR IF SO
9115 ff78 e1 81                      CMPB    ,X++            ; ? SAME VALUE
9116 ff7a 26 f8                      BNE     CENLP2          ; LOOP IF NOT
9117 ff7c e6 1f                      LDB     -1,X            ; LOAD RESULT VALUE
9118 ff7e ea e4                      ORB     ,S              ; ADD TO BASE SKELETON
9119 ff80 e7 e4                      STB     ,S              ; SAVE POSTBYTE ON STACK
9120 ff82 30 e4                      LEAX    ,S              ; POINT TO IT
9121 ff84 3f                         SWI                     ; SEND OUT AS HEX
9122 ff85 04                         FCB     OUT2HS          ; FUNCTION
9123 ff86 3f                         SWI                     ; TO NEXT LINE
9124 ff87 06                         FCB     PCRLF           ; FUNCTION
9125 ff88 35 84                      PULS    PC,B            ; END OF COMMAND
9126                         
9127                         * TABLE ONE DEFINES VALID INPUT IN SEQUENCE
9128                         CONV1
9129 ff8a 41 04 42 05 44 06          FCB     'A,$04,'B,$05,'D,$06,'H,$01
     48 01
9130 ff92 48 01 48 01 48 00          FCB     'H,$01,'H,$01,'H,$00,',,$00
     2c 00
9131 ff9a 2d 09 2d 01 53 70          FCB     '-,$09,'-,$01,'S,$70,'Y,$30
     59 30
9132 ffa2 55 50 58 10 2b 07          FCB     'U,$50,'X,$10,'+,$07,'+,$01
     2b 01
9133 ffaa 50 80 43 00 52 00          FCB     'P,$80,'C,$00,'R,$00,'],$00
     5d 00
9134 ffb2 ff                         FCB     $FF             ; END OF TABLE
9135                         
9136                         * CONV2 USES ABOVE CONVERSION TO SET POSTBYTE
9137                         * BIT SKELETON.
9138                         CONV2
9139 ffb3 10 84 11 00                FDB     $1084,$1100     ; R,      H,R
9140 ffb7 12 88 13 89                FDB     $1288,$1389     ; HH,R    HHHH,R
9141 ffbb 14 86 15 85                FDB     $1486,$1585     ; A,R     B,R
9142 ffbf 16 8b 17 80                FDB     $168B,$1780     ; D,R     ,R+
9143 ffc3 18 81 19 82                FDB     $1881,$1982     ; ,R++    ,-R
9144 ffc7 1a 83 82 8c                FDB     $1A83,$828C     ; ,--R    HH,PCR
9145 ffcb 83 8d 03 9f                FDB     $838D,$039F     ; HHHH,PCR [HHHH]
9146 ffcf 00                         FCB     0               ; END OF TABLE
9147                         
9148                         ****************************************************
9149                         *            DEFAULT INTERRUPT TRANSFERS           *
9150                         ****************************************************
9151 ffd0 6e 9d 70 f2        RSRVD   JMP     [VECTAB+.RSVD,PCR]      ; RESERVED VECTOR
9152 ffd4 6e 9d 70 f0        SWI3    JMP     [VECTAB+.SWI3,PCR]      ; SWI3 VECTOR
9153 ffd8 6e 9d 70 ee        SWI2    JMP     [VECTAB+.SWI2,PCR]      ; SWI2 VECTOR
9154 ffdc 6e 9d 70 ec        FIRQ    JMP     [VECTAB+.FIRQ,PCR]      ; FIRQ VECTOR
9155 ffe0 6e 9d 70 ea        IRQ     JMP     [VECTAB+.IRQ,PCR]       ; IRQ VECTOR
9156 ffe4 6e 9d 70 e8        SWI     JMP     [VECTAB+.SWI,PCR]       ; SWI VECTOR
9157 ffe8 6e 9d 70 e6        NMI     JMP     [VECTAB+.NMI,PCR]       ; NMI VECTOR
9158                         
9159                         ******************************************************
9160                         *            ASSIST09 HARDWARE VECTOR TABLE
9161                         * THIS TABLE IS USED IF THE ASSIST09 ROM ADDRESSES
9162                         * THE MC6809 HARDWARE VECTORS.
9163                         ******************************************************
9164 fff0                            ORG     ROMBEG+ROMSIZ-16 ; SETUP HARDWARE VECTORS
9165 fff0 ff d0                      FDB     RSRVD           ; RESERVED SLOT
9166 fff2 ff d4                      FDB     SWI3            ; SOFTWARE INTERRUPT 3
9167 fff4 ff d8                      FDB     SWI2            ; SOFTWARE INTERRUPT 2
9168 fff6 ff dc                      FDB     FIRQ            ; FAST INTERRUPT REQUEST
9169 fff8 ff e0                      FDB     IRQ             ; INTERRUPT REQUEST
9170 fffa ff e4                      FDB     SWI             ; SOFTWARE INTERRUPT
9171 fffc ff e8                      FDB     NMI             ; NON-MASKABLE INTERRUPT
9172 fffe f8 37                      FDB     RESET           ; RESTART
