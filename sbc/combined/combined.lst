0001                         ;
0002                         ; 6809 Disassembler
0003                         ;
0004                         ; Copyright (C) 2019 by Jeff Tranter <tranter@pobox.com>
0005                         ;
0006                         ; Licensed under the Apache License, Version 2.0 (the "License");
0007                         ; you may not use this file except in compliance with the License.
0008                         ; You may obtain a copy of the License at
0009                         ;
0010                         ;   http://www.apache.org/licenses/LICENSE-2.0
0011                         ;
0012                         ; Unless required by applicable law or agreed to in writing, software
0013                         ; distributed under the License is distributed on an "AS IS" BASIS,
0014                         ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0015                         ; See the License for the specific language governing permissions and
0016                         ; limitations under the License.
0017                         ;
0018                         ; Revision History
0019                         ; Version Date         Comments
0020                         ; 0.0     29-Jan-2019  First version started, based on 6502 code.
0021                         ; 0.1     03-Feb-2019  All instructions now supported.
0022                         ; 0.2     05-Feb-2019  Integrated into ASSSIST09/BASIC ROM.
0023                         
0024                         ; Character defines
0025                         
0026 000d                    RET     EQU     $0D             ; Carriage return
0027 0020                    SP      EQU     $20             ; Space
0028                         
0029 0018                    PAGELEN EQU     24              ; Number of instructions to show before waiting for keypress
0030                         
0031                         ; Start address for RAM variables
0032 5ff0                            ORG     $5FF0
0033                         
0034                         ; Variables
0035                         
0036 5ff0                    ADRS    RMB     2               ; Current address to disassemble
0037 5ff2                    OPCODE  RMB     1               ; Opcode of instruction
0038 5ff3                    AM      RMB     1               ; Addressing mode of instruction
0039 5ff4                    OPTYPE  RMB     1               ; Instruction type
0040 5ff5                    POSTBYT RMB     1               ; Post byte (for indexed addressing)
0041 5ff6                    LENG    RMB     1               ; Length of instruction
0042 5ff7                    TEMP    RMB     2               ; Temp variable (used by print routines)
0043 5ff9                    TEMP1   RMB     2               ; Temp variable
0044 5ffb                    FIRST   RMB     1               ; Flag used to indicate first time an item printed
0045 5ffc                    PAGE23  RMB     1               ; Flag indicating page2/3 instruction when non-zero
0046                         
0047                         ; Instructions. Matches indexes into entries in table MNEMONICS.
0048                         
0049 0000                    OP_INV   EQU    $00
0050 0001                    OP_ABX   EQU    $01
0051 0002                    OP_ADCA  EQU    $02
0052 0003                    OP_ADCB  EQU    $03
0053 0004                    OP_ADDA  EQU    $04
0054 0005                    OP_ADDB  EQU    $05
0055 0006                    OP_ADDD  EQU    $06
0056 0007                    OP_ANDA  EQU    $07
0057 0008                    OP_ANDB  EQU    $08
0058 0009                    OP_ANDCC EQU    $09
0059 000a                    OP_ASL   EQU    $0A
0060 000b                    OP_ASLA  EQU    $0B
0061 000c                    OP_ASLB  EQU    $0C
0062 000d                    OP_ASR   EQU    $0D
0063 000e                    OP_ASRA  EQU    $0E
0064 000f                    OP_ASRB  EQU    $0F
0065 0010                    OP_BCC   EQU    $10
0066 0011                    OP_BCS   EQU    $11
0067 0012                    OP_BEQ   EQU    $12
0068 0013                    OP_BGE   EQU    $13
0069 0014                    OP_BGT   EQU    $14
0070 0015                    OP_BHI   EQU    $15
0071 0016                    OP_BITA  EQU    $16
0072 0017                    OP_BITB  EQU    $17
0073 0018                    OP_BLE   EQU    $18
0074 0019                    OP_BLS   EQU    $19
0075 001a                    OP_BLT   EQU    $1A
0076 001b                    OP_BMI   EQU    $1B
0077 001c                    OP_BNE   EQU    $1C
0078 001d                    OP_BPL   EQU    $1D
0079 001e                    OP_BRA   EQU    $1E
0080 001f                    OP_BRN   EQU    $1F
0081 0020                    OP_BSR   EQU    $20
0082 0021                    OP_BVC   EQU    $21
0083 0022                    OP_BVS   EQU    $22
0084 0023                    OP_CLR   EQU    $23
0085 0024                    OP_CLRA  EQU    $24
0086 0025                    OP_CLRB  EQU    $25
0087 0026                    OP_CMPA  EQU    $26
0088 0027                    OP_CMPB  EQU    $27
0089 0028                    OP_CMPD  EQU    $28
0090 0029                    OP_CMPS  EQU    $29
0091 002a                    OP_CMPU  EQU    $2A
0092 002b                    OP_CMPX  EQU    $2B
0093 002c                    OP_CMPY  EQU    $2C
0094 002d                    OP_COMA  EQU    $2D
0095 002e                    OP_COMB  EQU    $2E
0096 002f                    OP_COM   EQU    $2F
0097 0030                    OP_CWAI  EQU    $30
0098 0031                    OP_DAA   EQU    $31
0099 0032                    OP_DEC   EQU    $32
0100 0033                    OP_DECA  EQU    $33
0101 0034                    OP_DECB  EQU    $34
0102 0035                    OP_EORA  EQU    $35
0103 0036                    OP_EORB  EQU    $36
0104 0037                    OP_EXG   EQU    $37
0105 0038                    OP_INC   EQU    $38
0106 0039                    OP_INCA  EQU    $39
0107 003a                    OP_INCB  EQU    $3A
0108 003b                    OP_JMP   EQU    $3B
0109 003c                    OP_JSR   EQU    $3C
0110 003d                    OP_LBCC  EQU    $3D
0111 003e                    OP_LBCS  EQU    $3E
0112 003f                    OP_LBEQ  EQU    $3F
0113 0040                    OP_LBGE  EQU    $40
0114 0041                    OP_LBGT  EQU    $41
0115 0042                    OP_LBHI  EQU    $42
0116 0043                    OP_LBLE  EQU    $43
0117 0044                    OP_LBLS  EQU    $44
0118 0045                    OP_LBLT  EQU    $45
0119 0046                    OP_LBMI  EQU    $46
0120 0047                    OP_LBNE  EQU    $47
0121 0048                    OP_LBPL  EQU    $48
0122 0049                    OP_LBRA  EQU    $49
0123 004a                    OP_LBRN  EQU    $4A
0124 004b                    OP_LBSR  EQU    $4B
0125 004c                    OP_LBVC  EQU    $4C
0126 004d                    OP_LBVS  EQU    $4D
0127 004e                    OP_LDA   EQU    $4E
0128 004f                    OP_LDB   EQU    $4F
0129 0050                    OP_LDD   EQU    $50
0130 0051                    OP_LDS   EQU    $51
0131 0052                    OP_LDU   EQU    $52
0132 0053                    OP_LDX   EQU    $53
0133 0054                    OP_LDY   EQU    $54
0134 0055                    OP_LEAS  EQU    $55
0135 0056                    OP_LEAU  EQU    $56
0136 0057                    OP_LEAX  EQU    $57
0137 0058                    OP_LEAY  EQU    $58
0138 0059                    OP_LSR   EQU    $59
0139 005a                    OP_LSRA  EQU    $5A
0140 005b                    OP_LSRB  EQU    $5B
0141 005c                    OP_MUL   EQU    $5C
0142 005d                    OP_NEG   EQU    $5D
0143 005e                    OP_NEGA  EQU    $5E
0144 005f                    OP_NEGB  EQU    $5F
0145 0060                    OP_NOP   EQU    $60
0146 0061                    OP_ORA   EQU    $61
0147 0062                    OP_ORB   EQU    $62
0148 0063                    OP_ORCC  EQU    $63
0149 0064                    OP_PSHS  EQU    $64
0150 0065                    OP_PSHU  EQU    $65
0151 0066                    OP_PULS  EQU    $66
0152 0067                    OP_PULU  EQU    $67
0153 0068                    OP_ROL   EQU    $68
0154 0069                    OP_ROLA  EQU    $69
0155 006a                    OP_ROLB  EQU    $6A
0156 006b                    OP_ROR   EQU    $6B
0157 006c                    OP_RORA  EQU    $6C
0158 006d                    OP_RORB  EQU    $6D
0159 006e                    OP_RTI   EQU    $6E
0160 006f                    OP_RTS   EQU    $6F
0161 0070                    OP_SBCA  EQU    $70
0162 0071                    OP_SBCB  EQU    $71
0163 0072                    OP_SEX   EQU    $72
0164 0073                    OP_STA   EQU    $73
0165 0074                    OP_STB   EQU    $74
0166 0075                    OP_STD   EQU    $75
0167 0076                    OP_STS   EQU    $76
0168 0077                    OP_STU   EQU    $77
0169 0078                    OP_STX   EQU    $78
0170 0079                    OP_STY   EQU    $79
0171 007a                    OP_SUBA  EQU    $7A
0172 007b                    OP_SUBB  EQU    $7B
0173 007c                    OP_SUBD  EQU    $7C
0174 007d                    OP_SWI   EQU    $7D
0175 007e                    OP_SWI2  EQU    $7E
0176 007f                    OP_SWI3  EQU    $7F
0177 0080                    OP_SYNC  EQU    $80
0178 0081                    OP_TFR   EQU    $81
0179 0082                    OP_TST   EQU    $82
0180 0083                    OP_TSTA  EQU    $83
0181 0084                    OP_TSTB  EQU    $84
0182                         
0183                         ; Addressing Modes. OPCODES table lists these for each instruction.
0184                         ; LENGTHS lists the instruction length for each addressing mode.
0185                         ; Need to distinguish relative modes that are 2 and 3 (long) bytes.
0186                         ; Some immediate are 2 and some 3 bytes.
0187                         ; Indexed modes can be longer depending on postbyte.
0188                         ; Page 2 and 3 opcodes are one byte longer (prefixed by 10 or 11)
0189                         
0190 0000                    AM_INVALID      EQU     0       ; $01 (1)
0191 0001                    AM_INHERENT     EQU     1       ; RTS (1)
0192 0002                    AM_IMMEDIATE8   EQU     2       ; LDA #$12 (2)
0193 0003                    AM_IMMEDIATE16  EQU     3       ; LDD #$1234 (3)
0194 0004                    AM_DIRECT       EQU     4       ; LDA $12 (2)
0195 0005                    AM_EXTENDED     EQU     5       ; LDA $1234 (3)
0196 0006                    AM_RELATIVE8    EQU     6       ; BSR $1234 (2)
0197 0007                    AM_RELATIVE16   EQU     7       ; LBSR $1234 (3)
0198 0008                    AM_INDEXED      EQU     8       ; LDA 0,X (2+)
0199                         
0200                         ; *** CODE ***
0201                         
0202 c000                      ORG     $C000
0203                         
0204                         ; Main program. Disassembles a page at a time. Can be run directly or
0205                         ; as an ASSIST09 monitor external command. Gets start address from
0206                         ; command line.
0207                         
0208 c000 17 3e 59           CUNAS:  LBSR    CDNUM           ; Parse command line, return 16-bit number in D
0209 c003 fd 5f f0                   STD     ADRS            ; Store it
0210 c006 86 18              PAGE:   LDA     #PAGELEN        ; Number of instruction to disassemble per page
0211 c008 34 02              DIS:    PSHS    A               ; Save A
0212 c00a 17 00 97                   LBSR    DISASM          ; Do disassembly of one instruction
0213 c00d 35 02                      PULS    A               ; Restore A
0214 c00f 4a                         DECA                    ; Decrement count
0215 c010 26 f6                      BNE     DIS             ; Go back and repeat until a page has been done
0216 c012 30 8d 0b 8c                LEAX    MSG2,PCR        ; Display message to press a key
0217 c016 17 00 84                   LBSR    PrintString
0218 c019 8d 63              BADKEY: BSR     GetChar         ; Wait for keyboard input
0219 c01b 8d 11                      BSR     PrintCR
0220 c01d 81 20                      CMPA    #SP             ; Space key pressed?
0221 c01f 27 e5                      BEQ     PAGE            ; If so, display next page
0222 c021 81 51                      CMPA    #'Q             ; Q key pressed?
0223 c023 27 08                      BEQ     RETN            ; If so, return
0224 c025 81 71                      CMPA    #'q             ; q key pressed?
0225 c027 27 04                      BEQ     RETN            ; If so, return
0226 c029 8d 72                      BSR     PrintString     ; Bad key, prompt and try again
0227 c02b 20 ec                      BRA     BADKEY
0228 c02d 39                 RETN:   RTS                     ; Return to caller
0229                         
0230                         ; *** Utility Functions ***
0231                         ; Some of these call ASSIST09 ROM monitor routines.
0232                         
0233                         ; Print CR/LF to the console.
0234                         ; Registers changed: none
0235                         PrintCR:
0236 c02e 34 02                      PSHS    A               ; Save A
0237 c030 86 0d                      LDA     #RET
0238 c032 8d 47                      BSR     PrintChar
0239 c034 86 0a                      LDA     #LF
0240 c036 8d 43                      BSR     PrintChar
0241 c038 35 02                      PULS    A               ; Restore A
0242 c03a 39                         RTS
0243                         
0244                         ; Print dollar sign to the console.
0245                         ; Registers changed: none
0246                         PrintDollar:
0247 c03b 34 02                      PSHS    A               ; Save A
0248 c03d 86 24                      LDA     #'$
0249 c03f 8d 3a                      BSR     PrintChar
0250 c041 35 02                      PULS    A               ; Restore A
0251 c043 39                         RTS
0252                         
0253                         ; Print comma to the console.
0254                         ; Registers changed: none
0255                         PrintComma:
0256 c044 34 02                      PSHS    A               ; Save A
0257 c046 86 2c                      LDA     #',
0258 c048 8d 31                      BSR     PrintChar
0259 c04a 35 02                      PULS    A               ; Restore A
0260 c04c 39                         RTS
0261                         
0262                         ; Print left square bracket to the console.
0263                         ; Registers changed: none
0264                         PrintLBracket:
0265 c04d 34 02                      PSHS    A               ; Save A
0266 c04f 86 5b                      LDA     #'[
0267 c051 8d 28                      BSR     PrintChar
0268 c053 35 02                      PULS    A               ; Restore A
0269 c055 39                         RTS
0270                         
0271                         ; Print right square bracket to the console.
0272                         ; Registers changed: none
0273                         PrintRBracket:
0274 c056 34 02                      PSHS    A               ; Save A
0275 c058 86 5d                      LDA     #']
0276 c05a 8d 1f                      BSR     PrintChar
0277 c05c 35 02                      PULS    A               ; Restore A
0278 c05e 39                         RTS
0279                         
0280                         ; Print space sign to the console.
0281                         ; Registers changed: none
0282                         PrintSpace:
0283 c05f 3f                         SWI
0284 c060 07                         FCB     SPACEF
0285 c061 39                         RTS
0286                         
0287                         ; Print two spaces to the console.
0288                         ; Registers changed: none
0289                         Print2Spaces:
0290 c062 34 02                      PSHS    A               ; Save A
0291 c064 86 20                      LDA     #SP
0292 c066 8d 13                      BSR     PrintChar
0293 c068 8d 11                      BSR     PrintChar
0294 c06a 35 02                      PULS    A               ; Restore A
0295 c06c 39                         RTS
0296                         
0297                         ; Print several space characters.
0298                         ; A contains number of spaces to print.
0299                         ; Registers changed: none
0300                         PrintSpaces:
0301 c06d 34 02                      PSHS    A               ; Save registers used
0302 c06f 81 00              PS1:    CMPA    #0              ; Is count zero?
0303 c071 27 05                      BEQ     PS2             ; Is so, done
0304 c073 8d ea                      BSR     PrintSpace      ; Print a space
0305 c075 4a                         DECA                    ; Decrement count
0306 c076 20 f7                      BRA     PS1             ; Check again
0307 c078 35 02              PS2:    PULS    A               ; Restore registers used
0308 c07a 39                         RTS
0309                         
0310                         ; Print character to the console
0311                         ; A contains character to print.
0312                         ; Registers changed: none
0313                         PrintChar:
0314 c07b 3f                         SWI                     ; Call ASSIST09 monitor function
0315 c07c 01                         FCB     OUTCH           ; Service code byte
0316 c07d 39                         RTS
0317                         
0318                         ; Get character from the console
0319                         ; A contains character read. Blocks until key pressed. Character is
0320                         ; echoed. Ignores NULL ($00) and RUBOUT ($7F). CR ($OD) is converted
0321                         ; to LF ($0A).
0322                         ; Registers changed: none (flags may change). Returns char in A.
0323                         GetChar:
0324 c07e 3f                         SWI                     ; Call ASSIST09 monitor function
0325 c07f 00                         FCB     INCHNP          ; Service code byte
0326 c080 39                         RTS
0327                         
0328                         ; Print a byte as two hex digits followed by a space.
0329                         ; A contains byte to print.
0330                         ; Registers changed: none
0331                         PrintByte:
0332 c081 34 16                      PSHS    A,B,X           ; Save registers used
0333 c083 b7 5f f7                   STA     TEMP            ; Needs to be in memory so we can point to it
0334 c086 30 8d 9f 6d                LEAX    TEMP,PCR        ; Get pointer to it
0335 c08a 3f                         SWI                     ; Call ASSIST09 monitor function
0336 c08b 04                         FCB     OUT2HS          ; Service code byte
0337 c08c 35 16                      PULS    X,B,A           ; Restore registers used
0338 c08e 39                         RTS
0339                         
0340                         ; Print a word as four hex digits followed by a space.
0341                         ; X contains word to print.
0342                         ; Registers changed: none
0343                         PrintAddress:
0344 c08f 34 16                      PSHS    A,B,X           ; Save registers used
0345 c091 bf 5f f7                   STX     TEMP            ; Needs to be in memory so we can point to it
0346 c094 30 8d 9f 5f                LEAX    TEMP,PCR        ; Get pointer to it
0347 c098 3f                         SWI                     ; Call ASSIST09 monitor function
0348 c099 05                         FCB     OUT4HS          ; Service code byte
0349 c09a 35 16                      PULS    X,B,A           ; Restore registers used
0350 c09c 39                         RTS
0351                         
0352                         ; Print a string.
0353                         ; X points to start of string to display.
0354                         ; String must be terminated in EOT character.
0355                         ; Registers changed: none
0356                         PrintString:
0357 c09d 34 10                      PSHS    X               ; Save registers used
0358 c09f 3f                         SWI                     ; Call ASSIST09 monitor function
0359 c0a0 02                         FCB     PDATA1          ; Service code byte
0360 c0a1 35 10                      PULS    X               ; Restore registers used
0361 c0a3 39                         RTS
0362                         
0363                         ; Disassemble instruction at address ADRS. On return, ADRS points to
0364                         ; next instruction so it can be called again.
0365                         
0366 c0a4 7f 5f fc           DISASM: CLR     PAGE23          ; Clear page2/3 flag
0367 c0a7 ae 8d 9f 45                LDX     ADRS,PCR        ; Get address of instruction
0368 c0ab e6 84                      LDB     ,X              ; Get instruction op code
0369 c0ad c1 10                      CMPB    #$10            ; Is it a page 2 16-bit opcode prefix with 10?
0370 c0af 27 07                      BEQ     handle10        ; If so, do special handling
0371 c0b1 c1 11                      CMPB    #$11            ; Is it a page 3 16-bit opcode prefix with 11?
0372 c0b3 27 53                      BEQ     handle11        ; If so, do special handling
0373 c0b5 16 00 a1                   LBRA    not1011         ; If not, handle as normal case
0374                         
0375                         handle10:                       ; Handle page 2 instruction
0376 c0b8 86 01                      LDA     #1              ; Set page2/3 flag
0377 c0ba b7 5f fc                   STA     PAGE23
0378 c0bd e6 01                      LDB     1,X             ; Get real opcode
0379 c0bf f7 5f f2                   STB     OPCODE          ; Save it.
0380 c0c2 30 8d 0a 43                LEAX    PAGE2,PCR       ; Pointer to start of table
0381 c0c6 4f                         CLRA                    ; Set index into table to zero
0382                         search10:
0383 c0c7 e1 86                      CMPB    A,X             ; Check for match of opcode in table
0384 c0c9 27 1f                      BEQ     found10         ; Branch if found
0385 c0cb 8b 03                      ADDA    #3              ; Advance to next entry in table (entries are 3 bytes long)
0386 c0cd 6d 86                      TST     A,X             ; Check entry
0387 c0cf 27 02                      BEQ     notfound10      ; If zero, then reached end of table
0388 c0d1 20 f4                      BRA     search10        ; If not, keep looking
0389                         
0390                         notfound10:                     ; Instruction not found, so is invalid.
0391 c0d3 86 10                      LDA     #$10            ; Set opcode to 10
0392 c0d5 b7 5f f2                   STA     OPCODE
0393 c0d8 86 00                      LDA     #OP_INV         ; Set as instruction type invalid
0394 c0da b7 5f f4                   STA     OPTYPE
0395 c0dd 86 00                      LDA     #AM_INVALID     ; Set as addressing mode invalid
0396 c0df b7 5f f3                   STA     AM
0397 c0e2 86 01                      LDA     #1              ; Set length to one
0398 c0e4 b7 5f f6                   STA     LENG
0399 c0e7 16 00 91                   LBRA    dism            ; Disassemble as normal
0400                         
0401                         found10:                        ; Found entry in table
0402 c0ea 8b 01                      ADDA    #1              ; Advance to instruction type entry in table
0403 c0ec e6 86                      LDB     A,X             ; Get instruction type
0404 c0ee f7 5f f4                   STB     OPTYPE          ; Save it
0405 c0f1 8b 01                      ADDA    #1              ; Advanced to address mode entry in table
0406 c0f3 e6 86                      LDB     A,X             ; Get address mode
0407 c0f5 f7 5f f3                   STB     AM              ; Save it
0408 c0f8 4f                         CLRA                    ; Clear MSB of D, addressing mode is now in A:B (D)
0409 c0f9 1f 01                      TFR     D,X             ; Put addressing mode in X
0410 c0fb e6 89 c8 dc                LDB     LENGTHS,X       ; Get instruction length from table
0411 c0ff f7 5f f6                   STB     LENG            ; Store it
0412 c102 7c 5f f6                   INC     LENG            ; Add one because it is a two byte op code
0413 c105 16 00 73                   LBRA    dism            ; Continue normal disassembly processing.
0414                         
0415                         handle11:                       ; Same logic as above, but use table for page 3 opcodes.
0416 c108 86 01                      LDA     #1              ; Set page2/3 flag
0417 c10a b7 5f fc                   STA     PAGE23
0418 c10d e6 01                      LDB     1,X             ; Get real opcode
0419 c10f f7 5f f2                   STB     OPCODE          ; Save it.
0420 c112 30 8d 0a 66                LEAX    PAGE3,PCR       ; Pointer to start of table
0421 c116 4f                         CLRA                    ; Set index into table to zero
0422                         search11:
0423 c117 e1 86                      CMPB    A,X             ; Check for match of opcode in table
0424 c119 27 1f                      BEQ     found11         ; Branch if found
0425 c11b 8b 03                      ADDA    #3              ; Advance to next entry in table (entries are 3 bytes long)
0426 c11d 6d 86                      TST     A,X             ; Check entry
0427 c11f 27 02                      BEQ     notfound11      ; If zero, then reached end of table
0428 c121 20 f4                      BRA     search11        ; If not, keep looking
0429                         
0430                         notfound11:                     ; Instruction not found, so is invalid.
0431 c123 86 11                      LDA     #$11            ; Set opcode to 10
0432 c125 b7 5f f2                   STA     OPCODE
0433 c128 86 00                      LDA     #OP_INV         ; Set as instruction type invalid
0434 c12a b7 5f f4                   STA     OPTYPE
0435 c12d 86 00                      LDA     #AM_INVALID     ; Set as addressing mode invalid
0436 c12f b7 5f f3                   STA     AM
0437 c132 86 01                      LDA     #1              ; Set length to one
0438 c134 b7 5f f6                   STA     LENG
0439 c137 16 00 41                   LBRA    dism            ; Disassemble as normal
0440                         
0441                         found11:                        ; Found entry in table
0442 c13a 8b 01                      ADDA    #1              ; Advance to instruction type entry in table
0443 c13c e6 86                      LDB     A,X             ; Get instruction type
0444 c13e f7 5f f4                   STB     OPTYPE          ; Save it
0445 c141 8b 01                      ADDA    #1              ; Advanced to address mode entry in table
0446 c143 e6 86                      LDB     A,X             ; Get address mode
0447 c145 f7 5f f3                   STB     AM              ; Save it
0448 c148 4f                         CLRA                    ; Clear MSB of D, addressing mode is now in A:B (D)
0449 c149 1f 01                      TFR     D,X             ; Put addressing mode in X
0450 c14b e6 89 c8 dc                LDB     LENGTHS,X       ; Get instruction length from table
0451 c14f f7 5f f6                   STB     LENG            ; Store it
0452 c152 7c 5f f6                   INC     LENG            ; Add one because it is a two byte op code
0453 c155 16 00 23                   LBRA    dism            ; Continue normal disassembly processing.
0454 c158 39                         RTS
0455                         
0456                         not1011:
0457 c159 f7 5f f2                   STB     OPCODE          ; Save the op code
0458 c15c 4f                         CLRA                    ; Clear MSB of D
0459 c15d 1f 01                      TFR     D,X             ; Put op code in X
0460 c15f e6 89 c9 09                LDB     OPCODES,X       ; Get opcode type from table
0461 c163 f7 5f f4                   STB     OPTYPE          ; Store it
0462 c166 f6 5f f2                   LDB     OPCODE          ; Get op code again
0463 c169 1f 01                      TFR     D,X             ; Put opcode in X
0464 c16b e6 89 ca 09                LDB     MODES,X         ; Get addressing mode type from table
0465 c16f f7 5f f3                   STB     AM              ; Store it
0466 c172 1f 01                      TFR     D,X             ; Put addressing mode in X
0467 c174 e6 89 c8 dc                LDB     LENGTHS,X       ; Get instruction length from table
0468 c178 f7 5f f6                   STB     LENG            ; Store it
0469                         
0470                         ; If addressing mode is indexed, get and save the indexed addressing
0471                         ; post byte.
0472                         
0473 c17b b6 5f f3           dism:   LDA     AM              ; Get addressing mode
0474 c17e 81 08                      CMPA    #AM_INDEXED     ; Is it indexed mode?
0475 c180 26 22                      BNE     NotIndexed      ; Branch if not
0476 c182 ae 8d 9e 6a                LDX     ADRS,PCR        ; Get address of op code
0477                                                         ; If it is a page2/3 instruction, op code is the next byte after ADRS
0478 c186 7d 5f fc                   TST     PAGE23          ; Page2/3 instruction?
0479 c189 27 04                      BEQ     norm            ; Branch of not
0480 c18b a6 02                      LDA     2,X             ; Post byte is two past ADRS
0481 c18d 20 02                      BRA     getpb
0482 c18f a6 01              norm:   LDA     1,X             ; Get next byte (the post byte)
0483 c191 b7 5f f5           getpb:  STA     POSTBYT         ; Save it
0484                         
0485                         ; Determine number of additional bytes for indexed addressing based on
0486                         ; postbyte. If most significant bit is 0, there are no additional
0487                         ; bytes and we can skip the rest of the check.
0488                         
0489 c194 2a 0e                      BPL     NotIndexed      ; Branch of MSB is zero
0490                         
0491                         ; Else if most significant bit is 1, mask off all but low order 5 bits
0492                         ; and look up length in table.
0493                         
0494 c196 84 1f                      ANDA    #%00011111      ; Mask off bits
0495 c198 30 8d 07 4d                LEAX    POSTBYTES,PCR   ; Lookup table of lengths
0496 c19c a6 86                      LDA     A,X             ; Get table entry
0497 c19e bb 5f f6                   ADDA    LENG            ; Add to instruction length
0498 c1a1 b7 5f f6                   STA     LENG            ; Save new length
0499                         
0500                         NotIndexed:
0501                         
0502                         ; Print address followed by a space
0503 c1a4 ae 8d 9e 48                LDX     ADRS,PCR
0504 c1a8 17 fe e4                   LBSR    PrintAddress
0505                         
0506                         ; Print one more space
0507                         
0508 c1ab 17 fe b1                   LBSR    PrintSpace
0509                         
0510                         ; Print the op code bytes based on the instruction length
0511                         
0512 c1ae f6 5f f6                   LDB     LENG            ; Number of bytes in instruction
0513 c1b1 ae 8d 9e 3b                LDX     ADRS,PCR        ; Pointer to start of instruction
0514 c1b5 a6 80              opby:   LDA     ,X+             ; Get instruction byte and increment pointer
0515 c1b7 17 fe c7                   LBSR    PrintByte       ; Print it, followed by a space
0516 c1ba 5a                         DECB                    ; Decrement byte count
0517 c1bb 26 f8                      BNE     opby            ; Repeat until done
0518                         
0519                         ; Print needed remaining spaces to pad out to correct column
0520                         
0521 c1bd 30 8d 07 24                LEAX    PADDING,PCR     ; Pointer to start of lookup table
0522 c1c1 b6 5f f6                   LDA     LENG            ; Number of bytes in instruction
0523 c1c4 4a                         DECA                    ; Subtract 1 since table starts at 1, not 0
0524 c1c5 a6 86                      LDA     A,X             ; Get number of spaces to print
0525 c1c7 17 fe a3                   LBSR    PrintSpaces
0526                         
0527                         ; If a page2/3 instruction, advance ADRS to the next byte which points
0528                         ; to the real op code.
0529                         
0530 c1ca 7d 5f fc                   TST     PAGE23          ; Flag set
0531 c1cd 27 09                      BEQ     noinc           ; Branch if not
0532 c1cf fc 5f f0                   LDD     ADRS            ; Increment 16-bit address
0533 c1d2 c3 00 01                   ADDD    #1
0534 c1d5 fd 5f f0                   STD     ADRS
0535                         
0536                         ; Get and print mnemonic (4 chars)
0537                         
0538 c1d8 f6 5f f4           noinc   LDB     OPTYPE          ; Get instruction type to index into table
0539 c1db 4f                         CLRA                    ; Clear MSB of D
0540 c1dc 58                         ASLB                    ; 16-bit shift of D: Rotate B, MSB into Carry
0541 c1dd 49                         ROLA                    ; Rotate A, Carry into LSB
0542 c1de 58                         ASLB                    ; Do it twice to multiple by four
0543 c1df 49                         ROLA                    ;
0544 c1e0 30 8d 04 e4                LEAX    MNEMONICS,PCR   ; Pointer to start of table
0545 c1e4 b7 5f f9                   STA     TEMP1           ; Save value of A
0546 c1e7 a6 8b                      LDA     D,X             ; Get first char of mnemonic
0547 c1e9 17 fe 8f                   LBSR    PrintChar       ; Print it
0548 c1ec b6 5f f9                   LDA     TEMP1           ; Restore value of A
0549 c1ef 5c                         INCB                    ; Advance pointer
0550 c1f0 a6 8b                      LDA     D,X             ; Get second char of mnemonic
0551 c1f2 17 fe 86                   LBSR    PrintChar       ; Print it
0552 c1f5 b6 5f f9                   LDA     TEMP1           ; Restore value of A
0553 c1f8 5c                         INCB                    ; Advance pointer
0554 c1f9 a6 8b                      LDA     D,X             ; Get third char of mnemonic
0555 c1fb 17 fe 7d                   LBSR    PrintChar       ; Print it
0556 c1fe b6 5f f9                   LDA     TEMP1           ; Restore value of A
0557 c201 5c                         INCB                    ; Advance pointer
0558 c202 a6 8b                      LDA     D,X             ; Get fourth char of mnemonic
0559 c204 17 fe 74                   LBSR    PrintChar       ; Print it
0560                         
0561                         ; Display any operands based on addressing mode and call appropriate
0562                         ; routine. TODO: Could use a lookup table for this.
0563                         
0564 c207 b6 5f f3                   LDA     AM              ; Get addressing mode
0565 c20a 81 00                      CMPA    #AM_INVALID
0566 c20c 27 2e                      BEQ     DO_INVALID
0567 c20e 81 01                      CMPA    #AM_INHERENT
0568 c210 27 39                      BEQ     DO_INHERENT
0569 c212 81 02                      CMPA    #AM_IMMEDIATE8
0570 c214 27 38                      BEQ     DO_IMMEDIATE8
0571 c216 81 03                      CMPA    #AM_IMMEDIATE16
0572 c218 10 27 01 af                LBEQ    DO_IMMEDIATE16
0573 c21c 81 04                      CMPA    #AM_DIRECT
0574 c21e 10 27 01 c4                LBEQ    DO_DIRECT
0575 c222 81 05                      CMPA    #AM_EXTENDED
0576 c224 10 27 01 d0                LBEQ    DO_EXTENDED
0577 c228 81 06                      CMPA    #AM_RELATIVE8
0578 c22a 10 27 01 e0                LBEQ    DO_RELATIVE8
0579 c22e 81 07                      CMPA    #AM_RELATIVE16
0580 c230 10 27 01 f5                LBEQ    DO_RELATIVE16
0581 c234 81 08                      CMPA    #AM_INDEXED
0582 c236 10 27 02 09                LBEQ    DO_INDEXED
0583 c23a 20 00                      BRA     DO_INVALID      ; Should never be reached
0584                         
0585                         DO_INVALID:                     ; Display "   ; INVALID"
0586 c23c 86 0f                      LDA     #15             ; Want 15 spaces
0587 c23e 17 fe 2c                   LBSR    PrintSpaces
0588 c241 30 8d 09 53                LEAX    MSG1,PCR
0589 c245 17 fe 55                   LBSR    PrintString
0590 c248 16 04 67                   LBRA    done
0591                         
0592                         DO_INHERENT:                    ; Nothing else to do
0593 c24b 16 04 64                   LBRA    done
0594                         
0595                         DO_IMMEDIATE8:
0596 c24e b6 5f f4                   LDA     OPTYPE          ; Get opcode type
0597 c251 81 81                      CMPA    #OP_TFR         ; Is is TFR?
0598 c253 27 33                      BEQ     XFREXG          ; Handle special case of TFR
0599 c255 81 37                      CMPA    #OP_EXG         ; Is is EXG?
0600 c257 27 2f                      BEQ     XFREXG          ; Handle special case of EXG
0601                         
0602 c259 81 66                      CMPA    #OP_PULS        ; Is is PULS?
0603 c25b 10 27 00 ad                LBEQ    PULPSH
0604 c25f 81 67                      CMPA    #OP_PULU        ; Is is PULU?
0605 c261 10 27 00 a7                LBEQ    PULPSH
0606 c265 81 64                      CMPA    #OP_PSHS        ; Is is PSHS?
0607 c267 10 27 00 a1                LBEQ    PULPSH
0608 c26b 81 65                      CMPA    #OP_PSHU        ; Is is PSHU?
0609 c26d 10 27 00 9b                LBEQ    PULPSH
0610                         
0611                                                         ; Display "  #$nn"
0612 c271 17 fd ee                   LBSR    Print2Spaces    ; Two spaces
0613 c274 86 23                      LDA     #'#             ; Number sign
0614 c276 17 fe 02                   LBSR    PrintChar
0615 c279 17 fd bf                   LBSR    PrintDollar     ; Dollar sign
0616 c27c ae 8d 9d 70                LDX     ADRS,PCR        ; Get address of op code
0617 c280 a6 01                      LDA     1,X             ; Get next byte (immediate data)
0618 c282 17 fd fc                   LBSR    PrintByte       ; Print as hex value
0619 c285 16 04 2a                   LBRA    done
0620                         
0621                         XFREXG:                         ; Handle special case of TFR and EXG
0622                                                         ; Display "  r1,r2"
0623 c288 17 fd d7                   LBSR    Print2Spaces    ; Two spaces
0624 c28b ae 8d 9d 61                LDX     ADRS,PCR        ; Get address of op code
0625 c28f a6 01                      LDA     1,X             ; Get next byte (postbyte)
0626 c291 84 f0                      ANDA    #%11110000      ; Mask out source register bits
0627 c293 44                         LSRA                    ; Shift into low order bits
0628 c294 44                         LSRA
0629 c295 44                         LSRA
0630 c296 44                         LSRA
0631 c297 8d 0e                      BSR     TFREXGRegister  ; Print source register name
0632 c299 86 2c                      LDA     #',             ; Print comma
0633 c29b 17 fd dd                   LBSR    PrintChar
0634 c29e a6 01                      LDA     1,X             ; Get postbyte again
0635 c2a0 84 0f                      ANDA    #%00001111      ; Mask out destination register bits
0636 c2a2 8d 03                      BSR     TFREXGRegister  ; Print destination register name
0637 c2a4 16 04 0b                   LBRA    done
0638                         
0639                         ; Look up register name (in A) from Transfer/Exchange postbyte. 4 LSB
0640                         ; bits determine the register name. Value is printed. Invalid value
0641                         ; is shown as '?'.
0642                         ; Value:    0 1 2 3 4 5  8 9 10 11
0643                         ; Register: D X Y U S PC A B CC DP
0644                         
0645                         TFREXGRegister:
0646 c2a7 81 00                      CMPA    #0
0647 c2a9 26 04                      BNE     Try1
0648 c2ab 86 44                      LDA     #'D
0649 c2ad 20 50                      BRA     Print1Reg
0650 c2af 81 01              Try1:   CMPA    #1
0651 c2b1 26 04                      BNE     Try2
0652 c2b3 86 58                      LDA     #'X
0653 c2b5 20 48                      BRA     Print1Reg
0654 c2b7 81 02              Try2:   CMPA    #2
0655 c2b9 26 04                      BNE     Try3
0656 c2bb 86 59                      LDA     #'Y
0657 c2bd 20 40                      BRA     Print1Reg
0658 c2bf 81 03              Try3:   CMPA    #3
0659 c2c1 26 04                      BNE     Try4
0660 c2c3 86 55                      LDA     #'U
0661 c2c5 20 38                      BRA     Print1Reg
0662 c2c7 81 04              Try4:   CMPA    #4
0663 c2c9 26 04                      BNE     Try5
0664 c2cb 86 53                      LDA     #'S
0665 c2cd 20 30                      BRA     Print1Reg
0666 c2cf 81 05              Try5:   CMPA    #5
0667 c2d1 26 06                      BNE     Try8
0668 c2d3 86 50                      LDA     #'P
0669 c2d5 c6 43                      LDB     #'C
0670 c2d7 20 2a                      BRA     Print2Reg
0671 c2d9 81 08              Try8:   CMPA    #8
0672 c2db 26 04                      BNE     Try9
0673 c2dd 86 41                      LDA     #'A
0674 c2df 20 1e                      BRA     Print1Reg
0675 c2e1 81 09              Try9:   CMPA    #9
0676 c2e3 26 04                      BNE     Try10
0677 c2e5 86 42                      LDA     #'B
0678 c2e7 20 16                      BRA     Print1Reg
0679 c2e9 81 0a              Try10:  CMPA    #10
0680 c2eb 26 06                      BNE     Try11
0681 c2ed 86 43                      LDA     #'C
0682 c2ef c6 43                      LDB     #'C
0683 c2f1 20 10                      BRA     Print2Reg
0684 c2f3 81 0b              Try11:  CMPA    #11
0685 c2f5 26 06                      BNE     Inv
0686 c2f7 86 44                      LDA     #'D
0687 c2f9 c6 50                      LDB     #'P
0688 c2fb 20 06                      BRA     Print2Reg
0689 c2fd 86 3f              Inv:    LDA     #'?             ; Invalid
0690                                                         ; Fall through
0691                         Print1Reg:
0692 c2ff 17 fd 79                   LBSR   PrintChar        ; Print character
0693 c302 39                         RTS
0694                         Print2Reg:
0695 c303 17 fd 75                   LBSR   PrintChar        ; Print first character
0696 c306 1f 98                      TFR    B,A
0697 c308 17 fd 70                   LBSR   PrintChar        ; Print second character
0698 c30b 39                         RTS
0699                         
0700                         ; Handle PSHS/PSHU/PULS/PULU instruction operands
0701                         ; Format is a register list, eg; "  A,B,X"
0702                         
0703                         PULPSH:
0704 c30c 17 fd 53                   LBSR    Print2Spaces    ; Two spaces
0705 c30f 86 01                      LDA     #1
0706 c311 b7 5f fb                   STA     FIRST           ; Flag set before any items printed
0707 c314 ae 8d 9c d8                LDX     ADRS,PCR        ; Get address of op code
0708 c318 a6 01                      LDA     1,X             ; Get next byte (postbyte)
0709                         
0710                         ; Postbyte bits indicate registers to push/pull when 1.
0711                         ; 7  6   5 4 3  2 1 0
0712                         ; PC S/U Y X DP B A CC
0713                         
0714                         ; TODO: Could simplify this with shifting and lookup table.
0715                         
0716 c31a 85 80                      BITA    #%10000000      ; Bit 7 set?
0717 c31c 27 0d                      BEQ     bit6
0718 c31e 34 06                      PSHS    A,B
0719 c320 86 50                      LDA     #'P
0720 c322 c6 43                      LDB     #'C
0721 c324 8d dd                      BSR     Print2Reg       ; Print PC
0722 c326 7f 5f fb                   CLR     FIRST
0723 c329 35 06                      PULS    A,B
0724 c32b 85 40              bit6:   BITA    #%01000000      ; Bit 6 set?
0725 c32d 27 21                      BEQ     bit5
0726                         
0727                         ; Need to show S or U depending on instruction
0728                         
0729 c32f 34 02                      PSHS    A               ; Save postbyte
0730 c331 b6 5f f4                   LDA     OPTYPE          ; Get opcode type
0731 c334 81 66                      CMPA    #OP_PULS
0732 c336 27 12                      BEQ     printu
0733 c338 81 64                      CMPA    #OP_PSHS
0734 c33a 27 0e                      BEQ     printu
0735 c33c 17 00 81                   LBSR    PrintCommaIfNotFirst
0736 c33f 86 53                      LDA     #'S             ; Print S
0737 c341 8d bc              pr1     BSR     Print1Reg
0738 c343 7f 5f fb                   CLR     FIRST
0739 c346 35 02                      PULS    A
0740 c348 20 06                      bra     bit5
0741 c34a 8d 74              printu: BSR     PrintCommaIfNotFirst
0742 c34c 86 55                      LDA     #'U             ; Print U
0743 c34e 20 f1                      bra     pr1
0744 c350 85 20              bit5:   BITA    #%00100000      ; Bit 5 set?
0745 c352 27 0d                      BEQ     bit4
0746 c354 34 02                      PSHS    A
0747 c356 8d 68                      BSR     PrintCommaIfNotFirst
0748 c358 86 59                      LDA     #'Y
0749 c35a 8d a3                      BSR     Print1Reg       ; Print Y
0750 c35c 7f 5f fb                   CLR     FIRST
0751 c35f 35 02                      PULS    A
0752 c361 85 10              bit4:   BITA    #%00010000      ; Bit 4 set?
0753 c363 27 0d                      BEQ     bit3
0754 c365 34 02                      PSHS    A
0755 c367 8d 57                      BSR     PrintCommaIfNotFirst
0756 c369 86 58                      LDA     #'X
0757 c36b 8d 92                      BSR     Print1Reg       ; Print X
0758 c36d 7f 5f fb                   CLR     FIRST
0759 c370 35 02                      PULS    A
0760 c372 85 08              bit3:   BITA    #%00001000      ; Bit 3 set?
0761 c374 27 0f                      BEQ     bit2
0762 c376 34 06                      PSHS    A,B
0763 c378 8d 46                      BSR     PrintCommaIfNotFirst
0764 c37a 86 44                      LDA     #'D
0765 c37c c6 50                      LDB     #'P
0766 c37e 8d 83                      BSR     Print2Reg       ; Print DP
0767 c380 7f 5f fb                   CLR     FIRST
0768 c383 35 06                      PULS    A,B
0769 c385 85 04              bit2:   BITA    #%00000100      ; Bit 2 set?
0770 c387 27 0e                      BEQ     bit1
0771 c389 34 02                      PSHS    A
0772 c38b 8d 33                      BSR     PrintCommaIfNotFirst
0773 c38d 86 42                      LDA     #'B
0774 c38f 17 ff 6d                   LBSR    Print1Reg       ; Print B
0775 c392 7f 5f fb                   CLR     FIRST
0776 c395 35 02                      PULS    A
0777 c397 85 02              bit1:   BITA    #%00000010      ; Bit 1 set?
0778 c399 27 0e                      BEQ     bit0
0779 c39b 34 02                      PSHS    A
0780 c39d 8d 21                      BSR     PrintCommaIfNotFirst
0781 c39f 86 41                      LDA     #'A
0782 c3a1 17 ff 5b                   LBSR    Print1Reg       ; Print A
0783 c3a4 7f 5f fb                   CLR     FIRST
0784 c3a7 35 02                      PULS    A
0785 c3a9 85 01              bit0:   BITA    #%00000001      ; Bit 0 set?
0786 c3ab 27 10                      BEQ     done1
0787 c3ad 34 06                      PSHS    A,B
0788 c3af 8d 0f                      BSR     PrintCommaIfNotFirst
0789 c3b1 86 43                      LDA     #'C
0790 c3b3 c6 43                      LDB     #'C
0791 c3b5 17 ff 4b                   LBSR    Print2Reg       ; Print CC
0792 c3b8 7f 5f fb                   CLR     FIRST
0793 c3bb 35 06                      PULS    A,B
0794 c3bd 16 02 f2           done1   LBRA    done
0795                         
0796                         ; Print comma if FIRST flag is not set.
0797                         PrintCommaIfNotFirst:
0798 c3c0 7d 5f fb                   TST     FIRST
0799 c3c3 26 05                      BNE     ret1
0800 c3c5 86 2c                      LDA     #',
0801 c3c7 17 fc b1                   LBSR    PrintChar
0802 c3ca 39                 ret1:   RTS
0803                         
0804                         DO_IMMEDIATE16:                 ; Display "  #$nnnn"
0805 c3cb 17 fc 94                   LBSR    Print2Spaces    ; Two spaces
0806 c3ce 86 23                      LDA     #'#             ; Number sign
0807 c3d0 17 fc a8                   LBSR    PrintChar
0808 c3d3 17 fc 65                   LBSR    PrintDollar     ; Dollar sign
0809 c3d6 ae 8d 9c 16                LDX     ADRS,PCR        ; Get address of op code
0810 c3da a6 01                      LDA     1,X             ; Get first byte (immediate data MSB)
0811 c3dc e6 02                      LDB     2,X             ; Get second byte (immediate data LSB)
0812 c3de 1f 01                      TFR     D,X             ; Put in X to print
0813 c3e0 17 fc ac                   LBSR    PrintAddress    ; Print as hex value
0814 c3e3 16 02 cc                   LBRA    done
0815                         
0816                         DO_DIRECT:                      ; Display "  $nn"
0817 c3e6 17 fc 79                   LBSR    Print2Spaces    ; Two spaces
0818 c3e9 17 fc 4f                   LBSR    PrintDollar     ; Dollar sign
0819 c3ec ae 8d 9c 00                LDX     ADRS,PCR        ; Get address of op code
0820 c3f0 a6 01                      LDA     1,X             ; Get next byte (byte data)
0821 c3f2 17 fc 8c                   LBSR    PrintByte       ; Print as hex value
0822 c3f5 16 02 ba                   LBRA    done
0823                         
0824                         DO_EXTENDED:                    ; Display "  $nnnn"
0825 c3f8 17 fc 67                   LBSR    Print2Spaces    ; Two spaces
0826 c3fb 17 fc 3d                   LBSR    PrintDollar     ; Dollar sign
0827 c3fe ae 8d 9b ee                LDX     ADRS,PCR        ; Get address of op code
0828 c402 a6 01                      LDA     1,X             ; Get first byte (address MSB)
0829 c404 e6 02                      LDB     2,X             ; Get second byte (address LSB)
0830 c406 1f 01                      TFR     D,X             ; Put in X to print
0831 c408 17 fc 84                   LBSR    PrintAddress    ; Print as hex value
0832 c40b 16 02 a4                   LBRA    done
0833                         
0834                         DO_RELATIVE8:                   ; Display "  $nnnn"
0835 c40e 17 fc 51                   LBSR    Print2Spaces    ; Two spaces
0836 c411 17 fc 27                   LBSR    PrintDollar     ; Dollar sign
0837                         
0838                         ; Destination address for relative branch is address of opcode + (sign
0839                         ; extended)offset + 2, e.g.
0840                         ;   $1015 + $(FF)FC + 2 = $1013
0841                         ;   $101B + $(00)27 + 2 = $1044
0842                         
0843 c414 ae 8d 9b d8                LDX     ADRS,PCR        ; Get address of op code
0844 c418 e6 01                      LDB     1,X             ; Get first byte (8-bit branch offset)
0845 c41a 1d                         SEX                     ; Sign extend to 16 bits
0846 c41b f3 5f f0                   ADDD    ADRS            ; Add address of op code
0847 c41e c3 00 02                   ADDD    #2              ; Add 2
0848 c421 1f 01                      TFR     D,X             ; Put in X to print
0849 c423 17 fc 69                   LBSR    PrintAddress    ; Print as hex value
0850 c426 16 02 89                   LBRA    done
0851                         
0852                         DO_RELATIVE16:                  ; Display "  $nnnn"
0853 c429 17 fc 36                   LBSR    Print2Spaces    ; Two spaces
0854 c42c 17 fc 0c                   LBSR    PrintDollar     ; Dollar sign
0855                         
0856                         ; Destination address calculation is similar to above, except offset
0857                         ; is 16 bits and need to add 3.
0858                         
0859 c42f ae 8d 9b bd                LDX     ADRS,PCR        ; Get address of op code
0860 c433 ec 01                      LDD     1,X             ; Get next 2 bytes (16-bit branch offset)
0861 c435 f3 5f f0                   ADDD    ADRS            ; Add address of op code
0862 c438 c3 00 03                   ADDD    #3              ; Add 3
0863 c43b 1f 01                      TFR     D,X             ; Put in X to print
0864 c43d 17 fc 4f                   LBSR    PrintAddress    ; Print as hex value
0865 c440 16 02 6f                   LBRA    done
0866                         
0867                         DO_INDEXED:
0868 c443 17 fc 1c                   LBSR    Print2Spaces    ; Two spaces
0869                         
0870                         ; Addressing modes are determined by the postbyte:
0871                         ;
0872                         ; Postbyte  Format  Additional Bytes
0873                         ; --------  ------  ----------------
0874                         ; 0RRnnnnn  n,R     0
0875                         ; 1RR00100  ,R      0
0876                         ; 1RR01000  n,R     1
0877                         ; 1RR01001  n,R     2
0878                         ; 1RR00110  A,R     0
0879                         ; 1RR00101  B,R     0
0880                         ; 1RR01011  D,R     0
0881                         ; 1RR00000  ,R+     0
0882                         ; 1RR00001  ,R++    0
0883                         ; 1RR00010  ,-R     0
0884                         ; 1RR00011  ,--R    0
0885                         ; 1xx01100  n,PCR   1
0886                         ; 1xx01101  n,PCR   2
0887                         ; 1RR10100  [,R]    0
0888                         ; 1RR11000  [n,R]   1
0889                         ; 1RR11001  [n,R]   2
0890                         ; 1RR10110  [A,R]   0
0891                         ; 1RR10101  [B,R]   0
0892                         ; 1RR11011  [D,R]   0
0893                         ; 1RR10001  [,R++]  0
0894                         ; 1RR10011  [,--R]  0
0895                         ; 1xx11100  [n,PCR] 1
0896                         ; 1xx11101  [n,PCR] 2
0897                         ; 10011111  [n]     2
0898                         ;
0899                         ; Where RR: 00=X 01=Y 10=U 11=S
0900                         
0901 c446 b6 5f f5                   LDA     POSTBYT         ; Get postbyte
0902 c449 2b 14                      BMI     ind2            ; Branch if MSB is 1
0903                         
0904                                                         ; Format is 0RRnnnnn  n,R
0905 c44b 84 1f                      ANDA    #%00011111      ; Get 5-bit offset
0906 c44d 17 fb eb                   LBSR    PrintDollar     ; Dollar sign
0907 c450 17 fc 2e                   LBSR    PrintByte       ; Print offset
0908 c453 17 fb ee                   LBSR    PrintComma      ; Print comma
0909 c456 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0910 c459 17 02 35                   LBSR    PrintRegister   ; Print register name
0911 c45c 16 02 53                   LBRA    done
0912                         ind2:
0913 c45f 84 9f                      ANDA    #%10011111      ; Mask out register bits
0914 c461 81 84                      CMPA    #%10000100      ; Check against pattern
0915 c463 26 0c                      BNE     ind3
0916                                                         ; Format is 1RR00100  ,R
0917 c465 17 fb dc                   LBSR    PrintComma      ; Print comma
0918 c468 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0919 c46b 17 02 23                   LBSR    PrintRegister   ; Print register name
0920 c46e 16 02 41                   LBRA    done
0921                         ind3:
0922 c471 81 88                      CMPA    #%10001000      ; Check against pattern
0923 c473 26 18                      BNE     ind4
0924                                                         ; Format is 1RR01000  n,R
0925 c475 ae 8d 9b 77                LDX     ADRS,PCR
0926 c479 a6 02                      LDA     2,X             ; Get 8-bit offset
0927 c47b 17 fb bd                   LBSR    PrintDollar     ; Dollar sign
0928 c47e 17 fc 00                   LBSR    PrintByte       ; Display it
0929 c481 17 fb c0                   LBSR    PrintComma      ; Print comma
0930 c484 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0931 c487 17 02 07                   LBSR    PrintRegister   ; Print register name
0932 c48a 16 02 25                   LBRA    done
0933                         ind4:
0934 c48d 81 89                      CMPA    #%10001001      ; Check against pattern
0935 c48f 26 1a                      BNE     ind5
0936                                                         ; Format is 1RR01001  n,R
0937 c491 ae 8d 9b 5b                LDX     ADRS,PCR
0938 c495 ec 02                      LDD     2,X             ; Get 16-bit offset
0939 c497 1f 01                      TFR     D,X
0940 c499 17 fb 9f                   LBSR    PrintDollar     ; Dollar sign
0941 c49c 17 fb f0                   LBSR    PrintAddress    ; Display it
0942 c49f 17 fb a2                   LBSR    PrintComma      ; Print comma
0943 c4a2 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0944 c4a5 17 01 e9                   LBSR    PrintRegister   ; Print register name
0945 c4a8 16 02 07                   LBRA    done
0946                         ind5:
0947 c4ab 81 86                      CMPA    #%10000110      ; Check against pattern
0948 c4ad 26 11                      BNE     ind6
0949                                                         ; Format is 1RR00110  A,R
0950 c4af 86 41                      LDA     #'A
0951 c4b1 17 fb c7                   LBSR    PrintChar       ; Print A
0952 c4b4 17 fb 8d           commar: LBSR    PrintComma      ; Print comma
0953 c4b7 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0954 c4ba 17 01 d4                   LBSR    PrintRegister   ; Print register name
0955 c4bd 16 01 f2                   LBRA    done
0956                         ind6:
0957 c4c0 81 85                      CMPA    #%10000101      ; Check against pattern
0958 c4c2 26 07                      BNE     ind7
0959                                                         ; Format is 1RR00101  B,R
0960 c4c4 86 42                      LDA     #'B
0961 c4c6 17 fb b2                   LBSR    PrintChar
0962 c4c9 20 e9                      BRA     commar
0963                         ind7:
0964 c4cb 81 8b                      CMPA    #%10001011      ; Check against pattern
0965 c4cd 26 07                      BNE     ind8
0966                                                         ; Format is 1RR01011  D,R
0967 c4cf 86 44                      LDA     #'D
0968 c4d1 17 fb a7                   LBSR    PrintChar
0969 c4d4 20 de                      BRA     commar
0970                         ind8:
0971 c4d6 81 80                      CMPA    #%10000000      ; Check against pattern
0972 c4d8 26 11                      BNE     ind9
0973                                                         ; Format is 1RR00000  ,R+
0974 c4da 17 fb 67                   LBSR    PrintComma      ; Print comma
0975 c4dd b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0976 c4e0 17 01 ae                   LBSR    PrintRegister   ; Print register name
0977 c4e3 86 2b                      LDA     #'+             ; Print plus
0978 c4e5 17 fb 93                   LBSR    PrintChar
0979 c4e8 16 01 c7                   LBRA    done
0980                         ind9:
0981 c4eb 81 81                      CMPA    #%10000001      ; Check against pattern
0982 c4ed 26 14                      BNE     ind10
0983                                                         ; Format is 1RR00001  ,R++
0984 c4ef 17 fb 52                   LBSR    PrintComma      ; Print comma
0985 c4f2 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0986 c4f5 17 01 99                   LBSR    PrintRegister   ; Print register name
0987 c4f8 86 2b                      LDA     #'+             ; Print plus twice
0988 c4fa 17 fb 7e                   LBSR    PrintChar
0989 c4fd 17 fb 7b                   LBSR    PrintChar
0990 c500 16 01 af                   LBRA    done
0991                         ind10:
0992 c503 81 82                      CMPA    #%10000010      ; Check against pattern
0993 c505 26 11                      BNE     ind11
0994                                                         ; Format is 1RR00010  ,-R
0995 c507 17 fb 3a                   LBSR    PrintComma      ; Print comma
0996 c50a 86 2d                      LDA     #'-             ; Print minus
0997 c50c 17 fb 6c                   LBSR    PrintChar
0998 c50f b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0999 c512 17 01 7c                   LBSR    PrintRegister   ; Print register name
1000 c515 16 01 9a                   LBRA    done
1001                         ind11:
1002 c518 81 83                      CMPA    #%10000011      ; Check against pattern
1003 c51a 26 14                      BNE     ind12
1004                                                         ; Format is 1RR00011  ,--R
1005 c51c 17 fb 25                   LBSR    PrintComma      ; Print comma
1006 c51f 86 2d                      LDA     #'-             ; Print minus twice
1007 c521 17 fb 57                   LBSR    PrintChar
1008 c524 17 fb 54                   LBSR    PrintChar
1009 c527 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1010 c52a 17 01 64                   LBSR    PrintRegister   ; Print register name
1011 c52d 16 01 82                   LBRA    done
1012                         ind12:
1013 c530 81 8c                      CMPA    #%10001100      ; Check against pattern
1014 c532 26 15                      BNE     ind13
1015                                                         ; Format is 1xx01100  n,PCR
1016 c534 ae 8d 9a b8                LDX     ADRS,PCR
1017 c538 a6 02                      LDA     2,X             ; Get 8-bit offset
1018 c53a 17 fa fe                   LBSR    PrintDollar     ; Dollar sign
1019 c53d 17 fb 41                   LBSR    PrintByte       ; Display it
1020 c540 17 fb 01                   LBSR    PrintComma      ; Print comma
1021 c543 17 01 64                   LBSR    PrintPCR        ; Print PCR
1022 c546 16 01 69                   LBRA    done
1023                         ind13:
1024 c549 81 8d                      CMPA    #%10001101      ; Check against pattern
1025 c54b 26 17                      BNE     ind14
1026                                                         ; Format is 1xx01101  n,PCR
1027 c54d ae 8d 9a 9f                LDX     ADRS,PCR
1028 c551 ec 02                      LDD     2,X             ; Get 16-bit offset
1029 c553 1f 01                      TFR     D,X
1030 c555 17 fa e3                   LBSR    PrintDollar     ; Dollar sign
1031 c558 17 fb 34                   LBSR    PrintAddress    ; Display it
1032 c55b 17 fa e6                   LBSR    PrintComma      ; Print comma
1033 c55e 17 01 49                   LBSR    PrintPCR        ; Print PCR
1034 c561 16 01 4e                   LBRA    done
1035                         ind14:
1036 c564 81 94                      CMPA    #%10010100      ; Check against pattern
1037 c566 26 12                      BNE     ind15
1038                                                         ; Format is 1RR10100  [,R]
1039 c568 17 fa e2                   LBSR    PrintLBracket   ; Print left bracket
1040 c56b 17 fa d6                   LBSR    PrintComma      ; Print comma
1041 c56e b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1042 c571 17 01 1d                   LBSR    PrintRegister   ; Print register name
1043 c574 17 fa df                   LBSR    PrintRBracket   ; Print right bracket
1044 c577 16 01 38                   LBRA    done
1045                         ind15:
1046 c57a 81 98                      CMPA    #%10011000      ; Check against pattern
1047 c57c 26 1e                      BNE     ind16
1048                                                         ; Format is 1RR11000  [n,R]
1049 c57e 17 fa cc                   LBSR    PrintLBracket   ; Print left bracket
1050 c581 ae 8d 9a 6b                LDX     ADRS,PCR
1051 c585 a6 02                      LDA     2,X             ; Get 8-bit offset
1052 c587 17 fa b1                   LBSR    PrintDollar     ; Dollar sign
1053 c58a 17 fa f4                   LBSR    PrintByte       ; Display it
1054 c58d 17 fa b4                   LBSR    PrintComma      ; Print comma
1055 c590 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1056 c593 17 00 fb                   LBSR    PrintRegister   ; Print register name
1057 c596 17 fa bd                   LBSR    PrintRBracket   ; Print right bracket
1058 c599 16 01 16                   LBRA    done
1059                         ind16:
1060 c59c 81 99                      CMPA    #%10011001      ; Check against pattern
1061 c59e 26 20                      BNE     ind17
1062                                                         ; Format is 1RR11001  [n,R]
1063 c5a0 17 fa aa                   LBSR    PrintLBracket   ; Print left bracket
1064 c5a3 ae 8d 9a 49                LDX     ADRS,PCR
1065 c5a7 ec 02                      LDD     2,X             ; Get 16-bit offset
1066 c5a9 1f 01                      TFR     D,X
1067 c5ab 17 fa 8d                   LBSR    PrintDollar     ; Dollar sign
1068 c5ae 17 fa de                   LBSR    PrintAddress    ; Display it
1069 c5b1 17 fa 90                   LBSR    PrintComma      ; Print comma
1070 c5b4 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1071 c5b7 17 00 d7                   LBSR    PrintRegister   ; Print register name
1072 c5ba 17 fa 99                   LBSR    PrintRBracket   ; Print right bracket
1073 c5bd 16 00 f2                   LBRA    done
1074                         ind17:
1075 c5c0 81 96                      CMPA    #%10010110      ; Check against pattern
1076 c5c2 26 17                      BNE     ind18
1077                                                         ; Format is 1RR10110  [A,R]
1078 c5c4 17 fa 86                   LBSR    PrintLBracket   ; Print left bracket
1079 c5c7 86 41                      LDA     #'A
1080 c5c9 17 fa af                   LBSR    PrintChar       ; Print A
1081 c5cc 17 fa 75           comrb:  LBSR    PrintComma      ; Print comma
1082 c5cf b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1083 c5d2 17 00 bc                   LBSR    PrintRegister   ; Print register name
1084 c5d5 17 fa 7e                   LBSR    PrintRBracket   ; Print right bracket
1085 c5d8 16 00 d7                   LBRA    done
1086                         ind18:
1087 c5db 81 95                      CMPA    #%10010101      ; Check against pattern
1088 c5dd 26 0a                      BNE     ind19
1089                                                         ; Format is 1RR10101  [B,R]
1090 c5df 17 fa 6b                   LBSR    PrintLBracket   ; Print left bracket
1091 c5e2 86 42                      LDA     #'B
1092 c5e4 17 fa 94                   LBSR    PrintChar
1093 c5e7 20 e3                      BRA     comrb
1094                         ind19:
1095 c5e9 81 9b                      CMPA    #%10011011      ; Check against pattern
1096 c5eb 26 0a                      BNE     ind20
1097                                                         ; Format is 1RR11011  [D,R]
1098 c5ed 17 fa 5d                   LBSR    PrintLBracket   ; Print left bracket
1099 c5f0 86 44                      LDA     #'D
1100 c5f2 17 fa 86                   LBSR    PrintChar
1101 c5f5 20 d5                      BRA     comrb
1102                         ind20:
1103 c5f7 81 91                      CMPA    #%10010001      ; Check against pattern
1104 c5f9 26 1a                      BNE     ind21
1105                                                         ; Format is 1RR10001  [,R++]
1106 c5fb 17 fa 4f                   LBSR    PrintLBracket   ; Print left bracket
1107 c5fe 17 fa 43                   LBSR    PrintComma      ; Print comma
1108 c601 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1109 c604 17 00 8a                   LBSR    PrintRegister   ; Print register name
1110 c607 86 2b                      LDA     #'+             ; Print plus twice
1111 c609 17 fa 6f                   LBSR    PrintChar
1112 c60c 17 fa 6c                   LBSR    PrintChar
1113 c60f 17 fa 44                   LBSR    PrintRBracket   ; Print right bracket
1114 c612 16 00 9d                   LBRA    done
1115                         ind21:
1116 c615 81 93                      CMPA    #%10010011      ; Check against pattern
1117 c617 26 1a                      BNE     ind22
1118                                                         ; Format is 1RR10011  [,--R]
1119 c619 17 fa 31                   LBSR    PrintLBracket   ; Print left bracket
1120 c61c 17 fa 25                   LBSR    PrintComma      ; Print comma
1121 c61f 86 2d                      LDA     #'-             ; Print minus twice
1122 c621 17 fa 57                   LBSR    PrintChar
1123 c624 17 fa 54                   LBSR    PrintChar
1124 c627 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1125 c62a 17 00 64                   LBSR    PrintRegister   ; Print register name
1126 c62d 17 fa 26                   LBSR    PrintRBracket   ; Print right bracket
1127 c630 16 00 7f                   LBRA    done
1128                         ind22:
1129 c633 81 9c                      CMPA    #%10011100      ; Check against pattern
1130 c635 26 1b                      BNE     ind23
1131                                                         ; Format is 1xx11100  [n,PCR]
1132 c637 17 fa 13                   LBSR    PrintLBracket   ; Print left bracket
1133 c63a ae 8d 99 b2                LDX     ADRS,PCR
1134 c63e a6 02                      LDA     2,X             ; Get 8-bit offset
1135 c640 17 f9 f8                   LBSR    PrintDollar     ; Dollar sign
1136 c643 17 fa 3b                   LBSR    PrintByte       ; Display it
1137 c646 17 f9 fb                   LBSR    PrintComma      ; Print comma
1138 c649 17 00 5e                   LBSR    PrintPCR        ; Print PCR
1139 c64c 17 fa 07                   LBSR    PrintRBracket   ; Print right bracket
1140 c64f 16 00 60                   LBRA    done
1141                         ind23:
1142 c652 81 9d                      CMPA    #%10011101      ; Check against pattern
1143 c654 26 1d                      BNE     ind24
1144                                                         ; Format is 1xx11101  [n,PCR]
1145 c656 17 f9 f4                   LBSR    PrintLBracket   ; Print left bracket
1146 c659 ae 8d 99 93                LDX     ADRS,PCR
1147 c65d ec 02                      LDD     2,X             ; Get 16-bit offset
1148 c65f 1f 01                      TFR     D,X
1149 c661 17 f9 d7                   LBSR    PrintDollar     ; Dollar sign
1150 c664 17 fa 28                   LBSR    PrintAddress    ; Display it
1151 c667 17 f9 da                   LBSR    PrintComma      ; Print comma
1152 c66a 17 00 3d                   LBSR    PrintPCR        ; Print PCR
1153 c66d 17 f9 e6                   LBSR    PrintRBracket   ; Print right bracket
1154 c670 16 00 3f                   LBRA    done
1155                         ind24:
1156 c673 81 9f                      CMPA    #%10011111      ; Check against pattern
1157 c675 26 17                      BNE     ind25
1158                                                         ; Format is 1xx11111  [n]
1159 c677 17 f9 d3                   LBSR    PrintLBracket   ; Print left bracket
1160 c67a ae 8d 99 72                LDX     ADRS,PCR
1161 c67e ec 02                      LDD     2,X             ; Get 16-bit offset
1162 c680 1f 01                      TFR     D,X
1163 c682 17 f9 b6                   LBSR    PrintDollar     ; Dollar sign
1164 c685 17 fa 07                   LBSR    PrintAddress    ; Display it
1165 c688 17 f9 cb                   LBSR    PrintRBracket   ; Print right bracket
1166 c68b 16 00 24                   LBRA    done
1167                         ind25:                          ; Should never be reached
1168 c68e 16 00 21                   LBRA    done
1169                         
1170                         ; Print register name encoded in bits 5 and 6 of A for indexed
1171                         ; addressing: xRRxxxxx where RR: 00=X 01=Y 10=U 11=S
1172                         ; Registers changed: X
1173                         PrintRegister:
1174 c691 34 02                      PSHS    A               ; Save A
1175 c693 84 60                      ANDA    #%01100000      ; Mask out other bits
1176 c695 44                         LSRA                    ; Shift into 2 LSB
1177 c696 44                         LSRA
1178 c697 44                         LSRA
1179 c698 44                         LSRA
1180 c699 44                         LSRA
1181 c69a 30 8d 00 08                LEAX    REGTABLE,PCR    ; Lookup table of register name characters
1182 c69e a6 86                      LDA     A,X             ; Get character
1183 c6a0 17 f9 d8                   LBSR    PrintChar       ; Print it
1184 c6a3 35 02                      PULS    A               ; Restore A
1185 c6a5 39                         RTS                     ; Return
1186                         REGTABLE:
1187 c6a6 58 59 55 53                FCC     "XYUS"
1188                         
1189                         
1190                         ; Print the string "PCR" on the console.
1191                         ; Registers changed: X
1192                         PrintPCR:
1193 c6aa 30 8d 05 1c                LEAX    MSG3,PCR        ; "PCR" string
1194 c6ae 17 f9 ec                   LBSR    PrintString
1195 c6b1 39                         RTS
1196                         
1197                         ; Print final CR
1198                         
1199 c6b2 17 f9 79           done:   LBSR    PrintCR
1200                         
1201                         ; Update address to next instruction
1202                         ; If it was a page 2/3 instruction, we need to subtract one from the
1203                         ; length to account for ADRS being moved to the second byte of the
1204                         ; instruction.
1205                         
1206 c6b5 7d 5f fc                   TST     PAGE23          ; Flag set
1207 c6b8 27 03                      BEQ     not23           ; Branch if not
1208 c6ba 7a 5f f6                   DEC     LENG            ; Decrement length
1209 c6bd 4f                 not23:  CLRA                    ; Clear MSB of D
1210 c6be f6 5f f6                   LDB     LENG            ; Get length byte in LSB of D
1211 c6c1 f3 5f f0                   ADDD    ADRS            ; Add to address
1212 c6c4 fd 5f f0                   STD     ADRS            ; Write new address
1213                         
1214                         ; Return
1215 c6c7 39                         RTS
1216                         
1217                         ; *** DATA
1218                         
1219                         ; Table of instruction strings. 4 bytes per table entry
1220                         MNEMONICS:
1221 c6c8 3f 3f 3f 20                FCC     "??? "          ; $00
1222 c6cc 41 42 58 20                FCC     "ABX "          ; $01
1223 c6d0 41 44 43 41                FCC     "ADCA"          ; $02
1224 c6d4 41 44 43 42                FCC     "ADCB"          ; $03
1225 c6d8 41 44 44 41                FCC     "ADDA"          ; $04
1226 c6dc 41 44 44 42                FCC     "ADDB"          ; $05
1227 c6e0 41 44 44 44                FCC     "ADDD"          ; $06
1228 c6e4 41 4e 44 41                FCC     "ANDA"          ; $07
1229 c6e8 41 4e 44 42                FCC     "ANDB"          ; $08
1230 c6ec 41 4e 44 43                FCC     "ANDC"          ; $09 Should really  be "ANDCC"
1231 c6f0 41 53 4c 20                FCC     "ASL "          ; $0A
1232 c6f4 41 53 4c 41                FCC     "ASLA"          ; $0B
1233 c6f8 41 53 4c 42                FCC     "ASLB"          ; $0C
1234 c6fc 41 53 52 20                FCC     "ASR "          ; $0D
1235 c700 41 53 52 41                FCC     "ASRA"          ; $0E
1236 c704 41 53 52 42                FCC     "ASRB"          ; $0F
1237 c708 42 43 43 20                FCC     "BCC "          ; $10
1238 c70c 42 43 53 20                FCC     "BCS "          ; $11
1239 c710 42 45 51 20                FCC     "BEQ "          ; $12
1240 c714 42 47 45 20                FCC     "BGE "          ; $13
1241 c718 42 47 54 20                FCC     "BGT "          ; $14
1242 c71c 42 48 49 20                FCC     "BHI "          ; $15
1243 c720 42 49 54 41                FCC     "BITA"          ; $16
1244 c724 42 49 54 42                FCC     "BITB"          ; $17
1245 c728 42 4c 45 20                FCC     "BLE "          ; $18
1246 c72c 42 4c 53 20                FCC     "BLS "          ; $19
1247 c730 42 4c 54 20                FCC     "BLT "          ; $1A
1248 c734 42 4d 49 20                FCC     "BMI "          ; $1B
1249 c738 42 4e 45 20                FCC     "BNE "          ; $1C
1250 c73c 42 50 4c 20                FCC     "BPL "          ; $1D
1251 c740 42 52 41 20                FCC     "BRA "          ; $1E
1252 c744 42 52 4e 20                FCC     "BRN "          ; $1F
1253 c748 42 53 52 20                FCC     "BSR "          ; $20
1254 c74c 42 56 43 20                FCC     "BVC "          ; $21
1255 c750 42 56 53 20                FCC     "BVS "          ; $22
1256 c754 43 4c 52 20                FCC     "CLR "          ; $23
1257 c758 43 4c 52 41                FCC     "CLRA"          ; $24
1258 c75c 43 4c 52 42                FCC     "CLRB"          ; $25
1259 c760 43 4d 50 41                FCC     "CMPA"          ; $26
1260 c764 43 4d 50 42                FCC     "CMPB"          ; $27
1261 c768 43 4d 50 44                FCC     "CMPD"          ; $28
1262 c76c 43 4d 50 53                FCC     "CMPS"          ; $29
1263 c770 43 4d 50 55                FCC     "CMPU"          ; $2A
1264 c774 43 4d 50 58                FCC     "CMPX"          ; $2B
1265 c778 43 4d 50 59                FCC     "CMPY"          ; $2C
1266 c77c 43 4f 4d 41                FCC     "COMA"          ; $2D
1267 c780 43 4f 4d 42                FCC     "COMB"          ; $2E
1268 c784 43 4f 4d 20                FCC     "COM "          ; $2F
1269 c788 43 57 41 49                FCC     "CWAI"          ; $30
1270 c78c 44 41 41 20                FCC     "DAA "          ; $31
1271 c790 44 45 43 20                FCC     "DEC "          ; $32
1272 c794 44 45 43 41                FCC     "DECA"          ; $33
1273 c798 44 45 43 42                FCC     "DECB"          ; $34
1274 c79c 45 4f 52 41                FCC     "EORA"          ; $35
1275 c7a0 45 4f 52 42                FCC     "EORB"          ; $36
1276 c7a4 45 58 47 20                FCC     "EXG "          ; $37
1277 c7a8 49 4e 43 20                FCC     "INC "          ; $38
1278 c7ac 49 4e 43 41                FCC     "INCA"          ; $39
1279 c7b0 49 4e 43 42                FCC     "INCB"          ; $3A
1280 c7b4 4a 4d 50 20                FCC     "JMP "          ; $3B
1281 c7b8 4a 53 52 20                FCC     "JSR "          ; $3C
1282 c7bc 4c 42 43 43                FCC     "LBCC"          ; $3D
1283 c7c0 4c 42 43 53                FCC     "LBCS"          ; $3E
1284 c7c4 4c 42 45 51                FCC     "LBEQ"          ; $3F
1285 c7c8 4c 42 47 45                FCC     "LBGE"          ; $40
1286 c7cc 4c 42 47 54                FCC     "LBGT"          ; $41
1287 c7d0 4c 42 48 49                FCC     "LBHI"          ; $42
1288 c7d4 4c 42 4c 45                FCC     "LBLE"          ; $43
1289 c7d8 4c 42 4c 53                FCC     "LBLS"          ; $44
1290 c7dc 4c 42 4c 54                FCC     "LBLT"          ; $45
1291 c7e0 4c 42 4d 49                FCC     "LBMI"          ; $46
1292 c7e4 4c 42 4e 45                FCC     "LBNE"          ; $47
1293 c7e8 4c 42 50 4c                FCC     "LBPL"          ; $48
1294 c7ec 4c 42 52 41                FCC     "LBRA"          ; $49
1295 c7f0 4c 42 52 4e                FCC     "LBRN"          ; $4A
1296 c7f4 4c 42 53 52                FCC     "LBSR"          ; $4B
1297 c7f8 4c 42 56 43                FCC     "LBVC"          ; $4C
1298 c7fc 4c 42 56 53                FCC     "LBVS"          ; $4D
1299 c800 4c 44 41 20                FCC     "LDA "          ; $4E
1300 c804 4c 44 42 20                FCC     "LDB "          ; $4F
1301 c808 4c 44 44 20                FCC     "LDD "          ; $50
1302 c80c 4c 44 53 20                FCC     "LDS "          ; $51
1303 c810 4c 44 55 20                FCC     "LDU "          ; $52
1304 c814 4c 44 58 20                FCC     "LDX "          ; $53
1305 c818 4c 44 59 20                FCC     "LDY "          ; $54
1306 c81c 4c 45 41 53                FCC     "LEAS"          ; $55
1307 c820 4c 45 41 55                FCC     "LEAU"          ; $56
1308 c824 4c 45 41 58                FCC     "LEAX"          ; $57
1309 c828 4c 45 41 59                FCC     "LEAY"          ; $58
1310 c82c 4c 53 52 20                FCC     "LSR "          ; $59
1311 c830 4c 53 52 41                FCC     "LSRA"          ; $5A
1312 c834 4c 53 52 42                FCC     "LSRB"          ; $5B
1313 c838 4d 55 4c 20                FCC     "MUL "          ; $5C
1314 c83c 4e 45 47 20                FCC     "NEG "          ; $5D
1315 c840 4e 45 47 41                FCC     "NEGA"          ; $5E
1316 c844 4e 45 47 42                FCC     "NEGB"          ; $5F
1317 c848 4e 4f 50 20                FCC     "NOP "          ; $60
1318 c84c 4f 52 41 20                FCC     "ORA "          ; $61
1319 c850 4f 52 42 20                FCC     "ORB "          ; $62
1320 c854 4f 52 43 43                FCC     "ORCC"          ; $63
1321 c858 50 53 48 53                FCC     "PSHS"          ; $64
1322 c85c 50 53 48 55                FCC     "PSHU"          ; $65
1323 c860 50 55 4c 53                FCC     "PULS"          ; $66
1324 c864 50 55 4c 55                FCC     "PULU"          ; $67
1325 c868 52 4f 4c 20                FCC     "ROL "          ; $68
1326 c86c 52 4f 4c 41                FCC     "ROLA"          ; $69
1327 c870 52 4f 4c 42                FCC     "ROLB"          ; $6A
1328 c874 52 4f 52 20                FCC     "ROR "          ; $6B
1329 c878 52 4f 52 41                FCC     "RORA"          ; $6C
1330 c87c 52 4f 52 42                FCC     "RORB"          ; $6D
1331 c880 52 54 49 20                FCC     "RTI "          ; $6E
1332 c884 52 54 53 20                FCC     "RTS "          ; $6F
1333 c888 53 42 43 41                FCC     "SBCA"          ; $70
1334 c88c 53 42 43 42                FCC     "SBCB"          ; $71
1335 c890 53 45 58 20                FCC     "SEX "          ; $72
1336 c894 53 54 41 20                FCC     "STA "          ; $73
1337 c898 53 54 42 20                FCC     "STB "          ; $74
1338 c89c 53 54 44 20                FCC     "STD "          ; $75
1339 c8a0 53 54 53 20                FCC     "STS "          ; $76
1340 c8a4 53 54 55 20                FCC     "STU "          ; $77
1341 c8a8 53 54 58 20                FCC     "STX "          ; $78
1342 c8ac 53 54 59 20                FCC     "STY "          ; $79
1343 c8b0 53 55 42 41                FCC     "SUBA"          ; $7A
1344 c8b4 53 55 42 42                FCC     "SUBB"          ; $7B
1345 c8b8 53 55 42 44                FCC     "SUBD"          ; $7C
1346 c8bc 53 57 49 20                FCC     "SWI "          ; $7D
1347 c8c0 53 57 49 32                FCC     "SWI2"          ; $7E
1348 c8c4 53 57 49 33                FCC     "SWI3"          ; $7F
1349 c8c8 53 59 4e 43                FCC     "SYNC"          ; $80
1350 c8cc 54 46 52 20                FCC     "TFR "          ; $81
1351 c8d0 54 53 54 20                FCC     "TST "          ; $82
1352 c8d4 54 53 54 41                FCC     "TSTA"          ; $83
1353 c8d8 54 53 54 42                FCC     "TSTB"          ; $84
1354                         
1355                         ; Lengths of instructions given an addressing mode. Matches values of
1356                         ; AM_* Indexed addessing instructions length can increase due to post
1357                         ; byte.
1358                         LENGTHS:
1359 c8dc 01                         FCB     1               ; 0 AM_INVALID
1360 c8dd 01                         FCB     1               ; 1 AM_INHERENT
1361 c8de 02                         FCB     2               ; 2 AM_IMMEDIATE8
1362 c8df 03                         FCB     3               ; 3 AM_IMMEDIATE16
1363 c8e0 02                         FCB     2               ; 4 AM_DIRECT
1364 c8e1 03                         FCB     3               ; 5 AM_EXTENDED
1365 c8e2 02                         FCB     2               ; 6 AM_RELATIVE8
1366 c8e3 03                         FCB     3               ; 7 AM_RELATIVE16
1367 c8e4 02                         FCB     2               ; 8 AM_INDEXED
1368                         
1369                         ; Lookup table to return needed remaining spaces to print to pad out
1370                         ; instruction to correct column in disassembly.
1371                         ; # bytes: 1 2 3 4
1372                         ; Padding: 9 6 3 0
1373                         PADDING:
1374 c8e5 0a 07 04 01                FCB     10, 7, 4, 1
1375                         
1376                         ; Lookup table to return number of additional bytes for indexed
1377                         ; addressing based on low order 5 bits of postbyte. Based on
1378                         ; detailed list of values below.
1379                         
1380                         POSTBYTES:
1381 c8e9 00 00 00 00 00 00          FCB     0, 0, 0, 0, 0, 0, 0, 0
     00 00
1382 c8f1 01 02 00 00 01 02          FCB     1, 2, 0, 0, 1, 2, 0, 0
     00 00
1383 c8f9 00 00 00 00 00 00          FCB     0, 0, 0, 0, 0, 0, 0, 0
     00 00
1384 c901 01 02 00 00 01 02          FCB     1, 2, 0, 0, 1, 2, 0, 2
     00 02
1385                         
1386                         ; Pattern:  # Extra bytes:
1387                         ; --------  --------------
1388                         ; 0XXXXXXX   0
1389                         ; 1XX00000   0
1390                         ; 1XX00001   0
1391                         ; 1XX00010   0
1392                         ; 1XX00011   0
1393                         ; 1XX00100   0
1394                         ; 1X000101   0
1395                         ; 1XX00110   0
1396                         ; 1XX00111   0 (INVALID)
1397                         ; 1XX01000   1
1398                         ; 1XX01001   2
1399                         ; 1XX01010   0 (INVALID)
1400                         ; 1XX01011   0
1401                         ; 1XX01100   1
1402                         ; 1XX01101   2
1403                         ; 1XX01110   0 (INVALID)
1404                         ; 1XX01111   0 (INVALID)
1405                         ; 1XX10000   0 (INVALID)
1406                         ; 1XX10001   0
1407                         ; 1XX10010   0 (INVALID)
1408                         ; 1XX10011   0
1409                         ; 1XX10100   0
1410                         ; 1XX10101   0
1411                         ; 1XX10110   0
1412                         ; 1XX10111   0 (INVALID)
1413                         ; 1XX11000   1
1414                         ; 1XX11001   2
1415                         ; 1XX11010   0 (INVALID)
1416                         ; 1XX11011   0
1417                         ; 1XX11100   1
1418                         ; 1XX11101   2
1419                         ; 1XX11110   0 (INVALID)
1420                         ; 1XX11111   2
1421                         
1422                         ; Opcodes. Listed in order indexed by op code. Defines the mnemonic.
1423                         OPCODES:
1424 c909 5d                         FCB     OP_NEG          ; 00
1425 c90a 00                         FCB     OP_INV          ; 01
1426 c90b 00                         FCB     OP_INV          ; 02
1427 c90c 2e                         FCB     OP_COMB         ; 03
1428 c90d 59                         FCB     OP_LSR          ; 04
1429 c90e 00                         FCB     OP_INV          ; 05
1430 c90f 6b                         FCB     OP_ROR          ; 06
1431 c910 0d                         FCB     OP_ASR          ; 07
1432 c911 0a                         FCB     OP_ASL          ; 08
1433 c912 68                         FCB     OP_ROL          ; 09
1434 c913 32                         FCB     OP_DEC          ; 0A
1435 c914 00                         FCB     OP_INV          ; 0B
1436 c915 38                         FCB     OP_INC          ; 0C
1437 c916 82                         FCB     OP_TST          ; 0D
1438 c917 3b                         FCB     OP_JMP          ; 0E
1439 c918 23                         FCB     OP_CLR          ; 0F
1440                         
1441 c919 00                         FCB     OP_INV          ; 10 Page 2 extended opcodes (see other table)
1442 c91a 00                         FCB     OP_INV          ; 11 Page 3 extended opcodes (see other table)
1443 c91b 60                         FCB     OP_NOP          ; 12
1444 c91c 80                         FCB     OP_SYNC         ; 13
1445 c91d 00                         FCB     OP_INV          ; 14
1446 c91e 00                         FCB     OP_INV          ; 15
1447 c91f 49                         FCB     OP_LBRA         ; 16
1448 c920 4b                         FCB     OP_LBSR         ; 17
1449 c921 00                         FCB     OP_INV          ; 18
1450 c922 31                         FCB     OP_DAA          ; 19
1451 c923 63                         FCB     OP_ORCC         ; 1A
1452 c924 00                         FCB     OP_INV          ; 1B
1453 c925 09                         FCB     OP_ANDCC        ; 1C
1454 c926 72                         FCB     OP_SEX          ; 1D
1455 c927 37                         FCB     OP_EXG          ; 1E
1456 c928 81                         FCB     OP_TFR          ; 1F
1457                         
1458 c929 1e                         FCB     OP_BRA          ; 20
1459 c92a 1f                         FCB     OP_BRN          ; 21
1460 c92b 15                         FCB     OP_BHI          ; 22
1461 c92c 19                         FCB     OP_BLS          ; 23
1462 c92d 10                         FCB     OP_BCC          ; 24
1463 c92e 11                         FCB     OP_BCS          ; 25
1464 c92f 1c                         FCB     OP_BNE          ; 26
1465 c930 12                         FCB     OP_BEQ          ; 27
1466 c931 21                         FCB     OP_BVC          ; 28
1467 c932 22                         FCB     OP_BVS          ; 29
1468 c933 1d                         FCB     OP_BPL          ; 2A
1469 c934 1b                         FCB     OP_BMI          ; 2B
1470 c935 13                         FCB     OP_BGE          ; 2C
1471 c936 1a                         FCB     OP_BLT          ; 2D
1472 c937 14                         FCB     OP_BGT          ; 2E
1473 c938 18                         FCB     OP_BLE          ; 2F
1474                         
1475 c939 57                         FCB     OP_LEAX         ; 30
1476 c93a 58                         FCB     OP_LEAY         ; 31
1477 c93b 55                         FCB     OP_LEAS         ; 32
1478 c93c 56                         FCB     OP_LEAU         ; 33
1479 c93d 64                         FCB     OP_PSHS         ; 34
1480 c93e 66                         FCB     OP_PULS         ; 35
1481 c93f 65                         FCB     OP_PSHU         ; 36
1482 c940 67                         FCB     OP_PULU         ; 37
1483 c941 00                         FCB     OP_INV          ; 38
1484 c942 6f                         FCB     OP_RTS          ; 39
1485 c943 01                         FCB     OP_ABX          ; 3A
1486 c944 6e                         FCB     OP_RTI          ; 3B
1487 c945 30                         FCB     OP_CWAI         ; 3C
1488 c946 5c                         FCB     OP_MUL          ; 3D
1489 c947 00                         FCB     OP_INV          ; 3E
1490 c948 7d                         FCB     OP_SWI          ; 3F
1491                         
1492 c949 5e                         FCB     OP_NEGA         ; 40
1493 c94a 00                         FCB     OP_INV          ; 41
1494 c94b 00                         FCB     OP_INV          ; 42
1495 c94c 2d                         FCB     OP_COMA         ; 43
1496 c94d 5a                         FCB     OP_LSRA         ; 44
1497 c94e 00                         FCB     OP_INV          ; 45
1498 c94f 6c                         FCB     OP_RORA         ; 46
1499 c950 0e                         FCB     OP_ASRA         ; 47
1500 c951 0b                         FCB     OP_ASLA         ; 48
1501 c952 69                         FCB     OP_ROLA         ; 49
1502 c953 33                         FCB     OP_DECA         ; 4A
1503 c954 00                         FCB     OP_INV          ; 4B
1504 c955 39                         FCB     OP_INCA         ; 4C
1505 c956 83                         FCB     OP_TSTA         ; 4D
1506 c957 00                         FCB     OP_INV          ; 4E
1507 c958 24                         FCB     OP_CLRA         ; 4F
1508                         
1509 c959 5f                         FCB     OP_NEGB         ; 50
1510 c95a 00                         FCB     OP_INV          ; 51
1511 c95b 00                         FCB     OP_INV          ; 52
1512 c95c 2e                         FCB     OP_COMB         ; 53
1513 c95d 5b                         FCB     OP_LSRB         ; 54
1514 c95e 00                         FCB     OP_INV          ; 55
1515 c95f 6d                         FCB     OP_RORB         ; 56
1516 c960 0f                         FCB     OP_ASRB         ; 57
1517 c961 0c                         FCB     OP_ASLB         ; 58
1518 c962 6a                         FCB     OP_ROLB         ; 59
1519 c963 34                         FCB     OP_DECB         ; 5A
1520 c964 00                         FCB     OP_INV          ; 5B
1521 c965 3a                         FCB     OP_INCB         ; 5C
1522 c966 84                         FCB     OP_TSTB         ; 5D
1523 c967 00                         FCB     OP_INV          ; 5E
1524 c968 25                         FCB     OP_CLRB         ; 5F
1525                         
1526 c969 5d                         FCB     OP_NEG          ; 60
1527 c96a 00                         FCB     OP_INV          ; 61
1528 c96b 00                         FCB     OP_INV          ; 62
1529 c96c 2f                         FCB     OP_COM          ; 63
1530 c96d 59                         FCB     OP_LSR          ; 64
1531 c96e 00                         FCB     OP_INV          ; 65
1532 c96f 6b                         FCB     OP_ROR          ; 66
1533 c970 0d                         FCB     OP_ASR          ; 67
1534 c971 0a                         FCB     OP_ASL          ; 68
1535 c972 68                         FCB     OP_ROL          ; 69
1536 c973 32                         FCB     OP_DEC          ; 6A
1537 c974 00                         FCB     OP_INV          ; 6B
1538 c975 38                         FCB     OP_INC          ; 6C
1539 c976 82                         FCB     OP_TST          ; 6D
1540 c977 3b                         FCB     OP_JMP          ; 6E
1541 c978 23                         FCB     OP_CLR          ; 6F
1542                         
1543 c979 5d                         FCB     OP_NEG          ; 70
1544 c97a 00                         FCB     OP_INV          ; 71
1545 c97b 00                         FCB     OP_INV          ; 72
1546 c97c 2f                         FCB     OP_COM          ; 73
1547 c97d 59                         FCB     OP_LSR          ; 74
1548 c97e 00                         FCB     OP_INV          ; 75
1549 c97f 6b                         FCB     OP_ROR          ; 76
1550 c980 0d                         FCB     OP_ASR          ; 77
1551 c981 0a                         FCB     OP_ASL          ; 78
1552 c982 68                         FCB     OP_ROL          ; 79
1553 c983 32                         FCB     OP_DEC          ; 7A
1554 c984 00                         FCB     OP_INV          ; 7B
1555 c985 38                         FCB     OP_INC          ; 7C
1556 c986 82                         FCB     OP_TST          ; 7D
1557 c987 3b                         FCB     OP_JMP          ; 7E
1558 c988 23                         FCB     OP_CLR          ; 7F
1559                         
1560 c989 7a                         FCB     OP_SUBA         ; 80
1561 c98a 26                         FCB     OP_CMPA         ; 81
1562 c98b 70                         FCB     OP_SBCA         ; 82
1563 c98c 7c                         FCB     OP_SUBD         ; 83
1564 c98d 07                         FCB     OP_ANDA         ; 84
1565 c98e 16                         FCB     OP_BITA         ; 85
1566 c98f 4e                         FCB     OP_LDA          ; 86
1567 c990 00                         FCB     OP_INV          ; 87
1568 c991 35                         FCB     OP_EORA         ; 88
1569 c992 02                         FCB     OP_ADCA         ; 89
1570 c993 61                         FCB     OP_ORA          ; 8A
1571 c994 04                         FCB     OP_ADDA         ; 8B
1572 c995 2b                         FCB     OP_CMPX         ; 8C
1573 c996 20                         FCB     OP_BSR          ; 8D
1574 c997 53                         FCB     OP_LDX          ; 8E
1575 c998 00                         FCB     OP_INV          ; 8F
1576                         
1577 c999 7a                         FCB     OP_SUBA         ; 90
1578 c99a 26                         FCB     OP_CMPA         ; 91
1579 c99b 70                         FCB     OP_SBCA         ; 92
1580 c99c 7c                         FCB     OP_SUBD         ; 93
1581 c99d 07                         FCB     OP_ANDA         ; 94
1582 c99e 16                         FCB     OP_BITA         ; 95
1583 c99f 4e                         FCB     OP_LDA          ; 96
1584 c9a0 73                         FCB     OP_STA          ; 97
1585 c9a1 35                         FCB     OP_EORA         ; 98
1586 c9a2 02                         FCB     OP_ADCA         ; 99
1587 c9a3 61                         FCB     OP_ORA          ; 9A
1588 c9a4 04                         FCB     OP_ADDA         ; 9B
1589 c9a5 2b                         FCB     OP_CMPX         ; 9C
1590 c9a6 3c                         FCB     OP_JSR          ; 9D
1591 c9a7 53                         FCB     OP_LDX          ; 9E
1592 c9a8 78                         FCB     OP_STX          ; 9F
1593                         
1594 c9a9 7a                         FCB     OP_SUBA         ; A0
1595 c9aa 26                         FCB     OP_CMPA         ; A1
1596 c9ab 70                         FCB     OP_SBCA         ; A2
1597 c9ac 7c                         FCB     OP_SUBD         ; A3
1598 c9ad 07                         FCB     OP_ANDA         ; A4
1599 c9ae 16                         FCB     OP_BITA         ; A5
1600 c9af 4e                         FCB     OP_LDA          ; A6
1601 c9b0 73                         FCB     OP_STA          ; A7
1602 c9b1 35                         FCB     OP_EORA         ; A8
1603 c9b2 02                         FCB     OP_ADCA         ; A9
1604 c9b3 61                         FCB     OP_ORA          ; AA
1605 c9b4 04                         FCB     OP_ADDA         ; AB
1606 c9b5 2b                         FCB     OP_CMPX         ; AC
1607 c9b6 3c                         FCB     OP_JSR          ; AD
1608 c9b7 53                         FCB     OP_LDX          ; AE
1609 c9b8 78                         FCB     OP_STX          ; AF
1610                         
1611 c9b9 7a                         FCB     OP_SUBA         ; B0
1612 c9ba 26                         FCB     OP_CMPA         ; B1
1613 c9bb 70                         FCB     OP_SBCA         ; B2
1614 c9bc 7c                         FCB     OP_SUBD         ; B3
1615 c9bd 07                         FCB     OP_ANDA         ; B4
1616 c9be 16                         FCB     OP_BITA         ; B5
1617 c9bf 4e                         FCB     OP_LDA          ; B6
1618 c9c0 73                         FCB     OP_STA          ; B7
1619 c9c1 35                         FCB     OP_EORA         ; B8
1620 c9c2 02                         FCB     OP_ADCA         ; B9
1621 c9c3 61                         FCB     OP_ORA          ; BA
1622 c9c4 04                         FCB     OP_ADDA         ; BB
1623 c9c5 2b                         FCB     OP_CMPX         ; BC
1624 c9c6 3c                         FCB     OP_JSR          ; BD
1625 c9c7 53                         FCB     OP_LDX          ; BE
1626 c9c8 78                         FCB     OP_STX          ; BF
1627                         
1628 c9c9 7b                         FCB     OP_SUBB         ; C0
1629 c9ca 27                         FCB     OP_CMPB         ; C1
1630 c9cb 71                         FCB     OP_SBCB         ; C2
1631 c9cc 06                         FCB     OP_ADDD         ; C3
1632 c9cd 08                         FCB     OP_ANDB         ; C4
1633 c9ce 17                         FCB     OP_BITB         ; C5
1634 c9cf 4f                         FCB     OP_LDB          ; C6
1635 c9d0 00                         FCB     OP_INV          ; C7
1636 c9d1 36                         FCB     OP_EORB         ; C8
1637 c9d2 03                         FCB     OP_ADCB         ; C9
1638 c9d3 62                         FCB     OP_ORB          ; CA
1639 c9d4 05                         FCB     OP_ADDB         ; CB
1640 c9d5 50                         FCB     OP_LDD          ; CC
1641 c9d6 00                         FCB     OP_INV          ; CD
1642 c9d7 52                         FCB     OP_LDU          ; CE
1643 c9d8 00                         FCB     OP_INV          ; CF
1644                         
1645 c9d9 7b                         FCB     OP_SUBB         ; D0
1646 c9da 27                         FCB     OP_CMPB         ; D1
1647 c9db 71                         FCB     OP_SBCB         ; D2
1648 c9dc 06                         FCB     OP_ADDD         ; D3
1649 c9dd 08                         FCB     OP_ANDB         ; D4
1650 c9de 17                         FCB     OP_BITB         ; D5
1651 c9df 4f                         FCB     OP_LDB          ; D6
1652 c9e0 74                         FCB     OP_STB          ; D7
1653 c9e1 36                         FCB     OP_EORB         ; D8
1654 c9e2 03                         FCB     OP_ADCB         ; D9
1655 c9e3 62                         FCB     OP_ORB          ; DA
1656 c9e4 05                         FCB     OP_ADDB         ; DB
1657 c9e5 50                         FCB     OP_LDD          ; DC
1658 c9e6 75                         FCB     OP_STD          ; DD
1659 c9e7 52                         FCB     OP_LDU          ; DE
1660 c9e8 77                         FCB     OP_STU          ; DF
1661                         
1662 c9e9 7b                         FCB     OP_SUBB         ; E0
1663 c9ea 27                         FCB     OP_CMPB         ; E1
1664 c9eb 71                         FCB     OP_SBCB         ; E2
1665 c9ec 06                         FCB     OP_ADDD         ; E3
1666 c9ed 08                         FCB     OP_ANDB         ; E4
1667 c9ee 17                         FCB     OP_BITB         ; E5
1668 c9ef 4f                         FCB     OP_LDB          ; E6
1669 c9f0 74                         FCB     OP_STB          ; E7
1670 c9f1 36                         FCB     OP_EORB         ; E8
1671 c9f2 03                         FCB     OP_ADCB         ; E9
1672 c9f3 62                         FCB     OP_ORB          ; EA
1673 c9f4 05                         FCB     OP_ADDB         ; EB
1674 c9f5 50                         FCB     OP_LDD          ; EC
1675 c9f6 75                         FCB     OP_STD          ; ED
1676 c9f7 52                         FCB     OP_LDU          ; EE
1677 c9f8 77                         FCB     OP_STU          ; EF
1678                         
1679 c9f9 7b                         FCB     OP_SUBB         ; F0
1680 c9fa 27                         FCB     OP_CMPB         ; F1
1681 c9fb 71                         FCB     OP_SBCB         ; F2
1682 c9fc 06                         FCB     OP_ADDD         ; F3
1683 c9fd 08                         FCB     OP_ANDB         ; F4
1684 c9fe 17                         FCB     OP_BITB         ; F5
1685 c9ff 4f                         FCB     OP_LDB          ; F6
1686 ca00 74                         FCB     OP_STB          ; F7
1687 ca01 36                         FCB     OP_EORB         ; F8
1688 ca02 03                         FCB     OP_ADCB         ; F9
1689 ca03 62                         FCB     OP_ORB          ; FA
1690 ca04 05                         FCB     OP_ADDB         ; FB
1691 ca05 50                         FCB     OP_LDD          ; FC
1692 ca06 75                         FCB     OP_STD          ; FD
1693 ca07 52                         FCB     OP_LDU          ; FE
1694 ca08 77                         FCB     OP_STU          ; FF
1695                         
1696                         ; Table of addressing modes. Listed in order,indexed by op code.
1697                         MODES:
1698 ca09 04                         FCB     AM_DIRECT       ; 00
1699 ca0a 00                         FCB     AM_INVALID      ; 01
1700 ca0b 00                         FCB     AM_INVALID      ; 02
1701 ca0c 04                         FCB     AM_DIRECT       ; 03
1702 ca0d 04                         FCB     AM_DIRECT       ; 04
1703 ca0e 00                         FCB     AM_INVALID      ; 05
1704 ca0f 04                         FCB     AM_DIRECT       ; 06
1705 ca10 04                         FCB     AM_DIRECT       ; 07
1706 ca11 04                         FCB     AM_DIRECT       ; 08
1707 ca12 04                         FCB     AM_DIRECT       ; 09
1708 ca13 04                         FCB     AM_DIRECT       ; 0A
1709 ca14 00                         FCB     AM_INVALID      ; 0B
1710 ca15 04                         FCB     AM_DIRECT       ; 0C
1711 ca16 04                         FCB     AM_DIRECT       ; 0D
1712 ca17 04                         FCB     AM_DIRECT       ; 0E
1713 ca18 04                         FCB     AM_DIRECT       ; 0F
1714                         
1715 ca19 00                         FCB     AM_INVALID      ; 10 Page 2 extended opcodes (see other table)
1716 ca1a 00                         FCB     AM_INVALID      ; 11 Page 3 extended opcodes (see other table)
1717 ca1b 01                         FCB     AM_INHERENT     ; 12
1718 ca1c 01                         FCB     AM_INHERENT     ; 13
1719 ca1d 00                         FCB     AM_INVALID      ; 14
1720 ca1e 00                         FCB     AM_INVALID      ; 15
1721 ca1f 07                         FCB     AM_RELATIVE16   ; 16
1722 ca20 07                         FCB     AM_RELATIVE16   ; 17
1723 ca21 00                         FCB     AM_INVALID      ; 18
1724 ca22 01                         FCB     AM_INHERENT     ; 19
1725 ca23 02                         FCB     AM_IMMEDIATE8   ; 1A
1726 ca24 00                         FCB     AM_INVALID      ; 1B
1727 ca25 02                         FCB     AM_IMMEDIATE8   ; 1C
1728 ca26 01                         FCB     AM_INHERENT     ; 1D
1729 ca27 02                         FCB     AM_IMMEDIATE8   ; 1E
1730 ca28 02                         FCB     AM_IMMEDIATE8   ; 1F
1731                         
1732 ca29 06                         FCB     AM_RELATIVE8    ; 20
1733 ca2a 06                         FCB     AM_RELATIVE8    ; 21
1734 ca2b 06                         FCB     AM_RELATIVE8    ; 22
1735 ca2c 06                         FCB     AM_RELATIVE8    ; 23
1736 ca2d 06                         FCB     AM_RELATIVE8    ; 24
1737 ca2e 06                         FCB     AM_RELATIVE8    ; 25
1738 ca2f 06                         FCB     AM_RELATIVE8    ; 26
1739 ca30 06                         FCB     AM_RELATIVE8    ; 27
1740 ca31 06                         FCB     AM_RELATIVE8    ; 28
1741 ca32 06                         FCB     AM_RELATIVE8    ; 29
1742 ca33 06                         FCB     AM_RELATIVE8    ; 2A
1743 ca34 06                         FCB     AM_RELATIVE8    ; 2B
1744 ca35 06                         FCB     AM_RELATIVE8    ; 2C
1745 ca36 06                         FCB     AM_RELATIVE8    ; 2D
1746 ca37 06                         FCB     AM_RELATIVE8    ; 2E
1747 ca38 06                         FCB     AM_RELATIVE8    ; 2F
1748                         
1749 ca39 08                         FCB     AM_INDEXED      ; 30
1750 ca3a 08                         FCB     AM_INDEXED      ; 31
1751 ca3b 08                         FCB     AM_INDEXED      ; 32
1752 ca3c 08                         FCB     AM_INDEXED      ; 33
1753 ca3d 02                         FCB     AM_IMMEDIATE8   ; 34
1754 ca3e 02                         FCB     AM_IMMEDIATE8   ; 35
1755 ca3f 02                         FCB     AM_IMMEDIATE8   ; 36
1756 ca40 02                         FCB     AM_IMMEDIATE8   ; 37
1757 ca41 00                         FCB     AM_INVALID      ; 38
1758 ca42 01                         FCB     AM_INHERENT     ; 39
1759 ca43 01                         FCB     AM_INHERENT     ; 3A
1760 ca44 01                         FCB     AM_INHERENT     ; 3B
1761 ca45 02                         FCB     AM_IMMEDIATE8   ; 3C
1762 ca46 01                         FCB     AM_INHERENT     ; 3D
1763 ca47 00                         FCB     AM_INVALID      ; 3E
1764 ca48 01                         FCB     AM_INHERENT     ; 3F
1765                         
1766 ca49 01                         FCB     AM_INHERENT     ; 40
1767 ca4a 00                         FCB     AM_INVALID      ; 41
1768 ca4b 00                         FCB     AM_INVALID      ; 42
1769 ca4c 01                         FCB     AM_INHERENT     ; 43
1770 ca4d 01                         FCB     AM_INHERENT     ; 44
1771 ca4e 00                         FCB     AM_INVALID      ; 45
1772 ca4f 01                         FCB     AM_INHERENT     ; 46
1773 ca50 01                         FCB     AM_INHERENT     ; 47
1774 ca51 01                         FCB     AM_INHERENT     ; 48
1775 ca52 01                         FCB     AM_INHERENT     ; 49
1776 ca53 01                         FCB     AM_INHERENT     ; 4A
1777 ca54 00                         FCB     AM_INVALID      ; 4B
1778 ca55 01                         FCB     AM_INHERENT     ; 4C
1779 ca56 01                         FCB     AM_INHERENT     ; 4D
1780 ca57 00                         FCB     AM_INVALID      ; 4E
1781 ca58 01                         FCB     AM_INHERENT     ; 4F
1782                         
1783 ca59 01                         FCB     AM_INHERENT     ; 50
1784 ca5a 00                         FCB     AM_INVALID      ; 51
1785 ca5b 00                         FCB     AM_INVALID      ; 52
1786 ca5c 01                         FCB     AM_INHERENT     ; 53
1787 ca5d 01                         FCB     AM_INHERENT     ; 54
1788 ca5e 00                         FCB     AM_INVALID      ; 55
1789 ca5f 01                         FCB     AM_INHERENT     ; 56
1790 ca60 01                         FCB     AM_INHERENT     ; 57
1791 ca61 01                         FCB     AM_INHERENT     ; 58
1792 ca62 01                         FCB     AM_INHERENT     ; 59
1793 ca63 01                         FCB     AM_INHERENT     ; 5A
1794 ca64 00                         FCB     AM_INVALID      ; 5B
1795 ca65 01                         FCB     AM_INHERENT     ; 5C
1796 ca66 01                         FCB     AM_INHERENT     ; 5D
1797 ca67 00                         FCB     AM_INVALID      ; 5E
1798 ca68 01                         FCB     AM_INHERENT     ; 5F
1799                         
1800 ca69 08                         FCB     AM_INDEXED      ; 60
1801 ca6a 00                         FCB     AM_INVALID      ; 61
1802 ca6b 00                         FCB     AM_INVALID      ; 62
1803 ca6c 08                         FCB     AM_INDEXED      ; 63
1804 ca6d 08                         FCB     AM_INDEXED      ; 64
1805 ca6e 00                         FCB     AM_INVALID      ; 65
1806 ca6f 08                         FCB     AM_INDEXED      ; 66
1807 ca70 08                         FCB     AM_INDEXED      ; 67
1808 ca71 08                         FCB     AM_INDEXED      ; 68
1809 ca72 08                         FCB     AM_INDEXED      ; 69
1810 ca73 08                         FCB     AM_INDEXED      ; 6A
1811 ca74 00                         FCB     AM_INVALID      ; 6B
1812 ca75 08                         FCB     AM_INDEXED      ; 6C
1813 ca76 08                         FCB     AM_INDEXED      ; 6D
1814 ca77 08                         FCB     AM_INDEXED      ; 6E
1815 ca78 08                         FCB     AM_INDEXED      ; 6F
1816                         
1817 ca79 05                         FCB     AM_EXTENDED     ; 70
1818 ca7a 00                         FCB     AM_INVALID      ; 71
1819 ca7b 00                         FCB     AM_INVALID      ; 72
1820 ca7c 05                         FCB     AM_EXTENDED     ; 73
1821 ca7d 05                         FCB     AM_EXTENDED     ; 74
1822 ca7e 00                         FCB     AM_INVALID      ; 75
1823 ca7f 05                         FCB     AM_EXTENDED     ; 76
1824 ca80 05                         FCB     AM_EXTENDED     ; 77
1825 ca81 05                         FCB     AM_EXTENDED     ; 78
1826 ca82 05                         FCB     AM_EXTENDED     ; 79
1827 ca83 05                         FCB     AM_EXTENDED     ; 7A
1828 ca84 00                         FCB     AM_INVALID      ; 7B
1829 ca85 05                         FCB     AM_EXTENDED     ; 7C
1830 ca86 05                         FCB     AM_EXTENDED     ; 7D
1831 ca87 05                         FCB     AM_EXTENDED     ; 7E
1832 ca88 05                         FCB     AM_EXTENDED     ; 7F
1833                         
1834 ca89 02                         FCB     AM_IMMEDIATE8   ; 80
1835 ca8a 02                         FCB     AM_IMMEDIATE8   ; 81
1836 ca8b 02                         FCB     AM_IMMEDIATE8   ; 82
1837 ca8c 03                         FCB     AM_IMMEDIATE16  ; 83
1838 ca8d 02                         FCB     AM_IMMEDIATE8   ; 84
1839 ca8e 02                         FCB     AM_IMMEDIATE8   ; 85
1840 ca8f 02                         FCB     AM_IMMEDIATE8   ; 86
1841 ca90 00                         FCB     AM_INVALID      ; 87
1842 ca91 02                         FCB     AM_IMMEDIATE8   ; 88
1843 ca92 02                         FCB     AM_IMMEDIATE8   ; 89
1844 ca93 02                         FCB     AM_IMMEDIATE8   ; 8A
1845 ca94 02                         FCB     AM_IMMEDIATE8   ; 8B
1846 ca95 03                         FCB     AM_IMMEDIATE16  ; 8C
1847 ca96 06                         FCB     AM_RELATIVE8    ; 8D
1848 ca97 03                         FCB     AM_IMMEDIATE16  ; 8E
1849 ca98 00                         FCB     AM_INVALID      ; 8F
1850                         
1851 ca99 04                         FCB     AM_DIRECT       ; 90
1852 ca9a 04                         FCB     AM_DIRECT       ; 91
1853 ca9b 04                         FCB     AM_DIRECT       ; 92
1854 ca9c 04                         FCB     AM_DIRECT       ; 93
1855 ca9d 04                         FCB     AM_DIRECT       ; 94
1856 ca9e 04                         FCB     AM_DIRECT       ; 95
1857 ca9f 04                         FCB     AM_DIRECT       ; 96
1858 caa0 04                         FCB     AM_DIRECT       ; 97
1859 caa1 04                         FCB     AM_DIRECT       ; 98
1860 caa2 04                         FCB     AM_DIRECT       ; 99
1861 caa3 04                         FCB     AM_DIRECT       ; 9A
1862 caa4 04                         FCB     AM_DIRECT       ; 9B
1863 caa5 04                         FCB     AM_DIRECT       ; 9C
1864 caa6 04                         FCB     AM_DIRECT       ; 9D
1865 caa7 04                         FCB     AM_DIRECT       ; 9E
1866 caa8 04                         FCB     AM_DIRECT       ; 9F
1867                         
1868 caa9 08                         FCB     AM_INDEXED      ; A0
1869 caaa 08                         FCB     AM_INDEXED      ; A1
1870 caab 08                         FCB     AM_INDEXED      ; A2
1871 caac 08                         FCB     AM_INDEXED      ; A3
1872 caad 08                         FCB     AM_INDEXED      ; A4
1873 caae 08                         FCB     AM_INDEXED      ; A5
1874 caaf 08                         FCB     AM_INDEXED      ; A6
1875 cab0 08                         FCB     AM_INDEXED      ; A7
1876 cab1 08                         FCB     AM_INDEXED      ; A8
1877 cab2 08                         FCB     AM_INDEXED      ; A9
1878 cab3 08                         FCB     AM_INDEXED      ; AA
1879 cab4 08                         FCB     AM_INDEXED      ; AB
1880 cab5 08                         FCB     AM_INDEXED      ; AC
1881 cab6 08                         FCB     AM_INDEXED      ; AD
1882 cab7 08                         FCB     AM_INDEXED      ; AE
1883 cab8 08                         FCB     AM_INDEXED      ; AF
1884                         
1885 cab9 05                         FCB     AM_EXTENDED     ; B0
1886 caba 05                         FCB     AM_EXTENDED     ; B1
1887 cabb 05                         FCB     AM_EXTENDED     ; B2
1888 cabc 05                         FCB     AM_EXTENDED     ; B3
1889 cabd 05                         FCB     AM_EXTENDED     ; B4
1890 cabe 05                         FCB     AM_EXTENDED     ; B5
1891 cabf 05                         FCB     AM_EXTENDED     ; B6
1892 cac0 05                         FCB     AM_EXTENDED     ; B7
1893 cac1 05                         FCB     AM_EXTENDED     ; B8
1894 cac2 05                         FCB     AM_EXTENDED     ; B9
1895 cac3 05                         FCB     AM_EXTENDED     ; BA
1896 cac4 05                         FCB     AM_EXTENDED     ; BB
1897 cac5 05                         FCB     AM_EXTENDED     ; BC
1898 cac6 05                         FCB     AM_EXTENDED     ; BD
1899 cac7 05                         FCB     AM_EXTENDED     ; BE
1900 cac8 05                         FCB     AM_EXTENDED     ; BF
1901                         
1902 cac9 02                         FCB     AM_IMMEDIATE8   ; C0
1903 caca 02                         FCB     AM_IMMEDIATE8   ; C1
1904 cacb 02                         FCB     AM_IMMEDIATE8   ; C2
1905 cacc 03                         FCB     AM_IMMEDIATE16  ; C3
1906 cacd 02                         FCB     AM_IMMEDIATE8   ; C4
1907 cace 02                         FCB     AM_IMMEDIATE8   ; C5
1908 cacf 02                         FCB     AM_IMMEDIATE8   ; C6
1909 cad0 00                         FCB     AM_INVALID      ; C7
1910 cad1 02                         FCB     AM_IMMEDIATE8   ; C8
1911 cad2 02                         FCB     AM_IMMEDIATE8   ; C9
1912 cad3 02                         FCB     AM_IMMEDIATE8   ; CA
1913 cad4 02                         FCB     AM_IMMEDIATE8   ; CB
1914 cad5 02                         FCB     AM_IMMEDIATE8   ; CC
1915 cad6 01                         FCB     AM_INHERENT     ; CD
1916 cad7 02                         FCB     AM_IMMEDIATE8   ; CE
1917 cad8 00                         FCB     AM_INVALID      ; CF
1918                         
1919 cad9 04                         FCB     AM_DIRECT       ; D0
1920 cada 04                         FCB     AM_DIRECT       ; D1
1921 cadb 04                         FCB     AM_DIRECT       ; D2
1922 cadc 04                         FCB     AM_DIRECT       ; D3
1923 cadd 04                         FCB     AM_DIRECT       ; D4
1924 cade 04                         FCB     AM_DIRECT       ; D5
1925 cadf 04                         FCB     AM_DIRECT       ; D6
1926 cae0 04                         FCB     AM_DIRECT       ; D7
1927 cae1 04                         FCB     AM_DIRECT       ; D8
1928 cae2 04                         FCB     AM_DIRECT       ; D9
1929 cae3 04                         FCB     AM_DIRECT       ; DA
1930 cae4 04                         FCB     AM_DIRECT       ; DB
1931 cae5 04                         FCB     AM_DIRECT       ; DC
1932 cae6 04                         FCB     AM_DIRECT       ; DD
1933 cae7 04                         FCB     AM_DIRECT       ; DE
1934 cae8 04                         FCB     AM_DIRECT       ; DF
1935                         
1936 cae9 08                         FCB     AM_INDEXED      ; E0
1937 caea 08                         FCB     AM_INDEXED      ; E1
1938 caeb 08                         FCB     AM_INDEXED      ; E2
1939 caec 08                         FCB     AM_INDEXED      ; E3
1940 caed 08                         FCB     AM_INDEXED      ; E4
1941 caee 08                         FCB     AM_INDEXED      ; E5
1942 caef 08                         FCB     AM_INDEXED      ; E6
1943 caf0 08                         FCB     AM_INDEXED      ; E7
1944 caf1 08                         FCB     AM_INDEXED      ; E8
1945 caf2 08                         FCB     AM_INDEXED      ; E9
1946 caf3 08                         FCB     AM_INDEXED      ; EA
1947 caf4 08                         FCB     AM_INDEXED      ; EB
1948 caf5 08                         FCB     AM_INDEXED      ; EC
1949 caf6 08                         FCB     AM_INDEXED      ; ED
1950 caf7 08                         FCB     AM_INDEXED      ; EE
1951 caf8 08                         FCB     AM_INDEXED      ; EF
1952                         
1953 caf9 05                         FCB     AM_EXTENDED     ; F0
1954 cafa 05                         FCB     AM_EXTENDED     ; F1
1955 cafb 05                         FCB     AM_EXTENDED     ; F2
1956 cafc 05                         FCB     AM_EXTENDED     ; F3
1957 cafd 05                         FCB     AM_EXTENDED     ; F4
1958 cafe 05                         FCB     AM_EXTENDED     ; F5
1959 caff 05                         FCB     AM_EXTENDED     ; F6
1960 cb00 05                         FCB     AM_EXTENDED     ; F7
1961 cb01 05                         FCB     AM_EXTENDED     ; F8
1962 cb02 05                         FCB     AM_EXTENDED     ; F9
1963 cb03 05                         FCB     AM_EXTENDED     ; FA
1964 cb04 05                         FCB     AM_EXTENDED     ; FB
1965 cb05 05                         FCB     AM_EXTENDED     ; FC
1966 cb06 05                         FCB     AM_EXTENDED     ; FD
1967 cb07 05                         FCB     AM_EXTENDED     ; FE
1968 cb08 05                         FCB     AM_EXTENDED     ; FF
1969                         
1970                         ; Special table for page 2 instructions prefixed by $10.
1971                         ; Format: opcode (less 10), instruction, addressing mode
1972                         
1973                         PAGE2:
1974 cb09 21 4a 07                   FCB     $21, OP_LBRN,  AM_RELATIVE16
1975 cb0c 22 42 07                   FCB     $22, OP_LBHI,  AM_RELATIVE16
1976 cb0f 23 44 07                   FCB     $23, OP_LBLS,  AM_RELATIVE16
1977 cb12 24 3d 07                   FCB     $24, OP_LBCC,  AM_RELATIVE16
1978 cb15 25 3e 07                   FCB     $25, OP_LBCS,  AM_RELATIVE16
1979 cb18 26 47 07                   FCB     $26, OP_LBNE,  AM_RELATIVE16
1980 cb1b 27 3f 07                   FCB     $27, OP_LBEQ,  AM_RELATIVE16
1981 cb1e 28 4c 07                   FCB     $28, OP_LBVC,  AM_RELATIVE16
1982 cb21 29 4d 07                   FCB     $29, OP_LBVS,  AM_RELATIVE16
1983 cb24 2a 48 07                   FCB     $2A, OP_LBPL,  AM_RELATIVE16
1984 cb27 2b 46 07                   FCB     $2B, OP_LBMI,  AM_RELATIVE16
1985 cb2a 2c 40 07                   FCB     $2C, OP_LBGE,  AM_RELATIVE16
1986 cb2d 2d 45 07                   FCB     $2D, OP_LBLT,  AM_RELATIVE16
1987 cb30 2e 41 07                   FCB     $2E, OP_LBGT,  AM_RELATIVE16
1988 cb33 2f 43 07                   FCB     $2F, OP_LBLE,  AM_RELATIVE16
1989 cb36 3f 7e 01                   FCB     $3F, OP_SWI2,  AM_INHERENT
1990 cb39 83 28 03                   FCB     $83, OP_CMPD,  AM_IMMEDIATE16
1991 cb3c 8c 2c 03                   FCB     $8C, OP_CMPY,  AM_IMMEDIATE16
1992 cb3f 8e 54 03                   FCB     $8E, OP_LDY,   AM_IMMEDIATE16
1993 cb42 93 28 04                   FCB     $93, OP_CMPD,  AM_DIRECT
1994 cb45 9c 2c 04                   FCB     $9C, OP_CMPY,  AM_DIRECT
1995 cb48 9e 54 04                   FCB     $9E, OP_LDY,   AM_DIRECT
1996 cb4b 9d 79 04                   FCB     $9D, OP_STY,   AM_DIRECT
1997 cb4e a3 28 08                   FCB     $A3, OP_CMPD,  AM_INDEXED
1998 cb51 ac 2c 08                   FCB     $AC, OP_CMPY,  AM_INDEXED
1999 cb54 ae 54 08                   FCB     $AE, OP_LDY,   AM_INDEXED
2000 cb57 af 79 08                   FCB     $AF, OP_STY,   AM_INDEXED
2001 cb5a b3 28 05                   FCB     $B3, OP_CMPD,  AM_EXTENDED
2002 cb5d bc 2c 05                   FCB     $BC, OP_CMPY,  AM_EXTENDED
2003 cb60 be 54 05                   FCB     $BE, OP_LDY,   AM_EXTENDED
2004 cb63 bf 79 05                   FCB     $BF, OP_STY,   AM_EXTENDED
2005 cb66 ce 51 03                   FCB     $CE, OP_LDS,   AM_IMMEDIATE16
2006 cb69 de 51 04                   FCB     $DE, OP_LDS,   AM_DIRECT
2007 cb6c dd 76 04                   FCB     $DD, OP_STS,   AM_DIRECT
2008 cb6f ee 51 08                   FCB     $EE, OP_LDS,   AM_INDEXED
2009 cb72 ef 76 08                   FCB     $EF, OP_STS,   AM_INDEXED
2010 cb75 fe 51 05                   FCB     $FE, OP_LDS,   AM_EXTENDED
2011 cb78 ff 76 05                   FCB     $FF, OP_STS,   AM_EXTENDED
2012 cb7b 00                         FCB     0                             ; indicates end of table
2013                         
2014                         ; Special table for page 3 instructions prefixed by $11.
2015                         ; Same format as table above.
2016                         
2017                         PAGE3:
2018 cb7c 3f 7f 01                   FCB     $3F, OP_SWI3,  AM_INHERENT
2019 cb7f 83 2a 03                   FCB     $83, OP_CMPU,  AM_IMMEDIATE16
2020 cb82 8c 29 03                   FCB     $8C, OP_CMPS,  AM_IMMEDIATE16
2021 cb85 93 2a 04                   FCB     $93, OP_CMPU,  AM_DIRECT
2022 cb88 9c 29 04                   FCB     $9C, OP_CMPS,  AM_DIRECT
2023 cb8b a3 2a 08                   FCB     $A3, OP_CMPU,  AM_INDEXED
2024 cb8e ac 29 08                   FCB     $AC, OP_CMPS,  AM_INDEXED
2025 cb91 b3 2a 05                   FCB     $B3, OP_CMPU,  AM_EXTENDED
2026 cb94 bc 29 05                   FCB     $BC, OP_CMPS,  AM_EXTENDED
2027 cb97 00                         FCB     0                             ; indicates end of table
2028                         
2029                         ; Display strings. Should be terminated in EOT character.
2030                         
2031 cb98 3b 20 49 4e 56 41  MSG1:   FCC     "; INVALID"
     4c 49 44
2032 cba1 04                         FCB     EOT
2033                         
2034 cba2 50 52 45 53 53 20  MSG2:   FCC     "PRESS <SPACE> TO CONTINUE, <Q> TO QUIT "
     3c 53 50 41 43 45
     3e 20 54 4f 20 43
     4f 4e 54 49 4e 55
     45 2c 20 3c 51 3e
     20 54 4f 20 51 55
     49 54 20
2035 cbc9 04                         FCB     EOT
2036                         
2037 cbca 50 43 52           MSG3:   FCC     "PCR"
2038 cbcd 04                         FCB     EOT
2039                         
2040 cbce ff ff ff ff ff ff            FILL $FF, $D000-*   ; Fill ROM with FFs until $D000
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff
2041                         
2042                         ************************************************************************
2043                         
2044 a000                    UART      EQU  $A000
2045 a001                    RECEV     EQU  UART+1
2046 a001                    TRANS     EQU  UART+1
2047 a000                    USTAT     EQU  UART
2048 a000                    UCTRL     EQU  UART
2049                         
2050 0008                    BS        EQU  8              ; BACKSPACE
2051 000d                    CR        EQU  $D             ; ENTER KEY
2052 001b                    ESC       EQU  $1B            ; ESCAPE CODE
2053 0020                    SPACE     EQU  $20            ; SPACE (BLANK)
2054 003a                    STKBUF    EQU  58             ; STACK BUFFER ROOM
2055 00fa                    LBUFMX    EQU  250            ; MAX NUMBER OF CHARS IN A BASIC LINE
2056 00fa                    MAXLIN    EQU  $FA            ; MAXIMUM MS BYTE OF LINE NUMBER
2057                         * PSEUDO OPS
2058 0021                    SKP1      EQU  $21            ; OP CODE OF BRN - SKIP ONE BYTE
2059 008c                    SKP2      EQU  $8C            ; OP CODE OF CMPX # - SKIP TWO BYTES
2060 0086                    SKP1LD    EQU  $86            ; OP CODE OF LDA # - SKIP THE NEXT BYTE
2061                         *                             ; AND LOAD THE VALUE OF THAT BYTE INTO ACCA - THIS
2062                         *                             ; IS USUALLY USED TO LOAD ACCA WITH A NON ZERO VALUE
2063 0015                    RTS_LOW   EQU  $15            ; 6850 ACIA CONTROL REGISTER: RX INT DISABLED, RTS LOW, TX INT DISABLED, 8N1, CLK/16
2064 0000                              ORG  0
2065 0000                    ENDFLG    RMB  1              ; STOP/END FLAG: POSITIVE=STOP, NEG=END
2066 0001                    CHARAC    RMB  1              ; TERMINATOR FLAG 1
2067 0002                    ENDCHR    RMB  1              ; TERMINATOR FLAG 2
2068 0003                    TMPLOC    RMB  1              ; SCRATCH VARIABLE
2069 0004                    IFCTR     RMB  1              ; IF COUNTER - HOW MANY IF STATEMENTS IN A LINE
2070 0005                    DIMFLG    RMB  1              ; *DV* ARRAY FLAG 0=EVALUATE, 1=DIMENSIONING
2071 0006                    VALTYP    RMB  1              ; *DV* *PV TYPE FLAG: 0=NUMERIC, $FF=STRING
2072 0007                    GARBFL    RMB  1              ; *TV STRING SPACE HOUSEKEEPING FLAG
2073 0008                    ARYDIS    RMB  1              ; DISABLE ARRAY SEARCH: 00=ALLOW SEARCH
2074 0009                    INPFLG    RMB  1              ; *TV INPUT FLAG: READ=0, INPUT<>0
2075 000a                    RELFLG    RMB  1              ; *TV RELATIONAL OPERATOR FLAG
2076 000b                    TEMPPT    RMB  2              ; *PV TEMPORARY STRING STACK POINTER
2077 000d                    LASTPT    RMB  2              ; *PV ADDR OF LAST USED STRING STACK ADDRESS
2078 000f                    TEMPTR    RMB  2              ; TEMPORARY POINTER
2079 0011                    TMPTR1    RMB  2              ; TEMPORARY DESCRIPTOR STORAGE (STACK SEARCH)
2080 0013                    FPA2      RMB  4              ; FLOATING POINT ACCUMULATOR #2 MANTISSA
2081 0017                    BOTSTK    RMB  2              ; BOTTOM OF STACK AT LAST CHECK
2082 0019                    TXTTAB    RMB  2              ; *PV BEGINNING OF BASIC PROGRAM
2083 001b                    VARTAB    RMB  2              ; *PV START OF VARIABLES
2084 001d                    ARYTAB    RMB  2              ; *PV START OF ARRAYS
2085 001f                    ARYEND    RMB  2              ; *PV END OF ARRAYS (+1)
2086 0021                    FRETOP    RMB  2              ; *PV START OF STRING STORAGE (TOP OF FREE RAM)
2087 0023                    STRTAB    RMB  2              ; *PV START OF STRING VARIABLES
2088 0025                    FRESPC    RMB  2              ; UTILITY STRING POINTER
2089 0027                    MEMSIZ    RMB  2              ; *PV TOP OF STRING SPACE
2090 0029                    OLDTXT    RMB  2              ; SAVED LINE NUMBER DURING A "STOP"
2091 002b                    BINVAL    RMB  2              ; BINARY VALUE OF A CONVERTED LINE NUMBER
2092 002d                    OLDPTR    RMB  2              ; SAVED INPUT PTR DURING A "STOP"
2093 002f                    TINPTR    RMB  2              ; TEMPORARY INPUT POINTER STORAGE
2094 0031                    DATTXT    RMB  2              ; *PV 'DATA' STATEMENT LINE NUMBER POINTER
2095 0033                    DATPTR    RMB  2              ; *PV 'DATA' STATEMENT ADDRESS POINTER
2096 0035                    DATTMP    RMB  2              ; DATA POINTER FOR 'INPUT' & 'READ'
2097 0037                    VARNAM    RMB  2              ; *TV TEMP STORAGE FOR A VARIABLE NAME
2098 0039                    VARPTR    RMB  2              ; *TV POINTER TO A VARIABLE DESCRIPTOR
2099 003b                    VARDES    RMB  2              ; TEMP POINTER TO A VARIABLE DESCRIPTOR
2100 003d                    RELPTR    RMB  2              ; POINTER TO RELATIONAL OPERATOR PROCESSING ROUTINE
2101 003f                    TRELFL    RMB  1              ; TEMPORARY RELATIONAL OPERATOR FLAG BYTE
2102                         * FLOATING POINT ACCUMULATORS #3,4 & 5 ARE MOSTLY
2103                         * USED AS SCRATCH PAD VARIABLES.
2104                         ** FLOATING POINT ACCUMULATOR #3 :PACKED: ($40-$44)
2105 0040                    V40       RMB  1
2106 0041                    V41       RMB  1
2107 0042                    V42       RMB  1
2108 0043                    V43       RMB  1
2109 0044                    V44       RMB  1
2110                         ** FLOATING POINT ACCUMULATOR #4 :PACKED: ($45-$49)
2111 0045                    V45       RMB  1
2112 0046                    V46       RMB  1
2113 0047                    V47       RMB  1
2114 0048                    V48       RMB  2
2115                         ** FLOATING POINT ACCUMULATOR #5 :PACKED: ($4A-$4E)
2116 004a                    V4A       RMB  1
2117 004b                    V4B       RMB  2
2118 004d                    V4D       RMB  2
2119                         ** FLOATING POINT ACCUMULATOR #0
2120 004f                    FP0EXP    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #0 EXPONENT
2121 0050                    FPA0      RMB  4              ; *PV FLOATING POINT ACCUMULATOR #0 MANTISSA
2122 0054                    FP0SGN    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #0 SIGN
2123 0055                    COEFCT    RMB  1              ; POLYNOMIAL COEFFICIENT COUNTER
2124 0056                    STRDES    RMB  5              ; TEMPORARY STRING DESCRIPTOR
2125 005b                    FPCARY    RMB  1              ; FLOATING POINT CARRY BYTE
2126                         ** FLOATING POINT ACCUMULATOR #1
2127 005c                    FP1EXP    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #1 EXPONENT
2128 005d                    FPA1      RMB  4              ; *PV FLOATING POINT ACCUMULATOR #1 MANTISSA
2129 0061                    FP1SGN    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #1 SIGN
2130 0062                    RESSGN    RMB  1              ; SIGN OF RESULT OF FLOATING POINT OPERATION
2131 0063                    FPSBYT    RMB  1              ; FLOATING POINT SUB BYTE (FIFTH BYTE)
2132 0064                    COEFPT    RMB  2              ; POLYNOMIAL COEFFICIENT POINTER
2133 0066                    LSTTXT    RMB  2              ; CURRENT LINE POINTER DURING LIST
2134 0068                    CURLIN    RMB  2              ; *PV CURRENT LINE # OF BASIC PROGRAM, $FFFF = DIRECT
2135 006a                    DEVCFW    RMB  1              ; *TV TAB FIELD WIDTH
2136 006b                    DEVLCF    RMB  1              ; *TV TAB ZONE
2137 006c                    DEVPOS    RMB  1              ; *TV PRINT POSITION
2138 006d                    DEVWID    RMB  1              ; *TV PRINT WIDTH
2139 006e                    RSTFLG    RMB  1              ; *PV WARM START FLAG: $55=WARM, OTHER=COLD
2140 006f                    RSTVEC    RMB  2              ; *PV WARM START VECTOR - JUMP ADDRESS FOR WARM START
2141 0071                    TOPRAM    RMB  2              ; *PV TOP OF RAM
2142 0073                    IKEYIM    RMB  1              ; *TV INKEY$ RAM IMAGE
2143 0074                    ZERO      RMB  2              ; *PV DUMMY - THESE TWO BYTES ARE ALWAYS ZERO
2144                         * THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM
2145 0076                    LPTCFW    RMB  1              ; 16
2146 0077                    LPTLCF    RMB  1              ; 112
2147 0078                    LPTWID    RMB  1              ; 132
2148 0079                    LPTPOS    RMB  1              ; 0
2149 007a                    EXECJP    RMB  2              ; LB4AA
2150                         
2151                         * THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM
2152                         * BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE
2153                         * INTERPRETED IS STORED AT CHARAD.
2154 007c 0c 84              GETNCH    INC  <CHARAD+1      ; *PV INCREMENT LS BYTE OF INPUT POINTER
2155 007e 26 02                        BNE  GETCCH         ; *PV BRANCH IF NOT ZERO (NO CARRY)
2156 0080 0c 83                        INC  <CHARAD        ; *PV INCREMENT MS BYTE OF INPUT POINTER
2157 0082 b6                 GETCCH    FCB  $B6            ; *PV OP CODE OF LDA EXTENDED
2158 0083                    CHARAD    RMB  2              ; *PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT
2159                         *         *    CHARACTER WHICH THE BASIC INTERPRETER IS
2160                         *         *    PROCESSING
2161 0085 7e d1 c2                     JMP  BROMHK         ; JUMP BACK INTO THE BASIC RUM
2162                         
2163 0088                    VAB       RMB  1              ; = LOW ORDER FOUR BYTES OF THE PRODUCT
2164 0089                    VAC       RMB  1              ; = OF A FLOATING POINT MULTIPLICATION
2165 008a                    VAD       RMB  1              ; = THESE BYTES ARE USE AS RANDOM DATA
2166 008b                    VAE       RMB  1              ; = BY THE RND STATEMENT
2167                         
2168                         * EXTENDED BASIC VARIABLES
2169 008c                    TRCFLG    RMB  1              ; *PV TRACE FLAG 0=OFF ELSE=ON
2170 008d                    USRADR    RMB  2              ; *PV ADDRESS OF THE START OF USR VECTORS
2171                         
2172                         * EXTENDED BASIC SCRATCH PAD VARIABLES
2173 008f                    VCF       RMB  2
2174 0091                    VD1       RMB  2
2175 0093                    VD3       RMB  2
2176 0095                    VD5       RMB  2
2177 0097                    VD7       RMB  1
2178 0098                    VD8       RMB  1
2179 0099                    VD9       RMB  1
2180 009a                    VDA       RMB  1
2181 009b                    SW3VEC    RMB  3
2182 009e                    SW2VEC    RMB  3
2183 00a1                    SWIVEC    RMB  3
2184 00a4                    NMIVEC    RMB  3
2185 00a7                    IRQVEC    RMB  3
2186 00aa                    FRQVEC    RMB  3
2187 00ad                    USRJMP    RMB  3              ; JUMP ADDRESS FOR BASIC'S USR FUNCTION
2188 00b0                    RVSEED    RMB  1              ; * FLOATING POINT RANDOM NUMBER SEED EXPONENT
2189 00b1                              RMB  4              ; * MANTISSA: INITIALLY SET TO $804FC75259
2190                         
2191                         **** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)
2192 00b5                    USR0      RMB  2              ; USR 0 VECTOR
2193 00b7                              RMB  2              ; USR 1
2194 00b9                              RMB  2              ; USR 2
2195 00bb                              RMB  2              ; USR 3
2196 00bd                              RMB  2              ; USR 4
2197 00bf                              RMB  2              ; USR 5
2198 00c1                              RMB  2              ; USR 6
2199 00c3                              RMB  2              ; USR 7
2200 00c5                              RMB  2              ; USR 8
2201 00c7                              RMB  2              ; USR 9
2202                         
2203 00c9                    STRSTK    RMB  8*5            ; STRING DESCRIPTOR STACK
2204 00f1                    LINHDR    RMB  2              ; LINE INPUT BUFFER HEADER
2205 00f3                    LINBUF    RMB  LBUFMX+1       ; BASIC LINE INPUT BUFFER
2206 01ee                    STRBUF    RMB  41             ; STRING BUFFER
2207                         
2208 0217                    PROGST    RMB  1              ; START OF PROGRAM SPACE
2209                         *         INTERRUPT VECTORS
2210                         *          ORG  $FFF2
2211                         *SWI3      RMB  2
2212                         *SWI2      RMB  2
2213                         *FIRQ      RMB  2
2214                         *IRQ       RMB  2
2215                         *SWI       RMB  2
2216                         *NMI       RMB  2
2217                         *RESETV    RMB  2
2218                         
2219 d000                              ORG  $D000
2220                         
2221                         * JUMP TO BASIC COLD START AT START OF ROM FOR CONVENIENCE
2222 d000 7e d0 49                     JMP   RESVEC
2223                         
2224                         * CONSOLE IN
2225 d003 8d 03              LA171     BSR  KEYIN          ; GET A CHARACTER FROM CONSOLE IN
2226 d005 27 fc                        BEQ  LA171          ; LOOP IF NO KEY DOWN
2227 d007 39                           RTS
2228                         
2229                         *
2230                         * THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A KEY
2231                         * IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DOWN.
2232                         *
2233                         *
2234                         LA1C1
2235 d008 b6 a0 00           KEYIN     LDA  USTAT
2236 d00b 85 01                        BITA #1
2237 d00d 27 06                        BEQ  NOCHAR
2238 d00f b6 a0 01                     LDA  RECEV
2239 d012 84 7f                        ANDA #$7F
2240 d014 39                           RTS
2241 d015 4f                 NOCHAR    CLRA
2242 d016 39                           RTS
2243                         
2244                         
2245                         
2246                         * CONSOLE OUT
2247 d017 8d 24              PUTCHR    BSR  WAITACIA
2248 d019 34 02                        PSHS A              ;
2249 d01b 81 0d                        CMPA #CR            ; IS IT CARRIAGE RETURN?
2250 d01d 27 0b                        BEQ  NEWLINE        ; YES
2251 d01f b7 a0 01                     STA  TRANS
2252 d022 0c 79                        INC  LPTPOS         ; INCREMENT CHARACTER COUNTER
2253 d024 96 79                        LDA  LPTPOS         ; CHECK FOR END OF LINE PRINTER LINE
2254 d026 91 78                        CMPA LPTWID         ; AT END OF LINE PRINTER LINE?
2255 d028 25 10                        BLO  PUTEND         ; NO
2256 d02a 0f 79              NEWLINE   CLR  LPTPOS         ; RESET CHARACTER COUNTER
2257 d02c 8d 0f                        BSR  WAITACIA
2258 d02e 86 0d                        LDA  #13
2259 d030 b7 a0 01                     STA  TRANS
2260 d033 8d 08                        BSR  WAITACIA
2261 d035 86 0a                        LDA  #10            ; DO LINEFEED AFTER CR
2262 d037 b7 a0 01                     STA  TRANS
2263 d03a 35 02              PUTEND    PULS A              ;
2264 d03c 39                           RTS
2265                         
2266 d03d 34 02              WAITACIA  PSHS A
2267 d03f b6 a0 00           WRWAIT    LDA  USTAT
2268 d042 85 02                        BITA #2
2269 d044 27 f9                        BEQ  WRWAIT
2270 d046 35 02                        PULS A              ;
2271 d048 39                           RTS
2272                         
2273                         *
2274                         RESVEC
2275 d049 10 ce 01 ee        LA00E     LDS  #LINBUF+LBUFMX+1 ; SET STACK TO TOP OF LINE INPUT BUFFER
2276 d04d 96 6e                        LDA  RSTFLG         ; GET WARM START FLAG
2277 d04f 81 55                        CMPA #$55           ; IS IT A WARM START?
2278 d051 26 0a                        BNE  BACDST         ; NO - D0 A COLD START
2279 d053 9e 6f                        LDX  RSTVEC         ; WARM START VECTOR
2280 d055 a6 84                        LDA  ,X             ; GET FIRST BYTE OF WARM START ADDR
2281 d057 81 12                        CMPA #$12           ; IS IT NOP?
2282 d059 26 02                        BNE  BACDST         ; NO - DO A COLD START
2283 d05b 6e 84                        JMP  ,X             ; YES, G0 THERE
2284                         
2285                         * COLD START ENTRY
2286                         
2287 d05d 8e 02 18           BACDST    LDX  #PROGST+1      ; POINT X TO CLEAR 1ST 1K OF RAM
2288 d060 6f 83              LA077     CLR  ,--X           ; MOVE POINTER DOWN TWO-CLEAR BYTE
2289 d062 30 01                        LEAX 1,X            ; ADVANCE POINTER ONE
2290 d064 26 fa                        BNE  LA077          ; KEEP GOING IF NOT AT BOTTOM OF PAGE 0
2291 d066 8e 02 17                     LDX  #PROGST        ; SET TO START OF PROGRAM SPACE
2292 d069 6f 80                        CLR  ,X+            ; CLEAR 1ST BYTE OF BASIC PROGRAM
2293 d06b 9f 19                        STX  TXTTAB         ; BEGINNING OF BASIC PROGRAM
2294 d06d a6 02              LA084     LDA  2,X            ; LOOK FOR END OF MEMORY
2295 d06f 43                           COMA                ; * COMPLEMENT IT AND PUT IT BACK
2296 d070 a7 02                        STA  2,X            ; * INTO SYSTEM MEMORY
2297 d072 a1 02                        CMPA 2,X            ; IS IT RAM?
2298 d074 26 06                        BNE  LA093          ; BRANCH IF NOT (ROM, BAD RAM OR NO RAM)
2299 d076 30 01                        LEAX 1,X            ; MOVE POINTER UP ONE
2300 d078 63 01                        COM  1,X            ; RE-COMPLEMENT TO RESTORE BYTE
2301 d07a 20 f1                        BRA  LA084          ; KEEP LOOKING FOR END OF RAM
2302 d07c 9f 71              LA093     STX  TOPRAM         ; SAVE ABSOLUTE TOP OF RAM
2303 d07e 9f 27                        STX  MEMSIZ         ; SAVE TOP OF STRING SPACE
2304 d080 9f 23                        STX  STRTAB         ; SAVE START OF STRING VARIABLES
2305 d082 30 89 ff 38                  LEAX -200,X         ; CLEAR 200 - DEFAULT STRING SPACE TO 200 BYTES
2306 d086 9f 21                        STX  FRETOP         ; SAVE START OF STRING SPACE
2307 d088 1f 14                        TFR  X,S            ; PUT STACK THERE
2308 d08a 8e d0 d1                     LDX  #LA10D         ; POINT X TO ROM SOURCE DATA
2309 d08d ce 00 76                     LDU  #LPTCFW        ; POINT U TO RAM DESTINATION
2310 d090 c6 12                        LDB  #18            ; MOVE 18 BYTES
2311 d092 bd d1 b1                     JSR  LA59A          ; MOVE 18 BYTES FROM ROM TO RAM
2312 d095 ce 00 a7                     LDU  #IRQVEC        ; POINT U TO NEXT RAM DESTINATION
2313 d098 c6 04                        LDB  #4             ; MOVE 4 MORE BYTES
2314 d09a bd d1 b1                     JSR  LA59A          ; MOVE 4 BYTES FROM ROM TO RAM
2315 d09d 86 39                        LDA  #$39
2316 d09f 97 f0                        STA  LINHDR-1       ; PUT RTS IN LINHDR-1
2317 d0a1 bd d4 bd                     JSR  LAD19          ; G0 DO A 'NEW'
2318                         * EXTENDED BASIC INITIALISATION
2319 d0a4 8e 00 b5                     LDX  #USR0          ; INITIALIZE ADDRESS OF START OF
2320 d0a7 9f 8d                        STX  USRADR         ; USR JUMP TABLE
2321                         * INITIALIZE THE USR CALLS TO 'FC ERROR'
2322 d0a9 ce db d1                     LDU  #LB44A         ; ADDRESS OF 'FC ERROR' ROUTINE
2323 d0ac c6 0a                        LDB  #10            ; 10 USR CALLS IN EX BASIC
2324 d0ae ef 81              L8031     STU  ,X++           ; STORE 'FC' ERROR AT USR ADDRESSES
2325 d0b0 5a                           DECB                ; FINISHED ALL 10?
2326 d0b1 26 fb                        BNE  L8031          ; NO
2327                         
2328                         * INITIALISE ACIA
2329 d0b3 86 15                        LDA  #RTS_LOW       ; DIV16 CLOCK -> 7372800 / 4 / 16 = 115200
2330 d0b5 b7 a0 00                     STA  UCTRL
2331 d0b8 8e d1 06                     LDX  #LA147-1       ; POINT X TO COLOR BASIC COPYRIGHT MESSAGE
2332 d0bb bd e0 e8                     JSR  LB99C          ; PRINT 'COLOR BASIC'
2333 d0be 8e d0 c9                     LDX  #BAWMST        ; WARM START ADDRESS
2334 d0c1 9f 6f                        STX  RSTVEC         ; SAVE IT
2335 d0c3 86 55                        LDA  #$55           ; WARM START FLAG
2336 d0c5 97 6e                        STA  RSTFLG         ; SAVE IT
2337 d0c7 20 04                        BRA  LA0F3          ; GO TO BASIC'S MAIN LOOP
2338 d0c9 12                 BAWMST    NOP                 ; NOP REQ'D FOR WARM START
2339 d0ca bd d4 d7                     JSR  LAD33          ; DO PART OF A NEW
2340 d0cd 7e d4 25           LA0F3     JMP  LAC73          ; GO TO MAIN LOOP OF BASIC
2341                         *
2342                         * FIRQ SERVICE ROUTINE
2343                         BFRQSV
2344 d0d0 3b                           RTI
2345                         *
2346                         * THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIRECT PAGE
2347 d0d1 10                 LA10D     FCB  16             ; TAB FIELD WIDTH
2348 d0d2 40                           FCB  64             ; LAST TAB ZONE
2349 d0d3 50                           FCB  80             ; PRINTER WIDTH
2350 d0d4 00                           FCB  0              ; LINE PRINTER POSITION
2351 d0d5 db d1                        FDB  LB44A          ; ARGUMENT OF EXEC COMMAND - SET TO 'FC' ERROR
2352                         * LINE INPUT ROUTINE
2353 d0d7 0c 84                        INC  CHARAD+1
2354 d0d9 26 02                        BNE  LA123
2355 d0db 0c 83                        INC  CHARAD
2356 d0dd b6 00 00           LA123     LDA  >0000
2357 d0e0 7e d1 c2                     JMP  BROMHK
2358                         *
2359                         * THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1
2360 d0e3 7e d1 c1                     JMP  BIRQSV         ; IRQ SERVICE
2361 d0e6 7e d0 d0                     JMP  BFRQSV         ; FIRQ SERVICE
2362 d0e9 7e db d1                     JMP  LB44A          ; USR ADDRESS FOR 8K BASIC (INITIALIZED TO 'FC' ERROR)
2363 d0ec 80                           FCB  $80            ; *RANDOM SEED
2364 d0ed 4f c7                        FDB  $4FC7          ; *RANDON SEED OF MANTISSA
2365 d0ef 52 59                        FDB  $5259          ; *.811635157
2366                         * BASIC COMMAND INTERPRETATION TABLE ROM IMAGE
2367 d0f1 32                 COMVEC    FCB  50             ; 50 BASIC COMMANDS
2368 d0f2 d2 20                        FDB  LAA66          ; POINTS TO RESERVED WORDS
2369 d0f4 d3 2d                        FDB  LAB67          ; POINTS TO JUMP TABLE FOR COMMANDS
2370 d0f6 1d                           FCB  29             ; 29 BASIC SECONDARY COMMANDS
2371 d0f7 d2 c0                        FDB  LAB1A          ; POINTS TO SECONDARY FUNCTION RESERVED WORDS
2372 d0f9 d1 d1                        FDB  LAA29          ; POINTS TO SECONDARY FUNCTION JUMP TABLE
2373 d0fb 00 00                        FDB  0              ; NO MORE TABLES (RES WORDS=0)
2374 d0fd 00 00                        FDB  0              ; NO MORE TABLES
2375 d0ff 00 00                        FDB  0              ; NO MORE TABLES
2376 d101 00 00                        FDB  0              ; NO MORE TABLES
2377 d103 00 00                        FDB  0              ; NO MORE TABLES
2378 d105 00 00                        FDB  0              ; NO MORE TABLES (SECONDARY FNS =0)
2379                         
2380                         * COPYRIGHT MESSAGES
2381 d107 36 38 30 39 20 45  LA147     FCC  "6809 EXTENDED BASIC"
     58 54 45 4e 44 45
     44 20 42 41 53 49
     43
2382 d11a 0d                           FCB  CR
2383 d11b 28 43 29 20 31 39            FCC  "(C) 1982 BY MICROSOFT"
     38 32 20 42 59 20
     4d 49 43 52 4f 53
     4f 46 54
2384 d130 0d 0d              LA156     FCB  CR,CR
2385 d132 00                 LA165     FCB  $00
2386                         
2387                         
2388 d133 34 16              LA35F     PSHS X,B,A          ; SAVE REGISTERS
2389 d135 9e 76                        LDX  LPTCFW         ; TAB FIELD WIDTH AND TAB ZONE
2390 d137 dc 78                        LDD  LPTWID         ; PRINTER WIDTH AND POSITION
2391 d139 9f 6a              LA37C     STX  DEVCFW         ; SAVE TAB FIELD WIDTH AND ZONE
2392 d13b d7 6c                        STB  DEVPOS         ; SAVE PRINT POSITION
2393 d13d 97 6d                        STA  DEVWID         ; SAVE PRINT WIDTH
2394 d13f 35 96                        PULS A,B,X,PC       ; RESTORE REGISTERS
2395                         
2396                         * THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASIC
2397                         * EXIT WITH BREAK KEY: CARRY = 1
2398                         * EXIT WITH ENTER KEY: CARRY = 0
2399                         LA38D
2400 d141 0f 73              LA390     CLR  IKEYIM         ; RESET BREAK CHECK KEY TEMP KEY STORAGE
2401 d143 8e 00 f4                     LDX  #LINBUF+1      ; INPUT LINE BUFFER
2402 d146 c6 01                        LDB  #1             ; ACCB CHAR COUNTER: SET TO 1 TO ALLOW A
2403                         *         BACKSPACE AS FIRST CHARACTER
2404 d148 bd d0 03           LA39A     JSR  LA171          ; GO GET A CHARACTER FROM CONSOLE IN
2405 d14b 81 08                        CMPA #BS            ; BACKSPACE
2406 d14d 26 07                        BNE  LA3B4          ; NO
2407 d14f 5a                           DECB                ; YES - DECREMENT CHAR COUNTER
2408 d150 27 ef                        BEQ  LA390          ; BRANCH IF BACK AT START OF LINE AGAIN
2409 d152 30 1f                        LEAX -1,X           ; DECREMENT BUFFER POINTER
2410 d154 20 34                        BRA  LA3E8          ; ECHO CHAR TO SCREEN
2411 d156 81 15              LA3B4     CMPA #$15           ; SHIFT RIGHT ARROW?
2412 d158 26 0a                        BNE  LA3C2          ; NO
2413                         * YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LINE
2414 d15a 5a                 LA3B8     DECB                ; DEC CHAR CTR
2415 d15b 27 e4                        BEQ  LA390          ; GO BACK TO START IF CHAR CTR = 0
2416 d15d 86 08                        LDA  #BS            ; BACKSPACE?
2417 d15f bd d0 17                     JSR  PUTCHR         ; SEND TO CONSOLE OUT (SCREEN)
2418 d162 20 f6                        BRA  LA3B8          ; KEEP GOING
2419 d164 81 03              LA3C2     CMPA #3             ; BREAK KEY?
2420 d166 1a 01                        ORCC #1             ; SET CARRY FLAG
2421 d168 27 05                        BEQ  LA3CD          ; BRANCH IF BREAK KEY DOWN
2422 d16a 81 0d              LA3C8     CMPA #CR            ; ENTER KEY?
2423 d16c 26 0d                        BNE  LA3D9          ; NO
2424 d16e 4f                 LA3CC     CLRA                ; CLEAR CARRY FLAG IF ENTER KEY - END LINE ENTRY
2425 d16f 34 01              LA3CD     PSHS CC             ; SAVE CARRY FLAG
2426 d171 bd e0 a8                     JSR  LB958          ; SEND CR TO SCREEN
2427 d174 6f 84                        CLR  ,X             ; MAKE LAST BYTE IN INPUT BUFFER = 0
2428 d176 8e 00 f3                     LDX  #LINBUF        ; RESET INPUT BUFFER POINTER
2429 d179 35 81                        PULS CC,PC          ; RESTORE CARRY FLAG
2430                         
2431                         * INSERT A CHARACTER INTO THE BASIC LINE INPUT BUFFER
2432 d17b 81 20              LA3D9     CMPA #$20           ; IS IT CONTROL CHAR?
2433 d17d 25 c9                        BLO  LA39A          ; BRANCH IF CONTROL CHARACTER
2434 d17f 81 7b                        CMPA #'z+1          ; *
2435 d181 24 c5                        BCC  LA39A          ; * IGNORE IF > LOWER CASE Z
2436 d183 c1 fa                        CMPB #LBUFMX        ; HAVE 250 OR MORE CHARACTERS BEEN ENTERED?
2437 d185 24 c1                        BCC  LA39A          ; YES, IGNORE ANY MORE
2438 d187 a7 80                        STA  ,X+            ; PUT IT IN INPUT BUFFER
2439 d189 5c                           INCB                ; INCREMENT CHARACTER COUNTER
2440 d18a bd d0 17           LA3E8     JSR  PUTCHR         ; ECHO IT TO SCREEN
2441 d18d 20 b9                        BRA  LA39A          ; GO SET SOME MORE
2442                         
2443                         
2444                         * EXEC
2445 d18f 27 05              EXEC      BEQ  LA545          ; BRANCH IF NO ARGUMENT
2446 d191 bd de c4                     JSR  LB73D          ; EVALUATE ARGUMENT - ARGUMENT RETURNED IN X
2447 d194 9f 7a                        STX  EXECJP         ; STORE X TO EXEC JUMP ADDRESS
2448 d196 6e 9f 00 7a        LA545     JMP  [EXECJP]       ; GO DO IT
2449                         
2450                         * BREAK CHECK
2451 d19a 7e d5 a6           LA549     JMP  LADEB          ; GO DO BREAK KEY CHECK
2452                         
2453                         * INKEY$
2454 d19d 96 73              INKEY     LDA  IKEYIM         ; WAS A KEY DOWN IN THE BREAK CHECK?
2455 d19f 26 03                        BNE  LA56B          ; YES
2456 d1a1 bd d0 08                     JSR  KEYIN          ; GO GET A KEY
2457 d1a4 0f 73              LA56B     CLR  IKEYIM         ; CLEAR INKEY RAM IMAGE
2458 d1a6 97 53                        STA  FPA0+3         ; STORE THE KEY IN FPA0
2459 d1a8 10 26 0c 6a                  LBNE LB68F          ; CONVERT FPA0+3 TO A STRING
2460 d1ac 97 56                        STA  STRDES         ; SET LENGTH OF STRING = 0 IF NO KEY DOWN
2461 d1ae 7e de 22                     JMP  LB69B          ; PUT A NULL STRING ONTO THE STRING STACK
2462                         
2463                         * MOVE ACCB BYTES FROM (X) TO (U)
2464 d1b1 a6 80              LA59A     LDA  ,X+            ; GET BYTE FROM X
2465 d1b3 a7 c0                        STA  ,U+            ; STORE IT AT U
2466 d1b5 5a                           DECB                ; MOVED ALL BYTES?
2467 d1b6 26 f9                        BNE  LA59A          ; NO
2468 d1b8 39                 LA5A1     RTS
2469                         
2470 d1b9 39                 LA5C4     RTS
2471                         
2472                         ** THIS ROUTINE WILL SCAN OFF THE FILE NAME FROM A BASIC LINE
2473                         ** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTERS
2474                         ** FOLLOWING THE END OF THE NAME
2475 d1ba 9d 82              LA5C7     JSR  GETCCH         ; GET CURRENT INPUT CHAR FROM BASIC LINE
2476 d1bc 27 fb              LA5C9     BEQ  LA5C4          ; RETURN IF END OF LINE
2477 d1be 7e da 03                     JMP  LB277          ; SYNTAX ERROR IF ANY MORE CHARACTERS
2478                         * IRQ SERVICE
2479                         BIRQSV
2480 d1c1 3b                 LA9C5     RTI                 ; RETURN FROM INTERRUPT
2481                         
2482                         * SET CARRY IF NUMERIC - RETURN WITH
2483                         * ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END
2484                         * OF BASIC LINE OR SUB LINE
2485 d1c2 81 3a              BROMHK    CMPA #'9+1          ; IS THIS CHARACTER >=(ASCII 9)+1?
2486 d1c4 24 0a                        BHS  LAA28          ; BRANCH IF > 9; Z SET IF = COLON
2487 d1c6 81 20                        CMPA #SPACE         ; SPACE?
2488 d1c8 26 02                        BNE  LAA24          ; NO - SET CARRY IF NUMERIC
2489 d1ca 0e 7c                        JMP  GETNCH         ; IF SPACE, GET NECT CHAR (IGNORE SPACES)
2490 d1cc 80 30              LAA24     SUBA #'0            ; * SET CARRY IF
2491 d1ce 80 d0                        SUBA #-'0           ; * CHARACTER > ASCII 0
2492 d1d0 39                 LAA28     RTS
2493                         
2494                         * DISPATCH TABLE FOR SECONDARY FUNCTIONS
2495                         * TOKENS ARE PRECEEDED BY $FF
2496                         * FIRST SET ALWAYS HAS ONE PARAMETER
2497                         FUNC_TAB
2498 d1d1 e3 c6              LAA29     FDB  SGN            ; SGN
2499 d1d3 e4 3a                        FDB  INT            ; INT
2500 d1d5 e3 df                        FDB  ABS            ; ABS
2501 d1d7 00 ad                        FDB  USRJMP         ; USR
2502 0083                    TOK_USR   EQU  *-FUNC_TAB/2+$7F
2503 ff83                    TOK_FF_USR EQU  *-FUNC_TAB/2+$FF7F
2504 d1d9 e6 6b                        FDB  RND            ; RND
2505 d1db e6 c0                        FDB  SIN            ; SIN
2506 d1dd de d7                        FDB  PEEK           ; PEEK
2507 d1df de 08                        FDB  LEN            ; LEN
2508 d1e1 dc 84                        FDB  STR            ; STR$
2509 d1e3 de 9d                        FDB  VAL            ; VAL
2510 d1e5 de 27                        FDB  ASC            ; ASC
2511 d1e7 de 13                        FDB  CHR            ; CHR$
2512 d1e9 e7 70                        FDB  ATN            ; ATN
2513 d1eb e7 38                        FDB  COS            ; COS
2514 d1ed e7 41                        FDB  TAN            ; TAN
2515 d1ef e8 b2                        FDB  EXP            ; EXP
2516 d1f1 e8 e4                        FDB  FIX            ; FIX
2517 d1f3 e8 06                        FDB  LOG            ; LOG
2518 d1f5 ea 6c                        FDB  POS            ; POS
2519 d1f7 e8 40                        FDB  SQR            ; SQR
2520 d1f9 ef 3e                        FDB  HEXDOL         ; HEX$
2521                         * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
2522 d1fb de 32                        FDB  LEFT           ; LEFT$
2523 0095                    TOK_LEFT  EQU  *-FUNC_TAB/2+$7F
2524 d1fd de 4f                        FDB  RIGHT          ; RIGHT$
2525 d1ff de 56                        FDB  MID            ; MID$
2526 0097                    TOK_MID   EQU  *-FUNC_TAB/2+$7F
2527                         * REMAINING FUNCTIONS
2528 d201 d1 9d                        FDB  INKEY          ; INKEY$
2529 0098                    TOK_INKEY EQU  *-FUNC_TAB/2+$7F
2530 d203 dc 75                        FDB  MEM            ; MEM
2531 d205 ea 74                        FDB  VARPT          ; VARPTR
2532 d207 eb 34                        FDB  INSTR          ; INSTR
2533 d209 eb 04                        FDB  STRING         ; STRING$
2534 001d                    NUM_SEC_FNS EQU  *-FUNC_TAB/2
2535                         
2536                         * THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESSES FOR ARITHMETIC
2537                         * AND LOGICAL OPERATORS - THE NEGATION OPERATORS DO NOT ACT ON TWO OPERANDS
2538                         * S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREATED SEPARATELY IN THE
2539                         * EXPRESSION EVALUATION ROUTINE. THEY ARE:
2540                         * UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGATION (NOT), PRECEDENCE $5A
2541                         * THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, PRECEDENCE $64.
2542                         * A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSION OR PARENTHESES
2543                         *
2544 d20b 79                 LAA51     FCB  $79
2545 d20c e1 11                        FDB  LB9C5          ; +
2546 d20e 79                           FCB  $79
2547 d20f e1 08                        FDB  LB9BC          ; -
2548 d211 7b                           FCB  $7B
2549 d212 e2 18                        FDB  LBACC          ; *
2550 d214 7b                           FCB  $7B
2551 d215 e2 dd                        FDB  LBB91          ; /
2552 d217 7f                           FCB  $7F
2553 d218 e8 49                        FDB  L8489          ; EXPONENTIATION
2554 d21a 50                           FCB  $50
2555 d21b da 5c                        FDB  LB2D5          ; AND
2556 d21d 46                           FCB  $46
2557 d21e da 5b                        FDB  LB2D4          ; OR
2558                         
2559                         * THIS IS THE RESERVED WORD TABLE
2560                         * FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS
2561 d220 46 4f              LAA66     FCC  "FO"           ; 80
2562 d222 d2                           FCB  $80+'R
2563 d223 47                           FCC  "G"            ; 81
2564 d224 cf                           FCB  $80+'O
2565 0081                    TOK_GO    EQU  $81
2566 d225 52 45                        FCC  "RE"           ; 82
2567 d227 cd                           FCB  $80+'M
2568 d228 a7                           FCB  ''+$80         ; 83
2569 d229 45 4c 53                     FCC  "ELS"          ; 84
2570 d22c c5                           FCB  $80+'E
2571 d22d 49                           FCC  "I"            ; 85
2572 d22e c6                           FCB  $80+'F
2573 d22f 44 41 54                     FCC  "DAT"          ; 86
2574 d232 c1                           FCB  $80+'A
2575 d233 50 52 49 4e                  FCC  "PRIN"         ; 87
2576 d237 d4                           FCB  $80+'T
2577 d238 4f                           FCC  "O"            ; 88
2578 d239 ce                           FCB  $80+'N
2579 d23a 49 4e 50 55                  FCC  "INPU"         ; 89
2580 d23e d4                           FCB  $80+'T
2581 d23f 45 4e                        FCC  "EN"           ; 8A
2582 d241 c4                           FCB  $80+'D
2583 d242 4e 45 58                     FCC  "NEX"          ; 8B
2584 d245 d4                           FCB  $80+'T
2585 d246 44 49                        FCC  "DI"           ; 8C
2586 d248 cd                           FCB  $80+'M
2587 d249 52 45 41                     FCC  "REA"          ; 8D
2588 d24c c4                           FCB  $80+'D
2589 d24d 52 55                        FCC  "RU"           ; 8E
2590 d24f ce                           FCB  $80+'N
2591 d250 52 45 53 54 4f 52            FCC  "RESTOR"       ; 8F
2592 d256 c5                           FCB  $80+'E
2593 d257 52 45 54 55 52               FCC  "RETUR"        ; 90
2594 d25c ce                           FCB  $80+'N
2595 d25d 53 54 4f                     FCC  "STO"          ; 91
2596 d260 d0                           FCB  $80+'P
2597 d261 50 4f 4b                     FCC  "POK"          ; 92
2598 d264 c5                           FCB  $80+'E
2599 d265 43 4f 4e                     FCC  "CON"          ; 93
2600 d268 d4                           FCB  $80+'T
2601 d269 4c 49 53                     FCC  "LIS"          ; 94
2602 d26c d4                           FCB  $80+'T
2603 d26d 43 4c 45 41                  FCC  "CLEA"         ; 95
2604 d271 d2                           FCB  $80+'R
2605 d272 4e 45                        FCC  "NE"           ; 96
2606 d274 d7                           FCB  $80+'W
2607 d275 45 58 45                     FCC  "EXE"          ; 97
2608 d278 c3                           FCB  $80+'C
2609 d279 54 52 4f                     FCC  "TRO"          ; 98
2610 d27c ce                           FCB  $80+'N
2611 d27d 54 52 4f 46                  FCC  "TROF"         ; 99
2612 d281 c6                           FCB  $80+'F
2613 d282 44 45                        FCC  "DE"           ; 9A
2614 d284 cc                           FCB  $80+'L
2615 d285 44 45                        FCC  "DE"           ; 9B
2616 d287 c6                           FCB  $80+'F
2617 d288 4c 49 4e                     FCC  "LIN"          ; 9C
2618 d28b c5                           FCB  $80+'E
2619 d28c 52 45 4e 55                  FCC  "RENU"         ; 9D
2620 d290 cd                           FCB  $80+'M
2621 d291 45 44 49                     FCC  "EDI"          ; 9E
2622 d294 d4                           FCB  $80+'T
2623                         * END OF EXECUTABLE COMMANDS. THE REMAINDER OF THE TABLE ARE NON-EXECUTABLE TOKENS
2624 d295 54 41 42                     FCC  "TAB"          ; 9F
2625 d298 a8                           FCB  $80+'(
2626 009f                    TOK_TAB   EQU  $9F
2627 d299 54                           FCC  "T"            ; A0
2628 d29a cf                           FCB  $80+'O
2629 00a0                    TOK_TO    EQU  $A0
2630 d29b 53 55                        FCC  "SU"           ; A1
2631 d29d c2                           FCB  $80+'B
2632 00a1                    TOK_SUB   EQU  $A1
2633 d29e 54 48 45                     FCC  "THE"          ; A2
2634 d2a1 ce                           FCB  $80+'N
2635 00a2                    TOK_THEN  EQU  $A2
2636 d2a2 4e 4f                        FCC  "NO"           ; A3
2637 d2a4 d4                           FCB  $80+'T
2638 00a3                    TOK_NOT   EQU  $A3
2639 d2a5 53 54 45                     FCC  "STE"          ; A4
2640 d2a8 d0                           FCB  $80+'P
2641 00a4                    TOK_STEP  EQU  $A4
2642 d2a9 4f 46                        FCC  "OF"           ; A5
2643 d2ab c6                           FCB  $80+'F
2644 d2ac ab                           FCB  '++$80         ; A6
2645 00a6                    TOK_PLUS  EQU  $A6
2646 d2ad ad                           FCB  '-+$80         ; A7
2647 00a7                    TOK_MINUS EQU  $A7
2648 d2ae aa                           FCB  '*+$80         ; A8
2649 d2af af                           FCB  '/+$80         ; A9
2650 d2b0 de                           FCB  '^+$80         ; AA
2651 d2b1 41 4e                        FCC  "AN"           ; AB
2652 d2b3 c4                           FCB  $80+'D
2653 d2b4 4f                           FCC  "O"            ; AC
2654 d2b5 d2                           FCB  $80+'R
2655 d2b6 be                           FCB  '>+$80         ; AD
2656 00ad                    TOK_GREATER EQU  $AD
2657 d2b7 bd                           FCB  '=+$80         ; AE
2658 00ae                    TOK_EQUALS EQU  $AE
2659 d2b8 bc                           FCB  '<+$80         ; AF
2660 d2b9 46                           FCC  "F"            ; B0
2661 d2ba ce                           FCB  $80+'N
2662 00b0                    TOK_FN    EQU  $B0
2663 d2bb 55 53 49 4e                  FCC  "USIN"         ; B1
2664 d2bf c7                           FCB  $80+'G
2665 00b1                    TOK_USING EQU  $B1
2666                         *
2667                         
2668                         * FIRST SET ALWAYS HAS ONE PARAMETER
2669 d2c0 53 47              LAB1A     FCC  "SG"           ; 80
2670 d2c2 ce                           FCB  $80+'N
2671 d2c3 49 4e                        FCC  "IN"           ; 81
2672 d2c5 d4                           FCB  $80+'T
2673 d2c6 41 42                        FCC  "AB"           ; 82
2674 d2c8 d3                           FCB  $80+'S
2675 d2c9 55 53                        FCC  "US"           ; 83
2676 d2cb d2                           FCB  $80+'R
2677 d2cc 52 4e                        FCC  "RN"           ; 84
2678 d2ce c4                           FCB  $80+'D
2679 d2cf 53 49                        FCC  "SI"           ; 85
2680 d2d1 ce                           FCB  $80+'N
2681 d2d2 50 45 45                     FCC  "PEE"          ; 86
2682 d2d5 cb                           FCB  $80+'K
2683 d2d6 4c 45                        FCC  "LE"           ; 87
2684 d2d8 ce                           FCB  $80+'N
2685 d2d9 53 54 52                     FCC  "STR"          ; 88
2686 d2dc a4                           FCB  $80+'$
2687 d2dd 56 41                        FCC  "VA"           ; 89
2688 d2df cc                           FCB  $80+'L
2689 d2e0 41 53                        FCC  "AS"           ; 8A
2690 d2e2 c3                           FCB  $80+'C
2691 d2e3 43 48 52                     FCC  "CHR"          ; 8B
2692 d2e6 a4                           FCB  $80+'$
2693 d2e7 41 54                        FCC  "AT"           ; 8C
2694 d2e9 ce                           FCB  $80+'N
2695 d2ea 43 4f                        FCC  "CO"           ; 8D
2696 d2ec d3                           FCB  $80+'S
2697 d2ed 54 41                        FCC  "TA"           ; 8E
2698 d2ef ce                           FCB  $80+'N
2699 d2f0 45 58                        FCC  "EX"           ; 8F
2700 d2f2 d0                           FCB  $80+'P
2701 d2f3 46 49                        FCC  "FI"           ; 90
2702 d2f5 d8                           FCB  $80+'X
2703 d2f6 4c 4f                        FCC  "LO"           ; 91
2704 d2f8 c7                           FCB  $80+'G
2705 d2f9 50 4f                        FCC  "PO"           ; 92
2706 d2fb d3                           FCB  $80+'S
2707 d2fc 53 51                        FCC  "SQ"           ; 93
2708 d2fe d2                           FCB  $80+'R
2709 d2ff 48 45 58                     FCC  "HEX"          ; 94
2710 d302 a4                           FCB  $80+'$
2711                         * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
2712 d303 4c 45 46 54                  FCC  "LEFT"         ; 95
2713 d307 a4                           FCB  $80+'$
2714 d308 52 49 47 48 54               FCC  "RIGHT"        ; 96
2715 d30d a4                           FCB  $80+'$
2716 d30e 4d 49 44                     FCC  "MID"          ; 97
2717 d311 a4                           FCB  $80+'$
2718                         * REMAINING FUNCTIONS
2719 d312 49 4e 4b 45 59               FCC  "INKEY"        ; 98
2720 d317 a4                           FCB  $80+'$
2721 d318 4d 45                        FCC  "ME"           ; 99
2722 d31a cd                           FCB  $80+'M
2723 d31b 56 41 52 50 54               FCC  "VARPT"        ; 9A
2724 d320 d2                           FCB  $80+'R
2725 d321 49 4e 53 54                  FCC  "INST"         ; 9B
2726 d325 d2                           FCB  $80+'R
2727 d326 53 54 52 49 4e 47            FCC  "STRING"       ; 9C
2728 d32c a4                           FCB  $80+'$
2729                         
2730                         *
2731                         * DISPATCH TABLE FOR COMMANDS TOKEN #
2732                         CMD_TAB
2733 d32d d4 eb              LAB67     FDB  FOR            ; 80
2734 d32f d6 36                        FDB  GO             ; 81
2735 d331 d6 93                        FDB  REM            ; 82
2736 0082                    TOK_REM   EQU  *-CMD_TAB/2+$7F
2737 d333 d6 93                        FDB  REM            ; 83 (')
2738 0083                    TOK_SNGL_Q EQU  *-CMD_TAB/2+$7F
2739 d335 d6 93                        FDB  REM            ; 84 (ELSE)
2740 0084                    TOK_ELSE  EQU  *-CMD_TAB/2+$7F
2741 d337 d6 c4                        FDB  IF             ; 85
2742 0085                    TOK_IF    EQU  *-CMD_TAB/2+$7F
2743 d339 d6 90                        FDB  DATA           ; 86
2744 0086                    TOK_DATA  EQU  *-CMD_TAB/2+$7F
2745 d33b e0 6d                        FDB  PRINT          ; 87
2746 0087                    TOK_PRINT EQU  *-CMD_TAB/2+$7F
2747 d33d d6 f2                        FDB  ON             ; 88
2748 d33f d7 9f                        FDB  INPUT          ; 89
2749 0089                    TOK_INPUT EQU  *-CMD_TAB/2+$7F
2750 d341 d5 bd                        FDB  END            ; 8A
2751 d343 d8 84                        FDB  NEXT           ; 8B
2752 d345 da d5                        FDB  DIM            ; 8C
2753 d347 d7 d9                        FDB  READ           ; 8D
2754 d349 d6 2b                        FDB  RUN            ; 8E
2755 d34b d5 9f                        FDB  RESTOR         ; 8F
2756 d34d d6 70                        FDB  RETURN         ; 90
2757 d34f d5 c1                        FDB  STOP           ; 91
2758 d351 de de                        FDB  POKE           ; 92
2759 d353 d5 e6                        FDB  CONT           ; 93
2760 d355 de e5                        FDB  LIST           ; 94
2761 d357 d5 f7                        FDB  CLEAR          ; 95
2762 d359 d4 bb                        FDB  NEW            ; 96
2763 d35b d1 8f                        FDB  EXEC           ; 97
2764 d35d ea 67                        FDB  TRON           ; 98
2765 d35f ea 68                        FDB  TROFF          ; 99
2766 d361 ec e3                        FDB  DEL            ; 9A
2767 d363 ec 27                        FDB  DEF            ; 9B
2768 d365 f3 d1                        FDB  LINE           ; 9C
2769 d367 ed 6d                        FDB  RENUM          ; 9D
2770 d369 e8 f3                        FDB  EDIT           ; 9E
2771 009e                    TOK_HIGH_EXEC EQU  *-CMD_TAB/2+$7F
2772                         
2773                         * ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY
2774 d36b 4e 46              LABAF     FCC  "NF"           ; 0 NEXT WITHOUT FOR
2775 d36d 53 4e                        FCC  "SN"           ; 1 SYNTAX ERROR
2776 d36f 52 47                        FCC  "RG"           ; 2 RETURN WITHOUT GOSUB
2777 d371 4f 44                        FCC  "OD"           ; 3 OUT OF DATA
2778 d373 46 43                        FCC  "FC"           ; 4 ILLEGAL FUNCTION CALL
2779 d375 4f 56                        FCC  "OV"           ; 5 OVERFLOW
2780 d377 4f 4d                        FCC  "OM"           ; 6 OUT OF MEMORY
2781 d379 55 4c                        FCC  "UL"           ; 7 UNDEFINED LINE NUMBER
2782 d37b 42 53                        FCC  "BS"           ; 8 BAD SUBSCRIPT
2783 d37d 44 44                        FCC  "DD"           ; 9 REDIMENSIONED ARRAY
2784 d37f 2f 30                        FCC  "/0"           ; 10 DIVISION BY ZERO
2785 d381 49 44                        FCC  "ID"           ; 11 ILLEGAL DIRECT STATEMENT
2786 d383 54 4d                        FCC  "TM"           ; 12 TYPE MISMATCH
2787 d385 4f 53                        FCC  "OS"           ; 13 OUT OF STRING SPACE
2788 d387 4c 53                        FCC  "LS"           ; 14 STRING TOO LONG
2789 d389 53 54                        FCC  "ST"           ; 15 STRING FORMULA TOO COMPLEX
2790 d38b 43 4e                        FCC  "CN"           ; 16 CAN'T CONTINUE
2791 d38d 46 44                        FCC  "FD"           ; 17 BAD FILE DATA
2792 d38f 41 4f                        FCC  "AO"           ; 18 FILE ALREADY OPEN
2793 d391 44 4e                        FCC  "DN"           ; 19 DEVICE NUMBER ERROR
2794 d393 49 4f                        FCC  "IO"           ; 20 I/O ERROR
2795 d395 46 4d                        FCC  "FM"           ; 21 BAD FILE MODE
2796 d397 4e 4f                        FCC  "NO"           ; 22 FILE NOT OPEN
2797 d399 49 45                        FCC  "IE"           ; 23 INPUT PAST END OF FILE
2798 d39b 44 53                        FCC  "DS"           ; 24 DIRECT STATEMENT IN FILE
2799                         * ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC
2800 d39d 55 46              L890B     FCC  "UF"           ; 25 UNDEFINED FUNCTION (FN) CALL
2801 d39f 4e 45              L890D     FCC  "NE"           ; 26 FILE NOT FOUND
2802                         
2803 d3a1 20 45 52 52 4f 52  LABE1     FCC  " ERROR"
2804 d3a7 00                           FCB  $00
2805 d3a8 20 49 4e 20        LABE8     FCC  " IN "
2806 d3ac 00                           FCB  $00
2807 d3ad 0d                 LABED     FCB  CR
2808 d3ae 4f 4b              LABEE     FCC  "OK"
2809 d3b0 0d 00                        FCB  CR,$00
2810 d3b2 0d                 LABF2     FCB  CR
2811 d3b3 42 52 45 41 4b               FCC  "BREAK"
2812 d3b8 00                           FCB  $00
2813                         
2814                         * SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DATA.
2815                         * THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEING
2816                         * SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT DATA IS 18
2817                         * BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DATA IS 5 BYTES
2818                         * WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DATA
2819                         * IS CONSIDERED 'GOSUB/RETURN'
2820 d3b9 30 64              LABF9     LEAX 4,S            ; POINT X TO 3RD ADDRESS ON STACK - IGNORE THE
2821                         *         FIRST TWO RETURN ADDRESSES ON THE STACK
2822 d3bb c6 12              LABFB     LDB  #18            ; 18 BYTES SAVED ON STACK FOR EACH 'FOR' LOOP
2823 d3bd 9f 0f                        STX  TEMPTR         ; SAVE POINTER
2824 d3bf a6 84                        LDA  ,X             ; GET 1ST BYTE
2825 d3c1 80 80                        SUBA #$80           ; * CHECK FOR TYPE OF STACK JUMP FOUND
2826 d3c3 26 15                        BNE  LAC1A          ; * BRANCH IF NOT 'FOR/NEXT'
2827 d3c5 ae 01                        LDX  1,X            ; = GET INDEX VARIABLE DESCRIPTOR
2828 d3c7 9f 11                        STX  TMPTR1         ; = POINTER AND SAVE IT IN TMPTR1
2829 d3c9 9e 3b                        LDX  VARDES         ; GET INDEX VARIABLE BEING SEARCHED FOR
2830 d3cb 27 09                        BEQ  LAC16          ; BRANCH IF DEFAULT INDEX VARIABLE - USE THE
2831                         *                             ; FIRST 'FOR/NEXT' DATA FOUND ON STACK
2832                         *                             ; IF NO INDEX VARIABLE AFTER 'NEXT'
2833 d3cd 9c 11                        CMPX TMPTR1         ; DOES THE STACK INDEX MATCH THE ONE
2834                         *                             ; BEING SEARCHED FOR?
2835 d3cf 27 09                        BEQ  LAC1A          ; YES
2836 d3d1 9e 0f                        LDX  TEMPTR         ; * RESTORE INITIAL POINTER, ADD
2837 d3d3 3a                           ABX                 ; * 18 TO IT AND LOOK FOR
2838 d3d4 20 e5                        BRA  LABFB          ; * NEXT BLOCK OF DATA
2839 d3d6 9e 11              LAC16     LDX  TMPTR1         ; = GET 1ST INDEX VARIABLE FOUND AND
2840 d3d8 9f 3b                        STX  VARDES         ; = SAVE AS 'NEXT' INDEX
2841 d3da 9e 0f              LAC1A     LDX  TEMPTR         ; POINT X TO START OF 'FOR/NEXT' DATA
2842 d3dc 4d                           TSTA                ; SET ZERO FLAG IF 'FOR/NEXT' DATA
2843 d3dd 39                           RTS
2844                         * CHECK FOR MEMORY SPACE FOR NEW TOP OF
2845                         * ARRAYS AND MOVE ARRAYS TO NEW LOCATION
2846 d3de 8d 17              LAC1E     BSR  LAC37          ; ACCD = NEW BOTTOM OF FREE RAM - IS THERE
2847                         *                             ; ROOM FOR THE STACK?
2848                         * MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND
2849                         * SAVE FINAL VALUE OF U IN V45
2850 d3e0 de 41              LAC20     LDU  V41            ; POINT U TO DESTINATION ADDRESS (V41)
2851 d3e2 33 41                        LEAU 1,U            ; ADD ONE TO U - COMPENSATE FOR FIRST PSHU
2852 d3e4 9e 43                        LDX  V43            ; POINT X TO SOURCE ADDRESS (V43)
2853 d3e6 30 01                        LEAX 1,X            ; ADD ONE - COMPENSATE FOR FIRST LDA ,X
2854 d3e8 a6 82              LAC28     LDA  ,-X            ; GRAB A BYTE FROM SOURCE
2855 d3ea 36 02                        PSHU A              ; MOVE IT TO DESTINATION
2856 d3ec 9c 47                        CMPX V47            ; DONE?
2857 d3ee 26 f8                        BNE  LAC28          ; NO - KEEP MOVING BYTES
2858 d3f0 df 45                        STU  V45            ; SAVE FINAL DESTINATION ADDRESS
2859 d3f2 39                 LAC32     RTS
2860                         * CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB
2861                         * BYTES IN FREE RAM - OM ERROR IF NOT
2862 d3f3 4f                 LAC33     CLRA                ; * ACCD CONTAINS NUMBER OF EXTRA
2863 d3f4 58                           ASLB                ; * BYTES TO PUT ON STACK
2864 d3f5 d3 1f                        ADDD ARYEND         ; END OF PROGRAM AND VARIABLES
2865 d3f7 c3 00 3a           LAC37     ADDD #STKBUF        ; ADD STACK BUFFER - ROOM FOR STACK?
2866 d3fa 25 08                        BCS  LAC44          ; BRANCH IF GREATER THAN $FFFF
2867 d3fc 10 df 17                     STS  BOTSTK         ; CURRENT NEW BOTTOM OF STACK STACK POINTER
2868 d3ff 10 93 17                     CMPD BOTSTK         ; ARE WE GOING TO BE BELOW STACK?
2869 d402 25 ee                        BCS  LAC32          ; YES - NO ERROR
2870 d404 c6 0c              LAC44     LDB  #6*2           ; OUT OF MEMORY ERROR
2871                         
2872                         * ERROR SERVICING ROUTINE
2873 d406 bd d4 d7           LAC46     JSR  LAD33          ; RESET STACK, STRING STACK, CONTINUE POINTER
2874 d409 bd e0 ac                     JSR  LB95C          ; SEND A CR TO SCREEN
2875 d40c bd e0 fb                     JSR  LB9AF          ; SEND A '?' TO SCREEN
2876 d40f 8e d3 6b                     LDX  #LABAF         ; POINT TO ERROR TABLE
2877 d412 3a                 LAC60     ABX                 ; ADD MESSAGE NUMBER OFFSET
2878 d413 8d 31                        BSR  LACA0          ; * GET TWO CHARACTERS FROM X AND
2879 d415 8d 2f                        BSR  LACA0          ; * SEND TO CONSOLE OUT (SCREEN)
2880 d417 8e d3 a0                     LDX  #LABE1-1       ; POINT TO "ERROR" MESSAGE
2881 d41a bd e0 e8           LAC68     JSR  LB99C          ; PRINT MESSAGE POINTED TO BY X
2882 d41d 96 68                        LDA  CURLIN         ; GET CURRENT LINE NUMBER (CURL IN)
2883 d41f 4c                           INCA                ; TEST FOR DIRECT MODE
2884 d420 27 03                        BEQ  LAC73          ; BRANCH IF DIRECT MODE
2885 d422 bd e5 11                     JSR  LBDC5          ; PRINT 'IN ****'
2886                         
2887                         * THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE
2888 d425 bd e0 ac           LAC73     JSR  LB95C          ; MOVE CURSOR TO START OF LINE
2889 d428 8e d3 ad                     LDX  #LABED         ; POINT X TO 'OK', CR MESSAGE
2890 d42b bd e0 e8                     JSR  LB99C          ; PRINT 'OK', CR
2891 d42e bd d1 41           LAC7C     JSR  LA390          ; GO GET AN INPUT LINE
2892 d431 ce ff ff                     LDU  #$FFFF         ; THE LINE NUMBER FOR DIRECT MODE IS $FFFF
2893 d434 df 68                        STU  CURLIN         ; SAVE IT IN CURLIN
2894 d436 25 f6                        BCS  LAC7C          ; BRANCH IF LINE INPUT TERMINATED BY BREAK
2895 d438 9f 83                        STX  CHARAD         ; SAVE (X) AS CURRENT INPUT POINTER - THIS WILL
2896                         *         ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. THE
2897                         *         LINE JUST ENTERED WILL BE INTERPRETED
2898 d43a 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
2899 d43c 27 f0                        BEQ  LAC7C          ; NO LINE INPUT - GET ANOTHER LINE
2900 d43e 25 0b                        BCS  LACA5          ; BRANCH IF NUMER1C - THERE WAS A LINE NUMBER BEFORE
2901                         *         THE  STATEMENT ENTERED, SO THIS STATEMENT
2902                         *         WILL BE MERGED INTO THE BASIC PROGRAM
2903 d440 bd df 9a                     JSR  LB821          ; GO CRUNCH LINE
2904 d443 7e d5 74                     JMP  LADC0          ; GO EXECUTE THE STATEMENT (LIVE KEYBOARD)
2905                         *
2906 d446 a6 80              LACA0     LDA  ,X+            ; GET A CHARACTER
2907 d448 7e e0 fd                     JMP  LB9B1          ; SEND TO CONSOLE OUT
2908                         * TAKE A LINE FROM THE LINE INPUT BUFFER
2909                         * AND INSERT IT INTO THE BASIC PROGRAM
2910 d44b bd d7 17           LACA5     JSR  LAF67          ; CONVERT LINE NUMBER TO BINARY
2911 d44e 9e 2b              LACA8     LDX  BINVAL         ; GET CONVERTED LINE NUMBER
2912 d450 9f f1                        STX  LINHDR         ; STORE IT IN LINE INPUT HEADER
2913 d452 bd df 9a                     JSR  LB821          ; GO CRUNCH THE LINE
2914 d455 d7 03                        STB  TMPLOC         ; SAVE LINE LENGTH
2915 d457 8d 4c                        BSR  LAD01          ; FIND OUT WHERE TO INSERT LINE
2916 d459 25 12                        BCS  LACC8          ; RANCH IF LINE NUMBER DOES NOT ALREADY EXIST
2917 d45b dc 47                        LDD  V47            ; GET ABSOLUTE ADDRESS OF LINE NUMBER
2918 d45d a3 84                        SUBD ,X             ; SUBTRACT ADDRESS OF NEXT LINE NUMBER
2919 d45f d3 1b                        ADDD VARTAB         ; * ADD TO CURRENT END OF PROGRAM - THIS WILL REMOVE
2920 d461 dd 1b                        STD  VARTAB         ; * THE LENGTH OF THIS LINE NUMBER FROM THE PROGRAM
2921 d463 ee 84                        LDU  ,X             ; POINT U TO ADDRESS OF NEXT LINE NUMBER
2922                         * DELETE OLD LINE FROM BASIC PROGRAM
2923 d465 37 02              LACC0     PULU A              ; GET A BYTE FROM WHAT'S LEFT OF PROGRAM
2924 d467 a7 80                        STA  ,X+            ; MOVE IT DOWN
2925 d469 9c 1b                        CMPX VARTAB         ; COMPARE TO END OF BASIC PROGRAM
2926 d46b 26 f8                        BNE  LACC0          ; BRANCH IF NOT AT END
2927 d46d 96 f3              LACC8     LDA  LINBUF         ; * CHECK TO SEE IF THERE IS A LINE IN
2928 d46f 27 1c                        BEQ  LACE9          ; * THE BUFFER AND BRANCH IF NONE
2929 d471 dc 1b                        LDD  VARTAB         ; = SAVE CURRENT END OF
2930 d473 dd 43                        STD  V43            ; = PROGRAM IN V43
2931 d475 db 03                        ADDB TMPLOC         ; * ADD LENGTH OF CRUNCHED LINE,
2932 d477 89 00                        ADCA #0             ; * PROPOGATE CARRY AND SAVE NEW END
2933 d479 dd 41                        STD  V41            ; * OF PROGRAM IN V41
2934 d47b bd d3 de                     JSR  LAC1E          ; = MAKE SURE THERE'S ENOUGH RAM FOR THIS
2935                         *         =    LINE & MAKE A HOLE IN BASIC FOR NEW LINE
2936 d47e ce 00 ef                     LDU  #LINHDR-2      ; POINT U TO LINE TO BE INSERTED
2937 d481 37 02              LACDD     PULU A              ; GET A BYTE FROM NEW LINE
2938 d483 a7 80                        STA  ,X+            ; INSERT IT IN PROGRAM
2939 d485 9c 45                        CMPX V45            ; * COMPARE TO ADDRESS OF END OF INSERTED
2940 d487 26 f8                        BNE  LACDD          ; * LINE AND BRANCH IF NOT DONE
2941 d489 9e 41                        LDX  V41            ; = GET AND SAVE
2942 d48b 9f 1b                        STX  VARTAB         ; = END OF PROGRAM
2943 d48d 8d 36              LACE9     BSR  LAD21          ; RESET INPUT POINTER, CLEAR VARIABLES, INITIALIZE
2944 d48f 8d 02                        BSR  LACEF          ; ADJUST START OF NEXT LINE ADDRESSES
2945 d491 20 9b                        BRA  LAC7C          ; EENTER BASIC'S INPUT LOOP
2946                         * COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BASIC PROGRAM
2947 d493 9e 19              LACEF     LDX  TXTTAB         ; POINT X TO START OF PROGRAM
2948 d495 ec 84              LACF1     LDD  ,X             ; GET ADDRESS OF NEXT LINE
2949 d497 27 21                        BEQ  LAD16          ; RETURN IF END OF PROGRAM
2950 d499 33 04                        LEAU 4,X            ; POINT U TO START OF BASIC TEXT IN LINE
2951 d49b a6 c0              LACF7     LDA  ,U+            ; * SKIP THROUGH THE LINE UNTIL A
2952 d49d 26 fc                        BNE  LACF7          ; * ZERO (END OF LINE) IS FOUND
2953 d49f ef 84                        STU  ,X             ; SAVE THE NEW START OF NEXT LINE ADDRESS
2954 d4a1 ae 84                        LDX  ,X             ; POINT X TO START OF NEXT LINE
2955 d4a3 20 f0                        BRA  LACF1          ; KEEP GOING
2956                         *
2957                         * FIND A LINE NUMBER IN THE BASIC PROGRAM
2958                         * RETURN WITH CARRY SET IF NO MATCH FOUND
2959 d4a5 dc 2b              LAD01     LDD  BINVAL         ; GET THE LINE NUMBER TO FIND
2960 d4a7 9e 19                        LDX  TXTTAB         ; BEGINNING OF PROGRAM
2961 d4a9 ee 84              LAD05     LDU  ,X             ; GET ADDRESS OF NEXT LINE NUMBER
2962 d4ab 27 09                        BEQ  LAD12          ; BRANCH IF END OF PROG
2963 d4ad 10 a3 02                     CMPD 2,X            ; IS IT A MATCH?
2964 d4b0 23 06                        BLS  LAD14          ; CARRY SET IF LOWER; CARRY CLEAR IF MATCH
2965 d4b2 ae 84                        LDX  ,X             ; X = ADDRESS OF NEXT LINE
2966 d4b4 20 f3                        BRA  LAD05          ; KEEP LOOPING FOR LINE NUMBER
2967 d4b6 1a 01              LAD12     ORCC #1             ; SET CARRY FLAG
2968 d4b8 9f 47              LAD14     STX  V47            ; SAVE MATCH LINE NUMBER OR NUMBER OF LINE JUST AFTER
2969                         *                             ; WHERE IT SHOULD HAVE BEEN
2970 d4ba 39                 LAD16     RTS
2971                         
2972                         * NEW
2973 d4bb 26 fb              NEW       BNE  LAD14          ; BRANCH IF ARGUMENT GIVEN
2974 d4bd 9e 19              LAD19     LDX  TXTTAB         ; GET START OF BASIC
2975 d4bf 6f 80                        CLR  ,X+            ; * PUT 2 ZERO BYTES THERE - ERASE
2976 d4c1 6f 80                        CLR  ,X+            ; * THE BASIC PROGRAM
2977 d4c3 9f 1b                        STX  VARTAB         ; AND THE NEXT ADDRESS IS NOW THE END OF PROGRAM
2978 d4c5 9e 19              LAD21     LDX  TXTTAB         ; GET START OF BASIC
2979 d4c7 bd d6 6b                     JSR  LAEBB          ; PUT INPUT POINTER ONE BEFORE START OF BASIC
2980                         * ERASE ALL VARIABLES
2981 d4ca 9e 27              LAD26     LDX  MEMSIZ         ; * RESET START OF STRING VARIABLES
2982 d4cc 9f 23                        STX  STRTAB         ; * TO TOP OF STRING SPACE
2983 d4ce bd d5 9f                     JSR  RESTOR         ; RESET 'DATA' POINTER TO START OF BASIC
2984 d4d1 9e 1b                        LDX  VARTAB         ; * GET START OF VARIABLES AND USE IT
2985 d4d3 9f 1d                        STX  ARYTAB         ; * TO RESET START OF ARRAYS
2986 d4d5 9f 1f                        STX  ARYEND         ; RESET END OF ARRAYS
2987 d4d7 8e 00 c9           LAD33     LDX  #STRSTK        ; * RESET STRING STACK POINTER TO
2988 d4da 9f 0b                        STX  TEMPPT         ; * BOTTOM OF STRING STACK
2989 d4dc ae e4                        LDX  ,S             ; GET RETURN ADDRESS OFF STACK
2990 d4de 10 de 21                     LDS  FRETOP         ; RESTORE STACK POINTER
2991 d4e1 6f e2                        CLR  ,-S            ; PUT A ZERO BYTE ON STACK - TO CLEAR ANY RETURN OF
2992                         *                             ; FOR/NEXT DATA FROM THE STACK
2993 d4e3 0f 2d                        CLR  OLDPTR         ; RESET 'CONT' ADDRESS SO YOU
2994 d4e5 0f 2e                        CLR  OLDPTR+1       ; 'CAN'T CONTINUE'
2995 d4e7 0f 08                        CLR  ARYDIS         ; CLEAR THE ARRAY DISABLE FLAG
2996 d4e9 6e 84                        JMP  ,X             ; RETURN TO CALLING ROUTINE - THIS IS NECESSARY
2997                         *                             ; SINCE THE STACK WAS RESET
2998                         *
2999                         * FOR
3000                         *
3001                         * THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR
3002                         * EACH FOR-NEXT LOOP WHICH IS BEING PROCESSED. THESE
3003                         * BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);
3004                         *         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=FP VALUE OF STEP;
3005                         *         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO; 1 IF POSITIVE;
3006                         * 9-13=FP VALUE OF 'TO' PARAMETER;
3007                         * 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE END
3008                         *         OF   THE LINE CONTAINING THE 'FOR' STATEMENT
3009 d4eb 86 80              FOR       LDA  #$80           ; * SAVE THE DISABLE ARRAY FLAG IN VO8
3010 d4ed 97 08                        STA  ARYDIS         ; * DO NOT ALLOW THE INDEX VARIABLE TO BE AN ARRAY
3011 d4ef bd d7 39                     JSR  LET            ; SET INDEX VARIABLE TO INITIAL VALUE
3012 d4f2 bd d3 b9                     JSR  LABF9          ; SEARCH THE STACK FOR 'FOR/NEXT' DATA
3013 d4f5 32 62                        LEAS 2,S            ; PURGE RETURN ADDRESS OFF OF THE STACK
3014 d4f7 26 04                        BNE  LAD59          ; BRANCH IF INDEX VARIABLE NOT ALREADY BEING USED
3015 d4f9 9e 0f                        LDX  TEMPTR         ; GET (ADDRESS + 18) OF MATCHED 'FOR/NEXT' DATA
3016 d4fb 32 85                        LEAS B,X            ; MOVE THE STACK POINTER TO THE BEGINNING OF THE
3017                         * MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
3018                         * OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY
3019                         * ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
3020                         * THIS POINT ON THE STACK
3021 d4fd c6 09              LAD59     LDB  #$09           ; * CHECK FOR ROOM FOR 18 BYTES
3022 d4ff bd d3 f3                     JSR  LAC33          ; * IN FREE RAM
3023 d502 bd d6 98                     JSR  LAEE8          ; GET ADDR OF END OF SUBLINE IN X
3024 d505 dc 68                        LDD  CURLIN         ; GET CURRENT LINE NUMBER
3025 d507 34 16                        PSHS X,B,A          ; SAVE LINE ADDR AND LINE NUMBER ON STACK
3026 d509 c6 a0                        LDB  #TOK_TO        ; TOKEN FOR 'TO'
3027 d50b bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR 'TO'
3028 d50e bd d8 cf                     JSR  LB143          ; 'TM' ERROR IF INDEX VARIABLE SET TO STRING
3029 d511 bd d8 cd                     JSR  LB141          ; EVALUATE EXPRESSION
3030                         *
3031 d514 d6 54                        LDB  FP0SGN         ; GET FPA0 MANTISSA SIGN
3032 d516 ca 7f                        ORB  #$7F           ; FORM A MASK TO SAVE DATA BITS OF HIGH ORDER MANTISSA
3033 d518 d4 50                        ANDB FPA0           ; PUT THE MANTISSA SIGN IN BIT 7 OF HIGH ORDER MANTISSA
3034 d51a d7 50                        STB  FPA0           ; SAVE THE PACKED HIGH ORDER MANTISSA
3035 d51c 10 8e d5 23                  LDY  #LAD7F         ; LOAD FOLLOWING ADDRESS INTO Y AS A RETURN
3036 d520 7e d9 76                     JMP  LB1EA          ; ADDRESS - PUSH FPA0 ONTO THE STACK
3037 d523 8e e2 11           LAD7F     LDX  #LBAC5         ; POINT X TO FLOATING POINT NUMBER 1.0 (DEFAULT STEP VALUE)
3038 d526 bd e3 60                     JSR  LBC14          ; MOVE (X) TO FPA0
3039 d529 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3040 d52b 81 a4                        CMPA #TOK_STEP      ; STEP TOKEN
3041 d52d 26 05                        BNE  LAD90          ; BRANCH IF NO 'STEP' VALUE
3042 d52f 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3043 d531 bd d8 cd                     JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
3044 d534 bd e3 b9           LAD90     JSR  LBC6D          ; CHECK STATUS OF FPA0
3045 d537 bd d9 72                     JSR  LB1E6          ; SAVE STATUS AND FPA0 ON THE STACK
3046 d53a dc 3b                        LDD  VARDES         ; * GET DESCRIPTOR POINTER FOR THE 'STEP'
3047 d53c 34 06                        PSHS B,A            ; * VARIABLE AND SAVE IT ON THE STACK
3048 d53e 86 80                        LDA  #$80           ; = GET THE 'FOR' FLAG AND
3049 d540 34 02                        PSHS A              ; = SAVE IT ON THE STACK
3050                         *
3051                         * MAIN COMMAND INTERPRETATION LOOP
3052 d542 1c af              LAD9E     ANDCC #$AF          ; ENABLE IRQ,FIRQ
3053 d544 8d 60                        BSR  LADEB          ; CHECK FOR KEYBOARD BREAK
3054 d546 9e 83                        LDX  CHARAD         ; GET BASIC'S INPUT POINTER
3055 d548 9f 2f                        STX  TINPTR         ; SAVE IT
3056 d54a a6 80                        LDA  ,X+            ; GET CURRENT INPUT CHAR & MOVE POINTER
3057 d54c 27 07                        BEQ  LADB4          ; BRANCH IF END OF LINE
3058 d54e 81 3a                        CMPA #':            ; CHECK FOR LINE SEPARATOR
3059 d550 27 22                        BEQ  LADC0          ; BRANCH IF COLON
3060 d552 7e da 03           LADB1     JMP  LB277          ; 'SYNTAX ERROR'-IF NOT LINE SEPARATOR
3061 d555 a6 81              LADB4     LDA  ,X++           ; GET MS BYTE OF ADDRESS OF NEXT BASIC LINE
3062 d557 97 00                        STA  ENDFLG         ; SAVE IN STOP/END FLAG - CAUSE A STOP IF
3063                         *                             ; NEXT LINE ADDRESS IS < $8000; CAUSE
3064                         *                             ; AN END IF ADDRESS > $8000
3065 d559 27 72                        BEQ  LAE15          ; BRANCH TO 'STOP' - END OF PROGRAM
3066 d55b ec 80                        LDD  ,X+            ; GET CURRENT LINE NUMBER
3067 d55d dd 68                        STD  CURLIN         ; SAVE IN CURLIN
3068 d55f 9f 83                        STX  CHARAD         ; SAVE ADDRESS OF FIRST BYTE OF LINE
3069                         * EXTENDED BASIC TRACE
3070 d561 96 8c                        LDA  TRCFLG         ; TEST THE TRACE FLAG
3071 d563 27 0f                        BEQ  LADC0          ; BRANCH IF TRACE OFF
3072 d565 86 5b                        LDA  #$5B           ; <LEFT HAND MARKER FOR TRON LINE NUMBER
3073 d567 bd d0 17                     JSR  PUTCHR         ; OUTPUT A CHARACTER
3074 d56a 96 68                        LDA  CURLIN         ; GET MS BYTE OF LINE NUMBER
3075 d56c bd e5 18                     JSR  LBDCC          ; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN
3076 d56f 86 5d                        LDA  #$5D           ; > RIGHT HAND MARKER FOR TRON LINE NUMBER
3077 d571 bd d0 17                     JSR  PUTCHR         ; OUTPUT A CHARACTER
3078                         * END OF EXTENDED BASIC TRACE
3079 d574 9d 7c              LADC0     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3080 d576 8d 02                        BSR  LADC6          ; GO PROCESS COMMAND
3081 d578 20 c8                        BRA  LAD9E          ; GO BACK TO MAIN LOOP
3082 d57a 27 29              LADC6     BEQ  LADEA          ; RETURN IF END OF LINE (RTS - was BEQ LAE40)
3083 d57c 4d                           TSTA                ; CHECK FOR TOKEN - BIT 7 SET (NEGATIVE)
3084 d57d 10 2a 01 b8                  LBPL LET            ; BRANCH IF NOT A TOKEN - GO DO A 'LET' WHICH
3085                         *                             ; IS THE 'DEFAULT' TOKEN FOR MICROSOFT BASIC
3086 d581 81 ff                        CMPA #$FF           ; SECONDARY TOKEN
3087 d583 27 0f                        BEQ  SECTOK
3088 d585 81 9e                        CMPA #TOK_HIGH_EXEC ; SKIPF TOKEN - HIGHEST EXECUTABLE COMMAND IN BASIC
3089 d587 22 c9                        BHI  LADB1          ; 'SYNTAX ERROR' IF NON-EXECUTABLE TOKEN
3090 d589 be d0 f4                     LDX  COMVEC+3       ; GET ADDRESS OF BASIC'S COMMAND TABLE
3091 d58c 48                 LADD4     ASLA                ; X2 (2 BYTE/JUMP ADDRESS) & DISCARD BIT 7
3092 d58d 1f 89                        TFR  A,B            ; SAVE COMMAND OFFSET IN ACCB
3093 d58f 3a                           ABX                 ; NON X POINTS TO COMMAND JUMP ADDR
3094 d590 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
3095                         *
3096                         * HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
3097 d592 6e 94                        JMP  [,X]           ; GO DO A COMMAND
3098                         SECTOK
3099                         * THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTABLE IS
3100                         * THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHECK DONE HERE
3101 d594 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
3102 d596 81 97                        CMPA #TOK_MID       ; TOKEN FOR "MID$"
3103 d598 10 27 14 f0                  LBEQ L86D6          ; PROCESS MID$ REPLACEMENT
3104 d59c 7e da 03                     JMP  LB277          ; SYNTAX ERROR
3105                         
3106                         *
3107                         * RESTORE
3108 d59f 9e 19              RESTOR    LDX  TXTTAB         ; BEGINNING OF PROGRAM ADDRESS
3109 d5a1 30 1f                        LEAX -1,X           ; MOVE TO ONE BYTE BEFORE PROGRAM
3110 d5a3 9f 33              LADE8     STX  DATPTR         ; SAVE NEW DATA POINTER
3111 d5a5 39                 LADEA     RTS
3112                         *
3113                         * BREAK CHECK
3114 d5a6 bd d0 08           LADEB     JSR  LA1C1          ; GET A KEYSTROKE ENTRY
3115 d5a9 27 0a                        BEQ  LADFA          ; RETURN IF NO INPUT
3116 d5ab 81 03              LADF0     CMPA #3             ; CONTROL C? (BREAK)
3117 d5ad 27 12                        BEQ  STOP           ; YES
3118 d5af 81 13                        CMPA #$13           ; CONTROL S? (PAUSE)
3119 d5b1 27 03                        BEQ  LADFB          ; YES
3120 d5b3 97 73                        STA  IKEYIM         ; SAVE KEYSTROKE IN INKEY IMAGE
3121 d5b5 39                 LADFA     RTS
3122 d5b6 bd d0 08           LADFB     JSR  KEYIN          ; GET A KEY
3123 d5b9 27 fb                        BEQ  LADFB          ; BRANCH IF NO KEY DOWN
3124 d5bb 20 ee                        BRA  LADF0          ; CONTINUE - DO A BREAK CHECK
3125                         *
3126                         * END
3127 d5bd 9d 82              END       JSR  GETCCH         ; GET CURRENT INPUT CHAR
3128 d5bf 20 02                        BRA  LAE0B
3129                         *
3130                         * STOP
3131 d5c1 1a 01              STOP      ORCC #$01           ; SET CARRY FLAG
3132 d5c3 26 31              LAE0B     BNE  LAE40          ; BRANCH IF ARGUMENT EXISTS
3133 d5c5 9e 83                        LDX  CHARAD         ; * SAVE CURRENT POSITION OF
3134 d5c7 9f 2f                        STX  TINPTR         ; * BASIC'S INPUT POINTER
3135 d5c9 06 00              LAE11     ROR  ENDFLG         ; ROTATE CARRY INTO BIT 7 OF STOP/END FLAG
3136 d5cb 32 62                        LEAS 2,S            ; PURGE RETURN ADDRESS OFF STACK
3137 d5cd 9e 68              LAE15     LDX  CURLIN         ; GET CURRENT LINE NUMBER
3138 d5cf 8c ff ff                     CMPX #$FFFF         ; DIRECT MODE?
3139 d5d2 27 06                        BEQ  LAE22          ; YES
3140 d5d4 9f 29                        STX  OLDTXT         ; SAVE CURRENT LINE NUMBER
3141 d5d6 9e 2f                        LDX  TINPTR         ; * GET AND SAVE CURRENT POSITION
3142 d5d8 9f 2d                        STX  OLDPTR         ; * OF BASIC'S INPUT POINTER
3143                         LAE22
3144 d5da 8e d3 b1                     LDX  #LABF2-1       ; POINT TO CR, 'BREAK' MESSAGE
3145 d5dd 0d 00                        TST  ENDFLG         ; CHECK STOP/END FLAG
3146 d5df 10 2a fe 42                  LBPL LAC73          ; BRANCH TO MAIN LOOP OF BASIC IF END
3147 d5e3 7e d4 1a                     JMP  LAC68          ; PRINT 'BREAK AT ####' AND GO TO
3148                         *                             ; BASIC'S MAIN LOOP IF 'STOP'
3149                         
3150                         * CONT
3151 d5e6 26 0e              CONT      BNE  LAE40          ; RETURN IF ARGUMENT GIVEN
3152 d5e8 c6 20                        LDB  #2*16          ; 'CAN'T CONTINUE' ERROR
3153 d5ea 9e 2d                        LDX  OLDPTR         ; GET CONTINUE ADDRESS (INPUT POINTER)
3154 d5ec 10 27 fe 16                  LBEQ LAC46          ; 'CN' ERROR IF CONTINUE ADDRESS = 0
3155 d5f0 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3156 d5f2 9e 29                        LDX  OLDTXT         ; GET LINE NUMBER
3157 d5f4 9f 68                        STX  CURLIN         ; RESET CURRENT LINE NUMBER
3158 d5f6 39                 LAE40     RTS
3159                         *
3160                         * CLEAR
3161 d5f7 27 2c              CLEAR     BEQ  LAE6F          ; BRANCH IF NO ARGUMENT
3162 d5f9 bd db 6d                     JSR  LB3E6          ; EVALUATE ARGUMENT
3163 d5fc 34 06                        PSHS B,A            ; SAVE AMOUNT OF STRING SPACE ON STACK
3164 d5fe 9e 27                        LDX  MEMSIZ         ; GET CURRENT TOP OF CLEARED SPACE
3165 d600 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3166 d602 27 0c                        BEQ  LAE5A          ; BRANCH IF NO NEW TOP OF CLEARED SPACE
3167 d604 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
3168 d607 bd de c4                     JSR  LB73D          ; EVALUATE EXPRESSlON; RETURN VALUE IN X
3169 d60a 30 1f                        LEAX -1,X           ; X = TOP OF CLEARED SPACE
3170 d60c 9c 71                        CMPX TOPRAM         ; COMPARE TO TOP OF RAM
3171 d60e 22 18                        BHI  LAE72          ; 'OM' ERROR IF > TOP OF RAM
3172 d610 1f 10              LAE5A     TFR  X,D            ; ACCD = TOP OF CLEARED SPACE
3173 d612 a3 e1                        SUBD ,S++           ; SUBTRACT OUT AMOUNT OF CLEARED SPACE
3174 d614 25 12                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
3175 d616 1f 03                        TFR  D,U            ; U = BOTTOM OF CLEARED SPACE
3176 d618 83 00 3a                     SUBD #STKBUF        ; SUBTRACT OUT STACK BUFFER
3177 d61b 25 0b                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
3178 d61d 93 1b                        SUBD VARTAB         ; SUBTRACT OUT START OF VARIABLES
3179 d61f 25 07                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
3180 d621 df 21                        STU  FRETOP         ; SAVE NEW BOTTOM OF CLEARED SPACE
3181 d623 9f 27                        STX  MEMSIZ         ; SAVE NEW TOP OF CLEARED SPACE
3182 d625 7e d4 ca           LAE6F     JMP  LAD26          ; ERASE ALL VARIABLES, INITIALIZE POINTERS, ETC
3183 d628 7e d4 04           LAE72     JMP  LAC44          ; 'OM' ERROR
3184                         *
3185                         * RUN
3186 d62b 9d 82              RUN       JSR  GETCCH         ; * GET CURRENT INPUT CHARACTER
3187 d62d 10 27 fe 94                  LBEQ LAD21          ; * IF NO LINE NUMBER
3188 d631 bd d4 ca                     JSR  LAD26          ; ERASE ALL VARIABLES
3189 d634 20 19                        BRA  LAE9F          ; 'GOTO' THE RUN ADDRESS
3190                         *
3191                         * GO
3192 d636 1f 89              GO        TFR  A,B            ; SAVE INPUT CHARACTER IN ACCB
3193 d638 9d 7c              LAE88     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3194 d63a c1 a0                        CMPB #TOK_TO        ; 'TO' TOKEN
3195 d63c 27 16                        BEQ  LAEA4          ; BRANCH IF GOTO
3196 d63e c1 a1                        CMPB #TOK_SUB       ; 'SUB' TOKEN
3197 d640 26 45                        BNE  LAED7          ; 'SYNTAX ERROR' IF NEITHER
3198 d642 c6 03                        LDB  #3             ; =ROOM FOR 6
3199 d644 bd d3 f3                     JSR  LAC33          ; =BYTES ON STACK?
3200 d647 de 83                        LDU  CHARAD         ; * SAVE CURRENT BASIC INPUT POINTER, LINE
3201 d649 9e 68                        LDX  CURLIN         ; * NUMBER AND SUB TOKEN ON STACK
3202 d64b 86 a1                        LDA  #TOK_SUB       ; *
3203 d64d 34 52                        PSHS U,X,A          ; *
3204 d64f 8d 03              LAE9F     BSR  LAEA4          ; GO DO A 'GOTO'
3205 d651 7e d5 42                     JMP  LAD9E          ; JUMP BACK TO BASIC'S MAIN LOOP
3206                         * GOTO
3207 d654 9d 82              LAEA4     JSR  GETCCH         ; GET CURRENT INPUT CHAR
3208 d656 bd d7 17                     JSR  LAF67          ; GET LINE NUMBER TO BINARY IN BINVAL
3209 d659 8d 40                        BSR  LAEEB          ; ADVANCE BASIC'S POINTER TO END OF LINE
3210 d65b 30 01                        LEAX $01,X          ; POINT TO START OF NEXT LINE
3211 d65d dc 2b                        LDD  BINVAL         ; GET THE LINE NUMBER TO RUN
3212 d65f 10 93 68                     CMPD CURLIN         ; COMPARE TO CURRENT LINE NUMBER
3213 d662 22 02                        BHI  LAEB6          ; IF REO'D LINE NUMBER IS > CURRENT LINE NUMBER,
3214                         *              ; DON'T START LOOKING FROM
3215                         *              ; START OF PROGRAM
3216 d664 9e 19                        LDX  TXTTAB         ; BEGINNING OF PROGRAM
3217 d666 bd d4 a9           LAEB6     JSR  LAD05          ; GO FIND A LINE NUMBER
3218 d669 25 17                        BCS  LAED2          ; 'UNDEFINED LINE NUMBER'
3219 d66b 30 1f              LAEBB     LEAX -1,X           ; MOVE BACK TO JUST BEFORE START OF LINE
3220 d66d 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3221 d66f 39                 LAEBF     RTS
3222                         *
3223                         * RETURN
3224 d670 26 fd              RETURN    BNE  LAEBF          ; EXIT ROUTINE IF ARGUMENT GIVEN
3225 d672 86 ff                        LDA  #$FF           ; * PUT AN ILLEGAL VARIABLE NAME IN FIRST BYTE OF
3226 d674 97 3b                        STA  VARDES         ; * VARDES WHICH WILL CAUSE 'FOR/NEXT' DATA ON THE
3227                         *              ; STACK TO BE IGNORED
3228 d676 bd d3 b9                     JSR  LABF9          ; CHECK FOR RETURN DATA ON THE STACK
3229 d679 1f 14                        TFR  X,S            ; RESET STACK POINTER - PURGE TWO RETURN ADDRESSES
3230                         *              ; FROM THE STACK
3231 d67b 81 21                        CMPA #TOK_SUB-$80   ; SUB TOKEN - $80
3232 d67d 27 0b                        BEQ  LAEDA          ; BRANCH IF 'RETURN' FROM SUBROUTINE
3233 d67f c6 04                        LDB  #2*2           ; ERROR #2 'RETURN WITHOUT GOSUB'
3234 d681 8c                           FCB  SKP2           ; SKIP TWO BYTES
3235 d682 c6 0e              LAED2     LDB  #7*2           ; ERROR #7 'UNDEFINED LINE NUMBER'
3236 d684 7e d4 06                     JMP  LAC46          ; JUMP TO ERROR HANDLER
3237 d687 7e da 03           LAED7     JMP  LB277          ; 'SYNTAX ERROR'
3238 d68a 35 52              LAEDA     PULS A,X,U          ; * RESTORE VALUES OF CURRENT LINE NUMBER AND
3239 d68c 9f 68                        STX  CURLIN         ; * BASIC'S INPUT POINTER FOR THIS SUBROUTINE
3240 d68e df 83                        STU  CHARAD         ; * AND LOAD ACCA WITH SUB TOKEN ($A6)
3241                         *
3242                         * DATA
3243 d690 8d 06              DATA      BSR  LAEE8          ; MOVE INPUT POINTER TO END OF SUBLINE OR LINE
3244 d692 8c                           FCB  SKP2           ; SKIP 2 BYTES
3245                         
3246                         * REM, ELSE
3247                         ELSE
3248 d693 8d 06              REM       BSR  LAEEB          ; MOVE INPUT POINTER TO END OF LINE
3249 d695 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3250 d697 39                 LAEE7     RTS
3251                         * ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE
3252 d698 c6 3a              LAEE8     LDB  #':            ; COLON = SUBLINE TERMINATOR CHARACTER
3253 d69a 86                 LAEEA     FCB  SKP1LD         ; SKPILD SKIP ONE BYTE; LDA #$5F
3254                         * ADVANCE BASIC'S INPUT POINTER TO END OF
3255                         * LINE - RETURN ADDRESS OF END OF LINE+1 IN X
3256 d69b 5f                 LAEEB     CLRB                ; 0 = LINE TERMINATOR CHARACTER
3257 d69c d7 01                        STB  CHARAC         ; TEMP STORE PRIMARY TERMINATOR CHARACTER
3258 d69e 5f                           CLRB                ; 0 (END OF LINE) = ALTERNATE TERM. CHAR.
3259 d69f 9e 83                        LDX  CHARAD         ; LOAD X W/BASIC'S INPUT POINTER
3260 d6a1 1f 98              LAEF1     TFR  B,A            ; * CHANGE TERMINATOR CHARACTER
3261 d6a3 d6 01                        LDB  CHARAC         ; * FROM ACCB TO CHARAC - SAVE OLD TERMINATOR
3262                         *         IN   CHARAC
3263 d6a5 97 01                        STA  CHARAC         ; SWAP PRIMARY AND SECONDARY TERMINATORS
3264 d6a7 a6 84              LAEF7     LDA  ,X             ; GET NEXT INPUT CHARACTER
3265 d6a9 27 ec                        BEQ  LAEE7          ; RETURN IF 0 (END OF LINE)
3266 d6ab 34 04                        PSHS B              ; SAVE TERMINATOR ON STACK
3267 d6ad a1 e0                        CMPA ,S+            ; COMPARE TO INPUT CHARACTER
3268 d6af 27 e6                        BEQ  LAEE7          ; RETURN IF EQUAL
3269 d6b1 30 01                        LEAX 1,X            ; MOVE POINTER UP ONE
3270 d6b3 81 22                        CMPA #'"            ; CHECK FOR DOUBLE QUOTES
3271 d6b5 27 ea                        BEQ  LAEF1          ; BRANCH IF " - TOGGLE TERMINATOR CHARACTERS
3272 d6b7 4c                           INCA                ; * CHECK FOR $FF AND BRANCH IF
3273 d6b8 26 02                        BNE  LAF0C          ; * NOT SECONDARY TOKEN
3274 d6ba 30 01                        LEAX 1,X            ; MOVE INPUT POINTER 1 MORE IF SECONDARY
3275 d6bc 81 86              LAF0C     CMPA #TOK_IF+1      ; TOKEN FOR IF?
3276 d6be 26 e7                        BNE  LAEF7          ; NO - GET ANOTHER INPUT CHARACTER
3277 d6c0 0c 04                        INC  IFCTR          ; INCREMENT IF COUNTER - KEEP TRACK OF HOW MANY
3278                         *                             ; 'IF' STATEMENTS ARE NESTED IN ONE LINE
3279 d6c2 20 e3                        BRA  LAEF7          ; GET ANOTHER INPUT CHARACTER
3280                         
3281                         * IF
3282 d6c4 bd d8 cd           IF        JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
3283 d6c7 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3284 d6c9 81 81                        CMPA #TOK_GO        ; TOKEN FOR GO
3285 d6cb 27 05                        BEQ  LAF22          ; TREAT 'GO' THE SAME AS 'THEN'
3286 d6cd c6 a2                        LDB  #TOK_THEN      ; TOKEN FOR THEN
3287 d6cf bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK ON ACCB
3288 d6d2 96 4f              LAF22     LDA  FP0EXP         ; CHECK FOR TRUE/FALSE - FALSE IF FPA0 EXPONENT = ZERO
3289 d6d4 26 13                        BNE  LAF39          ; BRANCH IF CONDITION TRUE
3290 d6d6 0f 04                        CLR  IFCTR          ; CLEAR FLAG - KEEP TRACK OF WHICH NESTED ELSE STATEMENT
3291                         *                             ; TO SEARCH FOR IN NESTED 'IF' LOOPS
3292 d6d8 8d b6              LAF28     BSR  DATA           ; MOVE BASIC'S POINTER TO END OF SUBLINE
3293 d6da 4d                           TSTA                ; * CHECK TO SEE IF END OF LINE OR SUBLINE
3294 d6db 27 ba                        BEQ  LAEE7          ; * AND RETURN IF END OF LINE
3295 d6dd 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
3296 d6df 81 84                        CMPA #TOK_ELSE      ; TOKEN FOR ELSE
3297 d6e1 26 f5                        BNE  LAF28          ; IGNORE ALL DATA EXCEPT 'ELSE' UNTIL
3298                         *                             ; END OF LINE (ZERO BYTE)
3299 d6e3 0a 04                        DEC  IFCTR          ; CHECK TO SEE IF YOU MUST SEARCH ANOTHER SUBLINE
3300 d6e5 2a f1                        BPL  LAF28          ; BRANCH TO SEARCH ANOTHER SUBLINE FOR 'ELSE'
3301 d6e7 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
3302 d6e9 9d 82              LAF39     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3303 d6eb 10 25 ff 65                  LBCS LAEA4          ; BRANCH TO 'GOTO' IF NUMERIC CHARACTER
3304 d6ef 7e d5 7a                     JMP  LADC6          ; RETURN TO MAIN INTERPRETATION LOOP
3305                         
3306                         * ON
3307 d6f2 bd de 92           ON        JSR  LB70B          ; EVALUATE EXPRESSION
3308 d6f5 c6 81                        LDB  #TOK_GO        ; TOKEN FOR GO
3309 d6f7 bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR GO
3310 d6fa 34 02                        PSHS A              ; SAVE NEW TOKEN (TO,SUB)
3311 d6fc 81 a1                        CMPA #TOK_SUB       ; TOKEN FOR SUB?
3312 d6fe 27 04                        BEQ  LAF54          ; YES
3313 d700 81 a0                        CMPA #TOK_TO        ; TOKEN FOR TO?
3314 d702 26 83              LAF52     BNE  LAED7          ; 'SYNTAX' ERROR IF NOT 'SUB' OR 'TO'
3315 d704 0a 53              LAF54     DEC  FPA0+3         ; DECREMENT IS BYTE OF MANTISSA OF FPA0 - THIS
3316                         *                             ; IS THE ARGUMENT OF THE 'ON' STATEMENT
3317 d706 26 05                        BNE  LAF5D          ; BRANCH IF NOT AT THE PROPER GOTO OR GOSUB LINE NUMBER
3318 d708 35 04                        PULS B              ; GET BACK THE TOKEN FOLLOWING 'GO'
3319 d70a 7e d6 38                     JMP  LAE88          ; GO DO A 'GOTO' OR 'GOSUB'
3320 d70d 9d 7c              LAF5D     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3321 d70f 8d 06                        BSR  LAF67          ; CONVERT BASIC LINE NUMBER TO BINARY
3322 d711 81 2c                        CMPA #',            ; IS CHARACTER FOLLOWING LINE NUMBER A COMMA?
3323 d713 27 ef                        BEQ  LAF54          ; YES
3324 d715 35 84                        PULS B,PC           ; IF NOT, FALL THROUGH TO NEXT COMMAND
3325 d717 9e 74              LAF67     LDX  ZERO           ; DEFAULT LINE NUMBER OF ZERO
3326 d719 9f 2b                        STX  BINVAL         ; SAVE IT IN BINVAL
3327                         *
3328                         * CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINVAL
3329                         *
3330 d71b 24 61              LAF6B     BCC  LAFCE          ; RETURN IF NOT NUMERIC CHARACTER
3331 d71d 80 30                        SUBA #'0            ; MASK OFF ASCII
3332 d71f 97 01                        STA  CHARAC         ; SAVE DIGIT IN VO1
3333 d721 dc 2b                        LDD  BINVAL         ; GET ACCUMULATED LINE NUMBER VALUE
3334 d723 81 18                        CMPA #24            ; LARGEST LINE NUMBER IS $F9FF (63999) -
3335                         *         (24*256+255)*10+9
3336 d725 22 db                        BHI  LAF52          ; 'SYNTAX' ERROR IF TOO BIG
3337                         * MULT ACCD X 10
3338 d727 58                           ASLB                ; *
3339 d728 49                           ROLA                ; * TIMES 2
3340 d729 58                           ASLB                ; =
3341 d72a 49                           ROLA                ; = TIMES 4
3342 d72b d3 2b                        ADDD BINVAL         ; ADD 1 = TIMES 5
3343 d72d 58                           ASLB                ; *
3344 d72e 49                           ROLA                ; * TIMES 10
3345 d72f db 01                        ADDB CHARAC         ; ADD NEXT DIGIT
3346 d731 89 00                        ADCA #0             ; PROPAGATE CARRY
3347 d733 dd 2b                        STD  BINVAL         ; SAVE NEW ACCUMULATED LINE NUMBER
3348 d735 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
3349 d737 20 e2                        BRA  LAF6B          ; LOOP- PROCESS NEXT DIGIT
3350                         *
3351                         * LET (EXBAS)
3352                         * EVALUATE A NON-TOKEN EXPRESSION
3353                         * TARGET = REPLACEMENT
3354 d739 bd da de           LET       JSR  LB357          ; FIND TARGET VARIABLE DESCRIPTOR
3355 d73c 9f 3b                        STX  VARDES         ; SAVE DESCRIPTOR ADDRESS OF 1ST EXPRESSION
3356 d73e c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR "="
3357 d740 bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR '='
3358 d743 96 06                        LDA  VALTYP         ; * GET VARIABLE TYPE AND
3359 d745 34 02                        PSHS A              ; * SAVE ON THE STACK
3360 d747 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
3361 d74a 35 02                        PULS A              ; * REGET VARIABLE TYPE OF 1ST EXPRESSION AND
3362 d74c 46                           RORA                ; * SET CARRY IF STRING
3363 d74d bd d8 d4                     JSR  LB148          ; TYPE CHECK-TM ERROR IF VARIABLE TYPES ON
3364                         *                             ; BOTH SIDES OF EQUALS SIGN NOT THE SAME
3365 d750 10 27 0c 2b                  LBEQ LBC33          ; GO PUT FPA0 INTO VARIABLE DESCRIPTOR IF NUMERIC
3366                         * MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT
3367                         * FPA0+2 INTO THE STRING SPACE. TRANSFER THE
3368                         * DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES
3369                         * DON'T MOVE THE STRING IF IT IS ALREADY IN THE
3370                         * STRING SPACE. REMOVE DESCRIPTOR FROM STRING
3371                         * STACK IF IT IS LAST ONE ON THE STACK
3372 d754 9e 52              LAFA4     LDX  FPA0+2         ; POINT X TO DESCRIPTOR OF REPLACEMENT STRING
3373 d756 dc 21                        LDD  FRETOP         ; LOAD ACCD WITH START OF STRING SPACE
3374 d758 10 a3 02                     CMPD 2,X            ; IS THE STRING IN STRING SPACE?
3375 d75b 24 11                        BCC  LAFBE          ; BRANCH IF IT'S NOT IN THE STRING SPACE
3376 d75d 9c 1b                        CMPX VARTAB         ; COMPARE DESCRIPTOR ADDRESS TO START OF VARIABLES
3377 d75f 25 0d                        BCS  LAFBE          ; BRANCH IF DESCRIPTOR ADDRESS NOT IN VARIABLES
3378 d761 e6 84              LAFB1     LDB  ,X             ; GET LENGTH OF REPLACEMENT STRING
3379 d763 bd dc 94                     JSR  LB50D          ; RESERVE ACCB BYTES OF STRING SPACE
3380 d766 9e 4d                        LDX  V4D            ; GET DESCRIPTOR ADDRESS BACK
3381 d768 bd dd ca                     JSR  LB643          ; MOVE STRING INTO STRING SPACE
3382 d76b 8e 00 56                     LDX  #STRDES        ; POINT X TO TEMP STRING DESCRIPTOR ADDRESS
3383 d76e 9f 4d              LAFBE     STX  V4D            ; SAVE STRING DESCRIPTOR ADDRESS IN V4D
3384 d770 bd dd fc                     JSR  LB675          ; REMOVE STRING DESCRIPTOR IF LAST ONE
3385                         *              ; ON STRING STACK
3386 d773 de 4d                        LDU  V4D            ; POINT U TO REPLACEMENT DESCRIPTOR ADDRESS
3387 d775 9e 3b                        LDX  VARDES         ; GET TARGET DESCRIPTOR ADDRESS
3388 d777 37 26                        PULU A,B,Y          ; GET LENGTH AND START OF REPLACEMENT STRING
3389 d779 a7 84                        STA  ,X             ; * SAVE STRING LENGTH AND START IN
3390 d77b 10 af 02                     STY  2,X            ; * TARGET DESCRIPTOR LOCATION
3391 d77e 39                 LAFCE     RTS
3392                         
3393 d77f 3f 52 45 44 4f     LAFCF     FCC  "?REDO"        ; ?REDO MESSAGE
3394 d784 0d 00                        FCB  CR,$00
3395                         
3396                         LAFD6
3397 d786 7e d4 06           LAFDC     JMP  LAC46          ; JMP TO ERROR HANDLER
3398 d789 96 09              LAFDF     LDA  INPFLG         ; = GET THE INPUT FLAG AND BRANCH
3399 d78b 27 07                        BEQ  LAFEA          ; = IF 'INPUT'
3400 d78d 9e 31                        LDX  DATTXT         ; * GET LINE NUMBER WHERE THE ERROR OCCURRED
3401 d78f 9f 68                        STX  CURLIN         ; * AND USE IT AS THE CURRENT LINE NUMBER
3402 d791 7e da 03                     JMP  LB277          ; 'SYNTAX ERROR'
3403 d794 8e d7 7e           LAFEA     LDX  #LAFCF-1       ; * POINT X TO '?REDO' AND PRINT
3404 d797 bd e0 e8                     JSR  LB99C          ; * IT ON THE SCREEN
3405 d79a 9e 2f                        LDX  TINPTR         ; = GET THE SAVED ABSOLUTE ADDRESS OF
3406 d79c 9f 83                        STX  CHARAD         ; = INPUT POINTER AND RESTORE IT
3407 d79e 39                           RTS
3408                         *
3409                         * INPUT
3410 d79f c6 16              INPUT     LDB  #11*2          ; 'ID' ERROR
3411 d7a1 9e 68                        LDX  CURLIN         ; GET CURRENT LINE NUMBER
3412 d7a3 30 01                        LEAX 1,X            ; ADD ONE
3413 d7a5 27 df                        BEQ  LAFDC          ; 'ID' ERROR BRANCH IF DIRECT MODE
3414 d7a7 8d 01                        BSR  LB00F          ; GET SOME INPUT DATA - WAS LB002
3415 d7a9 39                           RTS
3416 d7aa 81 22              LB00F     CMPA #'"            ; CHECK FOR PROMPT STRING DELIMITER
3417 d7ac 26 0b                        BNE  LB01E          ; BRANCH IF NO PROMPT STRING
3418 d7ae bd d9 d0                     JSR  LB244          ; PUT PROMPT STRING ON STRING STACK
3419 d7b1 c6 3b                        LDB  #';            ; *
3420 d7b3 bd d9 fb                     JSR  LB26F          ; * DO A SYNTAX CHECK FOR SEMICOLON
3421 d7b6 bd e0 eb                     JSR  LB99F          ; PRINT MESSAGE TO CONSOLE OUT
3422 d7b9 8e 00 f3           LB01E     LDX  #LINBUF        ; POINT TO BASIC'S LINE BUFFER
3423 d7bc 6f 84                        CLR  ,X             ; CLEAR 1ST BYTE - FLAG TO INDICATE NO DATA
3424                         *              ; IN LINE BUFFER
3425 d7be 8d 06                        BSR  LB02F          ; INPUT A STRING TO LINE BUFFER
3426 d7c0 c6 2c                        LDB  #',            ; * INSERT A COMMA AT THE END
3427 d7c2 e7 84                        STB  ,X             ; * OF THE LINE INPUT BUFFER
3428 d7c4 20 16                        BRA  LB049
3429                         * FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
3430 d7c6 bd e0 fb           LB02F     JSR  LB9AF          ; SEND A "?" TO CONSOLE OUT
3431 d7c9 bd e0 f8                     JSR  LB9AC          ; SEND A 'SPACE' TO CONSOLE OUT
3432 d7cc bd d1 41           LB035     JSR  LA390          ; GO READ IN A BASIC LINE
3433 d7cf 24 05                        BCC  LB03F          ; BRANCH IF ENTER KEY ENDED ENTRY
3434 d7d1 32 64                        LEAS 4,S            ; PURGE TWO RETURN ADDRESSES OFF THE STACK
3435 d7d3 7e d5 c9                     JMP  LAE11          ; GO DO A 'STOP' IF BREAK KEY ENDED LINE ENTRY
3436 d7d6 c6 2e              LB03F     LDB  #2*23          ; 'INPUT PAST END OF FILE' ERROR
3437 d7d8 39                           RTS
3438                         *
3439                         * READ
3440 d7d9 9e 33              READ      LDX  DATPTR         ; GET 'READ' START ADDRESS
3441 d7db 86                           FCB  SKP1LD         ; SKIP ONE BYTE - LDA #*$4F
3442 d7dc 4f                 LB049     CLRA                ; 'INPUT' ENTRY POINT: INPUT FLAG = 0
3443 d7dd 97 09                        STA  INPFLG         ; SET INPUT FLAG; 0 = INPUT: <> 0 = READ
3444 d7df 9f 35                        STX  DATTMP         ; SAVE 'READ' START ADDRESS/'INPUT' BUFFER START
3445 d7e1 bd da de           LB04E     JSR  LB357          ; EVALUATE A VARIABLE
3446 d7e4 9f 3b                        STX  VARDES         ; SAVE DESCRIPTOR ADDRESS
3447 d7e6 9e 83                        LDX  CHARAD         ; * GET BASIC'S INPUT POINTER
3448 d7e8 9f 2b                        STX  BINVAL         ; * AND SAVE IT
3449 d7ea 9e 35                        LDX  DATTMP         ; GET 'READ' ADDRESS START/'INPUT' BUFFER POINTER
3450 d7ec a6 84                        LDA  ,X             ; GET A CHARACTER FROM THE BASIC PROGRAM
3451 d7ee 26 09                        BNE  LB069          ; BRANCH IF NOT END OF LINE
3452 d7f0 96 09                        LDA  INPFLG         ; * CHECK INPUT FLAG AND BRANCH
3453 d7f2 26 51                        BNE  LB0B9          ; * IF LOOKING FOR DATA (READ)
3454                         * NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
3455                         * NOT COMING FROM SCREEN
3456 d7f4 bd e0 fb                     JSR  LB9AF          ; SEND A '?' TO CONSOLE OUT
3457 d7f7 8d cd                        BSR  LB02F          ; FILL INPUT BUFFER FROM CONSOLE IN
3458 d7f9 9f 83              LB069     STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3459 d7fb 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3460 d7fd d6 06                        LDB  VALTYP         ; * CHECK VARIABLE TYPE AND
3461 d7ff 27 23                        BEQ  LB098          ; * BRANCH IF NUMERIC
3462                         * READ/INPUT A STRING VARIABLE
3463 d801 9e 83                        LDX  CHARAD         ; LOAD X WITH CURRENT BASIC INPUT POINTER
3464 d803 97 01                        STA  CHARAC         ; SAVE CURRENT INPUT CHARACTER
3465 d805 81 22                        CMPA #'"            ; CHECK FOR STRING DELIMITER
3466 d807 27 0e                        BEQ  LB08B          ; BRANCH IF STRING DELIMITER
3467 d809 30 1f                        LEAX -1,X           ; BACK UP POINTER
3468 d80b 4f                           CLRA                ; * ZERO = END OF LINE CHARACTER
3469 d80c 97 01                        STA  CHARAC         ; * SAVE AS TERMINATOR
3470 d80e bd d1 33                     JSR  LA35F          ; SET UP PRINT PARAMETERS
3471 d811 86 3a                        LDA  #':            ; END OF SUBLINE CHARACTER
3472 d813 97 01                        STA  CHARAC         ; SAVE AS TERMINATOR I
3473 d815 86 2c                        LDA  #',            ; COMMA
3474 d817 97 02              LB08B     STA  ENDCHR         ; SAVE AS TERMINATOR 2
3475 d819 bd dc a5                     JSR  LB51E          ; STRIP A STRING FROM THE INPUT BUFFER
3476 d81c bd d9 d5                     JSR  LB249          ; MOVE INPUT POINTER TO END OF STRING
3477 d81f bd d7 54                     JSR  LAFA4          ; PUT A STRING INTO THE STRING SPACE IF NECESSARY
3478 d822 20 06                        BRA  LB09E          ; CHECK FOR ANOTHER DATA ITEM
3479                         * SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM
3480 d824 bd e4 5e           LB098     JSR  LBD12          ; CONVERT AN ASCII STRING TO FP NUMBER
3481 d827 bd e3 7f                     JSR  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS IN VARDES -
3482                         *                             ; INPUT OR READ DATA ITEM
3483 d82a 9d 82              LB09E     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3484 d82c 27 06                        BEQ  LB0A8          ; BRANCH IF END OF LINE
3485 d82e 81 2c                        CMPA #',            ; CHECK FOR A COMMA
3486 d830 10 26 ff 52                  LBNE LAFD6          ; BAD FILE DATA' ERROR OR RETRY
3487 d834 9e 83              LB0A8     LDX  CHARAD         ; * GET CURRENT INPUT
3488 d836 9f 35                        STX  DATTMP         ; * POINTER (USED AS A DATA POINTER) AND SAVE IT
3489 d838 9e 2b                        LDX  BINVAL         ; * RESET INPUT POINTER TO INPUT OR
3490 d83a 9f 83                        STX  CHARAD         ; * READ STATEMENT
3491 d83c 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
3492 d83e 27 21                        BEQ  LB0D5          ; BRANCH IF END OF LINE - EXIT COMMAND
3493 d840 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
3494 d843 20 9c                        BRA  LB04E          ; GET ANOTHER INPUT OR READ ITEM
3495                         * SEARCH FROM ADDRESS IN X FOR
3496                         * 1ST OCCURENCE OF THE TOKEN FOR DATA
3497 d845 9f 83              LB0B9     STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3498 d847 bd d6 98                     JSR  LAEE8          ; SEARCH FOR END OF CURRENT LINE OR SUBLINE
3499 d84a 30 01                        LEAX 1,X            ; MOVE X ONE PAST END OF LINE
3500 d84c 4d                           TSTA                ; CHECK FOR END OF LINE
3501 d84d 26 0a                        BNE  LB0CD          ; BRANCH IF END OF SUBLINE
3502 d84f c6 06                        LDB  #2*3           ; 'OUT OF DATA' ERROR
3503 d851 ee 81                        LDU  ,X++           ; GET NEXT 2 CHARACTERS
3504 d853 27 41                        BEQ  LB10A          ; 'OD' ERROR IF END OF PROGRAM
3505 d855 ec 81                        LDD  ,X++           ; GET BASIC LINE NUMBER AND
3506 d857 dd 31                        STD  DATTXT         ; SAVE IT IN DATTXT
3507 d859 a6 84              LB0CD     LDA  ,X             ; GET AN INPUT CHARACTER
3508 d85b 81 86                        CMPA #TOK_DATA      ; DATA TOKEN?
3509 d85d 26 e6                        BNE  LB0B9          ; NO - KEEP LOOKING
3510 d85f 20 98                        BRA  LB069          ; YES
3511                         * EXIT READ AND INPUT COMMANDS
3512 d861 9e 35              LB0D5     LDX  DATTMP         ; GET DATA POINTER
3513 d863 d6 09                        LDB  INPFLG         ; * CHECK INPUT FLAG
3514 d865 10 26 fd 3a                  LBNE LADE8          ; * SAVE NEW DATA POINTER IF READ
3515 d869 a6 84                        LDA  ,X             ; = CHECK NEXT CHARACTER IN 'INPUT' BUFFER
3516 d86b 27 06                        BEQ  LB0E7          ; =
3517 d86d 8e d8 73                     LDX  #LB0E8-1       ; POINT X TO '?EXTRA IGNORED'
3518 d870 7e e0 e8                     JMP  LB99C          ; PRINT THE MESSAGE
3519 d873 39                 LB0E7     RTS
3520                         
3521 d874 3f 45 58 54 52 41  LB0E8     FCC  "?EXTRA IGNORED" ; ?EXTRA IGNORED MESSAGE
     20 49 47 4e 4f 52
     45 44
3522                         
3523                         
3524 d882 0d 00                        FCB  CR,$00
3525                         
3526                         * NEXT
3527 d884 26 04              NEXT      BNE  LB0FE          ; BRANCH IF ARGUMENT GIVEN
3528 d886 9e 74                        LDX  ZERO           ; X = 0: DEFAULT FOR NO ARGUMENT
3529 d888 20 03                        BRA  LB101
3530 d88a bd da de           LB0FE     JSR  LB357          ; EVALUATE AN ALPHA EXPRESSION
3531 d88d 9f 3b              LB101     STX  VARDES         ; SAVE VARIABLE DESCRIPTOR POINTER
3532 d88f bd d3 b9                     JSR  LABF9          ; GO SCAN FOR 'FOR/NEXT' DATA ON STACK
3533 d892 27 04                        BEQ  LB10C          ; BRANCH IF DATA FOUND
3534 d894 c6 00                        LDB  #0             ; 'NEXT WITHOUT FOR' ERROR (SHOULD BE CLRB)
3535 d896 20 47              LB10A     BRA  LB153          ; PROCESS ERROR
3536 d898 1f 14              LB10C     TFR  X,S            ; POINT S TO START OF 'FOR/NEXT' DATA
3537 d89a 30 03                        LEAX 3,X            ; POINT X TO FP VALUE OF STEP
3538 d89c bd e3 60                     JSR  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
3539 d89f a6 68                        LDA  8,S            ; GET THE DIRECTION OF STEP
3540 d8a1 97 54                        STA  FP0SGN         ; SAVE IT AS THE SIGN OF FPA0
3541 d8a3 9e 3b                        LDX  VARDES         ; POINT (X) TO INDEX VARIABLE DESCRIPTOR
3542 d8a5 bd e1 0e                     JSR  LB9C2          ; ADD (X) TO FPA0 (STEP TO INDEX)
3543 d8a8 bd e3 7f                     JSR  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS
3544                         *                             ; CONTAINED IN VARDES
3545 d8ab 30 69                        LEAX 9,S            ; POINT (X) TO TERMINAL VALUE OF INDEX
3546 d8ad bd e3 e2                     JSR  LBC96          ; COMPARE CURRENT INDEX VALUE TO TERMINAL VALUE OF INDEX
3547 d8b0 e0 68                        SUBB 8,S            ; ACCB = 0 IF TERMINAL VALUE=CURRENT VALUE AND STEP=0 OR IF
3548                         *                             ; STEP IS POSITIVE AND CURRENT VALUE>TERMINAL VALUE OR
3549                         *                             ; STEP IS NEGATIVE AND CURRENT VALUE<TERMINAL VALUE
3550 d8b2 27 0c                        BEQ  LB134          ; BRANCH IF 'FOR/NEXT' LOOP DONE
3551 d8b4 ae 6e                        LDX  14,S           ; * GET LINE NUMBER AND
3552 d8b6 9f 68                        STX  CURLIN         ; * BASIC POINTER OF
3553 d8b8 ae e8 10                     LDX  16,S           ; * STATEMENT FOLLOWING THE
3554 d8bb 9f 83                        STX  CHARAD         ; * PROPER FOR STATEMENT
3555 d8bd 7e d5 42           LB131     JMP  LAD9E          ; JUMP BACK TO COMMAND INTEPR. LOOP
3556 d8c0 32 e8 12           LB134     LEAS 18,S           ; PULL THE 'FOR-NEXT' DATA OFF THE STACK
3557 d8c3 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3558 d8c5 81 2c                        CMPA #',            ; CHECK FOR ANOTHER ARGUMENT
3559 d8c7 26 f4                        BNE  LB131          ; RETURN IF NONE
3560 d8c9 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
3561 d8cb 8d bd                        BSR  LB0FE          ; BSR SIMULATES A CALL TO 'NEXT' FROM COMMAND LOOP
3562                         
3563                         
3564 d8cd 8d 13              LB141     BSR  LB156          ; EVALUATE EXPRESSION AND DO A TYPE CHECK FOR NUMERIC
3565 d8cf 1c fe              LB143     ANDCC #$FE          ; CLEAR CARRY FLAG
3566 d8d1 7d                 LB145     FCB  $7D            ; OP CODE OF TST $1A01 - SKIP TWO BYTES (DO
3567                         *              ; NOT CHANGE CARRY FLAG)
3568 d8d2 1a 01              LB146     ORCC #1             ; SET CARRY
3569                         
3570                         * STRING TYPE MODE CHECK - IF ENTERED AT LB146 THEN VALTYP PLUS IS 'TM' ERROR
3571                         * NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN VALTYP MINUS IS 'TM' ERROR
3572                         * IF ENTERED AT LB148, A TYPE CHECK IS DONE ON VALTYP
3573                         * IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERIC
3574                         * IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRING.
3575 d8d4 0d 06              LB148     TST  VALTYP         ; TEST TYPE FLAG; DO NOT CHANGE CARRY
3576 d8d6 25 03                        BCS  LB14F          ; BRANCH IF STRING
3577 d8d8 2a 99                        BPL  LB0E7          ; RETURN ON PLUS
3578 d8da 8c                           FCB  SKP2           ; SKIP 2 BYTES - 'TM' ERROR
3579 d8db 2b 96              LB14F     BMI  LB0E7          ; RETURN ON MINUS
3580 d8dd c6 18                        LDB  #12*2          ; 'TYPE M1SMATCH' ERROR
3581 d8df 7e d4 06           LB153     JMP  LAC46          ; PROCESS ERROR
3582                         * EVALUATE EXPRESSION
3583 d8e2 8d 6e              LB156     BSR  LB1C6          ; BACK UP INPUT POINTER
3584 d8e4 4f                 LB158     CLRA                ; END OF OPERATION PRECEDENCE FLAG
3585 d8e5 8c                           FCB  SKP2           ; SKIP TWO BYTES
3586 d8e6 34 04              LB15A     PSHS B              ; SAVE FLAG (RELATIONAL OPERATOR FLAG)
3587 d8e8 34 02                        PSHS A              ; SAVE FLAG (PRECEDENCE FLAG)
3588 d8ea c6 01                        LDB  #1             ; *
3589 d8ec bd d3 f3                     JSR  LAC33          ; * SEE IF ROOM IN FREE RAM FOR (B) WORDS
3590 d8ef bd d9 af                     JSR  LB223          ; GO EVALUATE AN EXPRESSION
3591 d8f2 0f 3f                        CLR  TRELFL         ; RESET RELATIONAL OPERATOR FLAG
3592 d8f4 9d 82              LB168     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3593                         * CHECK FOR RELATIONAL OPERATORS
3594 d8f6 80 ad              LB16A     SUBA #TOK_GREATER   ; TOKEN FOR >
3595 d8f8 25 13                        BCS  LB181          ; BRANCH IF LESS THAN RELATIONAL OPERATORS
3596 d8fa 81 03                        CMPA #3             ; *
3597 d8fc 24 0f                        BCC  LB181          ; * BRANCH IF GREATER THAN RELATIONAL OPERATORS
3598 d8fe 81 01                        CMPA #1             ; SET CARRY IF '>'
3599 d900 49                           ROLA                ; CARRY TO BIT 0
3600 d901 98 3f                        EORA TRELFL         ; * CARRY SET IF
3601 d903 91 3f                        CMPA TRELFL         ; * TRELFL = ACCA
3602 d905 25 64                        BCS  LB1DF          ; BRANCH IF SYNTAX ERROR : == << OR >>
3603 d907 97 3f                        STA  TRELFL         ; BIT 0: >, BIT 1 =, BIT 2: <
3604 d909 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER
3605 d90b 20 e9                        BRA  LB16A          ; CHECK FOR ANOTHER RELATIONAL OPERATOR
3606                         *
3607 d90d d6 3f              LB181     LDB  TRELFL         ; GET RELATIONAL OPERATOR FLAG
3608 d90f 26 33                        BNE  LB1B8          ; BRANCH IF RELATIONAL COMPARISON
3609 d911 10 24 00 6b                  LBCC LB1F4          ; BRANCH IF > RELATIONAL OPERATOR
3610 d915 8b 07                        ADDA #7             ; SEVEN ARITHMETIC/LOGICAL OPERATORS
3611 d917 24 67                        BCC  LB1F4          ; BRANCH IF NOT ARITHMETIC/LOGICAL OPERATOR
3612 d919 99 06                        ADCA VALTYP         ; ADD CARRY, NUMERIC FLAG AND MODIFIED TOKEN NUMBER
3613 d91b 10 27 04 77                  LBEQ LB60F          ; BRANCH IF VALTYP = FF, AND ACCA = '+' TOKEN -
3614                         *                             ; CONCATENATE TWO STRINGS
3615 d91f 89 ff                        ADCA #-1            ; RESTORE ARITHMETIC/LOGICAL OPERATOR NUMBER
3616 d921 34 02                        PSHS A              ; * STORE OPERATOR NUMBER ON STACK; MULTIPLY IT BY 2
3617 d923 48                           ASLA                ; * THEN ADD THE STORED STACK DATA = MULTIPLY
3618 d924 ab e0                        ADDA ,S+            ; * X 3; 3 BYTE/TABLE ENTRY
3619 d926 8e d2 0b                     LDX  #LAA51         ; JUMP TABLE FOR ARITHMETIC & LOGICAL OPERATORS
3620 d929 30 86                        LEAX A,X            ; POINT X TO PROPER TABLE
3621 d92b 35 02              LB19F     PULS A              ; GET PRECEDENCE FLAG FROM STACK
3622 d92d a1 84                        CMPA ,X             ; COMPARE TO CURRENT OPERATOR
3623 d92f 24 55                        BCC  LB1FA          ; BRANCH IF STACK OPERATOR > CURRENT OPERATOR
3624 d931 8d 9c                        BSR  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
3625                         
3626                         * OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE THAN THE PREVIOUS OPERATION.
3627 d933 34 02              LB1A7     PSHS A              ; SAVE PRECEDENCE FLAG
3628 d935 8d 29                        BSR  LB1D4          ; PUSH OPERATOR ROUTINE ADDRESS AND FPA0 ONTO STACK
3629 d937 9e 3d                        LDX  RELPTR         ; GET POINTER TO ARITHMETIC/LOGICAL TABLE ENTRY FOR
3630                         *                             ; LAST CALCULATED OPERATION
3631 d939 35 02                        PULS A              ; GET PRECEDENCE FLAG OF PREVIOUS OPERATION
3632 d93b 26 1d                        BNE  LB1CE          ; BRANCH IF NOT END OF OPERATION
3633 d93d 4d                           TSTA                ; CHECK TYPE OF PRECEDENCE FLAG
3634 d93e 10 27 00 6a                  LBEQ LB220          ; BRANCH IF END OF EXPRESSION OR SUB-EXPRESSION
3635 d942 20 4b                        BRA  LB203          ; EVALUATE AN OPERATION
3636                         
3637 d944 08 06              LB1B8     ASL  VALTYP         ; BIT 7 OF TYPE FLAG TO CARRY
3638 d946 59                           ROLB                ; SHIFT RELATIONAL FLAG LEFT - VALTYP TO BIT 0
3639 d947 8d 09                        BSR  LB1C6          ; MOVE THE INPUT POINTER BACK ONE
3640 d949 8e d9 57                     LDX  #LB1CB         ; POINT X TO RELATIONAL COMPARISON JUMP TABLE
3641 d94c d7 3f                        STB  TRELFL         ; SAVE RELATIONAL COMPARISON DATA
3642 d94e 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
3643 d950 20 d9                        BRA  LB19F          ; PERFORM OPERATION OR SAVE ON STACK
3644                         
3645 d952 9e 83              LB1C6     LDX  CHARAD         ; * GET BASIC'S INPUT POINTER AND
3646 d954 7e d6 6b                     JMP  LAEBB          ; * MOVE IT BACK ONE
3647                         * RELATIONAL COMPARISON JUMP TABLE
3648 d957 64                 LB1CB     FCB  $64            ; RELATIONAL COMPARISON FLAG
3649 d958 da 7b              LB1CC     FDB  LB2F4          ; JUMP ADDRESS
3650                         
3651 d95a a1 84              LB1CE     CMPA ,X             ; COMPARE PRECEDENCE OF LAST DONE OPERATION TO
3652                         *         NEXT TO BE DONE OPERATION
3653 d95c 24 31                        BCC  LB203          ; EVALUATE OPERATION IF LOWER PRECEDENCE
3654 d95e 20 d3                        BRA  LB1A7          ; PUSH OPERATION DATA ON STACK IF HIGHER PRECEDENCE
3655                         
3656                         * PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK AND EVALUATE ANOTHER EXPR
3657 d960 ec 01              LB1D4     LDD  1,X            ; GET ADDRESS OF OPERATOR ROUTINE
3658 d962 34 06                        PSHS B,A            ; SAVE IT ON THE STACK
3659 d964 8d 08                        BSR  LB1E2          ; PUSH FPA0 ONTO STACK
3660 d966 d6 3f                        LDB  TRELFL         ; GET BACK RELATIONAL OPERATOR FLAG
3661 d968 16 ff 7b                     LBRA LB15A          ; EVALUATE ANOTHER EXPRESSION
3662 d96b 7e da 03           LB1DF     JMP  LB277          ; 'SYNTAX ERROR'
3663                         * PUSH FPA0 ONTO THE STACK. ,S   = EXPONENT
3664                         * 1-2,S =HIGH ORDER MANTISSA 3-4,S = LOW ORDER MANTISSA
3665                         * 5,S = SIGN RETURN WITH PRECEDENCE CODE IN ACCA
3666 d96e d6 54              LB1E2     LDB  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
3667 d970 a6 84                        LDA  ,X             ; GET PRECEDENCE CODE TO ACCA
3668 d972 35 20              LB1E6     PULS Y              ; GET RETURN ADDRESS FROM STACK & PUT IT IN Y
3669 d974 34 04                        PSHS B              ; SAVE ACCB ON STACK
3670 d976 d6 4f              LB1EA     LDB  FP0EXP         ; * PUSH FPA0 ONTO THE STACK
3671 d978 9e 50                        LDX  FPA0           ; *
3672 d97a de 52                        LDU  FPA0+2         ; *
3673 d97c 34 54                        PSHS U,X,B          ; *
3674 d97e 6e a4                        JMP  ,Y             ; JUMP TO ADDRESS IN Y
3675                         
3676                         * BRANCH HERE IF NON-OPERATOR CHARACTER FOUND - USUALLY ')' OR END OF LINE
3677 d980 9e 74              LB1F4     LDX  ZERO           ; POINT X TO DUMMY VALUE (ZERO)
3678 d982 a6 e0                        LDA  ,S+            ; GET PRECEDENCE FLAG FROM STACK
3679 d984 27 26                        BEQ  LB220          ; BRANCH IF END OF EXPRESSION
3680 d986 81 64              LB1FA     CMPA #$64           ; * CHECK FOR RELATIONAL COMPARISON FLAG
3681 d988 27 03                        BEQ  LB201          ; * AND BRANCH IF RELATIONAL COMPARISON
3682 d98a bd d8 cf                     JSR  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
3683 d98d 9f 3d              LB201     STX  RELPTR         ; SAVE POINTER TO OPERATOR ROUTINE
3684 d98f 35 04              LB203     PULS B              ; GET RELATIONAL OPERATOR FLAG FROM STACK
3685 d991 81 5a                        CMPA #$5A           ; CHECK FOR 'NOT' OPERATOR
3686 d993 27 19                        BEQ  LB222          ; RETURN IF 'NOT' - NO RELATIONAL COMPARISON
3687 d995 81 7d                        CMPA #$7D           ; CHECK FOR NEGATION (UNARY) FLAG
3688 d997 27 15                        BEQ  LB222          ; RETURN IF NEGATION - NO RELATIONAL COMPARISON
3689                         
3690                         * EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON STACK, FIRST SIX BYTES
3691                         * ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRESS OF ROUTINE WHICH
3692                         * WILL EVALUATE THE OPERATION. THE RTS AT END OF ROUTINE WILL VECTOR
3693                         * TO EVALUATING ROUTINE.
3694 d999 54                           LSRB                ; = ROTATE VALTYP BIT INTO CARRY
3695 d99a d7 0a                        STB  RELFLG         ; = FLAG AND SAVE NEW RELFLG
3696 d99c 35 52                        PULS A,X,U          ; * PULL A FP VALUE OFF OF THE STACK
3697 d99e 97 5c                        STA  FP1EXP         ; * AND SAVE IT IN FPA1
3698 d9a0 9f 5d                        STX  FPA1           ; *
3699 d9a2 df 5f                        STU  FPA1+2         ; *
3700 d9a4 35 04                        PULS B              ; = GET MANTISSA SIGN AND
3701 d9a6 d7 61                        STB  FP1SGN         ; = SAVE IT IN FPA1
3702 d9a8 d8 54                        EORB FP0SGN         ; EOR IT WITH FPA1 MANTISSA SIGN
3703 d9aa d7 62                        STB  RESSGN         ; SAVE IT IN RESULT SIGN BYTE
3704 d9ac d6 4f              LB220     LDB  FP0EXP         ; GET EXPONENT OF FPA0
3705 d9ae 39                 LB222     RTS
3706                         
3707 d9af bd eb fc           LB223     JSR  XVEC15         ; CALL EXTENDED BASIC ADD-IN
3708 d9b2 0f 06                        CLR  VALTYP         ; INITIALIZE TYPE FLAG TO NUMERIC
3709 d9b4 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
3710 d9b6 24 03                        BCC  LB22F          ; BRANCH IF NOT NUMERIC
3711 d9b8 7e e4 5e           LB22C     JMP  LBD12          ; CONVERT ASCII STRING TO FLOATING POINT -
3712                         *         RETURN RESULT IN FPA0
3713                         * PROCESS A NON NUMERIC FIRST CHARACTER
3714 d9bb bd db 29           LB22F     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
3715 d9be 24 50                        BCC  LB284          ; BRANCH IF ALPHA CHARACTER
3716 d9c0 81 2e                        CMPA #'.            ; IS IT '.' (DECIMAL POINT)?
3717 d9c2 27 f4                        BEQ  LB22C          ; CONVERT ASCII STRING TO FLOATING POINT
3718 d9c4 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN
3719 d9c6 27 40                        BEQ  LB27C          ; YES - GO PROCESS THE MINUS OPERATOR
3720 d9c8 81 a6                        CMPA #TOK_PLUS      ; PLUS TOKEN
3721 d9ca 27 e3                        BEQ  LB223          ; YES - GET ANOTHER CHARACTER
3722 d9cc 81 22                        CMPA #'"            ; STRING DELIMITER?
3723 d9ce 26 0a                        BNE  LB24E          ; NO
3724 d9d0 9e 83              LB244     LDX  CHARAD         ; CURRENT BASIC POINTER TO X
3725 d9d2 bd dc 9f                     JSR  LB518          ; SAVE STRING ON STRING STACK
3726 d9d5 9e 64              LB249     LDX  COEFPT         ; * GET ADDRESS OF END OF STRING AND
3727 d9d7 9f 83                        STX  CHARAD         ; * PUT BASIC'S INPUT POINTER THERE
3728 d9d9 39                           RTS
3729 d9da 81 a3              LB24E     CMPA #TOK_NOT       ; NOT TOKEN?
3730 d9dc 26 0d                        BNE  LB25F          ; NO
3731                         * PROCESS THE NOT OPERATOR
3732 d9de 86 5a                        LDA  #$5A           ; 'NOT' PRECEDENCE FLAG
3733 d9e0 bd d8 e6                     JSR  LB15A          ; PROCESS OPERATION FOLLOWING 'NOT'
3734 d9e3 bd db 74                     JSR  INTCNV         ; CONVERT FPA0 TO INTEGER IN ACCD
3735 d9e6 43                           COMA                ; * 'NOT' THE INTEGER
3736 d9e7 53                           COMB                ; *
3737 d9e8 7e dc 7b                     JMP  GIVABF         ; CONVERT ACCD TO FLOATING POINT (FPA0)
3738 d9eb 4c                 LB25F     INCA                ; CHECK FOR TOKENS PRECEEDED BY $FF
3739 d9ec 27 2e                        BEQ  LB290          ; IT WAS PRECEEDED BY $FF
3740 d9ee 8d 06              LB262     BSR  LB26A          ; SYNTAX CHECK FOR A '('
3741 d9f0 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSIONS WITHIN PARENTHESES AT
3742                         *         HIGHEST PRECEDENCE
3743 d9f3 c6 29              LB267     LDB  #')            ; SYNTAX CHECK FOR ')'
3744 d9f5 8c                           FCB  SKP2           ; SKIP 2 BYTES
3745 d9f6 c6 28              LB26A     LDB  #'(            ; SYNTAX CHECK FOR '('
3746 d9f8 8c                           FCB  SKP2           ; SKIP 2 BYTES
3747 d9f9 c6 2c              LB26D     LDB  #',            ; SYNTAX CHECK FOR COMMA
3748 d9fb e1 9f 00 83        LB26F     CMPB [CHARAD]       ; * COMPARE ACCB TO CURRENT INPUT
3749 d9ff 26 02                        BNE  LB277          ; * CHARACTER - SYNTAX ERROR IF NO MATCH
3750 da01 0e 7c                        JMP  GETNCH         ; GET A CHARACTER FROM BASIC
3751 da03 c6 02              LB277     LDB  #2*1           ; SYNTAX ERROR
3752 da05 7e d4 06                     JMP  LAC46          ; JUMP TO ERROR HANDLER
3753                         
3754                         * PROCESS THE MINUS (UNARY) OPERATOR
3755 da08 86 7d              LB27C     LDA  #$7D           ; MINUS (UNARY) PRECEDENCE FLAG
3756 da0a bd d8 e6                     JSR  LB15A          ; PROCESS OPERATION FOLLOWING 'UNARY' NEGATION
3757 da0d 7e e6 35                     JMP  LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
3758                         
3759                         * EVALUATE ALPHA EXPRESSION
3760 da10 bd da de           LB284     JSR  LB357          ; FIND THE DESCRIPTOR ADDRESS OF A VARIABLE
3761 da13 9f 52              LB287     STX  FPA0+2         ; SAVE DESCRIPTOR ADDRESS IN FPA0
3762 da15 96 06                        LDA  VALTYP         ; TEST VARIABLE TYPE
3763 da17 26 95                        BNE  LB222          ; RETURN IF STRING
3764 da19 7e e3 60                     JMP  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
3765                         
3766                         * EVALUATING A SECONDARY TOKEN
3767 da1c 9d 7c              LB290     JSR  GETNCH         ; GET AN INPUT CHARACTER (SECONDARY TOKEN)
3768 da1e 1f 89                        TFR  A,B            ; SAVE IT IN ACCB
3769 da20 58                           ASLB                ; X2 & BET RID OF BIT 7
3770 da21 9d 7c                        JSR  GETNCH         ; GET ANOTHER INPUT CHARACTER
3771 da23 c1 38                        CMPB #NUM_SEC_FNS-1*2 ; 29 SECONDARY FUNCTIONS - 1
3772 da25 23 03                        BLS  LB29F          ; BRANCH IF COLOR BASIC TOKEN
3773 da27 7e da 03                     JMP  LB277          ; SYNTAX ERROR
3774 da2a 34 04              LB29F     PSHS B              ; SAVE TOKEN OFFSET ON STACK
3775 da2c c1 2a                        CMPB #TOK_LEFT-$80*2 ; CHECK FOR TOKEN WITH AN ARGUMENT
3776 da2e 25 1e                        BCS  LB2C7          ; DO SECONDARIES STRING$ OR LESS
3777 da30 c1 30                        CMPB #TOK_INKEY-$80*2 ; *
3778 da32 24 1c                        BCC  LB2C9          ; * DO SECONDARIES $92 (INKEY$) OR >
3779 da34 8d c0                        BSR  LB26A          ; SYNTAX CHECK FOR A '('
3780 da36 a6 e4                        LDA  ,S             ; GET TOKEN NUMBER
3781                         * DO SECONDARIES (LEFT$, RIGHT$, MID$)
3782 da38 bd d8 e2                     JSR  LB156          ; EVALUATE FIRST STRING IN ARGUMENT
3783 da3b 8d bc                        BSR  LB26D          ; SYNTAX CHECK FOR A COMMA
3784 da3d bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARiABLE
3785 da40 35 02                        PULS A              ; GET TOKEN OFFSET FROM STACK
3786 da42 de 52                        LDU  FPA0+2         ; POINT U TO STRING DESCRIPTOR
3787 da44 34 42                        PSHS U,A            ; SAVE TOKEN OFFSET AND DESCRIPTOR ADDRESS
3788 da46 bd de 92                     JSR  LB70B          ; EVALUATE FIRST NUMERIC ARGUMENT
3789 da49 35 02                        PULS A              ; GET TOKEN OFFSET FROM STACK
3790 da4b 34 06                        PSHS B,A            ; SAVE TOKEN OFFSET AND NUMERIC ARGUMENT
3791 da4d 8e                           FCB  $8E            ; OP CODE OF LDX# - SKlP 2 BYTES
3792 da4e 8d 9e              LB2C7     BSR  LB262          ; SYNTAX CHECK FOR A '('
3793 da50 35 04              LB2C9     PULS B              ; GET TOKEN OFFSET
3794 da52 be d0 f9                     LDX  COMVEC+8       ; GET SECONDARY FUNCTION JUMP TABLE ADDRESS
3795 da55 3a                 LB2CE     ABX                 ; ADD IN COMMAND OFFSET
3796                         *
3797                         * HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION
3798 da56 ad 94                        JSR  [,X]           ; GO DO AN SECONDARY FUNCTION
3799 da58 7e d8 cf                     JMP  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
3800                         
3801                         * LOGICAL OPERATOR 'OR' JUMPS HERE
3802 da5b 86                 LB2D4     FCB  SKP1LD         ; SKIP ONE BYTE - 'OR' FLAG = $4F
3803                         
3804                         * LOGICAL OPERATOR 'AND' JUMPS HERE
3805 da5c 4f                 LB2D5     CLRA                ; AND FLAG = 0
3806 da5d 97 03                        STA  TMPLOC         ; AND/OR FLAG
3807 da5f bd db 74                     JSR  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
3808 da62 dd 01                        STD  CHARAC         ; TEMP SAVE ACCD
3809 da64 bd e3 96                     JSR  LBC4A          ; MOVE FPA1 TO FPA0
3810 da67 bd db 74                     JSR  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
3811 da6a 0d 03                        TST  TMPLOC         ; CHECK AND/OR FLAG
3812 da6c 26 06                        BNE  LB2ED          ; BRANCH IF OR
3813 da6e 94 01                        ANDA CHARAC         ; * 'AND' ACCD WITH FPA0 INTEGER
3814 da70 d4 02                        ANDB ENDCHR         ; * STORED IN ENDCHR
3815 da72 20 04                        BRA  LB2F1          ; CONVERT TO FP
3816 da74 9a 01              LB2ED     ORA  CHARAC         ; * 'OR' ACCD WITH FPA0 INTEGER
3817 da76 da 02                        ORB  ENDCHR         ; * STORED IN CHARAC
3818 da78 7e dc 7b           LB2F1     JMP  GIVABF         ; CONVERT THE VALUE IN ACCD INTO A FP NUMBER
3819                         
3820                         * RELATIONAL COMPARISON PROCESS HANDLER
3821 da7b bd d8 d4           LB2F4     JSR  LB148          ; 'TM' ERROR IF TYPE MISMATCH
3822 da7e 26 10                        BNE  LB309          ; BRANCH IF STRING VARIABLE
3823 da80 96 61                        LDA  FP1SGN         ; * 'PACK' THE MANTISSA
3824 da82 8a 7f                        ORA  #$7F           ; * SIGN OF FPA1 INTO
3825 da84 94 5d                        ANDA FPA1           ; * BIT 7 OF THE
3826 da86 97 5d                        STA  FPA1           ; * MANTISSA MS BYTE
3827 da88 8e 00 5c                     LDX  #FP1EXP        ; POINT X TO FPA1
3828 da8b bd e3 e2                     JSR  LBC96          ; COMPARE FPA0 TO FPA1
3829 da8e 20 36                        BRA  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
3830                         
3831                         * RELATIONAL COMPARISON OF STRINGS
3832 da90 0f 06              LB309     CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
3833 da92 0a 3f                        DEC  TRELFL         ; REMOVE STRING TYPE FLAG (BIT0=1 FOR STRINGS) FROM THE
3834                         *                             ; DESIRED RELATIONAL COMPARISON DATA
3835 da94 bd dd de                     JSR  LB657          ; GET LENGTH AND ADDRESS OF STRING WHOSE
3836                         *                             ; DESCRIPTOR ADDRESS IS IN THE BOTTOM OF FPA0
3837 da97 d7 56                        STB  STRDES         ; * SAVE LENGTH AND ADDRESS IN TEMPORARY
3838 da99 9f 58                        STX  STRDES+2       ; * DESCRIPTOR (STRING B)
3839 da9b 9e 5f                        LDX  FPA1+2         ; = RETURN LENGTH AND ADDRESS OF STRING
3840 da9d bd dd e0                     JSR  LB659          ; = WHOSE DESCRIPTOR ADDRESS IS STORED IN FPA1+2
3841 daa0 96 56                        LDA  STRDES         ; LOAD ACCA WITH LENGTH OF STRING B
3842 daa2 34 04                        PSHS B              ; SAVE LENGTH A ON STACK
3843 daa4 a0 e0                        SUBA ,S+            ; SUBTRACT LENGTH A FROM LENGTH B
3844 daa6 27 07                        BEQ  LB328          ; BRANCH IF STRINGS OF EQUAL LENGTH
3845 daa8 86 01                        LDA  #1             ; ; TRUE FLAG
3846 daaa 24 03                        BCC  LB328          ; TRUE IF LENGTH B > LENGTH A
3847 daac d6 56                        LDB  STRDES         ; LOAD ACCB WITH LENGTH B
3848 daae 40                           NEGA                ; SET FLAG = FALSE (1FF)
3849 daaf 97 54              LB328     STA  FP0SGN         ; SAVE TRUE/FALSE FLAG
3850 dab1 de 58                        LDU  STRDES+2       ; POINT U TO START OF STRING
3851 dab3 5c                           INCB                ; COMPENSATE FOR THE DECB BELOW
3852                         * ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING
3853 dab4 5a                 LB32D     DECB                ; DECREMENT SHORTER STRING LENGTH
3854 dab5 26 04                        BNE  LB334          ; BRANCH IF ALL OF STRING NOT COMPARED
3855 dab7 d6 54                        LDB  FP0SGN         ; GET TRUE/FALSE FLAB
3856 dab9 20 0b                        BRA  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
3857 dabb a6 80              LB334     LDA  ,X+            ; GET A BYTE FROM STRING A
3858 dabd a1 c0                        CMPA ,U+            ; COMPARE TO STRING B
3859 dabf 27 f3                        BEQ  LB32D          ; CHECK ANOTHER CHARACTER IF =
3860 dac1 c6 ff                        LDB  #$FF           ; FALSE FLAG IF STRING A > B
3861 dac3 24 01                        BCC  LB33F          ; BRANCH IF STRING A > STRING B
3862 dac5 50                           NEGB                ; SET FLAG = TRUE
3863                         
3864                         * DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA0
3865 dac6 cb 01              LB33F     ADDB #1             ; CONVERT $FF,0,1 TO 0,1,2
3866 dac8 59                           ROLB                ; NOW IT'S 1,2,4 FOR > = <
3867 dac9 d4 0a                        ANDB RELFLG         ; 'AND' THE ACTUAL COMPARISON WITH THE DESIRED -
3868                         COMPARISON
3869 dacb 27 02                        BEQ  LB348          ; BRANCH IF FALSE (NO MATCHING BITS)
3870 dacd c6 ff                        LDB  #$FF           ; TRUE FLAG
3871 dacf 7e e3 c8           LB348     JMP  LBC7C          ; CONVERT ACCB INTO FP NUMBER IN FPA0
3872                         
3873                         * DIM
3874 dad2 bd d9 f9           LB34B     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
3875 dad5 c6 01              DIM       LDB  #1             ; DIMENSION FLAG
3876 dad7 8d 08                        BSR  LB35A          ; SAVE ARRAY SPACE FOR THIS VARIABLE
3877 dad9 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3878 dadb 26 f5                        BNE  LB34B          ; KEEP DIMENSIONING IF NOT END OF LINE
3879 dadd 39                           RTS
3880                         * EVALUATE A VARIABLE - RETURN X AND
3881                         * VARPTR POINTING TO VARIABLE DESCRIPTOR
3882                         * EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO
3883                         * BYTES ARE THE VARIABLE NAME AND THE NEXT 5
3884                         * BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE
3885                         * FIRST BYTE OF VARlABLE NAME IS SET, THE
3886                         * VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF
3887                         * THE SECOND BYTE OF VARIABLE NAME IS SET, THE
3888                         * VARIABLE IS A STRING, OTHERWISE THE VARIABLE
3889                         * IS NUMERIC.
3890                         * IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS
3891                         * INSERTED INTO THE VARIABLE SPACE
3892 dade 5f                 LB357     CLRB                ; DIMENSION FLAG = 0; DO NOT SET UP AN ARRAY
3893 dadf 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3894 dae1 d7 05              LB35A     STB  DIMFLG         ; SAVE ARRAY FLAG
3895                         * ENTRY POINT FOR DEF FN VARIABLE SEARCH
3896 dae3 97 37              LB35C     STA  VARNAM         ; SAVE INPUT CHARACTER
3897 dae5 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3898 dae7 8d 40                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
3899 dae9 10 25 ff 16                  LBCS LB277          ; SYNTAX ERROR IF NOT ALPHA
3900 daed 5f                           CLRB                ; DEFAULT 2ND VARIABLE CHARACTER TO ZERO
3901 daee d7 06                        STB  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
3902 daf0 9d 7c                        JSR  GETNCH         ; GET ANOTHER CHARACTER FROM BASIC
3903 daf2 25 04                        BCS  LB371          ; BRANCH IF NUMERIC (2ND CHARACTER IN
3904                         *                             ; VARIABLE MAY BE NUMERIC)
3905 daf4 8d 33                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
3906 daf6 25 0a                        BCS  LB37B          ; BRANCH IF NOT ALPHA
3907 daf8 1f 89              LB371     TFR  A,B            ; SAVE 2ND CHARACTER IN ACCB
3908                         * READ INPUT CHARACTERS UNTIL A NON ALPHA OR
3909                         * NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS
3910                         * IN VARIABLE NAME AFTER THE 1ST TWO
3911 dafa 9d 7c              LB373     JSR  GETNCH         ; GET AN INPUT CHARACTER
3912 dafc 25 fc                        BCS  LB373          ; BRANCH IF NUMERIC
3913 dafe 8d 29                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
3914 db00 24 f8                        BCC  LB373          ; BRANCH IF ALPHA
3915 db02 81 24              LB37B     CMPA #'$            ; CHECK FOR A STRING VARIABLE
3916 db04 26 06                        BNE  LB385          ; BRANCH IF IT IS NOT A STRING
3917 db06 03 06                        COM  VALTYP         ; SET VARIABLE TYPE TO STRING
3918 db08 cb 80                        ADDB #$80           ; SET BIT 7 OF 2ND CHARACTER (STRING)
3919 db0a 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER
3920 db0c d7 38              LB385     STB  VARNAM+1       ; SAVE 2ND CHARACTER IN VARNAM+1
3921 db0e 9a 08                        ORA  ARYDIS         ; OR IN THE ARRAY DISABLE FLAG - IF = $80,
3922                         *              ; DON'T SEARCH FOR VARIABLES IN THE ARRAYS
3923 db10 80 28                        SUBA #'(            ; IS THIS AN ARRAY VARIABLE?
3924 db12 10 27 00 75                  LBEQ LB404          ; BRANCH IF IT IS
3925 db16 0f 08                        CLR  ARYDIS         ; RESET THE ARRAY DISABLE FLAG
3926 db18 9e 1b                        LDX  VARTAB         ; POINT X TO THE START OF VARIABLES
3927 db1a dc 37                        LDD  VARNAM         ; GET VARIABLE IN QUESTION
3928 db1c 9c 1d              LB395     CMPX ARYTAB         ; COMPARE X TO THE END OF VARIABLES
3929 db1e 27 12                        BEQ  LB3AB          ; BRANCH IF END OF VARIABLES
3930 db20 10 a3 81                     CMPD ,X++           ; * COMPARE VARIABLE IN QUESTION TO CURRENT
3931 db23 27 3e                        BEQ  LB3DC          ; * VARIABLE AND BRANCH IF MATCH
3932 db25 30 05                        LEAX 5,X            ; = MOVE POINTER TO NEXT VARIABLE AND
3933 db27 20 f3                        BRA  LB395          ; = KEEP LOOKING
3934                         
3935                         * SET CARRY IF NOT UPPER CASE ALPHA
3936 db29 81 41              LB3A2     CMPA #'A            ; * CARRY SET IF < 'A'
3937 db2b 25 04                        BCS  LB3AA          ; *
3938 db2d 80 5b                        SUBA #'Z+1          ; =
3939                         *         SUBA #-('Z+1)       ; = CARRY CLEAR IF <= 'Z'
3940 db2f 80 a5                        FCB  $80,$A5
3941 db31 39                 LB3AA     RTS
3942                         * PUT A NEW VARIABLE IN TABLE OF VARIABLES
3943 db32 8e 00 74           LB3AB     LDX  #ZERO          ; POINT X TO ZERO LOCATION
3944 db35 ee e4                        LDU  ,S             ; GET CURRENT RETURN ADDRESS
3945 db37 11 83 da 13                  CMPU #LB287         ; DID WE COME FROM 'EVALUATE ALPHA EXPR'?
3946 db3b 27 28                        BEQ  LB3DE          ; YES - RETURN A ZERO VALUE
3947 db3d dc 1f                        LDD  ARYEND         ; * GET END OF ARRAYS ADDRESS AND
3948 db3f dd 43                        STD  V43            ; * SAVE IT AT V43
3949 db41 c3 00 07                     ADDD #7             ; = ADD 7 TO END OF ARRAYS (EACH
3950 db44 dd 41                        STD  V41            ; = VARIABLE = 7 BYTES) AND SAVE AT V41
3951 db46 9e 1d                        LDX  ARYTAB         ; * GET END OF VARIABLES AND SAVE AT V47
3952 db48 9f 47                        STX  V47            ; *
3953 db4a bd d3 de                     JSR  LAC1E          ; MAKE A SEVEN BYTE SLOT FOR NEW VARIABLE AT
3954                         *         TOP  OF VARIABLES
3955 db4d 9e 41                        LDX  V41            ; = GET NEW END OF ARRAYS AND SAVE IT
3956 db4f 9f 1f                        STX  ARYEND         ; =
3957 db51 9e 45                        LDX  V45            ; * GET NEW END OF VARIABLES AND SAVE IT
3958 db53 9f 1d                        STX  ARYTAB         ; *
3959 db55 9e 47                        LDX  V47            ; GET OLD END OF VARIABLES
3960 db57 dc 37                        LDD  VARNAM         ; GET NEW VARIABLE NAME
3961 db59 ed 81                        STD  ,X++           ; SAVE VARIABLE NAME
3962 db5b 4f                           CLRA                ; * ZERO OUT THE FP VALUE OF THE NUMERIC
3963 db5c 5f                           CLRB                ; * VARIABLE OR THE LENGTH AND ADDRESS
3964 db5d ed 84                        STD  ,X             ; * OF A STRING VARIABLE
3965 db5f ed 02                        STD  2,X            ; *
3966 db61 a7 04                        STA  4,X            ; *
3967 db63 9f 39              LB3DC     STX  VARPTR         ; STORE ADDRESS OF VARIABLE VALUE
3968 db65 39                 LB3DE     RTS
3969                         *
3970 db66 90 80 00 00 00     LB3DF     FCB  $90,$80,$00,$00,$00 ; * FLOATING POINT -32768
3971                         *                             ; SMALLEST SIGNED TWO BYTE INTEGER
3972                         *
3973 db6b 9d 7c              LB3E4     JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
3974 db6d bd d8 cd           LB3E6     JSR  LB141          ; GO EVALUATE NUMERIC EXPRESSION
3975 db70 96 54              LB3E9     LDA  FP0SGN         ; GET FPA0 MANTISSA SIGN
3976 db72 2b 5d                        BMI  LB44A          ; 'FC' ERROR IF NEGATIVE NUMBER
3977                         
3978                         
3979 db74 bd d8 cf           INTCNV    JSR  LB143          ; 'TM' ERROR IF STRING VARIABLE
3980 db77 96 4f                        LDA  FP0EXP         ; GET FPA0 EXPONENT
3981 db79 81 90                        CMPA #$90           ; * COMPARE TO 32768 - LARGEST INTEGER EXPONENT AND
3982 db7b 25 08                        BCS  LB3FE          ; * BRANCH IF FPA0 < 32768
3983 db7d 8e db 66                     LDX  #LB3DF         ; POINT X TO FP VALUE OF -32768
3984 db80 bd e3 e2                     JSR  LBC96          ; COMPARE -32768 TO FPA0
3985 db83 26 4c                        BNE  LB44A          ; 'FC' ERROR IF NOT =
3986 db85 bd e4 14           LB3FE     JSR  LBCC8          ; CONVERT FPA0 TO A TWO BYTE INTEGER
3987 db88 dc 52                        LDD  FPA0+2         ; GET THE INTEGER
3988 db8a 39                           RTS
3989                         * EVALUATE AN ARRAY VARIABLE
3990 db8b dc 05              LB404     LDD  DIMFLG         ; GET ARRAY FLAG AND VARIABLE TYPE
3991 db8d 34 06                        PSHS B,A            ; SAVE THEM ON STACK
3992 db8f 12                           NOP                 ; DEAD SPACE CAUSED BY 1.2 REVISION
3993 db90 5f                           CLRB                ; RESET DIMENSION COUNTER
3994 db91 9e 37              LB40A     LDX  VARNAM         ; GET VARIABLE NAME
3995 db93 34 14                        PSHS X,B            ; SAVE VARIABLE NAME AND DIMENSION COUNTER
3996 db95 8d d4                        BSR  LB3E4          ; EVALUATE EXPRESSION (DIMENSlON LENGTH)
3997 db97 35 34                        PULS B,X,Y          ; PULL OFF VARIABLE NAME, DIMENSlON COUNTER,
3998                         *                             ; ARRAY FLAG
3999 db99 9f 37                        STX  VARNAM         ; SAVE VARIABLE NAME AND VARIABLE TYPE
4000 db9b de 52                        LDU  FPA0+2         ; GET DIMENSION LENGTH
4001 db9d 34 60                        PSHS U,Y            ; SAVE DIMENSION LENGTH, ARRAY FLAG, VARIABLE TYPE
4002 db9f 5c                           INCB                ; INCREASE DIMENSION COUNTER
4003 dba0 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4004 dba2 81 2c                        CMPA #',            ; CHECK FOR ANOTHER DIMENSION
4005 dba4 27 eb                        BEQ  LB40A          ; BRANCH IF MORE
4006 dba6 d7 03                        STB  TMPLOC         ; SAVE DIMENSION COUNTER
4007 dba8 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR A ')'
4008 dbab 35 06                        PULS A,B            ; * RESTORE VARIABLE TYPE AND ARRAY
4009 dbad dd 05                        STD  DIMFLG         ; * FLAG - LEAVE DIMENSION LENGTH ON STACK
4010 dbaf 9e 1d                        LDX  ARYTAB         ; GET START OF ARRAYS
4011 dbb1 9c 1f              LB42A     CMPX ARYEND         ; COMPARE TO END OF ARRAYS
4012 dbb3 27 21                        BEQ  LB44F          ; BRANCH IF NO MATCH FOUND
4013 dbb5 dc 37                        LDD  VARNAM         ; GET VARIABLE IN QUESTION
4014 dbb7 10 a3 84                     CMPD ,X             ; COMPARE TO CURRENT VARIABLE
4015 dbba 27 06                        BEQ  LB43B          ; BRANCH IF =
4016 dbbc ec 02                        LDD  2,X            ; GET OFFSET TO NEXT ARRAY VARIABLE
4017 dbbe 30 8b                        LEAX D,X            ; ADD TO CURRENT POINTER
4018 dbc0 20 ef                        BRA  LB42A          ; KEEP SEARCHING
4019 dbc2 c6 12              LB43B     LDB  #2*9           ; 'REDIMENSIONED ARRAY' ERROR
4020 dbc4 96 05                        LDA  DIMFLG         ; * TEST ARRAY FLAG - IF <>0 YOU ARE TRYING
4021 dbc6 26 0b                        BNE  LB44C          ; * TO REDIMENSION AN ARRAY
4022 dbc8 d6 03                        LDB  TMPLOC         ; GET NUMBER OF DIMENSIONS IN ARRAY
4023 dbca e1 04                        CMPB 4,X            ; COMPARE TO THIS ARRAYS DIMENSIONS
4024 dbcc 27 59                        BEQ  LB4A0          ; BRANCH IF =
4025 dbce c6 10              LB447     LDB  #8*2           ; 'BAD SUBSCRIPT'
4026 dbd0 8c                           FCB  SKP2           ; SKIP TWO BYTES
4027 dbd1 c6 08              LB44A     LDB  #4*2           ; 'ILLEGAL FUNCTION CALL'
4028 dbd3 7e d4 06           LB44C     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
4029                         
4030                         * INSERT A NEW ARRAY INTO ARRAY VARIABLES
4031                         * EACH SET OF ARRAY VARIABLES IS PRECEEDED BY A DE-
4032                         * SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS THE
4033                         * NUMBER OF DIMENSIONS IN THE ARRAY. THE BLOCK IS DEFINED
4034                         * AS FOLLOWS: BYTES 0,1:VARIABLE'S NAME; 2,3:TOTAL LENGTH
4035                         * OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIMEN-
4036                         * ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIMEN-
4037                         * SION 2;... 4+N,5+N:LENGTH OF DIMENSION N.
4038                         
4039 dbd6 cc 00 05           LB44F     LDD  #5             ; * 5 BYTES/ARRAY ENTRY SAVE AT COEFPT
4040 dbd9 dd 64                        STD  COEFPT         ; *
4041 dbdb dc 37                        LDD  VARNAM         ; = GET NAME OF ARRAY AND SAVE IN
4042 dbdd ed 84                        STD  ,X             ; = FIRST 2 BYTES OF DESCRIPTOR
4043 dbdf d6 03                        LDB  TMPLOC         ; GET NUMBER OF DIMENSIONS AND SAVE IN
4044 dbe1 e7 04                        STB  4,X            ; * 5TH BYTE OF DESCRIPTOR
4045 dbe3 bd d3 f3                     JSR  LAC33          ; CHECK FOR ROOM FOR DESCRIPTOR IN FREE RAM
4046 dbe6 9f 41                        STX  V41            ; TEMPORARILY SAVE DESCRIPTOR ADDRESS
4047 dbe8 c6 0b              LB461     LDB  #11            ; * DEFAULT DIMENSION VALUE:X(10)
4048 dbea 4f                           CLRA                ; *
4049 dbeb 0d 05                        TST  DIMFLG         ; = CHECK ARRAY FLAG AND BRANCH IF
4050 dbed 27 05                        BEQ  LB46D          ; = NOT DIMENSIONING AN ARRAY
4051 dbef 35 06                        PULS A,B            ; GET DIMENSION LENGTH
4052 dbf1 c3 00 01                     ADDD #1             ; ADD ONE (X(0) HAS A LENGTH OF ONE)
4053 dbf4 ed 05              LB46D     STD  5,X            ; SAVE LENGTH OF ARRAY DIMENSION
4054 dbf6 8d 5d                        BSR  LB4CE          ; MULTIPLY ACCUM ARRAY SIZE NUMBER LENGTH
4055                         *                             ; OF NEW DIMENSION
4056 dbf8 dd 64                        STD  COEFPT         ; TEMP STORE NEW CURRENT ACCUMULATED ARRAY SIZE
4057 dbfa 30 02                        LEAX 2,X            ; BUMP POINTER UP TWO
4058 dbfc 0a 03                        DEC  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND BRANCH IF
4059 dbfe 26 e8                        BNE  LB461          ; * NOT DONE WITH ALL DIMENSIONS
4060 dc00 9f 0f                        STX  TEMPTR         ; SAVE ADDRESS OF (END OF ARRAY DESCRIPTOR - 5)
4061 dc02 d3 0f                        ADDD TEMPTR         ; ADD TOTAL SIZE OF NEW ARRAY
4062 dc04 10 25 f7 fc                  LBCS LAC44          ; 'OM' ERROR IF > $FFFF
4063 dc08 1f 01                        TFR  D,X            ; SAVE END OF ARRAY IN X
4064 dc0a bd d3 f7                     JSR  LAC37          ; MAKE SURE THERE IS ENOUGH FREE RAM FOR ARRAY
4065 dc0d 83 00 35                     SUBD #STKBUF-5      ; SUBTRACT OUT THE (STACK BUFFER - 5)
4066 dc10 dd 1f                        STD  ARYEND         ; SAVE NEW END OF ARRAYS
4067 dc12 4f                           CLRA                ; ZERO = TERMINATOR BYTE
4068 dc13 30 1f              LB48C     LEAX -1,X           ; * STORE TWO TERMINATOR BYTES AT
4069 dc15 a7 05                        STA  5,X            ; * THE END OF THE ARRAY DESCRIPTOR
4070 dc17 9c 0f                        CMPX TEMPTR         ; *
4071 dc19 26 f8                        BNE  LB48C          ; *
4072 dc1b 9e 41                        LDX  V41            ; GET ADDRESS OF START OF DESCRIPTOR
4073 dc1d 96 1f                        LDA  ARYEND         ; GET MSB OF END OF ARRAYS; LSB ALREADY THERE
4074 dc1f 93 41                        SUBD V41            ; SUBTRACT OUT ADDRESS OF START OF DESCRIPTOR
4075 dc21 ed 02                        STD  2,X            ; SAVE LENGTH OF (ARRAY AND DESCRIPTOR)
4076 dc23 96 05                        LDA  DIMFLG         ; * GET ARRAY FLAG AND BRANCH
4077 dc25 26 2d                        BNE  LB4CD          ; * BACK IF DIMENSIONING
4078                         * CALCULATE POINTER TO CORRECT ELEMENT
4079 dc27 e6 04              LB4A0     LDB  4,X            ; GET THE NUMBER OF DIMENSIONS
4080 dc29 d7 03                        STB  TMPLOC         ; TEMPORARILY SAVE
4081 dc2b 4f                           CLRA                ; * INITIALIZE POINTER
4082 dc2c 5f                           CLRB                ; * TO ZERO
4083 dc2d dd 64              LB4A6     STD  COEFPT         ; SAVE ACCUMULATED POINTER
4084 dc2f 35 06                        PULS A,B            ; * PULL DIMENSION ARGUMENT OFF THE
4085 dc31 dd 52                        STD  FPA0+2         ; * STACK AND SAVE IT
4086 dc33 10 a3 05                     CMPD 5,X            ; COMPARE TO STORED 'DIM' ARGUMENT
4087 dc36 24 3a                        BCC  LB4EB          ; 'BS' ERROR IF > = "DIM" ARGUMENT
4088 dc38 de 64                        LDU  COEFPT         ; * GET ACCUMULATED POINTER AND
4089 dc3a 27 04                        BEQ  LB4B9          ; * BRANCH IF 1ST DIMENSION
4090 dc3c 8d 17                        BSR  LB4CE          ; = MULTIPLY ACCUMULATED POINTER AND DIMENSION
4091 dc3e d3 52                        ADDD FPA0+2         ; = LENGTH AND ADD TO CURRENT ARGUMENT
4092 dc40 30 02              LB4B9     LEAX 2,X            ; MOVE POINTER TO NEXT DIMENSION
4093 dc42 0a 03                        DEC  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND
4094 dc44 26 e7                        BNE  LB4A6          ; * BRANCH IF ANY DIMENSIONS LEFT
4095                         * MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE
4096 dc46 ed e3                        STD  ,--S
4097 dc48 58                           ASLB
4098 dc49 49                           ROLA                ; TIMES 2
4099 dc4a 58                           ASLB
4100 dc4b 49                           ROLA                ; TIMES 4
4101 dc4c e3 e1                        ADDD ,S++           ; TIMES 5
4102 dc4e 30 8b                        LEAX D,X            ; ADD OFFSET TO START OF ARRAY
4103 dc50 30 05                        LEAX 5,X            ; ADJUST POINTER FOR SIZE OF DESCRIPTOR
4104 dc52 9f 39                        STX  VARPTR         ; SAVE POINTER TO ARRAY VALUE
4105 dc54 39                 LB4CD     RTS
4106                         * MULTIPLY 2 BYTE NUMBER IN 5,X BY THE 2 BYTE NUMBER
4107                         * IN COEFPT. RETURN RESULT IN ACCD, BS ERROR IF > $FFFF
4108 dc55 86 10              LB4CE     LDA  #16            ; 16 SHIFTS TO DO A MULTIPLY
4109 dc57 97 45                        STA  V45            ; SHIFT COUNTER
4110 dc59 ec 05                        LDD  5,X            ; * GET SIZE OF DIMENSION
4111 dc5b dd 17                        STD  BOTSTK         ; * AND SAVE IT
4112 dc5d 4f                           CLRA                ; * ZERO
4113 dc5e 5f                           CLRB                ; * ACCD
4114 dc5f 58                 LB4D8     ASLB                ; = SHIFT ACCB LEFT
4115 dc60 49                           ROLA                ; = ONE BIT
4116 dc61 25 0f                        BCS  LB4EB          ; 'BS' ERROR IF CARRY
4117 dc63 08 65                        ASL  COEFPT+1       ; * SHIFT MULTIPLICAND LEFT ONE
4118 dc65 09 64                        ROL  COEFPT         ; * BIT - ADD MULTIPLIER TO ACCUMULATOR
4119 dc67 24 04                        BCC  LB4E6          ; * IF CARRY <> 0
4120 dc69 d3 17                        ADDD BOTSTK         ; ADD MULTIPLIER TO ACCD
4121 dc6b 25 05                        BCS  LB4EB          ; 'BS' ERROR IF CARRY (>$FFFF)
4122 dc6d 0a 45              LB4E6     DEC  V45            ; * DECREMENT SHIFT COUNTER
4123 dc6f 26 ee                        BNE  LB4D8          ; * IF NOT DONE
4124 dc71 39                           RTS
4125 dc72 7e db ce           LB4EB     JMP  LB447          ; 'BS' ERROR
4126                         *
4127                         * MEM
4128                         * THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE
4129                         * BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK
4130                         * FOR WHICH MEM DOES NOT ALLOW.
4131                         *
4132 dc75 1f 40              MEM       TFR  S,D            ; PUT STACK POINTER INTO ACCD
4133 dc77 93 1f                        SUBD ARYEND         ; SUBTRACT END OF ARRAYS
4134 dc79 21                           FCB  SKP1           ; SKIP ONE BYTE
4135                         *CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0
4136 dc7a 4f                 LB4F3     CLRA                ; CLEAR MS BYTE OF ACCD
4137                         * CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMBER IN FPA0
4138 dc7b 0f 06              GIVABF    CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
4139 dc7d dd 50                        STD  FPA0           ; SAVE ACCD IN TOP OF FACA
4140 dc7f c6 90                        LDB  #$90           ; EXPONENT REQUIRED IF THE TOP TWO BYTES
4141                         *         OF   FPA0 ARE TO BE TREATED AS AN INTEGER IN FPA0
4142 dc81 7e e3 ce                     JMP  LBC82          ; CONVERT THE REST OF FPA0 TO AN INTEGER
4143                         
4144                         * STR$
4145 dc84 bd d8 cf           STR       JSR  LB143          ; 'TM' ERROR IF STRING VARIABLE
4146 dc87 ce 01 f0                     LDU  #STRBUF+2      ; *CONVERT FP NUMBER TO ASCII STRING IN
4147 dc8a bd e5 28                     JSR  LBDDC          ; *THE STRING BUFFER
4148 dc8d 32 62                        LEAS 2,S            ; PURGE THE RETURN ADDRESS FROM THE STACK
4149 dc8f 8e 01 ef                     LDX  #STRBUF+1      ; *POINT X TO STRING BUFFER AND SAVE
4150 dc92 20 0b                        BRA  LB518          ; *THE STRING IN THE STRING SPACE
4151                         * RESERVE ACCB BYTES OF STRING SPACE. RETURN START
4152                         * ADDRESS IN (X) AND FRESPC
4153 dc94 9f 4d              LB50D     STX  V4D            ; SAVE X IN V4D
4154 dc96 8d 5c              LB50F     BSR  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
4155 dc98 9f 58              LB511     STX  STRDES+2       ; SAVE NEW STRING ADDRESS
4156 dc9a d7 56                        STB  STRDES         ; SAVE LENGTH OF RESERVED BLOCK
4157 dc9c 39                           RTS
4158 dc9d 30 1f              LB516     LEAX -1,X           ; MOVE POINTER BACK ONE
4159                         * SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO) OR
4160                         * EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR ENDCHR IS MATCHED.
4161                         * THE RESULTING STRING IS STORED IN THE STRING SPACE
4162                         * ONLY IF THE START OF THE STRING IS <= STRBUF+2
4163 dc9f 86 22              LB518     LDA  #'"            ; * INITIALIZE
4164 dca1 97 01                        STA  CHARAC         ; * TERMINATORS
4165 dca3 97 02              LB51A     STA  ENDCHR         ; * TO "
4166 dca5 30 01              LB51E     LEAX 1,X            ; MOVE POINTER UP ONE
4167 dca7 9f 62                        STX  RESSGN         ; TEMPORARILY SAVE START OF STRING
4168 dca9 9f 58                        STX  STRDES+2       ; SAVE START OF STRING IN TEMP DESCRIPTOR
4169 dcab c6 ff                        LDB  #-1            ; INITIALIZE CHARACTER COUNTER TO - 1
4170 dcad 5c                 LB526     INCB                ; INCREMENT CHARACTER COUNTER
4171 dcae a6 80                        LDA  ,X+            ; GET CHARACTER
4172 dcb0 27 0c                        BEQ  LB537          ; BRANCH IF END OF LINE
4173 dcb2 91 01                        CMPA CHARAC         ; * CHECK FOR TERMINATORS
4174 dcb4 27 04                        BEQ  LB533          ; * IN CHARAC AND ENDCHR
4175 dcb6 91 02                        CMPA ENDCHR         ; * DON'T MOVE POINTER BACK
4176 dcb8 26 f3                        BNE  LB526          ; * ONE IF TERMINATOR IS "MATCHED"
4177 dcba 81 22              LB533     CMPA #'"            ; = COMPARE CHARACTER TO STRING DELIMITER
4178 dcbc 27 02                        BEQ  LB539          ; = & DON'T MOVE POINTER BACK IF SO
4179 dcbe 30 1f              LB537     LEAX -1,X           ; MOVE POINTER BACK ONE
4180 dcc0 9f 64              LB539     STX  COEFPT         ; SAVE END OF STRING ADDRESS
4181 dcc2 d7 56                        STB  STRDES         ; SAVE STRING LENGTH IN TEMP DESCRIPTOR
4182 dcc4 de 62                        LDU  RESSGN         ; GET INITlAL STRING START
4183 dcc6 11 83 01 f0                  CMPU #STRBUF+2      ; COMPARE TO START OF STRING BUFFER
4184 dcca 22 07              LB543     BHI  LB54C          ; BRANCH IF > START OF STRING BUFFER
4185 dccc 8d c6                        BSR  LB50D          ; GO RESERVE SPACE FOR THE STRING
4186 dcce 9e 62                        LDX  RESSGN         ; POINT X TO THE BEGINNING OF THE STRING
4187 dcd0 bd dd cc                     JSR  LB645          ; MOVE (B) BYTES FROM (X) TO
4188                         *                             [FRESPC] - MOVE STRING DATA
4189                         * PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA
4190                         * ON THE STRING STACK. SET VARIABLE TYPE TO STRING
4191 dcd3 9e 0b              LB54C     LDX  TEMPPT         ; GET NEXT AVAILABLE STRING STACK DESCRIPTOR
4192 dcd5 8c 00 f1                     CMPX #LINHDR        ; COMPARE TO TOP OF STRING DESCRIPTOR STACK - WAS #CFNBUF
4193 dcd8 26 05                        BNE  LB558          ; FORMULA O.K.
4194 dcda c6 1e                        LDB  #15*2          ; STRING FORMULA TOO COMPLEX' ERROR
4195 dcdc 7e d4 06           LB555     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
4196 dcdf 96 56              LB558     LDA  STRDES         ; * GET LENGTH OF STRING AND SAVE IT
4197                         *         STA  ,X             ; * IN BYTE 0 OF DESCRIPTOR
4198 dce1 a7 00                        FCB  $A7,$00
4199 dce3 dc 58                        LDD  STRDES+2       ; = GET START ADDRESS OF ACTUAL STRING
4200 dce5 ed 02                        STD  2,X            ; = AND SAVE IN BYTES 2,3 OF DESCRIPTOR
4201 dce7 86 ff                        LDA  #$FF           ; * VARIABLE TYPE = STRING
4202 dce9 97 06                        STA  VALTYP         ; * SAVE IN VARIABLE TYPE FLAG
4203 dceb 9f 0d                        STX  LASTPT         ; = SAVE START OF DESCRIPTOR
4204 dced 9f 52                        STX  FPA0+2         ; = ADDRESS IN LASTPT AND FPA0
4205 dcef 30 05                        LEAX 5,X            ; 5 BYTES/STRING DESCRIPTOR
4206 dcf1 9f 0b                        STX  TEMPPT         ; NEXT AVAILABLE STRING VARIABLE DESCRIPTOR
4207 dcf3 39                           RTS
4208                         * RESERVE ACCB BYTES IN STRING STORAGE SPACE
4209                         * RETURN WITH THE STARTING ADDRESS OF THE
4210                         * RESERVED STRING SPACE IN (X) AND FRESPC
4211 dcf4 0f 07              LB56D     CLR  GARBFL         ; CLEAR STRING REORGANIZATION FLAG
4212 dcf6 4f                 LB56F     CLRA                ; * PUSH THE LENGTH OF THE
4213 dcf7 34 06                        PSHS B,A            ; * STRING ONTO THE STACK
4214 dcf9 dc 23                        LDD  STRTAB         ; GET START OF STRING VARIABLES
4215 dcfb a3 e0                        SUBD ,S+            ; SUBTRACT STRING LENGTH
4216 dcfd 10 93 21                     CMPD FRETOP         ; COMPARE TO START OF STRING STORAGE
4217 dd00 25 0a                        BCS  LB585          ; IF BELOW START, THEN REORGANIZE
4218 dd02 dd 23                        STD  STRTAB         ; SAVE NEW START OF STRING VARIABLES
4219 dd04 9e 23                        LDX  STRTAB         ; GET START OF STRING VARIABLES
4220 dd06 30 01                        LEAX 1,X            ; ADD ONE
4221 dd08 9f 25                        STX  FRESPC         ; SAVE START ADDRESS OF NEWLY RESERVED SPACE
4222 dd0a 35 84                        PULS B,PC           ; RESTORE NUMBER OF BYTES RESERVED AND RETURN
4223 dd0c c6 1a              LB585     LDB  #2*13          ; OUT OF STRING SPACE' ERROR
4224 dd0e 03 07                        COM  GARBFL         ; TOGGLE REORGANIZATiON FLAG
4225 dd10 27 ca                        BEQ  LB555          ; ERROR IF FRESHLY REORGANIZED
4226 dd12 8d 04                        BSR  LB591          ; GO REORGANIZE STRING SPACE
4227 dd14 35 04                        PULS B              ; GET BACK THE NUMBER OF BYTES TO RESERVE
4228 dd16 20 de                        BRA  LB56F          ; TRY TO RESERVE ACCB BYTES AGAIN
4229                         * REORGANIZE THE STRING SPACE
4230 dd18 9e 27              LB591     LDX  MEMSIZ         ; GET THE TOP OF STRING SPACE
4231 dd1a 9f 23              LB593     STX  STRTAB         ; SAVE TOP OF UNORGANIZED STRING SPACE
4232 dd1c 4f                           CLRA                ; * ZERO OUT ACCD
4233 dd1d 5f                           CLRB                ; * AND RESET VARIABLE
4234 dd1e dd 4b                        STD  V4B            ; * POINTER TO 0
4235 dd20 9e 21                        LDX  FRETOP         ; POINT X TO START OF STRING SPACE
4236 dd22 9f 47                        STX  V47            ; SAVE POINTER IN V47
4237 dd24 8e 00 c9                     LDX  #STRSTK        ; POINT X TO START OF STRING DESCRIPTOR STACK
4238 dd27 9c 0b              LB5A0     CMPX TEMPPT         ; COMPARE TO ADDRESS OF NEXT AVAILABLE DESCRIPTOR
4239 dd29 27 04                        BEQ  LB5A8          ; BRANCH IF TOP OF STRING STACK
4240 dd2b 8d 32                        BSR  LB5D8          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
4241 dd2d 20 f8                        BRA  LB5A0          ; KEEP CHECKING
4242 dd2f 9e 1b              LB5A8     LDX  VARTAB         ; GET THE END OF BASIC PROGRAM
4243 dd31 9c 1d              LB5AA     CMPX ARYTAB         ; COMPARE TO END OF VARIABLES
4244 dd33 27 04                        BEQ  LB5B2          ; BRANCH IF AT TOP OF VARIABLES
4245 dd35 8d 22                        BSR  LB5D2          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
4246 dd37 20 f8                        BRA  LB5AA          ; KEEP CHECKING VARIABLES
4247 dd39 9f 41              LB5B2     STX  V41            ; SAVE ADDRESS OF THE END OF VARIABLES
4248 dd3b 9e 41              LB5B4     LDX  V41            ; GET CURRENT ARRAY POINTER
4249 dd3d 9c 1f              LB5B6     CMPX ARYEND         ; COMPARE TO THE END OF ARRAYS
4250 dd3f 27 35                        BEQ  LB5EF          ; BRANCH IF AT END OF ARRAYS
4251 dd41 ec 02                        LDD  2,X            ; GET LENGTH OF ARRAY AND DESCRIPTOR
4252 dd43 d3 41                        ADDD V41            ; * ADD TO CURRENT ARRAY POINTER
4253 dd45 dd 41                        STD  V41            ; * AND SAVE IT
4254 dd47 a6 01                        LDA  1,X            ; GET 1ST CHARACTER OF VARIABLE NAME
4255 dd49 2a f0                        BPL  LB5B4          ; BRANCH IF NUMERIC ARRAY
4256 dd4b e6 04                        LDB  4,X            ; GET THE NUMBER OF DIMENSIONS IN THIS ARRAY
4257 dd4d 58                           ASLB                ; MULTIPLY BY 2
4258 dd4e cb 05                        ADDB #5             ; ADD FIVE BYTES (VARIABLE NAME, ARRAY
4259                         *                             ; LENGTH, NUMBER DIMENSIONS)
4260 dd50 3a                           ABX                 ; X NOW POINTS TO START OF ARRAY ELEMENTS
4261 dd51 9c 41              LB5CA     CMPX V41            ; AT END OF THIS ARRAY?
4262 dd53 27 e8                        BEQ  LB5B6          ; YES - CHECK FOR ANOTHER
4263 dd55 8d 08                        BSR  LB5D8          ; CHECK FOR STRING LOCATED IN
4264                         *                             ; UNORGANIZED STRING SPACE
4265 dd57 20 f8                        BRA  LB5CA          ; KEEP CHECKING ELEMENTS IN THIS ARRAY
4266 dd59 a6 01              LB5D2     LDA  1,X            ; GET F1RST BYTE OF VARIABLE NAME
4267 dd5b 30 02                        LEAX 2,X            ; MOVE POINTER TO DESCRIPTOR
4268 dd5d 2a 14                        BPL  LB5EC          ; BRANCH IF VARIABLE IS NUMERIC
4269                         * SEARCH FOR STRING - ENTER WITH X POINTING TO
4270                         * THE STRING DESCRIPTOR. IF STRING IS STORED
4271                         * BETWEEN V47 AND STRTAB, SAVE DESCRIPTOR POINTER
4272                         * IN V4B AND RESET V47 TO STRING ADDRESS
4273 dd5f e6 84              LB5D8     LDB  ,X             ; GET THE LENGTH OF THE STRING
4274 dd61 27 10                        BEQ  LB5EC          ; BRANCH IF NULL - NO STRING
4275 dd63 ec 02                        LDD  2,X            ; GET STARTING ADDRESS OF THE STRING
4276 dd65 10 93 23                     CMPD STRTAB         ; COMPARE TO THE START OF STRING VARIABLES
4277 dd68 22 09                        BHI  LB5EC          ; BRANCH IF THIS STRING IS STORED IN
4278                         *              ; THE STRING VARIABLES
4279 dd6a 10 93 47                     CMPD V47            ; COMPARE TO START OF STRING SPACE
4280 dd6d 23 04                        BLS  LB5EC          ; BRANCH IF NOT STORED IN THE STRING SPACE
4281 dd6f 9f 4b                        STX  V4B            ; SAVE VARIABLE POINTER IF STORED IN STRING SPACE
4282 dd71 dd 47                        STD  V47            ; SAVE STRING STARTING ADDRESS
4283 dd73 30 05              LB5EC     LEAX 5,X            ; MOVE TO NEXT VARIABLE DESCRIPTOR
4284 dd75 39                 LB5EE     RTS
4285 dd76 9e 4b              LB5EF     LDX  V4B            ; GET ADDRESS OF THE DESCRIPTOR FOR THE
4286                         *              ; STRING WHICH IS STORED IN THE HIGHEST RAM ADDRESS IN
4287                         *              ; THE UNORGANIZED STRING SPACE
4288 dd78 27 fb                        BEQ  LB5EE          ; BRANCH IF NONE FOUND AND REORGANIZATION DONE
4289 dd7a 4f                           CLRA                ; CLEAR MS BYTE OF LENGTH
4290 dd7b e6 84                        LDB  ,X             ; GET LENGTH OF STRING
4291 dd7d 5a                           DECB                ; SUBTRACT ONE
4292 dd7e d3 47                        ADDD V47            ; ADD LENGTH OF STRING TO ITS STARTING ADDRESS
4293 dd80 dd 43                        STD  V43            ; SAVE AS MOVE STARTING ADDRESS
4294 dd82 9e 23                        LDX  STRTAB         ; POINT X TO THE START OF ORGANIZED STRING VARIABLES
4295 dd84 9f 41                        STX  V41            ; SAVE AS MOVE ENDING ADDRESS
4296 dd86 bd d3 e0                     JSR  LAC20          ; MOVE STRING FROM CURRENT POSITION TO THE
4297                         *              ; TOP OF UNORGANIZED STRING SPACE
4298 dd89 9e 4b                        LDX  V4B            ; POINT X TO STRING DESCRIPTOR
4299 dd8b dc 45                        LDD  V45            ; * GET NEW STARTING ADDRESS OF STRING AND
4300 dd8d ed 02                        STD  2,X            ; * SAVE IT IN DESCRIPTOR
4301 dd8f 9e 45                        LDX  V45            ; GET NEW TOP OF UNORGANIZED STRING SPACE
4302 dd91 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
4303 dd93 7e dd 1a                     JMP  LB593          ; JUMP BACK AND REORGANIZE SOME MORE
4304                         
4305                         
4306 dd96 dc 52              LB60F     LDD  FPA0+2         ; * GET DESCRIPTOR ADDRESS OF STRING A
4307 dd98 34 06                        PSHS B,A            ; * AND SAVE IT ON THE STACK
4308 dd9a bd d9 af                     JSR  LB223          ; GET DESCRIPTOR ADDRESS OF STRING B
4309 dd9d bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
4310 dda0 35 10                        PULS X              ; * POINT X TO STRING A DESCRIPTOR
4311 dda2 9f 62                        STX  RESSGN         ; * ADDRESS AND SAVE IT IN RESSGN
4312 dda4 e6 84                        LDB  ,X             ; GET LENGTH OF STRING A
4313 dda6 9e 52                        LDX  FPA0+2         ; POINT X TO DESCRIPTOR OF STRING B
4314 dda8 eb 84                        ADDB ,X             ; ADD LENGTH OF STRING B TO STR1NG A
4315 ddaa 24 05                        BCC  LB62A          ; BRANCH IF LENGTH < 256
4316 ddac c6 1c                        LDB  #2*14          ; 'STRING TOO LONG' ERROR IF LENGTH > 255
4317 ddae 7e d4 06                     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
4318 ddb1 bd dc 94           LB62A     JSR  LB50D          ; RESERVE ROOM IN STRING SPACE FOR NEW STRING
4319 ddb4 9e 62                        LDX  RESSGN         ; GET DESCRIPTOR ADDRESS OF STRING A
4320 ddb6 e6 84                        LDB  ,X             ; GET LENGTH OF STRING A
4321 ddb8 8d 10                        BSR  LB643          ; MOVE STRING A INTO RESERVED BUFFER IN STRING SPACE
4322 ddba 9e 4d                        LDX  V4D            ; GET DESCRIPTOR ADDRESS OF STRING B
4323 ddbc 8d 22                        BSR  LB659          ; GET LENGTH AND ADDRESS OF STRING B
4324 ddbe 8d 0c                        BSR  LB645          ; MOVE STRING B INTO REST OF RESERVED BUFFER
4325 ddc0 9e 62                        LDX  RESSGN         ; POINT X TO DESCRIPTOR OF STRING A
4326 ddc2 8d 1c                        BSR  LB659          ; DELETE STRING A IF LAST STRING ON STRING STACK
4327 ddc4 bd dc d3                     JSR  LB54C          ; PUT STRING DESCRIPTOR ON THE STRING STACK
4328 ddc7 7e d8 f4                     JMP  LB168          ; BRANCH BACK TO EXPRESSION EVALUATION
4329                         
4330                         * MOVE (B) BYTES FROM 2,X TO FRESPC
4331 ddca ae 02              LB643     LDX  2,X            ; POINT X TO SOURCE ADDRESS
4332 ddcc de 25              LB645     LDU  FRESPC         ; POINT U TO DESTINATION ADDRESS
4333 ddce 5c                           INCB                ; COMPENSATION FOR THE DECB BELOW
4334 ddcf 20 04                        BRA  LB64E          ; GO MOVE THE BYTES
4335                         * MOVE B BYTES FROM (X) TO (U)
4336 ddd1 a6 80              LB64A     LDA  ,X+            ; * GET A SOURCE BYTE AND MOVE IT
4337 ddd3 a7 c0                        STA  ,U+            ; * TO THE DESTINATION
4338 ddd5 5a                 LB64E     DECB                ; DECREMENT BYTE COUNTER
4339 ddd6 26 f9                        BNE  LB64A          ; BRANCH IF ALL BYTES NOT MOVED
4340 ddd8 df 25                        STU  FRESPC         ; SAVE ENDING ADDRESS IN FRESPC
4341 ddda 39                           RTS
4342                         * RETURN LENGTH (ACCB) AND ADDRESS (X) OF
4343                         * STRING WHOSE DESCRIPTOR IS IN FPA0+2
4344                         * DELETE THE STRING IF IT IS THE LAST ONE
4345                         * PUT ON THE STRING STACK. REMOVE STRING FROM STRING
4346                         * SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.
4347 dddb bd d8 d2           LB654     JSR  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
4348 ddde 9e 52              LB657     LDX  FPA0+2         ; GET ADDRESS OF SELECTED STRING DESCRIPTOR
4349 dde0 e6 84              LB659     LDB  ,X             ; GET LENGTH OF STRING
4350 dde2 8d 18                        BSR  LB675          ; * CHECK TO SEE IF THIS STRING DESCRIPTOR WAS
4351 dde4 26 13                        BNE  LB672          ; * THE LAST ONE PUT ON THE STRING STACK AND
4352                         *                             ; * BRANCH IF NOT
4353 dde6 ae 07                        LDX  5+2,X          ; GET START ADDRESS OF STRING JUST REMOVED
4354 dde8 30 1f                        LEAX -1,X           ; MOVE POINTER DOWN ONE
4355 ddea 9c 23                        CMPX STRTAB         ; COMPARE TO START OF STRING VARIABLES
4356 ddec 26 08                        BNE  LB66F          ; BRANCH IF THIS STRING IS NOT AT THE BOTTOM
4357                         *                             ; OF STRING VARIABLES
4358 ddee 34 04                        PSHS B              ; SAVE LENGTH; ACCA WAS CLEARED
4359 ddf0 d3 23                        ADDD STRTAB         ; * ADD THE LENGTH OF THE JUST REMOVED STRING
4360 ddf2 dd 23                        STD  STRTAB         ; * TO THE START OF STRING VARIABLES - THIS WILL
4361                         *                             ; * REMOVE THE STRING FROM THE STRING SPACE
4362 ddf4 35 04                        PULS B              ; RESTORE LENGTH
4363 ddf6 30 01              LB66F     LEAX 1,X            ; ADD ONE TO POINTER
4364 ddf8 39                           RTS
4365 ddf9 ae 02              LB672     LDX  2,X            ; *POINT X TO ADDRESS OF STRING NOT
4366 ddfb 39                           RTS                 ; *ON THE STRING STACK
4367                         * REMOVE STRING FROM STRING STACK. ENTER WITH X
4368                         * POINTING TO A STRING DESCRIPTOR - DELETE THE
4369                         * STRING FROM STACK IF IT IS ON TOP OF THE
4370                         * STACK. IF THE STRING IS DELETED, SET THE ZERO FLAG
4371 ddfc 9c 0d              LB675     CMPX LASTPT         ; *COMPARE TO LAST USED DESCRIPTOR ADDRESS
4372 ddfe 26 07                        BNE  LB680          ; *ON THE STRING STACK, RETURN IF DESCRIPTOR
4373                         *                             ; *ADDRESS NOT ON THE STRING STACK
4374 de00 9f 0b                        STX  TEMPPT         ; SAVE LAST USED DESCRIPTOR AS NEXT AVAILABLE
4375 de02 30 1b                        LEAX -5,X           ; * MOVE LAST USED DESCRIPTOR BACK 5 BYTES
4376 de04 9f 0d                        STX  LASTPT         ; * AND SAVE AS THE LAST USED DESCRIPTOR ADDR
4377 de06 4f                           CLRA                ; SET ZERO FLAG
4378 de07 39                 LB680     RTS
4379                         
4380                         * LEN
4381 de08 8d 03              LEN       BSR  LB686          ; POINT X TO PROPER STRING AND GET LENGTH
4382 de0a 7e dc 7a           LB683     JMP  LB4F3          ; CONVERT ACCB TO FP NUMBER IN FPA0
4383                         * POINT X TO STRING ADDRESS LOAD LENGTH INTO
4384                         * ACCB. ENTER WITH THE STRING DESCRIPTOR IN
4385                         * BOTTOM TWO BYTES OF FPA0
4386 de0d 8d cc              LB686     BSR  LB654          ; GET LENGTH AND ADDRESS OF STRING
4387 de0f 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
4388 de11 5d                           TSTB                ; SET FLAGS ACCORDING TO LENGTH
4389 de12 39                           RTS
4390                         
4391                         * CHR$
4392 de13 bd de 95           CHR       JSR  LB70E          ; CONVERT FPA0 TO AN INTEGER IN ACCD
4393 de16 c6 01              LB68F     LDB  #1             ; * RESERVE ONE BYTE IN
4394 de18 bd dc f4                     JSR  LB56D          ; * THE STRING SPACE
4395 de1b 96 53                        LDA  FPA0+3         ; GET ASCII STRING VALUE
4396 de1d bd dc 98                     JSR  LB511          ; SAVE RESERVED STRING DESCRIPTOR IN TEMP DESCRIPTOR
4397 de20 a7 84                        STA  ,X             ; SAVE THE STRING (IT'S ONLY ONE BYTE)
4398 de22 32 62              LB69B     LEAS 2,S            ; PURGE THE RETURN ADDRESS OFF OF THE STACK
4399 de24 7e dc d3           LB69D     JMP  LB54C          ; PUT TEMP DESCRIPTOR DATA ONTO STRING STACK
4400                         
4401                         
4402 de27 8d 02              ASC       BSR  LB6A4          ; PUT 1ST CHARACTER OF STRING INTO ACCB
4403 de29 20 df                        BRA  LB683          ; CONVERT ACCB INTO FP NUMBER IN FPA0
4404 de2b 8d e0              LB6A4     BSR  LB686          ; POINT X TO STRING DESCRIPTOR
4405 de2d 27 5e                        BEQ  LB706          ; 'FC' ERROR IF NULL STRING
4406 de2f e6 84                        LDB  ,X             ; GET FIRST BYTE OF STRING
4407 de31 39                           RTS
4408                         
4409                         
4410 de32 8d 48              LEFT      BSR  LB6F5          ; GET ARGUMENTS FROM STACK
4411 de34 4f                 LB6AD     CLRA                ; CLEAR STRING POINTER OFFSET - OFFSET = 0 FOR LEFT$
4412 de35 e1 84              LB6AE     CMPB ,X             ; * COMPARE LENGTH PARAMETER TO LENGTH OF
4413 de37 23 03                        BLS  LB6B5          ; * STRING AND BRANCH IF LENGTH OF STRING
4414                         *                             ; >= LENGTH PARAMETER
4415 de39 e6 84                        LDB  ,X             ; USE LENGTH OF STRING OTHERWISE
4416 de3b 4f                           CLRA                ; CLEAR STRING POINTER OFFSET (0 FOR LEFT$)
4417 de3c 34 06              LB6B5     PSHS B,A            ; PUSH PARAMETERS ONTO STACK
4418 de3e bd dc 96                     JSR  LB50F          ; RESERVE ACCB BYTES IN THE STRING SPACE
4419 de41 9e 4d                        LDX  V4D            ; POINT X TO STRING DESCRIPTOR
4420 de43 8d 9b                        BSR  LB659          ; GET ADDRESS OF OLD STRING (X=ADDRESS)
4421 de45 35 04                        PULS B              ; * PULL STRING POINTER OFFSET OFF OF THE STACK
4422 de47 3a                           ABX                 ; * AND ADD IT TO STRING ADDRESS
4423 de48 35 04                        PULS B              ; PULL LENGTH PARAMETER OFF OF THE STACK
4424 de4a bd dd cc                     JSR  LB645          ; MOVE ACCB BYTES FROM (X) TO [FRESPC]
4425 de4d 20 d5                        BRA  LB69D          ; PUT TEMP STRING DESCRIPTOR ONTO THE STRING STACK
4426                         
4427                         * RIGHT$
4428 de4f 8d 2b              RIGHT     BSR  LB6F5          ; GET ARGUMENTS FROM STACK
4429 de51 a0 84                        SUBA ,X             ; ACCA=LENGTH PARAMETER - LENGTH OF OLD STRING
4430 de53 40                           NEGA                ; NOW ACCA = LENGTH OF OLD STRING
4431 de54 20 df                        BRA  LB6AE          ; PUT NEW STRING IN THE STRING SPACE
4432                         
4433                         * MID$
4434 de56 c6 ff              MID       LDB  #$FF           ; * GET DEFAULT VALUE OF LENGTH AND
4435 de58 d7 53                        STB  FPA0+3         ; * SAVE IT IN FPA0
4436 de5a 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
4437 de5c 81 29                        CMPA #')            ; ARGUMENT DELIMITER?
4438 de5e 27 05                        BEQ  LB6DE          ; YES - NO LENGTH PARAMETER GIVEN
4439 de60 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4440 de63 8d 2d                        BSR  LB70B          ; EVALUATE NUMERIC EXPRESSION (LENGTH)
4441 de65 8d 15              LB6DE     BSR  LB6F5          ; GET ARGUMENTS FROM STACK
4442 de67 27 24                        BEQ  LB706          ; 'FC' ERROR IF NULL STRING
4443 de69 5f                           CLRB                ; CLEAR LENGTH COUNTER (DEFAULT VALUE)
4444 de6a 4a                           DECA                ; *SUOTRACT ONE FROM POSITION PARAMETER (THESE
4445 de6b a1 84                        CMPA ,X             ; *ROUTINES EXPECT 1ST POSITION TO BE ZERO, NOT ONE)
4446                         *                             ; *AND COMPARE IT TO LENGTH OF OLD STRING
4447 de6d 24 cd                        BCC  LB6B5          ; IF POSITION > LENGTH OF OLD STRING, THEN NEW
4448                         *                             ; STRING WILL BE A NULL STRING
4449 de6f 1f 89                        TFR  A,B            ; SAVE ABSOLUTE POSITION PARAMETER IN ACCB
4450 de71 e0 84                        SUBB ,X             ; ACCB=POSITION-LENGTH OF OLD STRING
4451 de73 50                           NEGB                ; NOW ACCB=LENGTH OF OLDSTRING-POSITION
4452 de74 d1 53                        CMPB FPA0+3         ; *IF THE AMOUNT OF OLD STRING TO THE RIGHT OF
4453 de76 23 c4                        BLS  LB6B5          ; *POSITION IS <= THE LENGTH PARAMETER, BRANCH AND
4454                         * USE ALL OF THE STRING TO THE RIGHT OF THE POSITION
4455                         * INSTEAD OF THE LENGTH PARAMETER
4456 de78 d6 53                        LDB  FPA0+3         ; GET LENGTH OF NEW STRING
4457 de7a 20 c0                        BRA  LB6B5          ; PUT NEW STRING IN STRING SPACE
4458                         * DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY CALCULATED NUMERIC
4459                         * ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR OFF OF THE STACK
4460 de7c bd d9 f3           LB6F5     JSR  LB267          ; SYNTAX CHECK FOR A ")"
4461 de7f ee e4                        LDU  ,S             ; LOAD THE RETURN ADDRESS INTO U REGISTER
4462 de81 ae 65                        LDX  5,S            ; * GET ADDRESS OF STRING AND
4463 de83 9f 4d                        STX  V4D            ; * SAVE IT IN V4D
4464 de85 a6 64                        LDA  4,S            ; = PUT LENGTH OF STRING IN
4465 de87 e6 64                        LDB  4,S            ; = BOTH ACCA AND ACCB
4466 de89 32 67                        LEAS 7,S            ; REMOVE DESCRIPTOR AND RETURN ADDRESS FROM STACK
4467 de8b 1f 35                        TFR  U,PC           ; JUMP TO ADDRESS IN U REGISTER
4468 de8d 7e db d1           LB706     JMP  LB44A          ; 'ILLEGAL FUNCTION CALL'
4469                         * EVALUATE AN EXPRESSION - RETURN AN INTEGER IN
4470                         * ACCB - 'FC' ERROR IF EXPRESSION > 255
4471 de90 9d 7c              LB709     JSR  GETNCH         ; GET NEXT BASIC INPUT CHARACTER
4472 de92 bd d8 cd           LB70B     JSR  LB141          ; EVALUATE A NUMERIC EXPRESSION
4473 de95 bd db 70           LB70E     JSR  LB3E9          ; CONVERT FPA0 TO INTEGER IN ACCD
4474 de98 4d                           TSTA                ; TEST MS BYTE OF INTEGER
4475 de99 26 f2                        BNE  LB706          ; 'FC' ERROR IF EXPRESSION > 255
4476 de9b 0e 82                        JMP  GETCCH         ; GET CURRENT INPUT CHARACTER FROM BASIC
4477                         
4478                         * VAL
4479 de9d bd de 0d           VAL       JSR  LB686          ; POINT X TO STRING ADDRESS
4480 dea0 10 27 02 e1                  LBEQ LBA39          ; IF NULL STRING SET FPA0
4481 dea4 de 83                        LDU  CHARAD         ; SAVE INPUT POINTER IN REGISTER U
4482 dea6 9f 83                        STX  CHARAD         ; POINT INPUT POINTER TO ADDRESS OF STRING
4483 dea8 3a                           ABX                 ; MOVE POINTER TO END OF STRING TERMINATOR
4484 dea9 a6 84                        LDA  ,X             ; GET LAST BYTE OF STRING
4485 deab 34 52                        PSHS U,X,A          ; SAVE INPUT POINTER, STRING TERMINATOR
4486                         *         ADDRESS AND CHARACTER
4487 dead 6f 84                        CLR  ,X             ; CLEAR STRING TERMINATOR : FOR ASCII - FP CONVERSION
4488 deaf 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
4489 deb1 bd e4 5e                     JSR  LBD12          ; CONVERT AN ASCII STRING TO FLOATING POINT
4490 deb4 35 52                        PULS A,X,U          ; RESTORE CHARACTERS AND POINTERS
4491 deb6 a7 84                        STA  ,X             ; REPLACE STRING TERMINATOR
4492 deb8 df 83                        STU  CHARAD         ; RESTORE INPUT CHARACTER
4493 deba 39                           RTS
4494                         
4495 debb 8d 07              LB734     BSR  LB73D          ; * EVALUATE AN EXPRESSION, RETURN
4496 debd 9f 2b                        STX  BINVAL         ; * THE VALUE IN X; STORE IT IN BINVAL
4497 debf bd d9 f9           LB738     JSR  LB26D          ; SYNTAX CHECK FOR A COMMA
4498 dec2 20 ce                        BRA  LB70B          ; EVALUATE EXPRESSION IN RANGE 0 <= X < 256
4499                         * EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 'FC' ERROR IF
4500                         
4501 dec4 bd d8 cd           LB73D     JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
4502 dec7 96 54              LB740     LDA  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
4503 dec9 2b c2                        BMI  LB706          ; ILLEGAL FUNCTION CALL' IF NEGATIVE
4504 decb 96 4f                        LDA  FP0EXP         ; GET EXPONENT OF FPA0
4505 decd 81 90                        CMPA #$90           ; COMPARE TO LARGEST POSITIVE INTEGER
4506 decf 22 bc                        BHI  LB706          ; ILLEGAL FUNCTION CALL' IF TOO LARGE
4507 ded1 bd e4 14                     JSR  LBCC8          ; SHIFT BINARY POINT TO EXTREME RIGHT OF FPA0
4508 ded4 9e 52                        LDX  FPA0+2         ; LOAD X WITH LOWER TWO BYTES OF FPA0
4509 ded6 39                           RTS
4510                         
4511                         * PEEK
4512 ded7 8d ee              PEEK      BSR  LB740          ; CONVERT FPA0 TO INTEGER IN REGISTER X
4513 ded9 e6 84                        LDB  ,X             ; GET THE VALUE BEING 'PEEK'ED
4514 dedb 7e dc 7a                     JMP  LB4F3          ; CONVERT ACCB INTO A FP NUMBER
4515                         
4516                         * POKE
4517 dede 8d db              POKE      BSR  LB734          ; EVALUATE 2 EXPRESSIONS
4518 dee0 9e 2b                        LDX  BINVAL         ; GET THE ADDRESS TO BE 'POKE'ED
4519 dee2 e7 84                        STB  ,X             ; STORE THE DATA IN THAT ADDRESS
4520 dee4 39                           RTS
4521                         
4522                         
4523                         * LIST
4524 dee5 34 01              LIST      PSHS CC             ; SAVE ZERO FLAG ON STACK
4525 dee7 bd d7 17                     JSR  LAF67          ; CONVERT DECIMAL LINE NUMBER TO BINARY
4526 deea bd d4 a5                     JSR  LAD01          ; * FIND RAM ADDRESS OF THAT LINE NUMBER AND
4527 deed 9f 66                        STX  LSTTXT         ; * SAVE IT IN LSTTXT
4528 deef 35 01                        PULS CC             ; GET ZERO FLAG FROM STACK
4529 def1 27 12                        BEQ  LB784          ; BRANCH IF END OF LINE
4530 def3 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
4531 def5 27 13                        BEQ  LB789          ; BRANCH IF END OF LINE
4532 def7 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN (IS IT A RANGE OF LINE NUMBERS?)
4533 def9 26 09                        BNE  LB783          ; NO - RETURN
4534 defb 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
4535 defd 27 06                        BEQ  LB784          ; BRANCH IF END OF LINE
4536 deff bd d7 17                     JSR  LAF67          ; GET ENDING LINE NUMBER
4537 df02 27 06                        BEQ  LB789          ; BRANCH IF LEGAL LINE NUMBER
4538 df04 39                 LB783 RTS
4539                         * LIST THE ENTIRE PROGRAM
4540 df05 ce ff ff           LB784     LDU  #$FFFF         ; * SET THE DEFAULT ENDING LINE NUMBER
4541 df08 df 2b                        STU  BINVAL         ; * TO $FFFF
4542 df0a 32 62              LB789     LEAS 2,S            ; PURGE RETURN ADDRESS FROM THE STACK
4543 df0c 9e 66                        LDX  LSTTXT         ; POINT X TO STARTING LINE ADDRESS
4544 df0e bd e0 ac           LB78D     JSR  LB95C          ; MOVE CURSOR TO START OF A NEW LINE
4545 df11 bd d1 9a                     JSR  LA549          ; CHECK FOR A BREAK OR PAUSE
4546 df14 ec 84                        LDD  ,X             ; GET ADDRESS OF NEXT BASIC LINE
4547 df16 26 03                        BNE  LB79F          ; BRANCH IF NOT END OF PROGRAM
4548                         LB797
4549 df18 7e d4 25                     JMP  LAC73          ; RETURN TO BASIC'S MAIN INPUT LOOP
4550 df1b 9f 66              LB79F     STX  LSTTXT         ; SAVE NEW STARTING LINE ADDRESS
4551 df1d ec 02                        LDD  2,X            ; * GET THE LINE NUMBER OF THIS LINE AND
4552 df1f 10 93 2b                     CMPD BINVAL         ; * COMPARE IT TO ENDING LINE NUMBER
4553 df22 22 f4                        BHI  LB797          ; EXIT IF LINE NUMBER > ENDING LINE NUMBER
4554 df24 bd e5 18                     JSR  LBDCC          ; PRINT THE NUMBER IN ACCD ON SCREEN IN DECIMAL
4555 df27 bd e0 f8                     JSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
4556 df2a 9e 66                        LDX  LSTTXT         ; GET RAM ADDRESS OF THIS LINE
4557 df2c 8d 10                        BSR  LB7C2          ; UNCRUNCH A LINE
4558 df2e ae 9f 00 66                  LDX  [LSTTXT]       ; POINT X TO START OF NEXT LINE
4559 df32 ce 00 f4                     LDU  #LINBUF+1      ; POINT U TO BUFFER FULL OF UNCRUNCHED LINE
4560 df35 a6 c0              LB7B9     LDA  ,U+            ; GET A BYTE FROM THE BUFFER
4561 df37 27 d5                        BEQ  LB78D          ; BRANCH IF END OF BUFFER
4562 df39 bd e0 fd                     JSR  LB9B1          ; SEND CHARACTER TO CONSOLE OUT
4563 df3c 20 f7                        BRA  LB7B9          ; GET ANOTHER CHARACTER
4564                         
4565                         * UNCRUNCH A LINE INTO BASIC'S LINE INPUT BUFFER
4566 df3e 30 04              LB7C2     LEAX 4,X            ; MOVE POINTER PAST ADDRESS OF NEXT LINE AND LINE NUMBER
4567 df40 10 8e 00 f4                  LDY  #LINBUF+1      ; UNCRUNCH LINE INTO LINE INPUT BUFFER
4568 df44 a6 80              LB7CB     LDA  ,X+            ; GET A CHARACTER
4569 df46 27 51                        BEQ  LB820          ; BRANCH IF END OF LINE
4570 df48 2b 15                        BMI  LB7E6          ; BRANCH IF IT'S A TOKEN
4571 df4a 81 3a                        CMPA #':            ; CHECK FOR END OF SUB LINE
4572 df4c 26 0d                        BNE  LB7E2          ; BRNCH IF NOT END OF SUB LINE
4573 df4e e6 84                        LDB  ,X             ; GET CHARACTER FOLLOWING COLON
4574 df50 c1 84                        CMPB #TOK_ELSE      ; TOKEN FOR ELSE?
4575 df52 27 f0                        BEQ  LB7CB          ; YES - DON'T PUT IT IN BUFFER
4576 df54 c1 83                        CMPB #TOK_SNGL_Q    ; TOKEN FOR REMARK?
4577 df56 27 ec                        BEQ  LB7CB          ; YES - DON'T PUT IT IN BUFFER
4578 df58 8c                           FCB  SKP2           ; SKIP TWO BYTES
4579 df59 86 21              LB7E0     LDA  #'!            ; EXCLAMATION POINT
4580 df5b 8d 30              LB7E2     BSR  LB814          ; PUT CHARACTER IN BUFFER
4581 df5d 20 e5                        BRA  LB7CB          ; GET ANOTHER CHARACTER
4582                         
4583 df5f ce d0 e7           LB7E6     LDU  #COMVEC-10     ; FIRST DO COMMANDS
4584 df62 81 ff                        CMPA #$FF           ; CHECK FOR SECONDARY TOKEN
4585 df64 26 04                        BNE  LB7F1          ; BRANCH IF NON SECONDARY TOKEN
4586 df66 a6 80                        LDA  ,X+            ; GET SECONDARY TOKEN
4587 df68 33 45                        LEAU 5,U            ; BUMP IT UP TO SECONDARY FUNCTIONS
4588 df6a 84 7f              LB7F1     ANDA #$7F           ; MASK OFF BIT 7 OF TOKEN
4589 df6c 33 4a              LB7F3     LEAU 10,U           ; MOVE TO NEXT COMMAND TABLE
4590 df6e 6d c4                        TST  ,U             ; IS THIS TABLE ENABLED?
4591 df70 27 e7                        BEQ  LB7E0          ; NO - ILLEGAL TOKEN
4592 df72 a0 c4                        SUBA ,U             ; SUBTRACT THE NUMBER OF TOKENS FROM THE CURRENT TOKEN NUMBER
4593 df74 2a f6                        BPL  LB7F3          ; BRANCH IF TOKEN NOT IN THIS TABLE
4594 df76 ab c4                        ADDA ,U             ; RESTORE TOKEN NUMBER RELATIVE TO THIS TABLE
4595 df78 ee 41                        LDU  1,U            ; POINT U TO COMMAND DICTIONARY TABLE
4596 df7a 4a                 LB801     DECA                ; DECREMENT TOKEN NUMBER
4597 df7b 2b 06                        BMI  LB80A          ; BRANCH IF THIS IS THE CORRECT TOKEN
4598                         * SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN
4599 df7d 6d c0              LB804     TST  ,U+            ; GRAB A BYTE
4600 df7f 2a fc                        BPL  LB804          ; BRANCH IF BIT 7 NOT SET
4601 df81 20 f7                        BRA  LB801          ; GO SEE IF THIS IS THE CORRECT TOKEN
4602 df83 a6 c4              LB80A     LDA  ,U             ; GET A CHARACTER FROM DICTIONARY TABLE
4603 df85 8d 06                        BSR  LB814          ; PUT CHARACTER IN BUFFER
4604 df87 6d c0                        TST  ,U+            ; CHECK FOR START OF NEXT TOKEN
4605 df89 2a f8                        BPL  LB80A          ; BRANCH IF NOT DONE WITH THIS TOKEN
4606 df8b 20 b7                        BRA  LB7CB          ; GO GET ANOTHER CHARACTER
4607 df8d 10 8c 01 ed        LB814     CMPY #LINBUF+LBUFMX ; TEST FOR END OF LINE INPUT BUFFER
4608 df91 24 06                        BCC  LB820          ; BRANCH IF AT END OF BUFFER
4609 df93 84 7f                        ANDA #$7F           ; MASK OFF BIT 7
4610 df95 a7 a0                        STA  ,Y+            ; * SAVE CHARACTER IN BUFFER AND
4611 df97 6f a4                        CLR  ,Y             ; * CLEAR NEXT CHARACTER SLOT IN BUFFER
4612 df99 39                 LB820     RTS
4613                         *
4614                         * CRUNCH THE LINE THAT THE INPUT POINTER IS
4615                         * POINTING TO INTO THE LINE INPUT BUFFER
4616                         * RETURN LENGTH OF CRUNCHED LINE IN ACCD
4617                         *
4618 df9a 9e 83              LB821     LDX  CHARAD         ; GET BASIC'S INPUT POINTER ADDRESS
4619 df9c ce 00 f3                     LDU  #LINBUF        ; POINT X TO LINE INPUT BUFFER
4620 df9f 0f 43              LB829     CLR  V43            ; CLEAR ILLEGAL TOKEN FLAG
4621 dfa1 0f 44                        CLR  V44            ; CLEAR DATA FLAG
4622 dfa3 a6 80              LB82D     LDA  ,X+            ; GET INPUT CHAR
4623 dfa5 27 21                        BEQ  LB852          ; BRANCH IF END OF LINE
4624 dfa7 0d 43                        TST  V43            ; * CHECK ILLEGAL TOKEN FLAG & BRANCH IF NOT
4625 dfa9 27 0f                        BEQ  LB844          ; * PROCESSING AN ILLEGAL TOKEN
4626 dfab bd db 29                     JSR  LB3A2          ; SET CARRY IF NOT UPPER CASE ALPHA
4627 dfae 24 18                        BCC  LB852          ; BRANCH IF UPPER CASE ALPHA
4628 dfb0 81 30                        CMPA #'0            ; * DON'T CRUNCH ASCII NUMERIC CHARACTERS
4629 dfb2 25 04                        BLO  LB842          ; * BRANCH IF NOT NUMERIC
4630 dfb4 81 39                        CMPA #'9            ; *
4631 dfb6 23 10                        BLS  LB852          ; * BRANCH IF NUMERIC
4632                         * END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC
4633 dfb8 0f 43              LB842     CLR  V43            ; CLEAR ILLEGAL TOKEN FLAG
4634 dfba 81 20              LB844     CMPA #SPACE         ; SPACE?
4635 dfbc 27 0a                        BEQ  LB852          ; DO NOT REMOVE SPACES
4636 dfbe 97 42                        STA  V42            ; SAVE INPUT CHARACTER AS SCAN DELIMITER
4637 dfc0 81 22                        CMPA #'"            ; CHECK FOR STRING DELIMITER
4638 dfc2 27 38                        BEQ  LB886          ; BRANCH IF STRING
4639 dfc4 0d 44                        TST  V44            ; * CHECK DATA FLAG AND BRANCH IF CLEAR
4640 dfc6 27 19                        BEQ  LB86B          ; * DO NOT CRUNCH DATA
4641 dfc8 a7 c0              LB852     STA  ,U+            ; SAVE CHARACTER IN BUFFER
4642 dfca 27 06                        BEQ  LB85C          ; BRANCH IF END OF LINE
4643 dfcc 81 3a                        CMPA #':            ; * CHECK FOR END OF SUBLINE
4644 dfce 27 cf                        BEQ  LB829          ; * AND RESET FLAGS IF END OF SUBLINE
4645 dfd0 20 d1              LB85A     BRA  LB82D          ; GO GET ANOTHER CHARACTER
4646 dfd2 6f c0              LB85C     CLR  ,U+            ; * DOUBLE ZERO AT END OF LINE
4647 dfd4 6f c0                        CLR  ,U+            ; *
4648 dfd6 1f 30                        TFR  U,D            ; SAVE ADDRESS OF END OF LINE IN ACCD
4649 dfd8 83 00 f1                     SUBD #LINHDR        ; LENGTH OF LINE IN ACCD
4650 dfdb 8e 00 f2                     LDX  #LINBUF-1      ; * SET THE INPUT POINTER TO ONE BEFORE
4651 dfde 9f 83                        STX  CHARAD         ; * THE START OF THE CRUNCHED LINE
4652 dfe0 39                           RTS                 ; EXIT 'CRUNCH'
4653 dfe1 81 3f              LB86B     CMPA #'?            ; CHECK FOR "?" - PRINT ABBREVIATION
4654 dfe3 26 04                        BNE  LB873          ; BRANCH IF NOT PRINT ABBREVIATION
4655 dfe5 86 87                        LDA  #TOK_PRINT     ; * GET THE PRINT TOKEN AND SAVE IT
4656 dfe7 20 df                        BRA  LB852          ; * IN BUFFER
4657 dfe9 81 27              LB873     CMPA #''            ; APOSTROPHE IS SAME AS REM
4658 dfeb 26 13                        BNE  LB88A          ; BRANCH IF NOT REMARK
4659 dfed cc 3a 83                     LDD  #$3A00+TOK_SNGL_Q ; COLON, REM TOKEN
4660 dff0 ed c1                        STD  ,U++           ; SAVE IN BUFFER
4661 dff2 0f 42              LB87C     CLR  V42            ; SET DELIMITER = 0 (END OF LINE)
4662 dff4 a6 80              LB87E     LDA  ,X+            ; SCAN TILL WE MATCH [V42]
4663 dff6 27 d0                        BEQ  LB852          ; BRANCH IF END OF LINE
4664 dff8 91 42                        CMPA V42            ; DELIMITER?
4665 dffa 27 cc                        BEQ  LB852          ; BRANCH OUT IF SO
4666 dffc a7 c0              LB886     STA  ,U+            ; DON'T CRUNCH REMARKS OR STRINGS
4667 dffe 20 f4                        BRA  LB87E          ; GO GET MORE STRING OR REMARK
4668 e000 81 30              LB88A     CMPA #'0            ; * LESS THAN ASCII ZERO?
4669 e002 25 04                        BCS  LB892          ; * BRANCH IF SO
4670 e004 81 3c                        CMPA #';+1          ; = CHECK FOR NUMERIC VALUE, COLON OR SEMICOLON
4671 e006 25 c0                        BCS  LB852          ; = AND INSERT IN BUFFER IF SO
4672 e008 30 1f              LB892     LEAX -1,X           ; MOVE INPUT POINTER BACK ONE
4673 e00a 34 50                        PSHS U,X            ; SAVE POINTERS TO INPUT STRING, OUTPUT STRING
4674 e00c 0f 41                        CLR  V41            ; TOKEN FLAG 0 = COMMAND, FF = SECONDARY
4675 e00e ce d0 e7                     LDU  #COMVEC-10     ; POINT U TO COMMAND INTERPRETATION
4676                         *                             ; TABLE FOR BASIC - 10
4677 e011 0f 42              LB89B     CLR  V42            ; INITIALIZE V42 AS TOKEN COUNTER
4678 e013 33 4a              LB89D     LEAU 10,U           ; MOVE TO NEXT COMMAND INTERPRETATION TABLE
4679 e015 a6 c4                        LDA  ,U             ; GET NUMBER OF COMMANDS
4680 e017 27 31                        BEQ  LB8D4          ; GO DO SECONDARY FUNCTIONS IF NO COMMAND TABLE
4681 e019 10 ae 41                     LDY  1,U            ; POINT Y TO COMMAND DICTIONARY TABLE
4682 e01c ae e4              LB8A6     LDX  ,S             ; GET POINTER TO INPUT STRING
4683 e01e e6 a0              LB8A8     LDB  ,Y+            ; GET A BYTE FROM DICTIONARY TABLE
4684 e020 e0 80                        SUBB ,X+            ; SUBTRACT INPUT CHARACTER
4685 e022 27 fa                        BEQ  LB8A8          ; LOOP IF SAME
4686 e024 c1 80                        CMPB #$80           ; LAST CHAR IN RESERVED WORD TABLE HAD
4687                         *                             ; BIT 7 SET, SO IF WE HAVE $80 HERE
4688                         *                             ; THEN IT IS A GOOD COMPARE
4689 e026 26 38                        BNE  LB8EA          ; BRANCH IF NO MATCH - CHECK ANOTHER COMMAND
4690 e028 32 62                        LEAS 2,S            ; DELETE OLD INPUT POINTER FROM STACK
4691 e02a 35 40                        PULS U              ; GET POINTER TO OUTPUT STRING
4692 e02c da 42                        ORB  V42            ; OR IN THE TABLE POSITION TO MAKE THE TOKEN
4693                         *                             ; - NOTE THAT B ALREADY HAD $80 IN IT -
4694 e02e 96 41                        LDA  V41            ; * CHECK TOKEN FLAG AND BRANCH
4695 e030 26 06                        BNE  LB8C2          ; * IF SECONDARY
4696 e032 c1 84                        CMPB #TOK_ELSE      ; IS IT ELSE TOKEN?
4697 e034 26 06                        BNE  LB8C6          ; NO
4698 e036 86 3a                        LDA  #':            ; PUT A COLON (SUBLINE) BEFORE ELSE TOKEN
4699 e038 ed c1              LB8C2     STD  ,U++           ; SECONDARY TOKENS PRECEEDED BY $FF
4700 e03a 20 94                        BRA  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
4701 e03c e7 c0              LB8C6     STB  ,U+            ; SAVE THIS TOKEN
4702 e03e c1 86                        CMPB #TOK_DATA      ; DATA TOKEN?
4703 e040 26 02                        BNE  LB8CE          ; NO
4704 e042 0c 44                        INC  V44            ; SET DATA FLAG
4705 e044 c1 82              LB8CE     CMPB #TOK_REM       ; REM TOKEN?
4706 e046 27 aa                        BEQ  LB87C          ; YES
4707 e048 20 86              LB8D2     BRA  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
4708                         * CHECK FOR A SECONDARY TOKEN
4709 e04a ce d0 ec           LB8D4     LDU  #COMVEC-5      ; NOW DO SECONDARY FUNCTIONS
4710 e04d 03 41                        COM  V41            ; TOGGLE THE TOKEN FLAG
4711 e04f 26 c0                        BNE  LB89B          ; BRANCH IF NOW CHECKING SECONDARY COMMANDS
4712                         
4713                         * THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CRUNCHED AND SO
4714                         * IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN
4715 e051 35 50                        PULS X,U            ; RESTORE INPUT AND OUTPUT POINTERS
4716 e053 a6 80                        LDA  ,X+            ; * MOVE THE FIRST CHARACTER OF AN
4717 e055 a7 c0                        STA  ,U+            ; * ILLEGAL TOKEN
4718 e057 bd db 29                     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
4719 e05a 25 ec                        BCS  LB8D2          ; BRANCH IF NOT ALPHA
4720 e05c 03 43                        COM  V43            ; SET ILLEGAL TOKEN FLAG IF UPPER CASE ALPHA
4721 e05e 20 e8                        BRA  LB8D2          ; PROCESS MORE INPUT CHARACTERS
4722 e060 0c 42              LB8EA     INC  V42            ; INCREMENT TOKEN COUNTER
4723 e062 4a                           DECA                ; DECR COMMAND COUNTER
4724 e063 27 ae                        BEQ  LB89D          ; GET ANOTHER COMMAND TABLE IF DONE W/THIS ONE
4725 e065 31 3f                        LEAY -1,Y           ; MOVE POINTER BACK ONE
4726 e067 e6 a0              LB8F1     LDB  ,Y+            ; * GET TO NEXT
4727 e069 2a fc                        BPL  LB8F1          ; * RESERVED WORD
4728 e06b 20 af                        BRA  LB8A6          ; GO SEE IF THIS WORD IS A MATCH
4729                         
4730                         * PRINT
4731 e06d 27 39              PRINT     BEQ  LB958          ; BRANCH IF NO ARGUMENT
4732 e06f 8d 01                        BSR  LB8FE          ; CHECK FOR ALL PRINT OPTIONS
4733 e071 39                           RTS
4734                         LB8FE
4735 e072 bd ef d2           LB918     JSR  XVEC9          ; CALL EXTENDED BASIC ADD-IN
4736 e075 27 3e              LB91B     BEQ  LB965          ; RETURN IF END OF LINE
4737 e077 81 9f              LB91D     CMPA #TOK_TAB       ; TOKEN FOR TAB( ?
4738 e079 27 53                        BEQ  LB97E          ; YES
4739 e07b 81 2c                        CMPA #',            ; COMMA?
4740 e07d 27 37                        BEQ  LB966          ; YES - ADVANCE TO NEXT TAB FIELD
4741 e07f 81 3b                        CMPA #';            ; SEMICOLON?
4742 e081 27 60                        BEQ  LB997          ; YES - DO NOT ADVANCE CURSOR
4743 e083 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
4744 e086 96 06                        LDA  VALTYP         ; * GET VARIABLE TYPE AND
4745 e088 34 02                        PSHS A              ; * SAVE IT ON THE STACK
4746 e08a 26 06                        BNE  LB938          ; BRANCH IF STRING VARIABLE
4747 e08c bd e5 25                     JSR  LBDD9          ; CONVERT FP NUMBER TO AN ASCII STRING
4748 e08f bd dc 9d                     JSR  LB516          ; PARSE A STRING FROM (X-1) AND PUT
4749                         *                             ; DESCRIPTOR ON STRING STACK
4750 e092 8d 57              LB938     BSR  LB99F          ; PRINT STRING POINTED TO BY X
4751 e094 35 04                        PULS B              ; GET VARIABLE TYPE BACK
4752 e096 bd d1 33                     JSR  LA35F          ; SET UP TAB WIDTH ZONE, ETC
4753 e099 5d                 LB949     TSTB                ; CHECK CURRENT PRINT POSITION
4754 e09a 26 08                        BNE  LB954          ; BRANCH IF NOT AT START OF LINE
4755 e09c 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4756 e09e 81 2c                        CMPA #',            ; COMMA?
4757 e0a0 27 14                        BEQ  LB966          ; SKIP TO NEXT TAB FIELD
4758 e0a2 8d 54                        BSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
4759 e0a4 9d 82              LB954     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4760 e0a6 26 cf                        BNE  LB91D          ; BRANCH IF NOT END OF LINE
4761 e0a8 86 0d              LB958     LDA  #CR            ; * SEND A CR TO
4762 e0aa 20 51                        BRA  LB9B1          ; * CONSOLE OUT
4763 e0ac bd d1 33           LB95C     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
4764 e0af 27 f7                        BEQ  LB958          ; BRANCH IF WIDTH = ZERO
4765 e0b1 96 6c                        LDA  DEVPOS         ; GET PRINT POSITION
4766 e0b3 26 f3                        BNE  LB958          ; BRANCH IF NOT AT START OF LINE
4767 e0b5 39                 LB965     RTS
4768                         * SKIP TO NEXT TAB FIELD
4769 e0b6 bd d1 33           LB966     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
4770 e0b9 27 0a                        BEQ  LB975          ; BRANCH IF LINE WIDTH = 0 (CASSETTE)
4771 e0bb d6 6c                        LDB  DEVPOS         ; GET CURRENT POSITION
4772 e0bd d1 6b                        CMPB DEVLCF         ; COMPARE TO LAST TAB ZONE
4773 e0bf 25 06                        BCS  LB977          ; BRANCH IF < LAST TAB ZONE
4774 e0c1 8d e5                        BSR  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
4775 e0c3 20 1e                        BRA  LB997          ; GET MORE DATA
4776 e0c5 d6 6c              LB975     LDB  DEVPOS         ; *
4777 e0c7 d0 6a              LB977     SUBB DEVCFW         ; * SUBTRACT TAB FIELD WIDTH FROM CURRENT
4778 e0c9 24 fc                        BCC  LB977          ; * POSITION UNTIL CARRY SET - NEGATING THE
4779 e0cb 50                           NEGB                ; * REMAINDER LEAVES THE NUMBER OF SPACES TO NEXT
4780                         *              ; * TAB ZONE IN ACCB
4781 e0cc 20 10                        BRA  LB98E          ; GO ADVANCE TO NEXT TAB ZONE
4782                         
4783                         * PRINT TAB(
4784 e0ce bd de 90           LB97E     JSR  LB709          ; EVALUATE EXPRESSION - RETURN VALUE IN B
4785 e0d1 81 29                        CMPA #')            ; * 'SYNTAX' ERROR IF NOT ')'
4786 e0d3 10 26 f9 2c                  LBNE LB277          ; *
4787 e0d7 bd d1 33                     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
4788 e0da d0 6c                        SUBB DEVPOS         ; GET DIFFERENCE OF PRINT POSITION & TAB POSITION
4789 e0dc 23 05                        BLS  LB997          ; BRANCH IF TAB POSITION < CURRENT POSITION
4790                         LB98E
4791 e0de 8d 18              LB992     BSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
4792 e0e0 5a                           DECB                ; DECREMENT DIFFERENCE COUNT
4793 e0e1 26 fb                        BNE  LB992          ; BRANCH UNTIL CURRENT POSITION = TAB POSITION
4794 e0e3 9d 7c              LB997     JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
4795 e0e5 7e e0 75                     JMP  LB91B          ; LOOK FOR MORE PRINT DATA
4796                         * COPY A STRING FROM (X) TO CONSOLE OUT
4797 e0e8 bd dc 9f           LB99C     JSR  LB518          ; PARSE A STRING FROM X AND PUT
4798                         *         DESCRIPTOR ON STRING STACK
4799 e0eb bd dd de           LB99F     JSR  LB657          ; GET LENGTH OF STRING AND REMOVE
4800                         *         DESCRIPTOR FROM STRING STACK
4801 e0ee 5c                           INCB                ; COMPENSATE FOR DECB BELOW
4802 e0ef 5a                 LB9A3     DECB                ; DECREMENT COUNTER
4803 e0f0 27 c3                        BEQ  LB965          ; EXIT ROUTINE
4804 e0f2 a6 80                        LDA  ,X+            ; GET A CHARACTER FROM X
4805 e0f4 8d 07                        BSR  LB9B1          ; SEND TO CONSOLE OUT
4806 e0f6 20 f7                        BRA  LB9A3          ; KEEP LOOPING
4807 e0f8 86 20              LB9AC     LDA  #SPACE         ; SPACE TO CONSOLE OUT
4808 e0fa 8c                           FCB  SKP2           ; SKIP NEXT TWO BYTES
4809 e0fb 86 3f              LB9AF     LDA  #'?            ; QUESTION MARK TO CONSOLE OUT
4810 e0fd 7e d0 17           LB9B1     JMP  PUTCHR         ; JUMP TO CONSOLE OUT
4811                         
4812                         * FLOATING POINT MATH PACKAGE
4813                         
4814                         * ADD .5 TO FPA0
4815 e100 8e e6 0c           LB9B4     LDX  #LBEC0         ; FLOATING POINT CONSTANT (.5)
4816 e103 20 09                        BRA  LB9C2          ; ADD .5 TO FPA0
4817                         * SUBTRACT FPA0 FROM FP NUMBER POINTED
4818                         * TO BY (X), LEAVE RESULT IN FPA0
4819 e105 bd e2 7b           LB9B9     JSR  LBB2F          ; COPY PACKED FP DATA FROM (X) TO FPA1
4820                         
4821                         * ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 FROM FPA1 (ENTER
4822                         * WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 IN ACCA)
4823 e108 03 54              LB9BC     COM  FP0SGN         ; CHANGE MANTISSA SIGN OF FPA0
4824 e10a 03 62                        COM  RESSGN         ; REVERSE RESULT SIGN FLAG
4825 e10c 20 03                        BRA  LB9C5          ; GO ADD FPA1 AND FPA0
4826                         * ADD FP NUMBER POINTED TO BY
4827                         * (X) TO FPA0 - LEAVE RESULT IN FPA0
4828 e10e bd e2 7b           LB9C2     JSR  LBB2F          ; UNPACK PACKED FP DATA FROM (X) TO
4829                         *         FPA1; RETURN EXPONENT OF FPA1 IN ACCA
4830                         
4831                         * ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO
4832                         
4833 e111 5d                 LB9C5     TSTB                ; CHECK EXPONENT OF FPA0
4834 e112 10 27 02 80                  LBEQ LBC4A          ; COPY FPA1 TO FPA0 IF FPA0 =
4835 e116 8e 00 5c                     LDX  #FP1EXP        ; POINT X TO FPA1
4836 e119 1f 89              LB9CD     TFR  A,B            ; PUT EXPONENT OF FPA1 INTO ACCB
4837 e11b 5d                           TSTB                ; CHECK EXPONENT
4838 e11c 27 6c                        BEQ  LBA3E          ; RETURN IF EXPONENT = 0 (ADDING 0 TO FPA0)
4839 e11e d0 4f                        SUBB FP0EXP         ; SUBTRACT EXPONENT OF FPA0 FROM EXPONENT OF FPA1
4840 e120 27 69                        BEQ  LBA3F          ; BRANCH IF EXPONENTS ARE EQUAL
4841 e122 25 0a                        BCS  LB9E2          ; BRANCH IF EXPONENT FPA0 > FPA1
4842 e124 97 4f                        STA  FP0EXP         ; REPLACE FPA0 EXPONENT WITH FPA1 EXPONENT
4843 e126 96 61                        LDA  FP1SGN         ; * REPLACE FPA0 MANTISSA SIGN
4844 e128 97 54                        STA  FP0SGN         ; * WITH FPA1 MANTISSA SIGN
4845 e12a 8e 00 4f                     LDX  #FP0EXP        ; POINT X TO FPA0
4846 e12d 50                           NEGB                ; NEGATE DIFFERENCE OF EXPONENTS
4847 e12e c1 f8              LB9E2     CMPB #-8            ; TEST DIFFERENCE OF EXPONENTS
4848 e130 2f 59                        BLE  LBA3F          ; BRANCH IF DIFFERENCE OF EXPONENTS <= 8
4849 e132 4f                           CLRA                ; CLEAR OVERFLOW BYTE
4850 e133 64 01                        LSR  1,X            ; SHIFT MS BYTE OF MANTISSA; BIT 7 = 0
4851 e135 bd e2 06                     JSR  LBABA          ; GO SHIFT MANTISSA OF (X) TO THE RIGHT (B) TIMES
4852 e138 d6 62              LB9EC     LDB  RESSGN         ; GET SIGN FLAG
4853 e13a 2a 0b                        BPL  LB9FB          ; BRANCH IF FPA0 AND FPA1 SIGNS ARE THE SAME
4854 e13c 63 01                        COM  1,X            ; * COMPLEMENT MANTISSA POINTED
4855 e13e 63 02                        COM  2,X            ; * TO BY (X) THE
4856 e140 63 03                        COM  3,X            ; * ADCA BELOW WILL
4857 e142 63 04                        COM  4,X            ; * CONVERT THIS OPERATION
4858 e144 43                           COMA                ; * INTO A NEG (MANTISSA)
4859 e145 89 00                        ADCA #0             ; ADD ONE TO ACCA - COMA ALWAYS SETS THE CARRY FLAG
4860                         * THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA
4861                         *
4862                         * ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0
4863 e147 97 63              LB9FB     STA  FPSBYT         ; SAVE FPA SUB BYTE
4864 e149 96 53                        LDA  FPA0+3         ; * ADD LS BYTE
4865 e14b 99 60                        ADCA FPA1+3         ; * OF MANTISSA
4866 e14d 97 53                        STA  FPA0+3         ; SAVE IN FPA0 LSB
4867 e14f 96 52                        LDA  FPA0+2         ; * ADD NEXT BYTE
4868 e151 99 5f                        ADCA FPA1+2         ; * OF MANTISSA
4869 e153 97 52                        STA  FPA0+2         ; SAVE IN FPA0
4870 e155 96 51                        LDA  FPA0+1         ; * ADD NEXT BYTE
4871 e157 99 5e                        ADCA FPA1+1         ; * OF MANTISSA
4872 e159 97 51                        STA  FPA0+1         ; SAVE IN FPA0
4873 e15b 96 50                        LDA  FPA0           ; * ADD MS BYTE
4874 e15d 99 5d                        ADCA FPA1           ; * OF MANTISSA
4875 e15f 97 50                        STA  FPA0           ; SAVE IN FPA0
4876 e161 5d                           TSTB                ; TEST SIGN FLAG
4877 e162 2a 44                        BPL  LBA5C          ; BRANCH IF FPA0 & FPA1 SIGNS WERE ALIKE
4878 e164 25 02              LBA18     BCS  LBA1C          ; BRANCH IF POSITIVE MANTISSA
4879 e166 8d 5d                        BSR  LBA79          ; NEGATE FPA0 MANTISSA
4880                         
4881                         * NORMALIZE FPA0
4882 e168 5f                 LBA1C     CLRB                ; CLEAR TEMPORARY EXPONENT ACCUMULATOR
4883 e169 96 50              LBA1D     LDA  FPA0           ; TEST MSB OF MANTISSA
4884 e16b 26 2e                        BNE  LBA4F          ; BRANCH IF <> 0
4885 e16d 96 51                        LDA  FPA0+1         ; * IF THE MSB IS
4886 e16f 97 50                        STA  FPA0           ; * 0, THEN SHIFT THE
4887 e171 96 52                        LDA  FPA0+2         ; * MANTISSA A WHOLE BYTE
4888 e173 97 51                        STA  FPA0+1         ; * AT A TIME. THIS
4889 e175 96 53                        LDA  FPA0+3         ; * IS FASTER THAN ONE
4890 e177 97 52                        STA  FPA0+2         ; * BIT AT A TIME
4891 e179 96 63                        LDA  FPSBYT         ; * BUT USES MORE MEMORY.
4892 e17b 97 53                        STA  FPA0+3         ; * FPSBYT, THE CARRY IN
4893 e17d 0f 63                        CLR  FPSBYT         ; * BYTE, REPLACES THE MATISSA LSB.
4894 e17f cb 08                        ADDB #8             ; SHIFTING ONE BYTE = 8 BIT SHIFTS; ADD 8 TO EXPONENT
4895 e181 c1 28                        CMPB #5*8           ; CHECK FOR 5 SHIFTS
4896 e183 2d e4                        BLT  LBA1D          ; BRANCH IF < 5 SHIFTS, IF > 5, THEN MANTISSA = 0
4897 e185 4f                 LBA39     CLRA                ; A ZERO EXPONENT = 0 FLOATING POINT
4898 e186 97 4f              LBA3A     STA  FP0EXP         ; ZERO OUT THE EXPONENT
4899 e188 97 54                        STA  FP0SGN         ; ZERO OUT THE MANTISSA SIGN
4900 e18a 39                 LBA3E     RTS
4901 e18b 8d 6d              LBA3F     BSR  LBAAE          ; SHIFT FPA0 MANTISSA TO RIGHT
4902 e18d 5f                           CLRB                ; CLEAR CARRY FLAG
4903 e18e 20 a8                        BRA  LB9EC
4904                         * SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7
4905                         * OF MATISSA MS BYTE = 1
4906 e190 5c                 LBA44     INCB                ; ADD ONE TO EXPONENT ACCUMULATOR
4907 e191 08 63                        ASL  FPSBYT         ; SHIFT SUB BYTE ONE LEFT
4908 e193 09 53                        ROL  FPA0+3         ; SHIFT LS BYTE
4909 e195 09 52                        ROL  FPA0+2         ; SHIFT NS BYTE
4910 e197 09 51                        ROL  FPA0+1         ; SHIFT NS BYTE
4911 e199 09 50                        ROL  FPA0           ; SHIFT MS BYTE
4912 e19b 2a f3              LBA4F     BPL  LBA44          ; BRANCH IF NOT YET NORMALIZED
4913 e19d 96 4f                        LDA  FP0EXP         ; GET CURRENT EXPONENT
4914 e19f 34 04                        PSHS B              ; SAVE EXPONENT MODIFIER CAUSED BY NORMALIZATION
4915 e1a1 a0 e0                        SUBA ,S+            ; SUBTRACT ACCUMULATED EXPONENT MODIFIER
4916 e1a3 97 4f                        STA  FP0EXP         ; SAVE AS NEW EXPONENT
4917 e1a5 23 de                        BLS  LBA39          ; SET FPA0 = 0 IF THE NORMALIZATION CAUSED
4918                         *         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE
4919                         *         SIZE OF THE EXPONENT
4920 e1a7 8c                           FCB  SKP2           ; SKIP 2 BYTES
4921 e1a8 25 08              LBA5C     BCS  LBA66          ; BRANCH IF MANTISSA OVERFLOW
4922 e1aa 08 63                        ASL  FPSBYT         ; SUB BYTE BIT 7 TO CARRY - USE AS ROUND-OFF
4923                         *                             ; FLAG (TRUNCATE THE REST OF SUB BYTE)
4924 e1ac 86 00                        LDA  #0             ; CLRA, BUT DO NOT CHANGE CARRY FLAG
4925 e1ae 97 63                        STA  FPSBYT         ; CLEAR THE SUB BYTE
4926 e1b0 20 0c                        BRA  LBA72          ; GO ROUND-OFF RESULT
4927 e1b2 0c 4f              LBA66     INC  FP0EXP         ; INCREMENT EXPONENT - MULTIPLY BY 2
4928 e1b4 27 28                        BEQ  LBA92          ; OVERFLOW ERROR IF CARRY PAST $FF
4929 e1b6 06 50                        ROR  FPA0           ; * SHIFT MANTISSA
4930 e1b8 06 51                        ROR  FPA0+1         ; * ONE TO
4931 e1ba 06 52                        ROR  FPA0+2         ; * THE RIGHT -
4932 e1bc 06 53                        ROR  FPA0+3         ; * DIVIDE BY TWO
4933 e1be 24 04              LBA72     BCC  LBA78          ; BRANCH IF NO ROUND-OFF NEEDED
4934 e1c0 8d 0d                        BSR  LBA83          ; ADD ONE TO MANTISSA - ROUND OFF
4935 e1c2 27 ee                        BEQ  LBA66          ; BRANCH iF OVERFLOW - MANTISSA = 0
4936 e1c4 39                 LBA78     RTS
4937                         * NEGATE FPA0 MANTISSA
4938 e1c5 03 54              LBA79     COM  FP0SGN         ; TOGGLE SIGN OF MANTISSA
4939 e1c7 03 50              LBA7B     COM  FPA0           ; * COMPLEMENT ALL 4 MANTISSA BYTES
4940 e1c9 03 51                        COM  FPA0+1         ; *
4941 e1cb 03 52                        COM  FPA0+2         ; *
4942 e1cd 03 53                        COM  FPA0+3         ; *
4943                         * ADD ONE TO FPA0 MANTISSA
4944 e1cf 9e 52              LBA83     LDX  FPA0+2         ; * GET BOTTOM 2 MANTISSA
4945 e1d1 30 01                        LEAX 1,X            ; * BYTES, ADD ONE TO
4946 e1d3 9f 52                        STX  FPA0+2         ; * THEM AND SAVE THEM
4947 e1d5 26 06                        BNE  LBA91          ; BRANCH IF NO OVERFLOW
4948 e1d7 9e 50                        LDX  FPA0           ; * IF OVERFLOW ADD ONE
4949 e1d9 30 01                        LEAX 1,X            ; * TO TOP 2 MANTISSA
4950 e1db 9f 50                        STX  FPA0           ; * BYTES AND SAVE THEM
4951 e1dd 39                 LBA91     RTS
4952 e1de c6 0a              LBA92     LDB  #2*5           ; OV' OVERFLOW ERROR
4953 e1e0 7e d4 06                     JMP  LAC46          ; PROCESS AN ERROR
4954 e1e3 8e 00 12           LBA97     LDX  #FPA2-1        ; POINT X TO FPA2
4955                         * SHIFT FPA POINTED TO BY (X) TO
4956                         * THE RIGHT -(B) TIMES. EXIT WITH
4957                         * ACCA CONTAINING DATA SHIFTED OUT
4958                         * TO THE RIGHT (SUB BYTE) AND THE DATA
4959                         * SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY
4960 e1e6 a6 04              LBA9A     LDA  4,X            ; GET LS BYTE OF MANTISSA (X)
4961 e1e8 97 63                        STA  FPSBYT         ; SAVE IN FPA SUB BYTE
4962 e1ea a6 03                        LDA  3,X            ; * SHIFT THE NEXT THREE BYTES OF THE
4963 e1ec a7 04                        STA  4,X            ; * MANTISSA RIGHT ONE COMPLETE BYTE.
4964 e1ee a6 02                        LDA  2,X            ; *
4965 e1f0 a7 03                        STA  3,X            ; *
4966 e1f2 a6 01                        LDA  1,X            ; *
4967 e1f4 a7 02                        STA  2,X            ; *
4968 e1f6 96 5b                        LDA  FPCARY         ; GET THE CARRY IN BYTE
4969 e1f8 a7 01                        STA  1,X            ; STORE AS THE MS MANTISSA BYTE OF (X)
4970 e1fa cb 08              LBAAE     ADDB #8             ; ADD 8 TO DIFFERENCE OF EXPONENTS
4971 e1fc 2f e8                        BLE  LBA9A          ; BRANCH IF EXPONENT DIFFERENCE < -8
4972 e1fe 96 63                        LDA  FPSBYT         ; GET FPA SUB BYTE
4973 e200 c0 08                        SUBB #8             ; CAST OUT THE 8 ADDED IN ABOVE
4974 e202 27 0c                        BEQ  LBAC4          ; BRANCH IF EXPONENT DIFFERENCE = 0
4975                         
4976                         
4977 e204 67 01              LBAB8     ASR  1,X            ; * SHIFT MANTISSA AND SUB BYTE ONE BIT TO THE RIGHT
4978 e206 66 02              LBABA     ROR  2,X            ; *
4979 e208 66 03                        ROR  3,X            ; *
4980 e20a 66 04                        ROR  4,X            ; *
4981 e20c 46                           RORA                ; *
4982 e20d 5c                           INCB                ; ADD ONE TO EXPONENT DIFFERENCE
4983 e20e 26 f4                        BNE  LBAB8          ; BRANCH IF EXPONENTS NOT =
4984 e210 39                 LBAC4     RTS
4985 e211 81 00 00 00 00     LBAC5     FCB  $81,$00,$00,$00,$00 ; FLOATING POINT CONSTANT 1.0
4986                         
4987                         * ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY
4988                         * FPA0 BY (X) - RETURN PRODUCT IN FPA0
4989 e216 8d 63              LBACA     BSR  LBB2F          ; MOVE PACKED FPA FROM (X) TO FPA1
4990 e218 27 60              LBACC     BEQ  LBB2E          ; BRANCH IF EXPONENT OF FPA0 = 0
4991 e21a 8d 78                        BSR  LBB48          ; CALCULATE EXPONENT OF PRODUCT
4992                         * MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE
4993                         * HIGH ORDER BYTES OF PRODUCT IN FPA0. THE
4994                         * LOW ORDER FOUR BYTES OF THE PRODUCT WILL
4995                         * BE STORED IN VAB-VAE.
4996 e21c 86 00              LBAD0     LDA  #0             ; * ZERO OUT MANTISSA OF FPA2
4997 e21e 97 13                        STA  FPA2           ; *
4998 e220 97 14                        STA  FPA2+1         ; *
4999 e222 97 15                        STA  FPA2+2         ; *
5000 e224 97 16                        STA  FPA2+3         ; *
5001 e226 d6 53                        LDB  FPA0+3         ; GET LS BYTE OF FPA0
5002 e228 8d 22                        BSR  LBB00          ; MULTIPLY BY FPA1
5003 e22a d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 4
5004 e22c d7 8b                        STB  VAE            ; *
5005 e22e d6 52                        LDB  FPA0+2         ; GET NUMBER 3 MANTISSA BYTE OF FPA0
5006 e230 8d 1a                        BSR  LBB00          ; MULTIPLY BY FPA1
5007 e232 d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 3
5008 e234 d7 8a                        STB  VAD            ; *
5009 e236 d6 51                        LDB  FPA0+1         ; GET NUMBER 2 MANTISSA BYTE OF FPA0
5010 e238 8d 12                        BSR  LBB00          ; MULTIPLY BY FPA1
5011 e23a d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 2
5012 e23c d7 89                        STB  VAC            ; *
5013 e23e d6 50                        LDB  FPA0           ; GET MS BYTE OF FPA0 MANTISSA
5014 e240 8d 0c                        BSR  LBB02          ; MULTIPLY BY FPA1
5015 e242 d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 1
5016 e244 d7 88                        STB  VAB            ; *
5017 e246 bd e3 57                     JSR  LBC0B          ; COPY MANTISSA FROM FPA2 TO FPA0
5018 e249 7e e1 68                     JMP  LBA1C          ; NORMALIZE FPA0
5019 e24c 27 95              LBB00     BEQ  LBA97          ; SHIFT FPA2 ONE BYTE TO RIGHT
5020 e24e 43                 LBB02     COMA                ; SET CARRY FLAG
5021                         * MULTIPLY FPA1 MANTISSA BY ACCB AND
5022                         * ADD PRODUCT TO FPA2 MANTISSA
5023 e24f 96 13              LBB03     LDA  FPA2           ; GET FPA2 MS BYTE
5024 e251 56                           RORB                ; ROTATE CARRY FLAG INTO SHIFT COUNTER;
5025                         *         DATA BIT INTO CARRY
5026 e252 27 26                        BEQ  LBB2E          ; BRANCH WHEN 8 SHIFTS DONE
5027 e254 24 16                        BCC  LBB20          ; DO NOT ADD FPA1 IF DATA BIT = 0
5028 e256 96 16                        LDA  FPA2+3         ; * ADD MANTISSA LS BYTE
5029 e258 9b 60                        ADDA FPA1+3         ; *
5030 e25a 97 16                        STA  FPA2+3         ; *
5031 e25c 96 15                        LDA  FPA2+2         ; = ADD MANTISSA NUMBER 3 BYTE
5032 e25e 99 5f                        ADCA FPA1+2         ; =
5033 e260 97 15                        STA  FPA2+2         ; =
5034 e262 96 14                        LDA  FPA2+1         ; * ADD MANTISSA NUMBER 2 BYTE
5035 e264 99 5e                        ADCA FPA1+1         ; *
5036 e266 97 14                        STA  FPA2+1         ; *
5037 e268 96 13                        LDA  FPA2           ; = ADD MANTISSA MS BYTE
5038 e26a 99 5d                        ADCA FPA1           ; =
5039 e26c 46                 LBB20     RORA                ; * ROTATE CARRY INTO MS BYTE
5040 e26d 97 13                        STA  FPA2           ; *
5041 e26f 06 14                        ROR  FPA2+1         ; = ROTATE FPA2 ONE BIT TO THE RIGHT
5042 e271 06 15                        ROR  FPA2+2         ; =
5043 e273 06 16                        ROR  FPA2+3         ; =
5044 e275 06 63                        ROR  FPSBYT         ; =
5045 e277 4f                           CLRA                ; CLEAR CARRY FLAG
5046 e278 20 d5                        BRA  LBB03          ; KEEP LOOPING
5047 e27a 39                 LBB2E     RTS
5048                         * UNPACK A FP NUMBER FROM (X) TO FPA1
5049 e27b ec 01              LBB2F     LDD  1,X            ; GET TWO MSB BYTES OF MANTISSA FROM
5050                         *         FPA  POINTED TO BY X
5051 e27d 97 61                        STA  FP1SGN         ; SAVE PACKED MANTISSA SIGN BYTE
5052 e27f 8a 80                        ORA  #$80           ; FORCE BIT 7 OF MSB MANTISSA = 1
5053 e281 dd 5d                        STD  FPA1           ; SAVE 2 MSB BYTES IN FPA1
5054 e283 d6 61                        LDB  FP1SGN         ; * GET PACKED MANTISSA SIGN BYTE. EOR W/FPA0
5055 e285 d8 54                        EORB FP0SGN         ; * SIGN - NEW SIGN POSITION IF BOTH OLD SIGNS ALIKE,
5056 e287 d7 62                        STB  RESSGN         ; * NEG IF BOTH OLD SIGNS DIFF. SAVE ADJUSTED
5057                         *                             ; * MANTISSA SIGN BYTE
5058 e289 ec 03                        LDD  3,X            ; = GET 2 LSB BYTES OF MANTISSA
5059 e28b dd 5f                        STD  FPA1+2         ; = AND PUT IN FPA1
5060 e28d a6 84                        LDA  ,X             ; * GET EXPONENT FROM (X) AND
5061 e28f 97 5c                        STA  FP1EXP         ; * PUT IN EXPONENT OF FPA1
5062 e291 d6 4f                        LDB  FP0EXP         ; GET EXPONENT OF FPA0
5063 e293 39                           RTS
5064                         * CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1
5065                         * ENTER WITH EXPONENT OF FPA1 IN ACCA
5066 e294 4d                 LBB48     TSTA                ; TEST EXPONENT OF FPA1
5067 e295 27 16                        BEQ  LBB61          ; PURGE RETURN ADDRESS & SET FPA0 = 0
5068 e297 9b 4f                        ADDA FP0EXP         ; ADD FPA1 EXPONENT TO FPA0 EXPONENT
5069 e299 46                           RORA                ; ROTATE CARRY INTO BIT 7; BIT 0 INTO CARRY
5070 e29a 49                           ROLA                ; SET OVERFLOW FLAG
5071 e29b 28 10                        BVC  LBB61          ; BRANCH IF EXPONENT TOO LARGE OR SMALL
5072 e29d 8b 80                        ADDA #$80           ; ADD $80 BIAS TO EXPONENT
5073 e29f 97 4f                        STA  FP0EXP         ; SAVE NEW EXPONENT
5074 e2a1 27 0c                        BEQ  LBB63          ; SET FPA0
5075 e2a3 96 62                        LDA  RESSGN         ; GET MANTISSA SIGN
5076 e2a5 97 54                        STA  FP0SGN         ; SAVE AS MANTISSA SIGN OF FPA0
5077 e2a7 39                           RTS
5078                         * IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0
5079                         * = IS NEGATIVE THEN FPA0 = 0
5080 e2a8 96 54              LBB5C     LDA  FP0SGN         ; GET MANTISSA SIGN OF FPA0
5081 e2aa 43                           COMA                ; CHANGE SIGN OF FPA0 MANTISSA
5082 e2ab 20 02                        BRA  LBB63
5083 e2ad 32 62              LBB61     LEAS 2,S            ; PURGE RETURN ADDRESS FROM STACK
5084 e2af 10 2a fe d2        LBB63     LBPL LBA39          ; ZERO FPA0 MANTISSA SIGN & EXPONENT
5085 e2b3 7e e1 de           LBB67     JMP  LBA92          ; 'OV' OVERFLOW ERROR
5086                         * FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0
5087 e2b6 bd e3 ab           LBB6A     JSR  LBC5F          ; TRANSFER FPA0 TO FPA1
5088 e2b9 27 0d                        BEQ  LBB7C          ; BRANCH IF EXPONENT = 0
5089 e2bb 8b 02                        ADDA #2             ; ADD 2 TO EXPONENT (TIMES 4)
5090 e2bd 25 f4                        BCS  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
5091 e2bf 0f 62                        CLR  RESSGN         ; CLEAR RESULT SIGN BYTE
5092 e2c1 bd e1 19                     JSR  LB9CD          ; ADD FPA1 TO FPA0 (TIMES 5)
5093 e2c4 0c 4f                        INC  FP0EXP         ; ADD ONE TO EXPONENT (TIMES 10)
5094 e2c6 27 eb                        BEQ  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
5095 e2c8 39                 LBB7C     RTS
5096 e2c9 84 20 00 00 00     LBB7D     FCB  $84,$20,$00,$00,$00 ; FLOATING POINT CONSTANT 10
5097                         * DIVIDE FPA0 BY 10
5098 e2ce bd e3 ab           LBB82     JSR  LBC5F          ; MOVE FPA0 TO FPA1
5099 e2d1 8e e2 c9                     LDX  #LBB7D         ; POINT TO FLOATING POINT CONSTANT 10
5100 e2d4 5f                           CLRB                ; ZERO MANTISSA SIGN BYTE
5101 e2d5 d7 62              LBB89     STB  RESSGN         ; STORE THE QUOTIENT MANTISSA SIGN BYTE
5102 e2d7 bd e3 60                     JSR  LBC14          ; UNPACK AN FP NUMBER FROM (X) INTO FPA0
5103 e2da 8c                           FCB  SKP2           ; SKIP TWO BYTES
5104                         * DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0
5105 e2db 8d 9e              LBB8F     BSR  LBB2F          ; GET FP NUMBER FROM (X) TO FPA1
5106                         
5107                         * ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY FPA0 (ENTER WITH
5108                         * EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY TSTA)
5109                         
5110                         * DIVIDE FPA1 BY FPA0
5111 e2dd 27 73              LBB91     BEQ  LBC06          ; '/0' DIVIDE BY ZERO ERROR
5112 e2df 00 4f                        NEG  FP0EXP         ; GET EXPONENT OF RECIPROCAL OF DIVISOR
5113 e2e1 8d b1                        BSR  LBB48          ; CALCULATE EXPONENT OF QUOTIENT
5114 e2e3 0c 4f                        INC  FP0EXP         ; INCREMENT EXPONENT
5115 e2e5 27 cc                        BEQ  LBB67          ; 'OV' OVERFLOW ERROR
5116 e2e7 8e 00 13                     LDX  #FPA2          ; POINT X TO MANTISSA OF FPA2 - HOLD
5117                         *                             ; TEMPORARY QUOTIENT IN FPA2
5118 e2ea c6 04                        LDB  #4             ; 5 BYTE DIVIDE
5119 e2ec d7 03                        STB  TMPLOC         ; SAVE BYTE COUNTER
5120 e2ee c6 01                        LDB  #1             ; SHIFT COUNTER-AND TEMPORARY QUOTIENT BYTE
5121                         * COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -
5122                         * SET CARRY FLAG IF FPA1 >= FPA0
5123 e2f0 96 50              LBBA4     LDA  FPA0           ; * COMPARE THE TWO MS BYTES
5124 e2f2 91 5d                        CMPA FPA1           ; * OF FPA0 AND FPA1 AND
5125 e2f4 26 13                        BNE  LBBBD          ; * BRANCH IF <>
5126 e2f6 96 51                        LDA  FPA0+1         ; = COMPARE THE NUMBER 2
5127 e2f8 91 5e                        CMPA FPA1+1         ; = BYTES AND
5128 e2fa 26 0d                        BNE  LBBBD          ; = BRANCH IF <>
5129 e2fc 96 52                        LDA  FPA0+2         ; * COMPARE THE NUMBER 3
5130 e2fe 91 5f                        CMPA FPA1+2         ; * BYTES AND
5131 e300 26 07                        BNE  LBBBD          ; * BRANCH IF <>
5132 e302 96 53                        LDA  FPA0+3         ; = COMPARE THE LS BYTES
5133 e304 91 60                        CMPA FPA1+3         ; = AND BRANCH
5134 e306 26 01                        BNE  LBBBD          ; = IF <>
5135 e308 43                           COMA                ; SET CARRY FLAG IF FPA0 = FPA1
5136 e309 1f a8              LBBBD     TFR  CC,A           ; SAVE CARRY FLAG STATUS IN ACCA; CARRY
5137                         *         CLEAR IF FPA0 > FPA1
5138 e30b 59                           ROLB                ; ROTATE CARRY INTO TEMPORARY QUOTIENT BYTE
5139 e30c 24 0a                        BCC  LBBCC          ; CARRY WILL BE SET AFTER 8 SHIFTS
5140 e30e e7 80                        STB  ,X+            ; SAVE TEMPORARY QUOTIENT
5141 e310 0a 03                        DEC  TMPLOC         ; DECREMENT BYTE COUNTER
5142 e312 2b 34                        BMI  LBBFC          ; BRANCH IF DONE
5143 e314 27 2e                        BEQ  LBBF8          ; BRANCH IF LAST BYTE
5144 e316 c6 01                        LDB  #1             ; RESET SHIFT COUNTER AND TEMPORARY QUOTIENT BYTE
5145 e318 1f 8a              LBBCC     TFR  A,CC           ; RESTORE CARRY FLAG AND
5146 e31a 25 0e                        BCS  LBBDE          ; BRANCH IF FPA0 =< FPA1
5147 e31c 08 60              LBBD0     ASL  FPA1+3         ; * SHIFT FPA1 MANTISSA 1 BIT TO LEFT
5148 e31e 09 5f                        ROL  FPA1+2         ; *
5149 e320 09 5e                        ROL  FPA1+1         ; *
5150 e322 09 5d                        ROL  FPA1           ; *
5151 e324 25 e3                        BCS  LBBBD          ; BRANCH IF CARRY - ADD ONE TO PARTIAL QUOTIENT
5152 e326 2b c8                        BMI  LBBA4          ; IF MSB OF HIGH ORDER MANTISSA BYTE IS
5153                         *         SET, CHECK THE MAGNITUDES OF FPA0, FPA1
5154 e328 20 df                        BRA  LBBBD          ; CARRY IS CLEAR, CHECK ANOTHER BIT
5155                         * SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1
5156 e32a 96 60              LBBDE     LDA  FPA1+3         ; * SUBTRACT THE LS BYTES OF MANTISSA
5157 e32c 90 53                        SUBA FPA0+3         ; *
5158 e32e 97 60                        STA  FPA1+3         ; *
5159 e330 96 5f                        LDA  FPA1+2         ; = THEN THE NEXT BYTE
5160 e332 92 52                        SBCA FPA0+2         ; =
5161 e334 97 5f                        STA  FPA1+2         ; =
5162 e336 96 5e                        LDA  FPA1+1         ; * AND THE NEXT
5163 e338 92 51                        SBCA FPA0+1         ; *
5164 e33a 97 5e                        STA  FPA1+1         ; *
5165 e33c 96 5d                        LDA  FPA1           ; = AND FINALLY, THE MS BYTE OF MANTISSA
5166 e33e 92 50                        SBCA FPA0           ; =
5167 e340 97 5d                        STA  FPA1           ; =
5168 e342 20 d8                        BRA  LBBD0          ; GO SHIFT FPA1
5169 e344 c6 40              LBBF8     LDB  #$40           ; USE ONLY TWO BITS OF THE LAST BYTE (FIFTH)
5170 e346 20 d0                        BRA  LBBCC          ; GO SHIFT THE LAST BYTE
5171 e348 56                 LBBFC     RORB                ; * SHIFT CARRY (ALWAYS SET HERE) INTO
5172 e349 56                           RORB                ; * BIT 5 AND MOVE
5173 e34a 56                           RORB                ; * BITS 1,0 TO BITS 7,6
5174 e34b d7 63                        STB  FPSBYT         ; SAVE SUB BYTE
5175 e34d 8d 08                        BSR  LBC0B          ; MOVE MANTISSA OF FPA2 TO FPA0
5176 e34f 7e e1 68                     JMP  LBA1C          ; NORMALIZE FPA0
5177 e352 c6 14              LBC06     LDB  #2*10          ; /0' ERROR
5178 e354 7e d4 06                     JMP  LAC46          ; PROCESS THE ERROR
5179                         * COPY MANTISSA FROM FPA2 TO FPA0
5180 e357 9e 13              LBC0B     LDX  FPA2           ; * MOVE TOP 2 BYTES
5181 e359 9f 50                        STX  FPA0           ; *
5182 e35b 9e 15                        LDX  FPA2+2         ; = MOVE BOTTOM 2 BYTES
5183 e35d 9f 52                        STX  FPA0+2         ; =
5184 e35f 39                           RTS
5185                         * COPY A PACKED FP NUMBER FROM (X) TO FPA0
5186 e360 34 02              LBC14     PSHS A              ; SAVE ACCA
5187 e362 ec 01                        LDD  1,X            ; GET TOP TWO MANTISSA BYTES
5188 e364 97 54                        STA  FP0SGN         ; SAVE MS BYTE OF MANTISSA AS MANTISSA SIGN
5189 e366 8a 80                        ORA  #$80           ; UNPACK MS BYTE
5190 e368 dd 50                        STD  FPA0           ; SAVE UNPACKED TOP 2 MANTISSA BYTES
5191 e36a 0f 63                        CLR  FPSBYT         ; CLEAR MANTISSA SUB BYTE
5192 e36c e6 84                        LDB  ,X             ; GET EXPONENT TO ACCB
5193 e36e ae 03                        LDX  3,X            ; * MOVE LAST 2
5194 e370 9f 52                        STX  FPA0+2         ; * MANTISSA BYTES
5195 e372 d7 4f                        STB  FP0EXP         ; SAVE EXPONENT
5196 e374 35 82                        PULS A,PC           ; RESTORE ACCA AND RETURN
5197                         
5198 e376 8e 00 45           LBC2A     LDX  #V45           ; POINT X TO MANTISSA OF FPA4
5199 e379 20 06                        BRA  LBC35          ; MOVE FPA0 TO FPA4
5200 e37b 8e 00 40           LBC2F     LDX  #V40           ; POINT X TO MANTISSA OF FPA3
5201 e37e 8c                           FCB  SKP2           ; SKIP TWO BYTES
5202 e37f 9e 3b              LBC33     LDX  VARDES         ; POINT X TO VARIABLE DESCRIPTOR IN VARDES
5203                         * PACK FPA0 AND MOVE IT TO ADDRESS IN X
5204 e381 96 4f              LBC35     LDA  FP0EXP         ; * COPY EXPONENT
5205 e383 a7 84                        STA  ,X             ; *
5206 e385 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN BIT
5207 e387 8a 7f                        ORA  #$7F           ; MASK THE BOTTOM 7 BITS
5208 e389 94 50                        ANDA FPA0           ; AND BIT 7 OF MANTISSA SIGN INTO BIT 7 OF MS BYTE
5209 e38b a7 01                        STA  1,X            ; SAVE MS BYTE
5210 e38d 96 51                        LDA  FPA0+1         ; * MOVE 2ND MANTISSA BYTE
5211 e38f a7 02                        STA  2,X            ; *
5212 e391 de 52                        LDU  FPA0+2         ; = MOVE BOTTOM 2 MANTISSA BYTES
5213 e393 ef 03                        STU  3,X            ; =
5214 e395 39                           RTS
5215                         * MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA
5216 e396 96 61              LBC4A     LDA  FP1SGN         ; * COPY MANTISSA SIGN FROM
5217 e398 97 54              LBC4C     STA  FP0SGN         ; * FPA1 TO FPA0
5218 e39a 9e 5c                        LDX  FP1EXP         ; = COPY EXPONENT + MS BYTE FROM
5219 e39c 9f 4f                        STX  FP0EXP         ; = FPA1 TO FPA0
5220 e39e 0f 63                        CLR  FPSBYT         ; CLEAR MANTISSA SUB BYTE
5221 e3a0 96 5e                        LDA  FPA1+1         ; * COPY 2ND MANTISSA BYTE
5222 e3a2 97 51                        STA  FPA0+1         ; * FROM FPA1 TO FPA0
5223 e3a4 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN
5224 e3a6 9e 5f                        LDX  FPA1+2         ; * COPY 3RD AND 4TH MANTISSA BYTE
5225 e3a8 9f 52                        STX  FPA0+2         ; * FROM FPA1 TO FPA0
5226 e3aa 39                           RTS
5227                         * TRANSFER FPA0 TO FPA1
5228 e3ab dc 4f              LBC5F     LDD  FP0EXP         ; * TRANSFER EXPONENT & MS BYTE
5229 e3ad dd 5c                        STD  FP1EXP         ; *
5230 e3af 9e 51                        LDX  FPA0+1         ; = TRANSFER MIDDLE TWO BYTES
5231 e3b1 9f 5e                        STX  FPA1+1         ; =
5232 e3b3 9e 53                        LDX  FPA0+3         ; * TRANSFER BOTTOM TWO BYTES
5233 e3b5 9f 60                        STX  FPA1+3         ; *
5234 e3b7 4d                           TSTA                ; SET FLAGS ACCORDING TO EXPONENT
5235 e3b8 39                           RTS
5236                         * CHECK FPA0; RETURN ACCB = 0 IF FPA0 = 0,
5237                         * ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = POSITIVE
5238 e3b9 d6 4f              LBC6D     LDB  FP0EXP         ; GET EXPONENT
5239 e3bb 27 08                        BEQ  LBC79          ; BRANCH IF FPA0 = 0
5240 e3bd d6 54              LBC71     LDB  FP0SGN         ; GET SIGN OF MANTISSA
5241 e3bf 59                 LBC73     ROLB                ; BIT 7 TO CARRY
5242 e3c0 c6 ff                        LDB  #$FF           ; NEGATIVE FLAG
5243 e3c2 25 01                        BCS  LBC79          ; BRANCH IF NEGATIVE MANTISSA
5244 e3c4 50                           NEGB                ; ACCB = 1 IF POSITIVE MANTISSA
5245 e3c5 39                 LBC79     RTS
5246                         
5247                         * SGN
5248 e3c6 8d f1              SGN       BSR  LBC6D          ; SET ACCB ACCORDING TO SIGN OF FPA0
5249                         * CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POINT NUMBER
5250 e3c8 d7 50              LBC7C     STB  FPA0           ; SAVE ACCB IN FPA0
5251 e3ca 0f 51                        CLR  FPA0+1         ; CLEAR NUMBER 2 MANTISSA BYTE OF FPA0
5252 e3cc c6 88                        LDB  #$88           ; EXPONENT REQUIRED IF FPA0 IS TO BE AN INTEGER
5253 e3ce 96 50              LBC82     LDA  FPA0           ; GET MS BYTE OF MANTISSA
5254 e3d0 80 80                        SUBA #$80           ; SET CARRY IF POSITIVE MANTISSA
5255 e3d2 d7 4f              LBC86     STB  FP0EXP         ; SAVE EXPONENT
5256 e3d4 dc 74                        LDD  ZERO           ; * ZERO OUT ACCD AND
5257 e3d6 dd 52                        STD  FPA0+2         ; * BOTTOM HALF OF FPA0
5258 e3d8 97 63                        STA  FPSBYT         ; CLEAR SUB BYTE
5259 e3da 97 54                        STA  FP0SGN         ; CLEAR SIGN OF FPA0 MANTISSA
5260 e3dc 7e e1 64                     JMP  LBA18          ; GO NORMALIZE FPA0
5261                         
5262                         * ABS
5263 e3df 0f 54              ABS       CLR  FP0SGN         ; FORCE MANTISSA SIGN OF FPA0 POSITIVE
5264 e3e1 39                           RTS
5265                         * COMPARE A PACKED FLOATING POINT NUMBER POINTED TO
5266                         * BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN
5267                         * ZERO FLAG SET AND ACCB = 0, IF EQUAL; ACCB = 1 IF
5268                         * FPA0 > (X); ACCB = $FF IF FPA0 < (X)
5269 e3e2 e6 84              LBC96     LDB  ,X             ; CHECK EXPONENT OF (X)
5270 e3e4 27 d3                        BEQ  LBC6D          ; BRANCH IF FPA = 0
5271 e3e6 e6 01                        LDB  1,X            ; GET MS BYTE OF MANTISSA OF (X)
5272 e3e8 d8 54                        EORB FP0SGN         ; EOR WITH SIGN OF FPA0
5273 e3ea 2b d1                        BMI  LBC71          ; BRANCH IF SIGNS NOT =
5274                         * COMPARE FPA0 WITH FP NUMBER POINTED TO BY (X).
5275                         * FPA0 IS NORMALIZED, (X) IS PACKED.
5276 e3ec d6 4f              LBCA0     LDB  FP0EXP         ; * GET EXPONENT OF
5277 e3ee e1 84                        CMPB ,X             ; * FPA0, COMPARE TO EXPONENT OF
5278 e3f0 26 1d                        BNE  LBCC3          ; * (X) AND BRANCH IF <>.
5279 e3f2 e6 01                        LDB  1,X            ; * GET MS BYTE OF (X), KEEP ONLY
5280 e3f4 ca 7f                        ORB  #$7F           ; * THE SIGN BIT - 'AND' THE BOTTOM 7
5281 e3f6 d4 50                        ANDB FPA0           ; * BITS OF FPA0 INTO ACCB
5282 e3f8 e1 01                        CMPB 1,X            ; = COMPARE THE BOTTOM 7 BITS OF THE MANTISSA
5283 e3fa 26 13                        BNE  LBCC3          ; = MS BYTE AND BRANCH IF <>
5284 e3fc d6 51                        LDB  FPA0+1         ; * COMPARE 2ND BYTE
5285 e3fe e1 02                        CMPB 2,X            ; * OF MANTISSA,
5286 e400 26 0d                        BNE  LBCC3          ; * BRANCH IF <>
5287 e402 d6 52                        LDB  FPA0+2         ; = COMPARE 3RD BYTE
5288 e404 e1 03                        CMPB 3,X            ; = OF MANTISSA,
5289 e406 26 07                        BNE  LBCC3          ; = BRANCH IF <>
5290 e408 d6 53                        LDB  FPA0+3         ; * SUBTRACT LS BYTE
5291 e40a e0 04                        SUBB 4,X            ; * OF (X) FROM LS BYTE OF
5292 e40c 26 01                        BNE  LBCC3          ; * FPA0, BRANCH IF <>
5293 e40e 39                           RTS                 ; RETURN IF FP (X) = FPA0
5294 e40f 56                 LBCC3     RORB                ; SHIFT CARRY TO BIT 7; CARRY SET IF FPA0 < (X)
5295 e410 d8 54                        EORB FP0SGN         ; TOGGLE SIZE COMPARISON BIT IF FPA0 IS NEGATIVE
5296 e412 20 ab                        BRA  LBC73          ; GO SET ACCB ACCORDING TO COMPARISON
5297                         * DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BINARY POINT IS TO THE RIGHT
5298                         * OF THE LEAST SIGNIFICANT BYTE OF THE MANTISSA
5299 e414 d6 4f              LBCC8     LDB  FP0EXP         ; GET EXPONENT OF FPA0
5300 e416 27 3d                        BEQ  LBD09          ; ZERO MANTISSA IF FPA0 = 0
5301 e418 c0 a0                        SUBB #$A0           ; SUBTRACT $A0 FROM FPA0 EXPONENT T THIS WILL YIELD
5302                         *                             ; THE NUMBER OF SHIFTS REQUIRED TO DENORMALIZE FPA0. WHEN
5303                         *                             ; THE EXPONENT OF FPA0 IS = ZERO, THEN THE BINARY POINT
5304                         *                             ; WILL BE TO THE RIGHT OF THE MANTISSA
5305 e41a 96 54                        LDA  FP0SGN         ; TEST SIGN OF FPA0 MANTISSA
5306 e41c 2a 05                        BPL  LBCD7          ; BRANCH IF POSITIVE
5307 e41e 03 5b                        COM  FPCARY         ; COMPLEMENT CARRY IN BYTE
5308 e420 bd e1 c7                     JSR  LBA7B          ; NEGATE MANTISSA OF FPA0
5309 e423 8e 00 4f           LBCD7     LDX  #FP0EXP        ; POINT X TO FPA0
5310 e426 c1 f8                        CMPB #-8            ; EXPONENT DIFFERENCE < -8?
5311 e428 2e 06                        BGT  LBCE4          ; YES
5312 e42a bd e1 fa                     JSR  LBAAE          ; SHIFT FPA0 RIGHT UNTIL FPA0 EXPONENT = $A0
5313 e42d 0f 5b                        CLR  FPCARY         ; CLEAR CARRY IN BYTE
5314 e42f 39                           RTS
5315 e430 0f 5b              LBCE4     CLR  FPCARY         ; CLEAR CARRY IN BYTE
5316 e432 96 54                        LDA  FP0SGN         ; * GET SIGN OF FPA0 MANTISSA
5317 e434 49                           ROLA                ; * ROTATE IT INTO THE CARRY FLAG
5318 e435 06 50                        ROR  FPA0           ; ROTATE CARRY (MANTISSA SIGN) INTO BIT 7
5319                         *                             ; OF LS BYTE OF MANTISSA
5320 e437 7e e2 06                     JMP  LBABA          ; DE-NORMALIZE FPA0
5321                         
5322                         * INT
5323                         * THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS IT WILL SHIFT THE BINARY POINT
5324                         * TO THE EXTREME RIGHT OF THE MANTISSA TO FORCE ITS EXPONENT TO BE $AO. ONCE
5325                         * THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE FOUR LEAST SIGNIFICANT
5326                         * BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUSION OF THE DE-NORMALIZATION
5327                         * ONLY THE INTEGER PORTION OF FPA0 WILL REMAIN.
5328                         *
5329 e43a d6 4f              INT       LDB  FP0EXP         ; GET EXPONENT OF FPA0
5330 e43c c1 a0                        CMPB #$A0           ; LARGEST POSSIBLE INTEGER EXPONENT
5331 e43e 24 1d                        BCC  LBD11          ; RETURN IF FPA0 >= 32768
5332 e440 8d d2                        BSR  LBCC8          ; SHIFT THE BINARY POINT ONE TO THE RIGHT OF THE
5333                         *                             ; LS BYTE OF THE FPA0 MANTISSA
5334 e442 d7 63                        STB  FPSBYT         ; ACCB = 0: ZERO OUT THE SUB BYTE
5335 e444 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN
5336 e446 d7 54                        STB  FP0SGN         ; FORCE MANTISSA SIGN TO BE POSITIVE
5337 e448 80 80                        SUBA #$80           ; SET CARRY IF MANTISSA
5338 e44a 86 a0                        LDA  #$A0           ; * GET DENORMALIZED EXPONENT AND
5339 e44c 97 4f                        STA  FP0EXP         ; * SAVE IT IN FPA0 EXPONENT
5340 e44e 96 53                        LDA  FPA0+3         ; = GET LS BYTE OF FPA0 AND
5341 e450 97 01                        STA  CHARAC         ; = SAVE IT IN CHARAC
5342 e452 7e e1 64                     JMP  LBA18          ; NORMALIZE FPA0
5343                         
5344 e455 d7 50              LBD09     STB  FPA0           ; * LOAD MANTISSA OF FPA0 WITH CONTENTS OF ACCB
5345 e457 d7 51                        STB  FPA0+1         ; *
5346 e459 d7 52                        STB  FPA0+2         ; *
5347 e45b d7 53                        STB  FPA0+3         ; *
5348 e45d 39                 LBD11     RTS                 ; *
5349                         
5350                         * CONVERT ASCII STRING TO FLOATING POINT
5351 e45e 9e 74              LBD12     LDX  ZERO           ; (X) = 0
5352 e460 9f 54                        STX  FP0SGN         ; * ZERO OUT FPA0 & THE SIGN FLAG (COEFCT)
5353 e462 9f 4f                        STX  FP0EXP         ; *
5354 e464 9f 51                        STX  FPA0+1         ; *
5355 e466 9f 52                        STX  FPA0+2         ; *
5356 e468 9f 47                        STX  V47            ; INITIALIZE EXPONENT & EXPONENT SIGN FLAG TO ZERO
5357 e46a 9f 45                        STX  V45            ; INITIALIZE RIGHT DECIMAL CTR & DECIMAL PT FLAG TO 0
5358 e46c 25 64                        BCS  LBD86          ; IF CARRY SET (NUMERIC CHARACTER), ASSUME ACCA CONTAINS FIRST
5359                         *         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE RAM HOOK
5360 e46e bd eb 9b                     JSR  XVEC19         ; CALL EXTENDED BASIC ADD-IN
5361 e471 81 2d              LBD25     CMPA #'-            ; * CHECK FOR A LEADING MINUS SIGN AND BRANCH
5362 e473 26 04                        BNE  LBD2D          ; * IF NO MINUS SIGN
5363 e475 03 55                        COM  COEFCT         ; TOGGLE SIGN; 0 = +; FF = -
5364 e477 20 04                        BRA  LBD31          ; INTERPRET THE REST OF THE STRING
5365 e479 81 2b              LBD2D     CMPA #'+            ; * CHECK FOR LEADING PLUS SlGN AND BRANCH
5366 e47b 26 04                        BNE  LBD35          ; * IF NOT A PLUS SIGN
5367 e47d 9d 7c              LBD31     JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
5368 e47f 25 51                        BCS  LBD86          ; BRANCH IF NUMERIC CHARACTER
5369 e481 81 2e              LBD35     CMPA #'.            ; DECIMAL POlNT?
5370 e483 27 28                        BEQ  LBD61          ; YES
5371 e485 81 45                        CMPA #'E            ; "E" SHORTHAND FORM (SCIENTIFIC NOTATION)?
5372 e487 26 28                        BNE  LBD65          ; NO
5373                         * EVALUATE EXPONENT OF EXPONENTIAL FORMAT
5374 e489 9d 7c                        JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
5375 e48b 25 64                        BCS  LBDA5          ; BRANCH IF NUMERIC
5376 e48d 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN?
5377 e48f 27 0e                        BEQ  LBD53          ; YES
5378 e491 81 2d                        CMPA #'-            ; ASCII MINUS?
5379 e493 27 0a                        BEQ  LBD53          ; YES
5380 e495 81 a6                        CMPA #TOK_PLUS      ; PLUS TOKEN?
5381 e497 27 08                        BEQ  LBD55          ; YES
5382 e499 81 2b                        CMPA #'+            ; ASCII PLUS?
5383 e49b 27 04                        BEQ  LBD55          ; YES
5384 e49d 20 06                        BRA  LBD59          ; BRANCH IF NO SIGN FOUND
5385 e49f 03 48              LBD53     COM  V48            ; SET EXPONENT SIGN FLAG TO NEGATIVE
5386                         * STRIP A DECIMAL NUMBER FROM BASIC LINE, CONVERT IT TO BINARY IN V47
5387 e4a1 9d 7c              LBD55     JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
5388 e4a3 25 4c                        BCS  LBDA5          ; IF NUMERIC CHARACTER, CONVERT TO BINARY
5389 e4a5 0d 48              LBD59     TST  V48            ; * CHECK EXPONENT SIGN FLAG
5390 e4a7 27 08                        BEQ  LBD65          ; * AND BRANCH IF POSITIVE
5391 e4a9 00 47                        NEG  V47            ; NEGATE VALUE OF EXPONENT
5392 e4ab 20 04                        BRA  LBD65
5393 e4ad 03 46              LBD61     COM  V46            ; *TOGGLE DECIMAL PT FLAG AND INTERPRET ANOTHER
5394 e4af 26 cc                        BNE  LBD31          ; *CHARACTER IF <> 0 - TERMINATE INTERPRETATION
5395                         *         IF   SECOND DECIMAL POINT
5396                         * ADJUST FPA0 FOR THE DECIMAL EXPONENT IN V47
5397 e4b1 96 47              LBD65     LDA  V47            ; * GET EXPONENT, SUBTRACT THE NUMBER OF
5398 e4b3 90 45                        SUBA V45            ; * PLACES TO THE RIGHT OF DECIMAL POINT
5399 e4b5 97 47                        STA  V47            ; * AND RESAVE IT.
5400 e4b7 27 12                        BEQ  LBD7F          ; EXIT ROUTINE IF ADJUSTED EXPONENT = ZERO
5401 e4b9 2a 09                        BPL  LBD78          ; BRANCH IF POSITIVE EXPONENT
5402 e4bb bd e2 ce           LBD6F     JSR  LBB82          ; DIVIDE FPA0 BY 10
5403 e4be 0c 47                        INC  V47            ; INCREMENT EXPONENT COUNTER (MULTIPLY BY 10)
5404 e4c0 26 f9                        BNE  LBD6F          ; KEEP MULTIPLYING
5405 e4c2 20 07                        BRA  LBD7F          ; EXIT ROUTINE
5406 e4c4 bd e2 b6           LBD78     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
5407 e4c7 0a 47                        DEC  V47            ; DECREMENT EXPONENT COUNTER (DIVIDE BY 10)
5408 e4c9 26 f9                        BNE  LBD78          ; KEEP MULTIPLYING
5409 e4cb 96 55              LBD7F     LDA  COEFCT         ; GET THE SIGN FLAG
5410 e4cd 2a 8e                        BPL  LBD11          ; RETURN IF POSITIVE
5411 e4cf 7e e6 35                     JMP  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0, IF NEGATIVE
5412                         *MULTIPLY FPA0 BY TEN AND ADD ACCA TO THE RESULT
5413 e4d2 d6 45              LBD86     LDB  V45            ; *GET THE RIGHT DECIMAL COUNTER AND SUBTRACT
5414 e4d4 d0 46                        SUBB V46            ; *THE DECIMAL POINT FLAG FROM IT. IF DECIMAL POINT
5415 e4d6 d7 45                        STB  V45            ; *FLAG=0, NOTHING HAPPENS. IF DECIMAL POINT FLAG IS
5416                         *                             -1, THEN RIGHT DECIMAL COUNTER IS INCREMENTED BY ONE
5417 e4d8 34 02                        PSHS A              ; SAVE NEW DIGIT ON STACK
5418 e4da bd e2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
5419 e4dd 35 04                        PULS B              ; GET NEW DIGIT BACK
5420 e4df c0 30                        SUBB #'0            ; MASK OFF ASCII
5421 e4e1 8d 02                        BSR  LBD99          ; ADD ACCB TO FPA0
5422 e4e3 20 98                        BRA  LBD31          ; GET ANOTHER CHARACTER FROM BASIC
5423 e4e5 bd e3 7b           LBD99     JSR  LBC2F          ; PACK FPA0 AND SAVE IT IN FPA3
5424 e4e8 bd e3 c8                     JSR  LBC7C          ; CONVERT ACCB TO FP NUMBER IN FPA0
5425 e4eb 8e 00 40                     LDX  #V40           ; * ADD FPA0 TO
5426 e4ee 7e e1 0e                     JMP  LB9C2          ; * FPA3
5427                         
5428                         
5429 e4f1 d6 47              LBDA5     LDB  V47
5430 e4f3 58                           ASLB                ; TIMES 2
5431 e4f4 58                           ASLB                ; TIMES 4
5432 e4f5 db 47                        ADDB V47            ; ADD 1 = TIMES 5
5433 e4f7 58                           ASLB                ; TIMES 10
5434 e4f8 80 30                        SUBA #'0            ; *MASK OFF ASCII FROM ACCA, PUSH
5435 e4fa 34 04                        PSHS B              ; *RESULT ONTO THE STACK AND
5436 e4fc ab e0                        ADDA ,S+            ; ADD lT TO ACCB
5437 e4fe 97 47                        STA  V47            ; SAVE IN V47
5438 e500 20 9f                        BRA  LBD55          ; INTERPRET ANOTHER CHARACTER
5439                         *
5440 e502 9b 3e bc 1f fd     LBDB6     FCB  $9B,$3E,$BC,$1F,$FD ; * 99999999.9
5441 e507 9e 6e 6b 27 fd     LBDBB     FCB  $9E,$6E,$6B,$27,$FD ; * 999999999
5442 e50c 9e 6e 6b 28 00     LBDC0     FCB  $9E,$6E,$6B,$28,$00 ; * 1E + 09
5443                         *
5444 e511 8e d3 a7           LBDC5     LDX  #LABE8-1       ; POINT X TO " IN " MESSAGE
5445 e514 8d 0c                        BSR  LBDD6          ; COPY A STRING FROM (X) TO CONSOLE OUT
5446 e516 dc 68                        LDD  CURLIN         ; GET CURRENT BASIC LINE NUMBER TO ACCD
5447                         * CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER
5448                         * AND PRINT IT TO CONSOLE OUT
5449 e518 dd 50              LBDCC     STD  FPA0           ; SAVE ACCD IN TOP HALF OF FPA0
5450 e51a c6 90                        LDB  #$90           ; REQ'D EXPONENT IF TOP HALF OF ACCD = INTEGER
5451 e51c 43                           COMA                ; SET CARRY FLAG - FORCE POSITIVE MANTISSA
5452 e51d bd e3 d2                     JSR  LBC86          ; ZERO BOTTOM HALF AND SIGN OF FPA0, THEN
5453                         *         SAVE EXPONENT AND NORMALIZE IT
5454 e520 8d 03                        BSR  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
5455 e522 7e e0 e8           LBDD6     JMP  LB99C          ; COPY A STRING FROM (X) TO CONSOLE OUT
5456                         
5457                         * CONVERT FP NUMBER TO ASCII STRING
5458 e525 ce 01 f1           LBDD9     LDU  #STRBUF+3      ; POINT U TO BUFFER WHICH WILL NOT CAUSE
5459                         *                             ; THE STRING TO BE STORED IN STRING SPACE
5460 e528 86 20              LBDDC     LDA  #SPACE         ; SPACE = DEFAULT SIGN FOR POSITIVE #
5461 e52a d6 54                        LDB  FP0SGN         ; GET SIGN OF FPA0
5462 e52c 2a 02                        BPL  LBDE4          ; BRANCH IF POSITIVE
5463 e52e 86 2d                        LDA  #'-            ; ASCII MINUS SIGN
5464 e530 a7 c0              LBDE4     STA  ,U+            ; STORE SIGN OF NUMBER
5465 e532 df 64                        STU  COEFPT         ; SAVE BUFFER POINTER
5466 e534 97 54                        STA  FP0SGN         ; SAVE SIGN (IN ASCII)
5467 e536 86 30                        LDA  #'0            ; ASCII ZERO IF EXPONENT = 0
5468 e538 d6 4f                        LDB  FP0EXP         ; GET FPA0 EXPONENT
5469 e53a 10 27 00 c6                  LBEQ LBEB8          ; BRANCH IF FPA0 = 0
5470 e53e 4f                           CLRA                ; BASE 10 EXPONENT=0 FOR FP NUMBER > 1
5471 e53f c1 80                        CMPB #$80           ; CHECK EXPONENT
5472 e541 22 08                        BHI  LBDFF          ; BRANCH IF FP NUMBER > 1
5473                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE CONVERSION PROCESS
5474 e543 8e e5 0c                     LDX  #LBDC0         ; POINT X TO FP 1E+09
5475 e546 bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY (X)
5476 e549 86 f7                        LDA  #-9            ; BASE 10 EXPONENT = -9
5477 e54b 97 45              LBDFF     STA  V45            ; BASE 10 EXPONENT
5478                         * PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE RANGE
5479                         * OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST
5480                         * NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE
5481                         * SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING
5482                         * SCIENTIFIC NOTATION
5483 e54d 8e e5 07           LBE01     LDX  #LBDBB         ; POINT X TO FP 999,999,999
5484 e550 bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO 999,999,999
5485 e553 2e 0f                        BGT  LBE18          ; BRANCH IF > 999,999,999
5486 e555 8e e5 02           LBE09     LDX  #LBDB6         ; POINT X TO FP 99,999,999.9
5487 e558 bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO 99,999,999.9
5488 e55b 2e 0e                        BGT  LBE1F          ; BRANCH IF > 99,999,999.9 (IN RANGE)
5489 e55d bd e2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
5490 e560 0a 45                        DEC  V45            ; SUBTRACT ONE FROM DECIMAL OFFSET
5491 e562 20 f1                        BRA  LBE09          ; PSEUDO - NORMALIZE SOME MORE
5492 e564 bd e2 ce           LBE18     JSR  LBB82          ; DIVIDE FPA0 BY 10
5493 e567 0c 45                        INC  V45            ; ADD ONE TO BASE 10 EXPONENT
5494 e569 20 e2                        BRA  LBE01          ; PSEUDO - NORMALIZE SOME MORE
5495 e56b bd e1 00           LBE1F     JSR  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
5496 e56e bd e4 14                     JSR  LBCC8          ; CONVERT FPA0 TO AN INTEGER
5497 e571 c6 01                        LDB  #1             ; DEFAULT DECIMAL POINT FLAG (FORCE IMMED DECIMAL PT)
5498 e573 96 45                        LDA  V45            ; * GET BASE 10 EXPONENT AND ADD TEN TO IT
5499 e575 8b 0a                        ADDA #9+1           ; * (NUMBER 'NORMALIZED' TO 9 PLACES & DECIMAL PT)
5500 e577 2b 09                        BMI  LBE36          ; BRANCH IF NUMBER < 1.0
5501 e579 81 0b                        CMPA #9+2           ; NINE PLACES MAY BE DISPLAYED WITHOUT
5502                         *         USING SCIENTIFIC NOTATION
5503 e57b 24 05                        BCC  LBE36          ; BRANCH IF SCIENTIFIC NOTATION REQUIRED
5504 e57d 4a                           DECA                ; * SUBTRACT 1 FROM MODIFIED BASE 10 EXPONENT CTR
5505 e57e 1f 89                        TFR  A,B            ; * AND SAVE IT IN ACCB (DECiMAL POINT FLAG)
5506 e580 86 02                        LDA  #2             ; FORCE EXPONENT = 0 - DON'T USE SCIENTIFIC NOTATION
5507 e582 4a                 LBE36     DECA                ; * SUBTRACT TWO (WITHOUT AFFECTING CARRY)
5508 e583 4a                           DECA                ; * FROM BASE 10 EXPONENT
5509 e584 97 47                        STA  V47            ; SAVE EXPONENT - ZERO EXPONENT = DO NOT DISPLAY
5510                         *         IN   SCIENTIFIC NOTATION
5511 e586 d7 45                        STB  V45            ; DECIMAL POINT FLAG - NUMBER OF PLACES TO
5512                         *         LEFT OF DECIMAL POINT
5513 e588 2e 0d                        BGT  LBE4B          ; BRANCH IF >= 1
5514 e58a de 64                        LDU  COEFPT         ; POINT U TO THE STRING BUFFER
5515 e58c 86 2e                        LDA  #'.            ; * STORE A PERIOD
5516 e58e a7 c0                        STA  ,U+            ; * IN THE BUFFER
5517 e590 5d                           TSTB                ; CHECK DECIMAL POINT FLAG
5518 e591 27 04                        BEQ  LBE4B          ; BRANCH IF NOTHING TO LEFT OF DECIMAL POINT
5519 e593 86 30                        LDA  #'0            ; * STORE A ZERO
5520 e595 a7 c0                        STA  ,U+            ; * IN THE BUFFER
5521                         
5522                         * CONVERT FPA0 INTO A STRING OF ASCII DIGITS
5523 e597 8e e6 11           LBE4B     LDX  #LBEC5         ; POINT X TO FP POWER OF 10 MANTISSA
5524 e59a c6 80                        LDB  #0+$80         ; INITIALIZE DIGIT COUNTER TO 0+$80
5525                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
5526                         * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
5527                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB IS HOW
5528                         * THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.
5529 e59c 96 53              LBE50     LDA  FPA0+3         ; * ADD MANTISSA LS
5530 e59e ab 03                        ADDA 3,X            ; * BYTE OF FPA0
5531 e5a0 97 53                        STA  FPA0+3         ; * AND (X)
5532 e5a2 96 52                        LDA  FPA0+2         ; = ADD MANTISSA
5533 e5a4 a9 02                        ADCA 2,X            ; = NUMBER 3 BYTE OF
5534 e5a6 97 52                        STA  FPA0+2         ; = FPA0 AND (X)
5535 e5a8 96 51                        LDA  FPA0+1         ; * ADD MANTISSA
5536 e5aa a9 01                        ADCA 1,X            ; * NUMBER 2 BYTE OF
5537 e5ac 97 51                        STA  FPA0+1         ; * FPA0 AND (X)
5538 e5ae 96 50                        LDA  FPA0           ; = ADD MANTISSA
5539 e5b0 a9 84                        ADCA ,X             ; = MS BYTE OF
5540 e5b2 97 50                        STA  FPA0           ; = FPA0 AND (X)
5541 e5b4 5c                           INCB                ; ADD ONE TO DIGIT COUNTER
5542 e5b5 56                           RORB                ; ROTATE CARRY INTO BIT 7
5543 e5b6 59                           ROLB                ; *SET OVERFLOW FLAG AND BRANCH IF CARRY = 1 AND
5544 e5b7 28 e3                        BVC  LBE50          ; *POSITIVE MANTISSA OR CARRY = 0 AND NEG MANTISSA
5545 e5b9 24 03                        BCC  LBE72          ; BRANCH IF NEGATIVE MANTISSA
5546 e5bb c0 0b                        SUBB #10+1          ; * TAKE THE 9'S COMPLEMENT IF
5547 e5bd 50                           NEGB                ; * ADDING MANTISSA
5548 e5be cb 2f              LBE72     ADDB #'0-1          ; ADD ASCII OFFSET TO DIGIT
5549 e5c0 30 04                        LEAX 4,X            ; MOVE TO NEXT POWER OF 10 MANTISSA
5550 e5c2 1f 98                        TFR  B,A            ; SAVE DIGIT IN ACCA
5551 e5c4 84 7f                        ANDA #$7F           ; MASK OFF BIT 7 (ADD/SUBTRACT FLAG)
5552 e5c6 a7 c0                        STA  ,U+            ; STORE DIGIT IN STRING BUFFER
5553 e5c8 0a 45                        DEC  V45            ; DECREMENT DECIMAL POINT FLAG
5554 e5ca 26 04                        BNE  LBE84          ; BRANCH IF NOT TIME FOR DECIMAL POINT
5555 e5cc 86 2e                        LDA  #'.            ; * STORE DECIMAL POINT IN
5556 e5ce a7 c0                        STA  ,U+            ; * STRING BUFFER
5557 e5d0 53                 LBE84     COMB                ; TOGGLE BIT 7 (ADD/SUBTRACT FLAG)
5558 e5d1 c4 80                        ANDB #$80           ; MASK OFF ALL BUT ADD/SUBTRACT FLAG
5559 e5d3 8c e6 35                     CMPX #LBEC5+36      ; COMPARE X TO END OF MANTISSA TABLE
5560 e5d6 26 c4                        BNE  LBE50          ; BRANCH IF NOT AT END OF TABLE
5561                         * BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY
5562 e5d8 a6 c2              LBE8C     LDA  ,-U            ; GET THE LAST CHARACTER; MOVE POINTER BACK
5563 e5da 81 30                        CMPA #'0            ; WAS IT A ZERO?
5564 e5dc 27 fa                        BEQ  LBE8C          ; IGNORE TRAILING ZEROS IF SO
5565 e5de 81 2e                        CMPA #'.            ; CHECK FOR DECIMAL POINT
5566 e5e0 26 02                        BNE  LBE98          ; BRANCH IF NOT DECIMAL POINT
5567 e5e2 33 5f                        LEAU -1,U           ; STEP OVER THE DECIMAL POINT
5568 e5e4 86 2b              LBE98     LDA  #'+            ; ASCII PLUS SIGN
5569 e5e6 d6 47                        LDB  V47            ; GET SCIENTIFIC NOTATION EXPONENT
5570 e5e8 27 1c                        BEQ  LBEBA          ; BRANCH IF NOT SCIENTIFIC NOTATION
5571 e5ea 2a 03                        BPL  LBEA3          ; BRANCH IF POSITIVE EXPONENT
5572 e5ec 86 2d                        LDA  #'-            ; ASCII MINUS SIGN
5573 e5ee 50                           NEGB                ; NEGATE EXPONENT IF NEGATIVE
5574 e5ef a7 42              LBEA3     STA  2,U            ; STORE EXPONENT SIGN IN STRING
5575 e5f1 86 45                        LDA  #'E            ; * GET ASCII 'E' (SCIENTIFIC NOTATION
5576 e5f3 a7 41                        STA  1,U            ; * FLAG) AND SAVE IT IN THE STRING
5577 e5f5 86 2f                        LDA  #'0-1          ; INITIALIZE ACCA TO ASCII ZERO
5578                         
5579                         
5580 e5f7 4c                 LBEAB     INCA                ; ADD ONE TO 10'S DIGIT OF EXPONENT
5581 e5f8 c0 0a                        SUBB #10            ; SUBTRACT 10 FROM ACCB
5582 e5fa 24 fb                        BCC  LBEAB          ; ADD 1 TO 10'S DIGIT IF NO CARRY
5583 e5fc cb 3a                        ADDB #'9+1          ; CONVERT UNITS DIGIT TO ASCII
5584 e5fe ed 43                        STD  3,U            ; SAVE EXPONENT IN STRING
5585 e600 6f 45                        CLR  5,U            ; CLEAR LAST BYTE (TERMINATOR)
5586 e602 20 04                        BRA  LBEBC          ; GO RESET POINTER
5587 e604 a7 c4              LBEB8     STA  ,U             ; STORE LAST CHARACTER
5588 e606 6f 41              LBEBA     CLR  1,U            ; CLEAR LAST BYTE (TERMINATOR - REQUIRED BY
5589                         *         PRINT SUBROUTINES)
5590 e608 8e 01 f1           LBEBC     LDX  #STRBUF+3      ; RESET POINTER TO START OF BUFFER
5591 e60b 39                           RTS
5592                         *
5593 e60c 80 00 00 00 00     LBEC0     FCB  $80,$00,$00,$00,$00 ; FLOATING POINT .5
5594                         *
5595                         *** TABLE OF UNNORMALIZED POWERS OF 10
5596 e611 fa 0a 1f 00        LBEC5     FCB  $FA,$0A,$1F,$00 ; -100000000
5597 e615 00 98 96 80        LBEC9     FCB  $00,$98,$96,$80 ; 10000000
5598 e619 ff f0 bd c0        LBECD     FCB  $FF,$F0,$BD,$C0 ; -1000000
5599 e61d 00 01 86 a0        LBED1     FCB  $00,$01,$86,$A0 ; 100000
5600 e621 ff ff d8 f0        LBED5     FCB  $FF,$FF,$D8,$F0 ; -10000
5601 e625 00 00 03 e8        LBED9     FCB  $00,$00,$03,$E8 ; 1000
5602 e629 ff ff ff 9c        LBEDD     FCB  $FF,$FF,$FF,$9C ; -100
5603 e62d 00 00 00 0a        LBEE1     FCB  $00,$00,$00,$0A ; 10
5604 e631 ff ff ff ff        LBEE5     FCB  $FF,$FF,$FF,$FF ; -1
5605                         *
5606                         *
5607 e635 96 4f              LBEE9     LDA  FP0EXP         ; GET EXPONENT OF FPA0
5608 e637 27 02                        BEQ  LBEEF          ; BRANCH IF FPA0 = 0
5609 e639 03 54                        COM  FP0SGN         ; TOGGLE MANTISSA SIGN OF FPA0
5610 e63b 39                 LBEEF     RTS
5611                         * EXPAND A POLYNOMIAL OF THE FORM
5612                         * AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0
5613                         * AND THE X REGISTER POINTS TO A TABLE OF
5614                         * COEFFICIENTS A,B,C,D....
5615 e63c 9f 64              LBEF0     STX  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
5616 e63e bd e3 7b                     JSR  LBC2F          ; MOVE FPA0 TO FPA3
5617 e641 8d 05                        BSR  LBEFC          ; MULTIPLY FPA3 BY FPA0
5618 e643 8d 08                        BSR  LBF01          ; EXPAND POLYNOMIAL
5619 e645 8e 00 40                     LDX  #V40           ; POINT X TO FPA3
5620 e648 7e e2 16           LBEFC     JMP  LBACA          ; MULTIPLY (X) BY FPA0
5621                         
5622                         * CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL
5623                         * EXPRESSION. ENTER WITH (X) POINTING TO A TABLE
5624                         * OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE
5625                         * NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER
5626                         * OF PACKED FLOATING POINT NUMBERS. THE
5627                         * POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =
5628                         * (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0...YN)
5629 e64b 9f 64              LBEFF     STX  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
5630 e64d bd e3 76           LBF01     JSR  LBC2A          ; MOVE FPA0 TO FPA4
5631 e650 9e 64                        LDX  COEFPT         ; GET THE COEFFICIENT POINTER
5632 e652 e6 80                        LDB  ,X+            ; GET THE TOP OF COEFFICIENT TABLE TO
5633 e654 d7 55                        STB  COEFCT         ; * USE AND STORE IT IN TEMPORARY COUNTER
5634 e656 9f 64                        STX  COEFPT         ; SAVE NEW COEFFICIENT POINTER
5635 e658 8d ee              LBF0C     BSR  LBEFC          ; MULTIPLY (X) BY FPA0
5636 e65a 9e 64                        LDX  COEFPT         ; *GET COEFFICIENT POINTER
5637 e65c 30 05                        LEAX 5,X            ; *MOVE TO NEXT FP NUMBER
5638 e65e 9f 64                        STX  COEFPT         ; *SAVE NEW COEFFICIENT POINTER
5639 e660 bd e1 0e                     JSR  LB9C2          ; ADD (X) AND FPA0
5640 e663 8e 00 45                     LDX  #V45           ; POINT (X) TO FPA4
5641 e666 0a 55                        DEC  COEFCT         ; DECREMENT TEMP COUNTER
5642 e668 26 ee                        BNE  LBF0C          ; BRANCH IF MORE COEFFICIENTS LEFT
5643 e66a 39                           RTS
5644                         
5645                         * RND
5646 e66b bd e3 b9           RND       JSR  LBC6D          ; TEST FPA0
5647 e66e 2b 1f                        BMI  LBF45          ; BRANCH IF FPA0 = NEGATIVE
5648 e670 27 15                        BEQ  LBF3B          ; BRANCH IF FPA0 = 0
5649 e672 8d 10                        BSR  LBF38          ; CONVERT FPA0 TO AN INTEGER
5650 e674 bd e3 7b                     JSR  LBC2F          ; PACK FPA0 TO FPA3
5651 e677 8d 0e                        BSR  LBF3B          ; GET A RANDOM NUMBER: FPA0 < 1.0
5652 e679 8e 00 40                     LDX  #V40           ; POINT (X) TO FPA3
5653 e67c 8d ca                        BSR  LBEFC          ; MULTIPLY (X) BY FPA0
5654 e67e 8e e2 11                     LDX  #LBAC5         ; POINT (X) TO FP VALUE OF 1.0
5655 e681 bd e1 0e                     JSR  LB9C2          ; ADD 1.0 TO FPA0
5656 e684 7e e4 3a           LBF38     JMP  INT            ; CONVERT FPA0 TO AN INTEGER
5657                         * CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.0
5658 e687 9e b1              LBF3B     LDX  RVSEED+1       ; * MOVE VARIABLE
5659 e689 9f 50                        STX  FPA0           ; * RANDOM NUMBER
5660 e68b 9e b3                        LDX  RVSEED+3       ; * SEED TO
5661 e68d 9f 52                        STX  FPA0+2         ; * FPA0
5662 e68f be e6 bc           LBF45     LDX  RSEED          ; = MOVE FIXED
5663 e692 9f 5d                        STX  FPA1           ; = RANDOM NUMBER
5664 e694 be e6 be                     LDX  RSEED+2        ; = SEED TO
5665 e697 9f 5f                        STX  FPA1+2         ; = MANTISSA OF FPA0
5666 e699 bd e2 1c                     JSR  LBAD0          ; MULTIPLY FPA0 X FPA1
5667 e69c dc 8a                        LDD  VAD            ; GET THE TWO LOWEST ORDER PRODUCT BYTES
5668 e69e c3 65 8b                     ADDD #$658B         ; ADD A CONSTANT
5669 e6a1 dd b3                        STD  RVSEED+3       ; SAVE NEW LOW ORDER VARIABLE RANDOM # SEED
5670 e6a3 dd 52                        STD  FPA0+2         ; SAVE NEW LOW ORDER BYTES OF FPA0 MANTISSA
5671 e6a5 dc 88                        LDD  VAB            ; GET 2 MORE LOW ORDER PRODUCT BYTES
5672 e6a7 c9 b0                        ADCB #$B0           ; ADD A CONSTANT
5673 e6a9 89 05                        ADCA #5             ; ADD A CONSTANT
5674 e6ab dd b1                        STD  RVSEED+1       ; SAVE NEW HIGH ORDER VARIABLE RANDOM # SEED
5675 e6ad dd 50                        STD  FPA0           ; SAVE NEW HIGH ORDER FPA0 MANTISSA
5676 e6af 0f 54                        CLR  FP0SGN         ; FORCE FPA0 MANTISSA = POSITIVE
5677 e6b1 86 80                        LDA  #$80           ; * SET FPA0 BIASED EXPONENT
5678 e6b3 97 4f                        STA  FP0EXP         ; * TO 0 1 < FPA0 < 0
5679 e6b5 96 15                        LDA  FPA2+2         ; GET A BYTE FROM FPA2 (MORE RANDOMNESS)
5680 e6b7 97 63                        STA  FPSBYT         ; SAVE AS SUB BYTE
5681 e6b9 7e e1 68                     JMP  LBA1C          ; NORMALIZE FPA0
5682                         *
5683 e6bc 40 e6              RSEED     FDB  $40E6          ; *CONSTANT RANDOM NUMBER GENERATOR SEED
5684 e6be 4d ab                        FDB  $4DAB          ; *
5685                         
5686                         * SIN
5687                         * THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND WILL REPEAT ITSELF EVERY
5688                         * 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ONLY THE FRACTIONAL PART IS
5689                         * RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, THE COEFFICIENTS MUST BE
5690                         * MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.
5691                         
5692                         * SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES BELOW:
5693                         * SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)
5694 e6c0 bd e3 ab           SIN       JSR  LBC5F          ; COPY FPA0 TO FPA1
5695 e6c3 8e e7 05                     LDX  #LBFBD         ; POINT (X) TO 2*PI
5696 e6c6 d6 61                        LDB  FP1SGN         ; *GET MANTISSA SIGN OF FPA1
5697 e6c8 bd e2 d5                     JSR  LBB89          ; *AND DIVIDE FPA0 BY 2*PI
5698 e6cb bd e3 ab                     JSR  LBC5F          ; COPY FPA0 TO FPA1
5699 e6ce 8d b4                        BSR  LBF38          ; CONVERT FPA0 TO AN INTEGER
5700 e6d0 0f 62                        CLR  RESSGN         ; SET RESULT SIGN = POSITIVE
5701 e6d2 96 5c                        LDA  FP1EXP         ; *GET EXPONENT OF FPA1
5702 e6d4 d6 4f                        LDB  FP0EXP         ; *GET EXPONENT OF FPA0
5703 e6d6 bd e1 08                     JSR  LB9BC          ; *SUBTRACT FPA0 FROM FPA1
5704                         * NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUMENT/2*PI
5705 e6d9 8e e7 0a                     LDX  #LBFC2         ; POINT X TO FP (.25)
5706 e6dc bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM .25 (PI/2)
5707 e6df 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN OF FPA0
5708 e6e1 34 02                        PSHS A              ; SAVE IT ON STACK
5709 e6e3 2a 09                        BPL  LBFA6          ; BRANCH IF MANTISSA POSITIVE
5710 e6e5 bd e1 00                     JSR  LB9B4          ; ADD .5 (PI) TO FPA0
5711 e6e8 96 54                        LDA  FP0SGN         ; GET SIGN OF FPA0
5712 e6ea 2b 05                        BMI  LBFA9          ; BRANCH IF NEGATIVE
5713 e6ec 03 0a                        COM  RELFLG         ; COM IF +(3*PI)/2 >= ARGUMENT >+ PI/2 (QUADRANT FLAG)
5714 e6ee bd e6 35           LBFA6     JSR  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0
5715 e6f1 8e e7 0a           LBFA9     LDX  #LBFC2         ; POINT X TO FP (.25)
5716 e6f4 bd e1 0e                     JSR  LB9C2          ; ADD .25 (PI/2) TO FPA0
5717 e6f7 35 02                        PULS A              ; GET OLD MANTISSA SIGN
5718 e6f9 4d                           TSTA                ; * BRANCH IF OLD
5719 e6fa 2a 03                        BPL  LBFB7          ; * SIGN WAS POSITIVE
5720 e6fc bd e6 35                     JSR  LBEE9          ; TOGGLE MANTISSA SIGN
5721 e6ff 8e e7 0f           LBFB7     LDX  #LBFC7         ; POINT X TO TABLE OF COEFFICIENTS
5722 e702 7e e6 3c                     JMP  LBEF0          ; GO CALCULATE POLYNOMIAL VALUE
5723                         
5724 e705 83 49 0f da a2     LBFBD     FCB  $83,$49,$0F,$DA,$A2 ; 6.28318531 (2*PI)
5725 e70a 7f 00 00 00 00     LBFC2     FCB  $7F,$00,$00,$00,$00 ; .25
5726                         
5727                         
5728 e70f 05                 LBFC7     FCB  6-1            ; SIX COEFFICIENTS
5729 e710 84 e6 1a 2d 1b     LBFC8     FCB  $84,$E6,$1A,$2D,$1B ; * -((2*PI)**11)/11!
5730 e715 86 28 07 fb f8     LBFCD     FCB  $86,$28,$07,$FB,$F8 ; * ((2*PI)**9)/9!
5731 e71a 87 99 68 89 01     LBFD2     FCB  $87,$99,$68,$89,$01 ; * -((2*PI)**7)/7!
5732 e71f 87 23 35 df e1     LBFD7     FCB  $87,$23,$35,$DF,$E1 ; * ((2*PI)**5)/5!
5733 e724 86 a5 5d e7 28     LBFDC     FCB  $86,$A5,$5D,$E7,$28 ; * -((2*PI)**3)/3!
5734 e729 83 49 0f da a2     LBFE1     FCB  $83,$49,$0F,$DA,$A2 ; *
5735                         
5736 e72e a1 54 46 8f 13               FCB  $A1,$54,$46,$8F,$13 ; UNUSED GARBAGE BYTES
5737 e733 8f 52 43 89 cd               FCB  $8F,$52,$43,$89,$CD ; UNUSED GARBAGE BYTES
5738                         * EXTENDED BASIC
5739                         
5740                         * COS
5741                         * THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTITY COS(X)=SIN((PI/2)+X)
5742 e738 8e e7 6b           COS       LDX  #L83AB         ; POINT X TO FP CONSTANT (P1/2)
5743 e73b bd e1 0e                     JSR  LB9C2          ; ADD FPA0 TO (X)
5744 e73e 7e e6 c0           L837E     JMP  SIN            ; JUMP TO SIN ROUTINE
5745                         
5746                         * TAN
5747                         * THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTITY TAN(X)=SIN(X)/COS(X)
5748 e741 bd e3 7b           TAN       JSR  LBC2F          ; PACK FPA0 AND MOVE IT TO FPA3
5749 e744 0f 0a                        CLR  RELFLG         ; RESET QUADRANT FLAG
5750 e746 8d f6                        BSR  L837E          ; CALCULATE SIN OF ARGUMENT
5751 e748 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5
5752 e74b bd e3 81                     JSR  LBC35          ; PACK FPA0 AND MOVE IT TO FPA5
5753 e74e 8e 00 40                     LDX  #V40           ; POINT X TO FPA3
5754 e751 bd e3 60                     JSR  LBC14          ; MOVE FPA3 TO FPA0
5755 e754 0f 54                        CLR  FP0SGN         ; FORCE FPA0 MANTISSA TO BE POSITIVE
5756 e756 96 0a                        LDA  RELFLG         ; GET THE QUADRANT FLAG - COS NEGATIVE IN QUADS 2,3
5757 e758 8d 0c                        BSR  L83A6          ; CALCULATE VALUE OF COS(FPA0)
5758 e75a 0d 4f                        TST  FP0EXP         ; CHECK EXPONENT OF FPA0
5759 e75c 10 27 fa 7e                  LBEQ LBA92          ; ''OV' ERROR IF COS(X)=0
5760 e760 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5
5761 e763 7e e2 db           L83A3     JMP  LBB8F          ; DIVIDE (X) BY FPA0 - SIN(X)/COS(X)
5762 e766 34 02              L83A6     PSHS A              ; SAVE SIGN FLAG ON STACK
5763 e768 7e e6 ee                     JMP  LBFA6          ; EXPAND POLYNOMIAL
5764                         
5765 e76b 81 49 0f da a2     L83AB     FCB  $81,$49,$0F,$DA,$A2 ; 1.57079633 (PI/2)
5766                         
5767                         * ATN
5768                         * A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE
5769                         * ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED
5770                         * TO EVALUATE THE EXPRESSION DEPENDING UPON
5771                         * WHETHER OR NOT THE ARGUMENT SQUARED IS > OR < 1.0
5772                         
5773                         * IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .
5774                         * IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5)*5)-. . .)
5775                         
5776 e770 96 54              ATN       LDA  FP0SGN         ; * GET THE SIGN OF THE MANTISSA AND
5777 e772 34 02                        PSHS A              ; * SAVE IT ON THE STACK
5778 e774 2a 02                        BPL  L83B8          ; BRANCH IF POSITIVE MANTISSA
5779 e776 8d 24                        BSR  L83DC          ; CHANGE SIGN OF FPA0
5780 e778 96 4f              L83B8     LDA  FP0EXP         ; * GET EXPONENT OF FPA0 AND
5781 e77a 34 02                        PSHS A              ; * SAVE IT ON THE STACK
5782 e77c 81 81                        CMPA #$81           ; IS FPAO < 1.0?
5783 e77e 25 05                        BLO  L83C5          ; YES
5784 e780 8e e2 11                     LDX  #LBAC5         ; POINT X TO FP CONSTANT 1.0
5785 e783 8d de                        BSR  L83A3          ; GET RECIPROCAL OF FPA0
5786 e785 8e e7 a0           L83C5     LDX  #L83E0         ; POINT (X) TO TAYLOR SERIES COEFFICIENTS
5787 e788 bd e6 3c                     JSR  LBEF0          ; EXPAND POLYNOMIAL
5788 e78b 35 02                        PULS A              ; GET EXPONENT OF ARGUMENT
5789 e78d 81 81                        CMPA #$81           ; WAS ARGUMENT < 1.0?
5790 e78f 25 06                        BLO  L83D7          ; YES
5791 e791 8e e7 6b                     LDX  #L83AB         ; POINT (X) TO FP NUMBER (PI/2)
5792 e794 bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (PI/2)
5793 e797 35 02              L83D7     PULS A              ; * GET SIGN OF INITIAL ARGUMENT MANTISSA
5794 e799 4d                           TSTA                ; * AND SET FLAGS ACCORDING TO IT
5795 e79a 2a 03                        BPL  L83DF          ; RETURN IF ARGUMENT WAS POSITIVE
5796 e79c 7e e6 35           L83DC     JMP  LBEE9          ; CHANGE MANTISSA SIGN OF FPA0
5797 e79f 39                 L83DF     RTS
5798                         *
5799                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR ARCTANGENT
5800 e7a0 0b                 L83E0     FCB  $0B            ; TWELVE COEFFICIENTS
5801 e7a1 76 b3 83 bd d3     L83E1     FCB  $76,$B3,$83,$BD,$D3 ; -6.84793912E-04 1/23
5802 e7a6 79 1e f4 a6 f5     L83E6     FCB  $79,$1E,$F4,$A6,$F5 ; +4.85094216E-03 1/21
5803 e7ab 7b 83 fc b0 10     L83EB     FCB  $7B,$83,$FC,$B0,$10 ; -0.0161117018
5804 e7b0 7c 0c 1f 67 ca     L83F0     FCB  $7C,$0C,$1F,$67,$CA ; 0.0342096381
5805 e7b5 7c de 53 cb c1     L83F5     FCB  $7C,$DE,$53,$CB,$C1 ; -0.0542791328
5806 e7ba 7d 14 64 70 4c     L83FA     FCB  $7D,$14,$64,$70,$4C ; 0.0724571965
5807 e7bf 7d b7 ea 51 7a     L83FF     FCB  $7D,$B7,$EA,$51,$7A ; -0.0898023954
5808 e7c4 7d 63 30 88 7e     L8404     FCB  $7D,$63,$30,$88,$7E ; 0.110932413
5809 e7c9 7e 92 44 99 3a     L8409     FCB  $7E,$92,$44,$99,$3A ; -0.142839808
5810 e7ce 7e 4c cc 91 c7     L840E     FCB  $7E,$4C,$CC,$91,$C7 ; 0.199999121
5811 e7d3 7f aa aa aa 13     L8413     FCB  $7F,$AA,$AA,$AA,$13 ; -0.333333316
5812 e7d8 81 00 00 00 00     L8418     FCB  $81,$00,$00,$00,$00 ; 1
5813                         *
5814                         *** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR LN(X)
5815                         *
5816 e7dd 03                 L841D     FCB  3              ; FOUR COEFFICIENTS
5817 e7de 7f 5e 56 cb 79     L841E     FCB  $7F,$5E,$56,$CB,$79 ; 0.434255942
5818 e7e3 80 13 9b 0b 64     L8423     FCB  $80,$13,$9B,$0B,$64 ; 0.576584541
5819 e7e8 80 76 38 93 16     L8428     FCB  $80,$76,$38,$93,$16 ; 0.961800759
5820 e7ed 82 38 aa 3b 20     L842D     FCB  $82,$38,$AA,$3B,$20 ; 2.88539007
5821                         
5822 e7f2 80 35 04 f3 34     L8432     FCB  $80,$35,$04,$F3,$34 ; 1/SQR(2)
5823                         
5824 e7f7 81 35 04 f3 34     L8437     FCB  $81,$35,$04,$F3,$34 ; SQR(2)
5825                         
5826 e7fc 80 80 00 00 00     L843C     FCB  $80,$80,$00,$00,$00 ; -0.5
5827                         
5828 e801 80 31 72 17 f8     L8441     FCB  $80,$31,$72,$17,$F8 ; LN(2)
5829                         *
5830                         * LOG - NATURAL LOGARITHM (LN)
5831                         
5832                         * THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USING
5833                         * MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*(2**B) (SCIENTIFIC
5834                         * NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE VALUE OF
5835                         * LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WILL EXPAND THIS
5836                         * TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)*LN(2). ALL OF
5837                         * THE TERMS OF THE LATTER EXPRESSION ARE CONSTANTS EXCEPT FOR THE
5838                         * LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLOR SERIES EXPANSION
5839 e806 bd e3 b9           LOG       JSR  LBC6D          ; CHECK STATUS OF FPA0
5840 e809 10 2f f3 c4                  LBLE LB44A          ; 'FC' ERROR IF NEGATIVE OR ZERO
5841 e80d 8e e7 f2                     LDX  #L8432         ; POINT (X) TO FP NUMBER (1/SQR(2))
5842 e810 96 4f                        LDA  FP0EXP         ; *GET EXPONENT OF ARGUMENT
5843 e812 80 80                        SUBA #$80           ; *SUBTRACT OFF THE BIAS AND
5844 e814 34 02                        PSHS A              ; *SAVE IT ON THE STACK
5845 e816 86 80                        LDA  #$80
5846 e818 97 4f                        STA  FP0EXP
5847 e81a bd e1 0e                     JSR  LB9C2          ; ADD FPA0 TO (X)
5848 e81d 8e e7 f7                     LDX  #L8437         ; POINT X TO SQR(2)
5849 e820 bd e2 db                     JSR  LBB8F          ; DIVIDE SQR(2) BY FPA0
5850 e823 8e e2 11                     LDX  #LBAC5         ; POINT X TO FP VALUE OF 1.00
5851 e826 bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (X)
5852                         *         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE X IS ARGUMENT
5853 e829 8e e7 dd                     LDX  #L841D         ; POINT X TO TABLE OF COEFFICIENTS
5854 e82c bd e6 3c                     JSR  LBEF0          ; EXPAND POLYNOMIAL
5855 e82f 8e e7 fc                     LDX  #L843C         ; POINT X TO FP VALUE OF (-.5)
5856 e832 bd e1 0e                     JSR  LB9C2          ; ADD FPA0 TO X
5857 e835 35 04                        PULS B              ; GET EXPONENT OF ARGUMENT BACK (WITHOUT BIAS)
5858 e837 bd e4 e5                     JSR  LBD99          ; ADD ACCB TO FPA0
5859 e83a 8e e8 01                     LDX  #L8441         ; POINT X TO LN(2)
5860 e83d 7e e2 16                     JMP  LBACA          ; MULTIPLY FPA0 * LN(2)
5861                         
5862                         * SQR
5863 e840 bd e3 ab           SQR       JSR  LBC5F          ; MOVE FPA0 TO FPA1
5864 e843 8e e6 0c                     LDX  #LBEC0         ; POINT (X) TO FP NUMBER (.5)
5865 e846 bd e3 60                     JSR  LBC14          ; COPY A PACKED NUMBER FROM (X) TO FPA0
5866                         
5867                         * ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS
5868                         * HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION
5869                         * IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.7182818
5870 e849 27 67              L8489     BEQ  EXP            ; DO A NATURAL EXPONENTIATION IF EXPONENT = 0
5871 e84b 4d                           TSTA                ; *CHECK VALUE BEING EXPONENTIATED
5872 e84c 26 03                        BNE  L8491          ; *AND BRANCH IF IT IS <> 0
5873 e84e 7e e1 86                     JMP  LBA3A          ; FPA0=0 IF RAISING ZERO TO A POWER
5874 e851 8e 00 4a           L8491     LDX  #V4A           ; * PACK FPA0 AND SAVE
5875 e854 bd e3 81                     JSR  LBC35          ; * IT IN FPA5 (ARGUMENT'S EXPONENT)
5876 e857 5f                           CLRB                ; ACCB=DEFAULT RESULT SIGN FLAG; 0=POSITIVE
5877 e858 96 61                        LDA  FP1SGN         ; *CHECK THE SIGN OF ARGUMENT
5878 e85a 2a 10                        BPL  L84AC          ; *BRANCH IF POSITIVE
5879 e85c bd e4 3a                     JSR  INT            ; CONVERT EXPONENT INTO AN INTEGER
5880 e85f 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5 (ORIGINAL EXPONENT)
5881 e862 96 61                        LDA  FP1SGN         ; GET MANTISSA SIGN OF FPA1 (ARGUMENT)
5882 e864 bd e3 ec                     JSR  LBCA0          ; *COMPARE FPA0 TO (X) AND
5883 e867 26 03                        BNE  L84AC          ; *BRANCH IF NOT EQUAL
5884 e869 43                           COMA                ; TOGGLE FPA1 MANTISSA SIGN - FORCE POSITIVE
5885 e86a d6 01                        LDB  CHARAC         ; GET LS BYTE OF INTEGER VALUE OF EXPONENT (RESULT SIGN FLAG)
5886 e86c bd e3 98           L84AC     JSR  LBC4C          ; COPY FPA1 TO FPA0; ACCA = MANTISSA SIGN
5887 e86f 34 04                        PSHS B              ; PUT RESULT SIGN FLAG ON THE STACK
5888 e871 bd e8 06                     JSR  LOG
5889 e874 8e 00 4a                     LDX  #V4A           ; POINT (X) TO FPA5
5890 e877 bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY FPA5
5891 e87a 8d 36                        BSR  EXP            ; CALCULATE E**(FPA0)
5892 e87c 35 02                        PULS A              ; * GET RESULT SIGN FLAG FROM THE STACK
5893 e87e 46                           RORA                ; * AND BRANCH IF NEGATIVE
5894 e87f 10 25 fd b2                  LBCS LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
5895 e883 39                           RTS
5896                         
5897                         * CORRECTION FACTOR FOR EXPONENTIAL FUNCTION
5898 e884 81 38 aa 3b 29     L84C4     FCB  $81,$38,$AA,$3B,$29 ; 1.44269504 ( CF )
5899                         *
5900                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E**X
5901                         *
5902 e889 07                 L84C9     FCB  7              ; EIGHT COEFFICIENTS
5903 e88a 71 34 58 3e 56     L84CA     FCB  $71,$34,$58,$3E,$56 ; 2.14987637E-05: 1/(7!*(CF**7))
5904 e88f 74 16 7e b3 1b     L84CF     FCB  $74,$16,$7E,$B3,$1B ; 1.4352314E-04 : 1/(6!*(CF**6))
5905 e894 77 2f ee e3 85     L84D4     FCB  $77,$2F,$EE,$E3,$85 ; 1.34226348E-03: 1/(5!*(CF**5))
5906 e899 7a 1d 84 1c 2a     L84D9     FCB  $7A,$1D,$84,$1C,$2A ; 9.61401701E-03: 1/(4!*(CF**4))
5907 e89e 7c 63 59 58 0a     L84DE     FCB  $7C,$63,$59,$58,$0A ; 0.0555051269
5908 e8a3 7e 75 fd e7 c6     L84E3     FCB  $7E,$75,$FD,$E7,$C6 ; 0.240226385
5909 e8a8 80 31 72 18 10     L84E8     FCB  $80,$31,$72,$18,$10 ; 0.693147186
5910 e8ad 81 00 00 00 00     L84ED     FCB  $81,$00,$00,$00,$00 ; 1
5911                         *
5912                         * EXP ( E**X)
5913                         * THE EXPONENTIAL FUNCTION IS EVALUATED BY FIRST MULTIPLYING THE
5914                         * ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS DONE, AN
5915                         * ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFLOW) FOR A
5916                         * NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A POSITIVE
5917                         * ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED TO REFLECT
5918                         * THE CF MULTIPLICATION AT THE START OF THE EVALUATION PROCESS.
5919                         
5920 e8b2 8e e8 84           EXP       LDX  #L84C4         ; POINT X TO THE CORRECTION FACTOR
5921 e8b5 bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY (X)
5922 e8b8 bd e3 7b                     JSR  LBC2F          ; PACK FPA0 AND STORE IT IN FPA3
5923 e8bb 96 4f                        LDA  FP0EXP         ; *GET EXPONENT OF FPA0 AND
5924 e8bd 81 88                        CMPA #$88           ; *COMPARE TO THE MAXIMUM VALUE
5925 e8bf 25 03                        BLO  L8504          ; BRANCH IF FPA0 < 128
5926 e8c1 7e e2 a8           L8501     JMP  LBB5C          ; SET FPA0 = 0 OR 'OV' ERROR
5927 e8c4 bd e4 3a           L8504     JSR  INT            ; CONVERT FPA0 TO INTEGER
5928 e8c7 96 01                        LDA  CHARAC         ; GET LS BYTE OF INTEGER
5929 e8c9 8b 81                        ADDA #$81           ; * WAS THE ARGUMENT =127, IF SO
5930 e8cb 27 f4                        BEQ  L8501          ; * THEN 'OV' ERROR; THIS WILL ALSO ADD THE $80 BIAS
5931                         *              ; * REQUIRED WHEN THE NEW EXPONENT IS CALCULATED BELOW
5932 e8cd 4a                           DECA                ; DECREMENT ONE FROM THE EXPONENT, BECAUSE $81, NOT $80 WAS USED ABOVE
5933 e8ce 34 02                        PSHS A              ; SAVE EXPONENT OF INTEGER PORTION ON STACK
5934 e8d0 8e 00 40                     LDX  #V40           ; POINT (X) TO FPA3
5935 e8d3 bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (X) - GET FRACTIONAL PART OF ARGUMENT
5936 e8d6 8e e8 89                     LDX  #L84C9         ; POINT X TO COEFFICIENTS
5937 e8d9 bd e6 4b                     JSR  LBEFF          ; EVALUATE POLYNOMIAL FOR FRACTIONAL PART
5938 e8dc 0f 62                        CLR  RESSGN         ; FORCE THE MANTISSA TO BE POSITIVE
5939 e8de 35 02                        PULS A              ; GET INTEGER EXPONENT FROM STACK
5940 e8e0 bd e2 94                     JSR  LBB48          ; * CALCULATE EXPONENT OF NEW FPA0 BY ADDING THE EXPONENTS OF THE
5941                         *              ; * INTEGER AND FRACTIONAL PARTS
5942 e8e3 39                           RTS
5943                         
5944                         * FIX
5945 e8e4 bd e3 b9           FIX       JSR  LBC6D          ; CHECK STATUS OF FPA0
5946 e8e7 2b 03                        BMI  L852C          ; BRANCH IF FPA0 = NEGATIVE
5947 e8e9 7e e4 3a           L8529     JMP  INT            ; CONVERT FPA0 TO INTEGER
5948 e8ec 03 54              L852C     COM  FP0SGN         ; TOGGLE SIGN OF FPA0 MANTISSA
5949 e8ee 8d f9                        BSR  L8529          ; CONVERT FPA0 TO INTEGER
5950 e8f0 7e e6 35                     JMP  LBEE9          ; TOGGLE SIGN OF FPA0
5951                         
5952                         * EDIT
5953 e8f3 bd ed 21           EDIT      JSR  L89AE          ; GET LINE NUMBER FROM BASIC
5954 e8f6 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF THE STACK
5955 e8f8 86 01              L8538     LDA  #$01           ; 'LIST' FLAG
5956 e8fa 97 98                        STA  VD8            ; SET FLAG TO LIST LINE
5957 e8fc bd d4 a5                     JSR  LAD01          ; GO FIND THE LINE NUMBER IN PROGRAM
5958 e8ff 10 25 ed 7f                  LBCS LAED2          ; ERROR #7 'UNDEFINED LINE #'
5959 e903 bd df 3e                     JSR  LB7C2          ; GO UNCRUNCH LINE INTO BUFFER AT LINBUF+1
5960 e906 1f 20                        TFR  Y,D            ; PUT ABSOLUTE ADDRESS OF END OF LINE TO ACCD
5961 e908 83 00 f5                     SUBD #LINBUF+2      ; SUBTRACT OUT THE START OF LINE
5962 e90b d7 97                        STB  VD7            ; SAVE LENGTH OF LINE
5963 e90d dc 2b              L854D     LDD  BINVAL         ; GET THE HEX VALUE OF LINE NUMBER
5964 e90f bd e5 18                     JSR  LBDCC          ; LIST THE LINE NUMBER ON THE SCREEN
5965 e912 bd e0 f8                     JSR  LB9AC          ; PRINT A SPACE
5966 e915 8e 00 f4                     LDX  #LINBUF+1      ; POINT X TO BUFFER
5967 e918 d6 98                        LDB  VD8            ; * CHECK TO SEE IF LINE IS TO BE
5968 e91a 26 25                        BNE  L8581          ; * LISTED TO SCREEN - BRANCH IF IT IS
5969 e91c 5f                 L855C     CLRB                ; RESET DIGIT ACCUMULATOR - DEFAULT VALUE
5970 e91d bd ea 47           L855D     JSR  L8687          ; GET KEY STROKE
5971 e920 bd f1 ec                     JSR  L90AA          ; SET CARRY IF NOT NUMERIC
5972 e923 25 0b                        BLO  L8570          ; BRANCH IF NOT NUMERIC
5973 e925 80 30                        SUBA #'0            ; MASK OFF ASCII
5974 e927 34 02                        PSHS A              ; SAVE IT ON STACK
5975 e929 86 0a                        LDA  #10            ; NUMBER BEING CONVERTED IS BASE 10
5976 e92b 3d                           MUL                 ; MULTIPLY ACCUMULATED VALUE BY BASE (10)
5977 e92c eb e0                        ADDB ,S+            ; ADD DIGIT TO ACCUMULATED VALUE
5978 e92e 20 ed                        BRA  L855D          ; CHECK FOR ANOTHER DIGIT
5979 e930 c0 01              L8570     SUBB #$01           ; * REPEAT PARAMETER IN ACCB; IF IT
5980 e932 c9 01                        ADCB #$01           ; *IS 0, THEN MAKE IT '1'
5981 e934 81 41                        CMPA #'A            ; ABORT?
5982 e936 26 05                        BNE  L857D          ; NO
5983 e938 bd e0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
5984 e93b 20 bb                        BRA  L8538          ; RESTART EDIT PROCESS - CANCEL ALL CHANGES
5985 e93d 81 4c              L857D     CMPA #'L            ; LIST?
5986 e93f 26 0b                        BNE  L858C          ; NO
5987 e941 8d 31              L8581     BSR  L85B4          ; LIST THE LINE
5988 e943 0f 98                        CLR  VD8            ; RESET THE LIST FLAG TO 'NO LIST'
5989 e945 bd e0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN
5990 e948 20 c3                        BRA  L854D          ; GO INTERPRET ANOTHER EDIT COMMAND
5991 e94a 32 62              L858A     LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF THE STACK
5992 e94c 81 0d              L858C     CMPA #CR            ; ENTER KEY?
5993 e94e 26 0d                        BNE  L859D          ; NO
5994 e950 8d 22                        BSR  L85B4          ; ECHO THE LINE TO THE SCREEN
5995 e952 bd e0 a8           L8592     JSR  LB958          ; PRINT CARRIAGE RETURN
5996 e955 8e 00 f4                     LDX  #LINBUF+1      ; * RESET BASIC'S INPUT POINTER
5997 e958 9f 83                        STX  CHARAD         ; * TO THE LINE INPUT BUFFER
5998 e95a 7e d4 4e                     JMP  LACA8          ; GO PUT LINE BACK IN PROGRAM
5999 e95d 81 45              L859D     CMPA #'E            ; EXIT?
6000 e95f 27 f1                        BEQ  L8592          ; YES - SAME AS ENTER EXCEPT NO ECHO
6001 e961 81 51                        CMPA #'Q            ; QUIT?
6002 e963 26 06                        BNE  L85AB          ; NO
6003 e965 bd e0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
6004 e968 7e d4 25                     JMP  LAC73          ; GO TO COMMAND LEVEL - MAKE NO CHANGES
6005 e96b 8d 02              L85AB     BSR  L85AF          ; INTERPRET THE REMAINING COMMANDS AS SUBROUTINES
6006 e96d 20 ad                        BRA  L855C          ; GO INTERPRET ANOTHER EDIT COMMAND
6007 e96f 81 20              L85AF     CMPA #SPACE         ; SPACE BAR?
6008 e971 26 10                        BNE  L85C3          ; NO
6009 e973 8c                 L85B3     FCB  SKP2           ; SKIP TWO BYTES
6010                         * DISPLAY THE NEXT ACCB BYTES OF THE LINE IN THE BUFFER TO THE SCREEN
6011                         *
6012 e974 c6 f9              L85B4     LDB  #LBUFMX-1      ; 250 BYTES MAX IN BUFFER
6013 e976 a6 84              L85B6     LDA  ,X             ; GET A CHARACTER FROM BUFFER
6014 e978 27 08                        BEQ  L85C2          ; EXIT IF IT'S A 0
6015 e97a bd d0 17                     JSR  PUTCHR         ; SEND CHAR TO CONSOLE OUT
6016 e97d 30 01                        LEAX $01,X          ; MOVE POINTER UP ONE
6017 e97f 5a                           DECB                ; DECREMENT CHARACTER COUNTER
6018 e980 26 f4                        BNE  L85B6          ; LOOP IF NOT DONE
6019 e982 39                 L85C2     RTS
6020 e983 81 44              L85C3     CMPA #'D            ; DELETE?
6021 e985 26 48                        BNE  L860F          ; NO
6022 e987 6d 84              L85C7     TST  ,X             ; * CHECK FOR END OF LINE
6023 e989 27 f7                        BEQ  L85C2          ; * AND BRANCH IF SO
6024 e98b 8d 04                        BSR  L85D1          ; REMOVE A CHARACTER
6025 e98d 5a                           DECB                ; DECREMENT REPEAT PARAMETER
6026 e98e 26 f7                        BNE  L85C7          ; BRANCH IF NOT DONE
6027 e990 39                           RTS
6028                         * REMOVE ONE CHARACTER FROM BUFFER
6029 e991 0a 97              L85D1     DEC  VD7            ; DECREMENT LENGTH OF BUFFER
6030 e993 31 1f                        LEAY -1,X           ; POINT Y TO ONE BEFORE CURRENT BUFFER POINTER
6031 e995 31 21              L85D5     LEAY $01,Y          ; INCREMENT TEMPORARY BUFFER POINTER
6032 e997 a6 21                        LDA  $01,Y          ; GET NEXT CHARACTER
6033 e999 a7 a4                        STA  ,Y             ; PUT IT IN CURRENT POSITION
6034 e99b 26 f8                        BNE  L85D5          ; BRANCH IF NOT END OF LINE
6035 e99d 39                           RTS
6036 e99e 81 49              L85DE     CMPA #'I            ;  INSERT?
6037 e9a0 27 13                        BEQ  L85F5          ; YES
6038 e9a2 81 58                        CMPA #'X            ; EXTEND?
6039 e9a4 27 0d                        BEQ  L85F3          ; YES
6040 e9a6 81 48                        CMPA #'H            ; HACK?
6041 e9a8 26 5c                        BNE  L8646          ; NO
6042 e9aa 6f 84                        CLR  ,X             ; TURN CURRENT BUFFER POINTER INTO END OF LINE FLAG
6043 e9ac 1f 10                        TFR  X,D            ; PUT CURRENT BUFFER POINTER IN ACCD
6044 e9ae 83 00 f5                     SUBD #LINBUF+2      ; SUBTRACT INITIAL POINTER POSITION
6045 e9b1 d7 97                        STB  VD7            ; SAVE NEW BUFFER LENGTH
6046 e9b3 8d bf              L85F3     BSR  L85B4          ; DISPLAY THE LINE ON THE SCREEN
6047 e9b5 bd ea 47           L85F5     JSR  L8687          ; GET A KEYSTROKE
6048 e9b8 81 0d                        CMPA #CR            ; ENTER KEY?
6049 e9ba 27 8e                        BEQ  L858A          ; YES - INTERPRET ANOTHER COMMAND - PRINT LINE
6050 e9bc 81 1b                        CMPA #ESC           ; ESCAPE?
6051 e9be 27 25                        BEQ  L8625          ; YES - RETURN TO COMMAND LEVEL - DON'T PRINT LINE
6052 e9c0 81 08                        CMPA #BS            ; BACK SPACE?
6053 e9c2 26 22                        BNE  L8626          ; NO
6054 e9c4 8c 00 f4                     CMPX #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
6055 e9c7 27 ec                        BEQ  L85F5          ; DO NOT ALLOW BS IF AT START
6056 e9c9 8d 45                        BSR  L8650          ; MOVE POINTER BACK ONE, BS TO SCREEN
6057 e9cb 8d c4                        BSR  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
6058 e9cd 20 e6                        BRA  L85F5          ; GET INSERT SUB COMMAND
6059 e9cf 81 43              L860F     CMPA #'C            ; CHANGE?
6060 e9d1 26 cb                        BNE  L85DE          ; NO
6061 e9d3 6d 84              L8613     TST  ,X             ; CHECK CURRENT BUFFER CHARACTER
6062 e9d5 27 0e                        BEQ  L8625          ; BRANCH IF END OF LINE
6063 e9d7 bd ea 47                     JSR  L8687          ; GET A KEYSTROKE
6064 e9da 25 02                        BLO  L861E          ; BRANCH IF LEGITIMATE KEY
6065 e9dc 20 f5                        BRA  L8613          ; TRY AGAIN IF ILLEGAL KEY
6066 e9de a7 80              L861E     STA  ,X+            ; INSERT NEW CHARACTER INTO BUFFER
6067 e9e0 8d 37                        BSR  L8659          ; SEND NEW CHARACTER TO SCREEN
6068 e9e2 5a                           DECB                ; DECREMENT REPEAT PARAMETER
6069 e9e3 26 ee                        BNE  L8613          ; BRANCH IF NOT DONE
6070 e9e5 39                 L8625     RTS
6071 e9e6 d6 97              L8626     LDB  VD7            ; GET LENGTH OF LINE
6072 e9e8 c1 f9                        CMPB #LBUFMX-1      ; COMPARE TO MAXIMUM LENGTH
6073 e9ea 26 02                        BNE  L862E          ; BRANCH IF NOT AT MAXIMUM
6074 e9ec 20 c7                        BRA  L85F5          ; IGNORE INPUT IF LINE AT MAXIMUM LENGTH
6075 e9ee 34 10              L862E     PSHS X              ; SAVE CURRENT BUFFER POINTER
6076 e9f0 6d 80              L8630     TST  ,X+            ; * SCAN THE LINE UNTIL END OF
6077 e9f2 26 fc                        BNE  L8630          ; * LINE (0) IS FOUND
6078 e9f4 e6 82              L8634     LDB  ,-X            ; DECR TEMP LINE POINTER AND GET A CHARACTER
6079 e9f6 e7 01                        STB  $01,X          ; PUT CHARACTER BACK DOWN ONE SPOT
6080 e9f8 ac e4                        CMPX ,S             ; HAVE WE REACHED STARTING POINT?
6081 e9fa 26 f8                        BNE  L8634          ; NO - KEEP GOING
6082 e9fc 32 62                        LEAS $02,S          ; PURGE BUFFER POINTER FROM STACK
6083 e9fe a7 80                        STA  ,X+            ; INSERT NEW CHARACTER INTO THE LINE
6084 ea00 8d 17                        BSR  L8659          ; SEND A CHARACTER TO CONSOLE OUT
6085 ea02 0c 97                        INC  VD7            ; ADD ONE TO BUFFER LENGTH
6086 ea04 20 af                        BRA  L85F5          ; GET INSERT SUB COMMAND
6087 ea06 81 08              L8646     CMPA #BS            ; BACKSPACE?
6088 ea08 26 12                        BNE  L865C          ; NO
6089 ea0a 8d 04              L864A     BSR  L8650          ; MOVE POINTER BACK 1, SEND BS TO SCREEN
6090 ea0c 5a                           DECB                ; DECREMENT REPEAT PARAMETER
6091 ea0d 26 fb                        BNE  L864A          ; LOOP UNTIL DONE
6092 ea0f 39                           RTS
6093 ea10 8c 00 f4           L8650     CMPX #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
6094 ea13 27 d0                        BEQ  L8625          ; DO NOT ALLOW BS IF AT START
6095 ea15 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
6096 ea17 86 08                        LDA  #BS            ; BACK SPACE
6097 ea19 7e d0 17           L8659     JMP  PUTCHR         ; SEND TO CONSOLE OUT
6098 ea1c 81 4b              L865C     CMPA #'K            ; KILL?
6099 ea1e 27 05                        BEQ  L8665          ; YES
6100 ea20 80 53                        SUBA #'S            ; SEARCH?
6101 ea22 27 01                        BEQ  L8665          ; YES
6102 ea24 39                           RTS
6103 ea25 34 02              L8665     PSHS A              ; SAVE KILL/SEARCH FLAG ON STACK
6104 ea27 8d 1e                        BSR  L8687          ; * GET A KEYSTROKE (TARGET CHARACTER)
6105 ea29 34 02                        PSHS A              ; * AND SAVE IT ON STACK
6106 ea2b a6 84              L866B     LDA  ,X             ; GET CURRENT BUFFER CHARACTER
6107 ea2d 27 16                        BEQ  L8685          ; AND RETURN IF END OF LINE
6108 ea2f 6d 61                        TST  $01,S          ; CHECK KILL/SEARCH FLAG
6109 ea31 26 06                        BNE  L8679          ; BRANCH IF KILL
6110 ea33 8d e4                        BSR  L8659          ; SEND A CHARACTER TO CONSOLE OUT
6111 ea35 30 01                        LEAX $01,X          ; INCREMENT BUFFER POINTER
6112 ea37 20 03                        BRA  L867C          ; CHECK NEXT INPUT CHARACTER
6113 ea39 bd e9 91           L8679     JSR  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
6114 ea3c a6 84              L867C     LDA  ,X             ; GET CURRENT INPUT CHARACTER
6115 ea3e a1 e4                        CMPA ,S             ; COMPARE TO TARGET CHARACTER
6116 ea40 26 e9                        BNE  L866B          ; BRANCH IF NO MATCH
6117 ea42 5a                           DECB                ; DECREMENT REPEAT PARAMETER
6118 ea43 26 e6                        BNE  L866B          ; BRANCH IF NOT DONE
6119 ea45 35 a0              L8685     PULS Y,PC           ; THE Y PULL WILL CLEAN UP THE STACK FOR THE 2 PSHS A
6120                         *
6121                         * GET A KEYSTRKE
6122 ea47 bd d0 03           L8687     JSR  LA171          ; CALL CONSOLE IN : DEV NBR=SCREEN
6123 ea4a 81 7f                        CMPA #$7F           ; GRAPHIC CHARACTER?
6124 ea4c 24 f9                        BCC  L8687          ; YES - GET ANOTHER CHAR
6125 ea4e 81 5f                        CMPA #$5F           ; SHIFT UP ARROW (QUIT INSERT)
6126 ea50 26 02                        BNE  L8694          ; NO
6127 ea52 86 1b                        LDA  #ESC           ; REPLACE W/ESCAPE CODE
6128 ea54 81 0d              L8694     CMPA #CR            ; ENTER KEY
6129 ea56 27 0e                        BEQ  L86A6          ; YES
6130 ea58 81 1b                        CMPA #ESC           ; ESCAPE?
6131 ea5a 27 0a                        BEQ  L86A6          ; YES
6132 ea5c 81 08                        CMPA #BS            ; BACKSPACE?
6133 ea5e 27 06                        BEQ  L86A6          ; YES
6134 ea60 81 20                        CMPA #SPACE         ; SPACE
6135 ea62 25 e3                        BLO  L8687          ; GET ANOTHER CHAR IF CONTROL CHAR
6136 ea64 1a 01                        ORCC #$01           ; SET CARRY
6137 ea66 39                 L86A6     RTS
6138                         
6139                         * TRON
6140 ea67 86                 TRON      FCB  SKP1LD         ; SKIP ONE BYTE AND LDA #$4F
6141                         
6142                         * TROFF
6143 ea68 4f                 TROFF     CLRA                ; TROFF FLAG
6144 ea69 97 8c                        STA  TRCFLG         ; TRON/TROFF FLAG:0=TROFF, <> 0=TRON
6145 ea6b 39                           RTS
6146                         
6147                         * POS
6148                         
6149 ea6c 86 00              POS       LDA  #0             ; GET DEVICE NUMBER
6150 ea6e d6 79                        LDB  LPTPOS         ; GET PRINT POSITION
6151 ea70 1d                 LA5E8     SEX                 ; CONVERT ACCB TO 2 DIGIT SIGNED INTEGER
6152 ea71 7e dc 7b                     JMP  GIVABF         ; CONVERT ACCD TO FLOATING POINT
6153                         
6154                         
6155                         * VARPTR
6156 ea74 bd d9 f6           VARPT     JSR  LB26A          ; SYNTAX CHECK FOR '('
6157 ea77 dc 1f                        LDD  ARYEND         ; GET ADDR OF END OF ARRAYS
6158 ea79 34 06                        PSHS B,A            ; SAVE IT ON STACK
6159 ea7b bd da de                     JSR  LB357          ; GET VARIABLE DESCRIPTOR
6160 ea7e bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6161 ea81 35 06                        PULS A,B            ; GET END OF ARRAYS ADDR BACK
6162 ea83 1e 10                        EXG  X,D            ; SWAP END OF ARRAYS AND VARIABLE DESCRIPTOR
6163 ea85 9c 1f                        CMPX ARYEND         ; COMPARE TO NEW END OF ARRAYS
6164 ea87 26 51                        BNE  L8724          ; 'FC' ERROR IF VARIABLE WAS NOT DEFINED PRIOR TO CALLING VARPTR
6165 ea89 7e dc 7b                     JMP  GIVABF         ; CONVERT VARIABLE DESCRIPTOR INTO A FP NUMBER
6166                         
6167                         * MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT
6168 ea8c 9d 7c              L86D6     JSR  GETNCH         ; GET INPUT CHAR FROM BASIC
6169 ea8e bd d9 f6                     JSR  LB26A          ; SYNTAX CHECK FOR '('
6170 ea91 bd da de                     JSR  LB357          ; * GET VARIABLE DESCRIPTOR ADDRESS AND
6171 ea94 34 10                        PSHS X              ; * SAVE IT ON THE STACK
6172 ea96 ec 02                        LDD  $02,X          ; POINT ACCD TO START OF OLDSTRING
6173 ea98 10 93 21                     CMPD FRETOP         ; COMPARE TO START OF CLEARED SPACE
6174 ea9b 23 04                        BLS  L86EB          ; BRANCH IF <=
6175 ea9d 93 27                        SUBD MEMSIZ         ; SUBTRACT OUT TOP OF CLEARED SPACE
6176 ea9f 23 12                        BLS  L86FD          ; BRANCH IF STRING IN STRING SPACE
6177 eaa1 e6 84              L86EB     LDB  ,X             ; GET LENGTH OF OLDSTRING
6178 eaa3 bd dc f4                     JSR  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
6179 eaa6 34 10                        PSHS X              ; SAVE RESERVED SPACE STRING ADDRESS ON STACK
6180 eaa8 ae 62                        LDX  $02,S          ; POINT X TO OLDSTRING DESCRIPTOR
6181 eaaa bd dd ca                     JSR  LB643          ; MOVE OLDSTRING INTO STRING SPACE
6182 eaad 35 50                        PULS X,U            ; * GET OLDSTRING DESCRIPTOR ADDRESS AND RESERVED STRING
6183 eaaf af 42                        STX  $02,U          ; * ADDRESS AND SAVE RESERVED ADDRESS AS OLDSTRING ADDRESS
6184 eab1 34 40                        PSHS U              ; SAVE OLDSTRING DESCRIPTOR ADDRESS
6185 eab3 bd de bf           L86FD     JSR  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
6186 eab6 34 04                        PSHS B              ; SAVE POSITION PARAMETER ON STACK
6187 eab8 5d                           TSTB                ; * CHECK POSITION PARAMETER AND BRANCH
6188 eab9 27 1f                        BEQ  L8724          ; * IF START OF STRING
6189 eabb c6 ff                        LDB  #$FF           ; DEFAULT REPLACEMENT LENGTH = $FF
6190 eabd 81 29                        CMPA #')            ; * CHECK FOR END OF MID$ STATEMENT AND
6191 eabf 27 03                        BEQ  L870E          ; * BRANCH IF AT END OF STATEMENT
6192 eac1 bd de bf                     JSR  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
6193 eac4 34 04              L870E     PSHS B              ; SAVE LENGTH PARAMETER ON STACK
6194 eac6 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6195 eac9 c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR =
6196 eacb bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR '='
6197 eace 8d 2e                        BSR  L8748          ; EVALUATE REPLACEMENT STRING
6198 ead0 1f 13                        TFR  X,U            ; SAVE REPLACEMENT STRING ADDRESS IN U
6199 ead2 ae 62                        LDX  $02,S          ; POINT X TO OLOSTRING DESCRIPTOR ADDRESS
6200 ead4 a6 84                        LDA  ,X             ; GET LENGTH OF OLDSTRING
6201 ead6 a0 61                        SUBA $01,S          ; SUBTRACT POSITION PARAMETER
6202 ead8 24 03                        BCC  L8727          ; INSERT REPLACEMENT STRING INTO OLDSTRING
6203 eada 7e db d1           L8724     JMP  LB44A          ; 'FC' ERROR IF POSITION > LENGTH OF OLDSTRING
6204 eadd 4c                 L8727     INCA                ; * NOW ACCA = NUMBER OF CHARACTERS TO THE RIGHT
6205                         *                             ; * (INCLUSIVE) OF THE POSITION PARAMETER
6206 eade a1 e4                        CMPA ,S
6207 eae0 24 02                        BCC  L872E          ; BRANCH IF NEW STRING WILL FIT IN OLDSTRING
6208 eae2 a7 e4                        STA  ,S             ; IF NOT, USE AS MUCH OF LENGTH PARAMETER AS WILL FIT
6209 eae4 a6 61              L872E     LDA  $01,S          ; GET POSITION PARAMETER
6210 eae6 1e 89                        EXG  A,B            ; ACCA=LENGTH OF REPL STRING, ACCB=POSITION PARAMETER
6211 eae8 ae 02                        LDX  $02,X          ; POINT X TO OLDSTRING ADDRESS
6212 eaea 5a                           DECB                ; * BASIC'S POSITION PARAMETER STARTS AT 1; THIS ROUTINE
6213                         *                             ; * WANTS IT TO START AT ZERO
6214 eaeb 3a                           ABX                 ; POINT X TO POSITION IN OLDSTRING WHERE THE REPLACEMENT WILL GO
6215 eaec 4d                           TSTA                ; * IF THE LENGTH OF THE REPLACEMENT STRING IS ZERO
6216 eaed 27 0d                        BEQ  L8746          ; * THEN RETURN
6217 eaef a1 e4                        CMPA ,S
6218 eaf1 23 02                        BLS  L873F          ; ADJUSTED LENGTH PARAMETER, THEN BRANCH
6219 eaf3 a6 e4                        LDA  ,S             ; OTHERWISE USE AS MUCH ROOM AS IS AVAILABLE
6220 eaf5 1f 89              L873F     TFR  A,B            ; SAVE NUMBER OF BYTES TO MOVE IN ACCB
6221 eaf7 1e 31                        EXG  U,X            ; SWAP SOURCE AND DESTINATION POINTERS
6222 eaf9 bd d1 b1                     JSR  LA59A          ; MOVE (B) BYTES FROM (X) TO (U)
6223 eafc 35 96              L8746     PULS A,B,X,PC
6224 eafe bd d8 e2           L8748     JSR  LB156          ; EVALUATE EXPRESSION
6225 eb01 7e dd db                     JMP  LB654          ; *'TM' ERROR IF NUMERIC; RETURN WITH X POINTING
6226                         *                             ; *TO STRING, ACCB = LENGTH
6227                         
6228                         * STRING
6229 eb04 bd d9 f6           STRING    JSR  LB26A          ; SYNTAX CHECK FOR '('
6230 eb07 bd de 92                     JSR  LB70B          ; EVALUATE EXPRESSION; ERROR IF > 255
6231 eb0a 34 04                        PSHS B              ; SAVE LENGTH OF STRING
6232 eb0c bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6233 eb0f bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
6234 eb12 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6235 eb15 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
6236 eb17 26 05                        BNE  L8768          ; BRANCH IF STRING
6237 eb19 bd de 95                     JSR  LB70E          ; CONVERT FPA0 INTO AN INTEGER IN ACCB
6238 eb1c 20 03                        BRA  L876B          ; SAVE THE STRING IN STRING SPACE
6239 eb1e bd de 2b           L8768     JSR  LB6A4          ; GET FIRST BYTE OF STRING
6240 eb21 34 04              L876B     PSHS B              ; SAVE FIRST BYTE OF EXPRESSION
6241 eb23 e6 61                        LDB  $01,S          ; GET LENGTH OF STRING
6242 eb25 bd dc 96                     JSR  LB50F          ; RESERVE ACCB BYTES IN STRING SPACE
6243 eb28 35 06                        PULS A,B            ; GET LENGTH OF STRING AND CHARACTER
6244 eb2a 27 05                        BEQ  L877B          ; BRANCH IF NULL STRING
6245 eb2c a7 80              L8776     STA  ,X+            ; SAVE A CHARACTER IN STRING SPACE
6246 eb2e 5a                           DECB                ; DECREMENT LENGTH
6247 eb2f 26 fb                        BNE  L8776          ; BRANCH IF NOT DONE
6248 eb31 7e de 22           L877B     JMP  LB69B          ; PUT STRING DESCRIPTOR ONTO STRING STACK
6249                         
6250                         * INSTR
6251 eb34 bd d9 f6           INSTR     JSR  LB26A          ; SYNTAX CHECK FOR '('
6252 eb37 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
6253 eb3a c6 01                        LDB  #$01           ; DEFAULT POSITION = 1 (SEARCH START)
6254 eb3c 34 04                        PSHS B              ; SAVE START
6255 eb3e 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
6256 eb40 26 10                        BNE  L879C          ; BRANCH IF STRING
6257 eb42 bd de 95                     JSR  LB70E          ; CONVERT FPA0 TO INTEGER IN ACCB
6258 eb45 e7 e4                        STB  ,S             ; SAVE START SEARCH VALUE
6259 eb47 27 91                        BEQ  L8724          ; BRANCH IF START SEARCH AT ZERO
6260 eb49 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6261 eb4c bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION - SEARCH STRING
6262 eb4f bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC
6263 eb52 9e 52              L879C     LDX  FPA0+2         ; SEARCH STRING DESCRIPTOR ADDRESS
6264 eb54 34 10                        PSHS X              ; SAVE ON THE STACK
6265 eb56 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6266 eb59 bd ea fe                     JSR  L8748          ; EVALUATE TARGET STRING EXPRESSION
6267 eb5c 34 14                        PSHS X,B            ; SAVE ADDRESS AND LENGTH ON STACK
6268 eb5e bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6269 eb61 ae 63                        LDX  $03,S          ; * LOAD X WITH SEARCH STRING DESCRIPTOR ADDRESS
6270 eb63 bd dd e0                     JSR  LB659          ; * AND GET THE LENGTH ANDADDRESS OF SEARCH STRING
6271 eb66 34 04                        PSHS B              ; SAVE LENGTH ON STACK
6272                         *
6273                         * AT THIS POINT THE STACK HAS THE FOLLOWING INFORMATION
6274                         * ON IT: 0,S-SEARCH LENGTH; 1,S-TARGET LENGTH; 2 3,S-TARGET
6275                         * ADDRESS; 4 5,S-SEARCH DESCRIPTOR ADDRESS; 6,S-SEARCH POSITION
6276 eb68 e1 66                        CMPB $06,S          ; COMPARE LENGTH OF SEARCH STRING TO START
6277 eb6a 25 23                        BLO  L87D9          ; POSITION; RETURN 0 IF LENGTH < START
6278 eb6c a6 61                        LDA  $01,S          ; GET LENGTH OF TARGET STRING
6279 eb6e 27 1c                        BEQ  L87D6          ; BRANCH IF TARGET STRING = NULL
6280 eb70 e6 66                        LDB  $06,S          ; GET START POSITION
6281 eb72 5a                           DECB                ; MOVE BACK ONE
6282 eb73 3a                           ABX                 ; POINT X TO POSITION IN SEARCH STRING WHERE SEARCHING WILL START
6283 eb74 31 84              L87BE     LEAY ,X             ; POINT Y TO SEARCH POSITION
6284 eb76 ee 62                        LDU  $02,S          ; POINT U TO START OF TARGET
6285 eb78 e6 61                        LDB  $01,S          ; LOAD ACCB WITH LENGTH OF TARGET
6286 eb7a a6 e4                        LDA  ,S             ; LOAD ACCA WITH LENGTH OF SEARCH
6287 eb7c a0 66                        SUBA $06,S          ; SUBTRACT SEARCH POSITION FROM SEARCH LENGTH
6288 eb7e 4c                           INCA                ; ADD ONE
6289 eb7f a1 61                        CMPA $01,S          ; COMPARE TO TARGET LENGTH
6290 eb81 25 0c                        BLO  L87D9          ; RETURN 0 IF TARGET LENGTH > WHAT'S LEFT OF SEARCH STRING
6291 eb83 a6 80              L87CD     LDA  ,X+            ; GET A CHARACTER FROM SEARCH STRING
6292 eb85 a1 c0                        CMPA ,U+            ; COMPARE IT TO TARGET STRING
6293 eb87 26 0c                        BNE  L87DF          ; BRANCH IF NO MATCH
6294 eb89 5a                           DECB                ; DECREMENT TARGET LENGTH
6295 eb8a 26 f7                        BNE  L87CD          ; CHECK ANOTHER CHARACTER
6296 eb8c e6 66              L87D6     LDB  $06,S          ; GET MATCH POSITION
6297 eb8e 21                 L87D8     FCB  SKP1           ; SKIP NEXT BYTE
6298 eb8f 5f                 L87D9     CLRB                ; MATCH ADDRESS = 0
6299 eb90 32 67                        LEAS $07,S          ; CLEAN UP THE STACK
6300 eb92 7e dc 7a                     JMP  LB4F3          ; CONVERT ACCB TO FP NUMBER
6301 eb95 6c 66              L87DF     INC  $06,S          ; INCREMENT SEARCH POSITION
6302 eb97 30 21                        LEAX $01,Y          ; MOVE X TO NEXT SEARCH POSITION
6303 eb99 20 d9                        BRA  L87BE          ; KEEP LOOKING FOR A MATCH
6304                         
6305                         * EXTENDED BASIC RVEC19 HOOK CODE
6306 eb9b 81 26              XVEC19    CMPA #'&            ; *
6307 eb9d 26 5c                        BNE  L8845          ; * RETURN IF NOT HEX OR OCTAL VARIABLE
6308 eb9f 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS FROM STACK
6309                         * PROCESS A VARIABLE PRECEEDED BY A '&' (&H,&O)
6310 eba1 0f 52              L87EB     CLR  FPA0+2         ; * CLEAR BOTTOM TWO
6311 eba3 0f 53                        CLR  FPA0+3         ; * BYTES OF FPA0
6312 eba5 8e 00 52                     LDX  #FPA0+2        ; BYTES 2,3 OF FPA0 = (TEMPORARY ACCUMULATOR)
6313 eba8 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6314 ebaa 81 4f                        CMPA #'O
6315 ebac 27 12                        BEQ  L880A          ; YES
6316 ebae 81 48                        CMPA #'H
6317 ebb0 27 23                        BEQ  L881F          ; YES
6318 ebb2 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6319 ebb4 20 0c                        BRA  L880C          ; DEFAULT TO OCTAL (&O)
6320 ebb6 81 38              L8800     CMPA #'8
6321 ebb8 10 22 ee 47                  LBHI LB277
6322 ebbc c6 03                        LDB  #$03           ; BASE 8 MULTIPLIER
6323 ebbe 8d 2a                        BSR  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
6324                         * EVALUATE AN &O VARIABLE
6325 ebc0 9d 7c              L880A     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6326 ebc2 25 f2              L880C     BLO  L8800          ; BRANCH IF NUMERIC
6327 ebc4 0f 50              L880E     CLR  FPA0           ; * CLEAR 2 HIGH ORDER
6328 ebc6 0f 51                        CLR  FPA0+1         ; * BYTES OF FPA0
6329 ebc8 0f 06                        CLR  VALTYP         ; SET VARXABLE TYPE TO NUMERIC
6330 ebca 0f 63                        CLR  FPSBYT         ; ZERO OUT SUB BYTE OF FPA0
6331 ebcc 0f 54                        CLR  FP0SGN         ; ZERO OUT MANTISSA SIGN OF FPA0
6332 ebce c6 a0                        LDB  #$A0           ; * SET EXPONENT OF FPA0
6333 ebd0 d7 4f                        STB  FP0EXP         ; *
6334 ebd2 7e e1 68                     JMP  LBA1C          ; GO NORMALIZE FPA0
6335                         * EVALUATE AN &H VARIABLE
6336 ebd5 9d 7c              L881F     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6337 ebd7 25 0b                        BLO  L882E          ; BRANCH IF NUMERIC
6338 ebd9 bd db 29                     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
6339 ebdc 25 e6                        BLO  L880E          ; BRANCH IF NOT ALPHA OR NUMERIC
6340 ebde 81 47                        CMPA #'G            ; CHECK FOR LETTERS A-F
6341 ebe0 24 e2                        BCC  L880E          ; BRANCH IF >= G (ILLEGAL HEX LETTER)
6342 ebe2 80 07                        SUBA #7             ; SUBTRACT ASCII DIFFERENCE BETWEEN A AND 9
6343 ebe4 c6 04              L882E     LDB  #$04           ; BASE 16 DIGIT MULTIPLIER = 2**4
6344 ebe6 8d 02                        BSR  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
6345 ebe8 20 eb                        BRA  L881F          ; KEEP EVALUATING VARIABLE
6346 ebea 68 01              L8834     ASL  $01,X          ; * MULTIPLY TEMPORARY
6347 ebec 69 84                        ROL  ,X             ; * ACCUMULATOR BY TWO
6348 ebee 10 25 f5 ec                  LBCS LBA92          ; 'OV' OVERFLOW ERROR
6349 ebf2 5a                           DECB                ; DECREMENT SHIFT COUNTER
6350 ebf3 26 f5                        BNE  L8834          ; MULTIPLY TEMPORARY ACCUMULATOR AGAIN
6351 ebf5 80 30                        SUBA #'0            ; MASK OFF ASCII
6352 ebf7 ab 01                        ADDA $01,X          ; * ADD DIGIT TO TEMPORARY
6353 ebf9 a7 01                        STA  $01,X          ; * ACCUMULATOR AND SAVE IT
6354 ebfb 39                 L8845     RTS
6355                         
6356 ebfc 35 40              XVEC15    PULS U              ; PULL RETURN ADDRESS AND SAVE IN U REGISTER
6357 ebfe 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
6358 ec00 9e 83                        LDX  CHARAD         ; CURRENT INPUT POINTER TO X
6359 ec02 9d 7c                        JSR  GETNCH         ; GET CHARACTER FROM BASIC
6360 ec04 81 26                        CMPA #'&            ; HEX AND OCTAL VARIABLES ARE PRECEEDED BY &
6361 ec06 27 99                        BEQ  L87EB          ; PROCESS A '&' VARIABLE
6362 ec08 81 b0                        CMPA #TOK_FN        ; TOKEN FOR FN
6363 ec0a 27 5e                        BEQ  L88B4          ; PROCESS FN CALL
6364 ec0c 81 ff                        CMPA #$FF           ; CHECK FOR SECONDARY TOKEN
6365 ec0e 26 08                        BNE  L8862          ; NOT SECONDARY
6366 ec10 9d 7c                        JSR  GETNCH         ; GET CHARACTER FROM BASIC
6367 ec12 81 83                        CMPA #TOK_USR       ; TOKEN FOR USR
6368 ec14 10 27 00 ab                  LBEQ L892C          ; PROCESS USR CALL
6369 ec18 9f 83              L8862     STX  CHARAD         ; RESTORE BASIC'S INPUT POINTER
6370 ec1a 6e c4                        JMP  ,U             ; RETURN TO CALLING ROUTINE
6371 ec1c 9e 68              L8866     LDX  CURLIN         ; GET CURRENT LINE NUMBER
6372 ec1e 30 01                        LEAX $01,X          ; IN DIRECT MODE?
6373 ec20 26 d9                        BNE  L8845          ; RETURN IF NOT IN DIRECT MODE
6374 ec22 c6 16                        LDB  #2*11          ; 'ILLEGAL DIRECT STATEMENT' ERROR
6375 ec24 7e d4 06           L886E     JMP  LAC46          ; PROCESS ERROR
6376                         
6377 ec27 ae 9f 00 83        DEF       LDX  [CHARAD]       ; GET TWO INPUT CHARS
6378 ec2b 8c ff 83                     CMPX #TOK_FF_USR    ; TOKEN FOR USR
6379 ec2e 10 27 00 74                  LBEQ L890F          ; BRANCH IF DEF USR
6380 ec32 8d 23                        BSR  L88A1          ; GET DESCRIPTOR ADDRESS FOR FN VARIABLE NAME
6381 ec34 8d e6                        BSR  L8866          ; DON'T ALLOW DEF FN IF IN DIRECT MODE
6382 ec36 bd d9 f6                     JSR  LB26A          ; SYNTAX CHECK FOR '('
6383 ec39 c6 80                        LDB  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE
6384 ec3b d7 08                        STB  ARYDIS         ; * AND SAVE IT IN THE ARRAY DISABLE FLAG
6385 ec3d bd da de                     JSR  LB357          ; GET VARIABLE DESCRIPTOR
6386 ec40 8d 25                        BSR  L88B1          ; 'TM' ERROR IF STRING
6387 ec42 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6388 ec45 c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR '='
6389 ec47 bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR =
6390 ec4a 9e 4b                        LDX  V4B            ; GET THE ADDRESS OF THE FN NAME DESCRIPTOR
6391 ec4c dc 83                        LDD  CHARAD         ; * GET THE CURRENT INPUT POINTER ADDRESS AND
6392 ec4e ed 84                        STD  ,X             ; * SAVE IT IN FIRST 2 BYTES OF THE DESCRIPTOR
6393 ec50 dc 39                        LDD  VARPTR         ; = GET THE DESCRIPTOR ADDRESS OF THE ARGUMENT
6394 ec52 ed 02                        STD  $02,X          ; = VARIABLE AND SAVE IT IN THE DESCRIPTOR OF THE FN NAME
6395 ec54 7e d6 90                     JMP  DATA           ; MOVE INPUT POINTER TO END OF LINE OR SUBLINE
6396 ec57 c6 b0              L88A1     LDB  #TOK_FN        ; TOKEN FOR FN
6397 ec59 bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR FN
6398 ec5c c6 80                        LDB  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE FLAG
6399 ec5e d7 08                        STB  ARYDIS         ; * AND SAVE IT IN ARRAY VARIABLE FLAG
6400 ec60 8a 80                        ORA  #$80           ; SET BIT 7 OF CURRENT INPUT CHARACTER TO INDICATE AN FN VARIABLE
6401 ec62 bd da e3                     JSR  LB35C          ; * GET THE DESCRIPTOR ADDRESS OF THIS
6402 ec65 9f 4b                        STX  V4B            ; * VARIABLE AND SAVE IT IN V4B
6403 ec67 7e d8 cf           L88B1     JMP  LB143          ; 'TM' ERROR IF STRING VARIABLE
6404                         * EVALUATE AN FN CALL
6405 ec6a 8d eb              L88B4     BSR  L88A1          ; * GET THE DESCRIPTOR OF THE FN NAME
6406 ec6c 34 10                        PSHS X              ; * VARIABLE AND SAVE IT ON THE STACK
6407 ec6e bd d9 ee                     JSR  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
6408 ec71 8d f4                        BSR  L88B1          ; 'TM' ERROR IF STRING VARIABLE
6409 ec73 35 40                        PULS U              ; POINT U TO FN NAME DESCRIPTOR
6410 ec75 c6 32                        LDB  #2*25          ; 'UNDEFINED FUNCTION CALL' ERROR
6411 ec77 ae 42                        LDX  $02,U          ; POINT X TO ARGUMENT VARIABLE DESCRIPTOR
6412 ec79 27 a9                        BEQ  L886E          ; BRANCH TO ERROR HANDLER
6413 ec7b 10 9e 83                     LDY  CHARAD         ; SAVE CURRENT INPUT POINTER IN Y
6414 ec7e ee c4                        LDU  ,U             ; * POINT U TO START OF FN FORMULA AND
6415 ec80 df 83                        STU  CHARAD         ; * SAVE IT IN INPUT POINTER
6416 ec82 a6 04                        LDA  $04,X          ; = GET FP VALUE OF
6417 ec84 34 02                        PSHS A              ; = ARGUMENT VARIABLE, CURRENT INPUT
6418 ec86 ec 84                        LDD  ,X             ; = POINTER, AND ADDRESS OF START
6419 ec88 ee 02                        LDU  $02,X          ; = OF FN FORMULA AND SAVE
6420 ec8a 34 76                        PSHS U,Y,X,B,A      ; = THEM ON THE STACK
6421 ec8c bd e3 81                     JSR  LBC35          ; PACK FPA0 AND SAVE IT IN (X)
6422 ec8f bd d8 cd           L88D9     JSR  LB141          ; EVALUATE FN EXPRESSION
6423 ec92 35 76                        PULS A,B,X,Y,U      ; RESTORE REGISTERS
6424 ec94 ed 84                        STD  ,X             ; * GET THE FP
6425 ec96 ef 02                        STU  $02,X          ; * VALUE OF THE ARGUMENT
6426 ec98 35 02                        PULS A              ; * VARIABLE OFF OF THE
6427 ec9a a7 04                        STA  $04,X          ; * STACK AND RE-SAVE IT
6428 ec9c 9d 82                        JSR  GETCCH         ; GET FINAL CHARACTER OF THE FN FORMULA
6429 ec9e 10 26 ed 61                  LBNE LB277          ; 'SYNTAX' ERROR IF NOT END OF LINE
6430 eca2 10 9f 83                     STY  CHARAD         ; RESTORE INPUT POINTER
6431 eca5 39                 L88EF     RTS
6432                         
6433                         
6434                         
6435                         * DEF USR
6436 eca6 9d 7c              L890F     JSR  GETNCH         ; SKIP PAST SECOND BYTE OF DEF USR TOKEN
6437 eca8 8d 09                        BSR  L891C          ; GET FN NUMBER
6438 ecaa 34 10                        PSHS X              ; SAVE FN EXEC ADDRESS STORAGE LOC
6439 ecac 8d 2d                        BSR  L8944          ; CALCULATE EXEC ADDRESS
6440 ecae 35 40                        PULS U              ; GET FN EXEC ADDRESS STORAGE LOC
6441 ecb0 af c4                        STX  ,U             ; SAVE EXEC ADDRESS
6442 ecb2 39                           RTS
6443 ecb3 5f                 L891C     CLRB                ; DEFAULT TO USR0 IF NO ARGUMENT
6444 ecb4 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6445 ecb6 24 06                        BCC  L8927          ; BRANCH IF NOT NUMERIC
6446 ecb8 80 30                        SUBA #'0            ; MASK OFF ASCII
6447 ecba 1f 89                        TFR  A,B            ; SAVE USR NUMBER IN ACCB
6448 ecbc 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6449 ecbe 9e 8d              L8927     LDX  USRADR         ; GET ADDRESS OF STORAGE LOCs FOR USR ADDRESS
6450 ecc0 58                           ASLB                ; X2 - 2 BYTES/USR ADDRESS
6451 ecc1 3a                           ABX                 ; ADD OFFSET TO START ADDRESS OF STORAGE LOCs
6452 ecc2 39                           RTS
6453                         * PROCESS A USR CALL
6454 ecc3 8d ee              L892C     BSR  L891C          ; GET STORAGE LOC OF EXEC ADDRESS FOR USR N
6455 ecc5 ae 84                        LDX  ,X             ; * GET EXEC ADDRESS AND
6456 ecc7 34 10                        PSHS X              ; * PUSH IT ONTO STACK
6457 ecc9 bd d9 ee                     JSR  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
6458 eccc 8e 00 4f                     LDX  #FP0EXP        ; POINT X TO FPA0
6459 eccf 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
6460 ecd1 27 07                        BEQ  L8943          ; BRANCH IF NUMERIC, STRING IF <> 0
6461 ecd3 bd dd de                     JSR  LB657          ; GET LENGTH & ADDRESS OF STRING VARIABLE
6462 ecd6 9e 52                        LDX  FPA0+2         ; GET POINTER TO STRING DESCRIPTOR
6463 ecd8 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
6464 ecda 39                 L8943     RTS                 ; JUMP TO USR ROUTINE (PSHS X ABOVE)
6465 ecdb c6 ae              L8944     LDB  #TOK_EQUALS    ; TOKEN FOR '='
6466 ecdd bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR =
6467 ece0 7e de c4                     JMP  LB73D          ; EVALUATE EXPRESSION, RETURN VALUE IN X
6468                         
6469                         
6470                         
6471                         * DEL
6472 ece3 10 27 ee ea        DEL       LBEQ LB44A          ; 'FC' ERROR IF NO ARGUMENT
6473 ece7 bd d7 17                     JSR  LAF67          ; CONVERT A DECIMAL BASiC NUMBER TO BINARY
6474 ecea bd d4 a5                     JSR  LAD01          ; FIND RAM ADDRESS OF START OF A BASIC LINE
6475 eced 9f 93                        STX  VD3            ; SAVE RAM ADDRESS OF STARTING LINE NUMBER
6476 ecef 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6477 ecf1 27 10                        BEQ  L8990          ; BRANCH IF END OF LINE
6478 ecf3 81 a7                        CMPA #TOK_MINUS     ; TOKEN FOR '-'
6479 ecf5 26 3b                        BNE  L89BF          ; TERMINATE COMMAND IF LINE NUMBER NOT FOLLOWED BY '-'
6480 ecf7 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6481 ecf9 27 04                        BEQ  L898C          ; IF END OF LINE, USE DEFAULT ENDING LINE NUMBER
6482 ecfb 8d 24                        BSR  L89AE          ; * CONVERT ENDING LINE NUMBER TO BINARY
6483 ecfd 20 04                        BRA  L8990          ; * AND SAVE IT IN BINVAL
6484 ecff 86 ff              L898C     LDA  #$FF           ; = USE $FFXX AS DEFAULT ENDING
6485 ed01 97 2b                        STA  BINVAL         ; = LINE NUMBER - SAVE IT IN BINVAL
6486 ed03 de 93              L8990     LDU  VD3            ; POINT U TO STARTING LINE NUMBER ADDRESS
6487 ed05 8c                 L8992     FCB  SKP2           ; SKIP TWO BYTES
6488 ed06 ee c4              L8993     LDU  ,U             ; POINT U TO START OF NEXT LINE
6489 ed08 ec c4                        LDD  ,U             ; CHECK FOR END OF PROGRAM
6490 ed0a 27 06                        BEQ  L899F          ; BRANCH IF END OF PROGRAM
6491 ed0c ec 42                        LDD  $02,U          ; LOAD ACCD WITH THIS LINE'S NUMBER
6492 ed0e 93 2b                        SUBD BINVAL         ; SUBTRACT ENDING LINE NUMBER ADDRESS
6493 ed10 23 f4                        BLS  L8993          ; BRANCH IF = < ENDING LINE NUMBER
6494 ed12 9e 93              L899F     LDX  VD3            ; GET STARTING LINE NUMBER
6495 ed14 8d 15                        BSR  L89B8          ; MOVE (U) TO (X) UNTIL END OF PROGRAM
6496 ed16 bd d4 c5                     JSR  LAD21          ; RESET BASIC'S INPUT POINTER AND ERASE VARIABLES
6497 ed19 9e 93                        LDX  VD3            ; GET STARTING LINE NUMBER ADDRESS
6498 ed1b bd d4 95                     JSR  LACF1          ; RECOMPUTE START OF NEXT LINE ADDRESSES
6499 ed1e 7e d4 25                     JMP  LAC73          ; JUMP TO BASIC'S MAIN COMMAND LOOP
6500 ed21 bd d7 17           L89AE     JSR  LAF67          ; GO GET LINE NUMBER CONVERTED TO BINARY
6501 ed24 7e d1 ba                     JMP  LA5C7          ; MAKE SURE THERE'S NO MORE ON THIS LINE
6502 ed27 a6 c0              L89B4     LDA  ,U+            ; GET A BYTE FROM (U)
6503 ed29 a7 80                        STA  ,X+            ; MOVE THE BYTE TO (X)
6504 ed2b 11 93 1b           L89B8     CMPU VARTAB         ; COMPARE TO END OF BASIC
6505 ed2e 26 f7                        BNE  L89B4          ; BRANCH IF NOT AT END
6506 ed30 9f 1b                        STX  VARTAB         ; SAVE (X) AS NEW END OF BASIC
6507 ed32 39                 L89BF     RTS
6508                         
6509                         
6510 ed33 bd ec 1c           L89C0     JSR  L8866          ; 'BS' ERROR IF IN DIRECT MODE
6511 ed36 9d 7c                        JSR  GETNCH         ; GET A CHAR FROM BASIC
6512 ed38 81 22              L89D2     CMPA #'"            ; CHECK FOR PROMPT STRING
6513 ed3a 26 0b                        BNE  L89E1          ; BRANCH IF NO PROMPT STRING
6514 ed3c bd d9 d0                     JSR  LB244          ; STRIP OFF PROMPT STRING & PUT IT ON STRING STACK
6515 ed3f c6 3b                        LDB  #';            ; *
6516 ed41 bd d9 fb                     JSR  LB26F          ; * DO A SYNTAX CHECK FOR;
6517 ed44 bd e0 eb                     JSR  LB99F          ; REMOVE PROMPT STRING FROM STRING STACK & SEND TO CONSOLE OUT
6518 ed47 32 7e              L89E1     LEAS -2,S           ; RESERVE TWO STORAGE SLOTS ON STACK
6519 ed49 bd d7 cc                     JSR  LB035          ; INPUT A LINE FROM CURRENT INPUT DEVICE
6520 ed4c 32 62                        LEAS $02,S          ; CLEAN UP THE STACK
6521 ed4e bd da de                     JSR  LB357          ; SEARCH FOR A VARIABLE
6522 ed51 9f 3b                        STX  VARDES         ; SAVE POINTER TO VARIABLE DESCRIPTOR
6523 ed53 bd d8 d2                     JSR  LB146          ; ''TM' ERROR IF VARIABLE TYPE = NUMERIC
6524 ed56 8e 00 f3                     LDX  #LINBUF        ; POINT X TO THE STRING BUFFER WHERE THE INPUT STRING WAS STORED
6525 ed59 4f                           CLRA                ; TERMINATOR CHARACTER 0 (END OF LINE)
6526 ed5a bd dc a3                     JSR  LB51A          ; PARSE THE INPUT STRING AND STORE IT IN THE STRING SPACE
6527 ed5d 7e d7 54                     JMP  LAFA4          ; REMOVE DESCRIPTOR FROM STRING STACK
6528 ed60 bd d7 17           L89FC     JSR  LAF67          ; STRIP A DECIMAL NUMBER FROM BASIC INPUT LINE
6529 ed63 9e 2b                        LDX  BINVAL         ; GET BINARY VALUE
6530 ed65 39                           RTS
6531 ed66 9e 91              L8A02     LDX  VD1            ; GET CURRENT OLD NUMBER BEING RENUMBERED
6532 ed68 9f 2b              L8A04     STX  BINVAL         ; SAVE THE LINE NUMBER BEING SEARCHED FOR
6533 ed6a 7e d4 a5                     JMP  LAD01          ; GO FIND THE LINE NUMBER IN BASIC PROGRAM
6534                         
6535                         * RENUM
6536 ed6d bd d4 ca           RENUM     JSR  LAD26          ; ERASE VARIABLES
6537 ed70 cc 00 0a                     LDD  #10            ; DEFAULT LINE NUMBER INTERVAL
6538 ed73 dd 95                        STD  VD5            ; SAVE DEFAULT RENUMBER START LINE NUMBER
6539 ed75 dd 8f                        STD  VCF            ; SAVE DEFAULT INTERVAL
6540 ed77 5f                           CLRB                ; NOW ACCD = 0
6541 ed78 dd 91                        STD  VD1            ; DEFAULT LINE NUMBER OF WHERE TO START RENUMBERING
6542 ed7a 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6543 ed7c 24 06                        BCC  L8A20          ; BRANCH IF NOT NUMERIC
6544 ed7e 8d e0                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
6545 ed80 9f 95                        STX  VD5            ; SAVE LINE NUMBER WHERE RENUMBERING STARTS
6546 ed82 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6547 ed84 27 1b              L8A20     BEQ  L8A3D          ; BRANCH IF END OF LINE
6548 ed86 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6549 ed89 24 06                        BCC  L8A2D          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
6550 ed8b 8d d3                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
6551 ed8d 9f 91                        STX  VD1            ; SAVE NEW RENUMBER LINE
6552 ed8f 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6553 ed91 27 0e              L8A2D     BEQ  L8A3D          ; BRANCH IF END OF LINE
6554 ed93 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6555 ed96 24 06                        BCC  L8A3A          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
6556 ed98 8d c6                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
6557 ed9a 9f 8f                        STX  VCF            ; SAVE NEW INTERVAL
6558 ed9c 27 49                        BEQ  L8A83          ; 'FC' ERROR
6559 ed9e bd d1 ba           L8A3A     JSR  LA5C7          ; CHECK FOR MORE CHARACTERS ON LINE - 'SYNTAX' ERROR IF ANY
6560 eda1 8d c3              L8A3D     BSR  L8A02          ; GO GET ADDRESS OF OLD NUMBER BEING RENUMBERED
6561 eda3 9f 93                        STX  VD3            ; SAVE ADDRESS
6562 eda5 9e 95                        LDX  VD5            ; GET NEXT RENUMBERED LINE NUMBER TO USE
6563 eda7 8d bf                        BSR  L8A04          ; FIND THE LINE NUMBER IN THE BASIC PROGRAM
6564 eda9 9c 93                        CMPX VD3            ; COMPARE TO ADDRESS OF OLD LINE NUMBER
6565 edab 25 3a                        BLO  L8A83          ; 'FC' ERROR IF NEW ADDRESS < OLD ADDRESS
6566 edad 8d 1c                        BSR  L8A67          ; MAKE SURE RENUMBERED LINE NUMBERS WILL BE IN RANGE
6567 edaf bd ee 41                     JSR  L8ADD          ; CONVERT ASCII LINE NUMBERS TO 'EXPANDED' BINARY
6568 edb2 bd d4 93                     JSR  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESSES
6569 edb5 8d af                        BSR  L8A02          ; GET RAM ADDRESS OF FIRST LINE TO BE RENUMBERED
6570 edb7 9f 93                        STX  VD3            ; SAVE IT
6571 edb9 8d 3a                        BSR  L8A91          ; MAKE SURE LINE NUMBERS EXIST
6572 edbb 8d 0f                        BSR  L8A68          ; INSERT NEW LINE NUMBERS IN LINE HEADERS
6573 edbd 8d 36                        BSR  L8A91          ; INSERT NEW LINE NUMBERS IN PROGRAM STATEMENTS
6574 edbf bd ee dc                     JSR  L8B7B          ; CONVERT PACKED BINARY LINE NUMBERS TO ASCII
6575 edc2 bd d4 ca                     JSR  LAD26          ; ERASE VARIABLES
6576 edc5 bd d4 93                     JSR  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESS
6577 edc8 7e d4 25                     JMP  LAC73          ; GO BACK TO BASIC'S MAIN LOOP
6578 edcb 86                 L8A67     FCB  SKP1LD         ; SKIP ONE BYTE - LDA #$4F
6579 edcc 4f                 L8A68     CLRA                ; NEW LINE NUMBER FLAG - 0; INSERT NEW LINE NUMBERS
6580 edcd 97 98                        STA  VD8            ; SAVE NEW LINE NUMBER FLAG; 0 = INSERT NEW NUMBERS
6581 edcf 9e 93                        LDX  VD3            ; GET ADDRESS OF OLD LINE NUMBER BEING RENUMBERED
6582 edd1 dc 95                        LDD  VD5            ; GET THE CURRENT RENUMBERED LINE NUMBER
6583 edd3 8d 15                        BSR  L8A86          ; RETURN IF END OF PROGRAM
6584 edd5 0d 98              L8A71     TST  VD8            ; CHECK NEW LINE NUMBER FLAG
6585 edd7 26 02                        BNE  L8A77          ; BRANCH IF NOT INSERTING NEW LINE NUMBERS
6586 edd9 ed 02                        STD  $02,X          ; STORE THE NEW LINE NUMBER IN THE BASIC PROGRAM
6587 eddb ae 84              L8A77     LDX  ,X             ; POINT X TO THE NEXT LINE IN BASIC
6588 eddd 8d 0b                        BSR  L8A86          ; RETURN IF END OF PROGRAM
6589 eddf d3 8f                        ADDD VCF            ; ADD INTERVAL TO CURRENT RENUMBERED LINE NUMBER
6590 ede1 25 04                        BLO  L8A83          ; 'FC' ERROR IF LINE NUMBER > $FFFF
6591 ede3 81 fa                        CMPA #MAXLIN        ; LARGEST LINE NUMBER = $F9FF
6592 ede5 25 ee                        BLO  L8A71          ; BRANCH IF LEGAL LINE NUMBER
6593 ede7 7e db d1           L8A83     JMP  LB44A          ; 'FC' ERROR IF LINE NUMBER MS BYTE > $F9
6594                         * TEST THE TWO BYTES POINTED TO BY (X).
6595                         * NORMAL RETURN IF <> 0. IF = 0 (END OF
6596                         * PROGRAM) RETURN IS PULLED OFF STACK AND
6597                         * YOU RETURN TO PREVIOUS SUBROUTINE CALL.
6598 edea 34 06              L8A86     PSHS B,A            ; SAVE ACCD
6599 edec ec 84                        LDD  ,X             ; TEST THE 2 BYTES POINTED TO BY X
6600 edee 35 06                        PULS A,B            ; RESTORE ACCD
6601 edf0 26 02                        BNE  L8A90          ; BRANCH IF NOT END OF PROGRAM
6602 edf2 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS FROM STACK
6603 edf4 39                 L8A90     RTS
6604 edf5 9e 19              L8A91     LDX  TXTTAB         ; GET START OF BASIC PROGRAM
6605 edf7 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
6606 edf9 30 01              L8A95     LEAX $01,X          ; MOVE POINTER UP ONE
6607 edfb 8d ed                        BSR  L8A86          ; RETURN IF END OF PROGRAM
6608 edfd 30 03              L8A99     LEAX $03,X          ; SKIP OVER NEXT LINE ADDRESS AND LINE NUMBER
6609 edff 30 01              L8A9B     LEAX $01,X          ; MOVE POINTER TO NEXT CHARACTER
6610 ee01 a6 84                        LDA  ,X             ; CHECK CURRENT CHARACTER
6611 ee03 27 f4                        BEQ  L8A95          ; BRANCH IF END OF LINE
6612 ee05 9f 0f                        STX  TEMPTR         ; SAVE CURRENT POINTER
6613 ee07 4a                           DECA                ; =
6614 ee08 27 0c                        BEQ  L8AB2          ; =BRANCH IF START OF PACKED NUMERIC LINE
6615 ee0a 4a                           DECA                ; *
6616 ee0b 27 2a                        BEQ  L8AD3          ; *BRANCH IF LINE NUMBER EXISTS
6617 ee0d 4a                           DECA                ; =
6618 ee0e 26 ef                        BNE  L8A9B          ; =MOVE TO NEXT CHARACTER IF > 3
6619 ee10 86 03              L8AAC     LDA  #$03           ; * SET 1ST BYTE = 3 TO INDICATE LINE
6620 ee12 a7 80                        STA  ,X+            ; * NUMBER DOESN'T CURRENTLY EXIST
6621 ee14 20 e7                        BRA  L8A99          ; GO GET ANOTHER CHARACTER
6622 ee16 ec 01              L8AB2     LDD  $01,X          ; GET MS BYTE OF LINE NUMBER
6623 ee18 6a 02                        DEC  $02,X          ; DECREMENT ZERO CHECK BYTE
6624 ee1a 27 01                        BEQ  L8AB9          ; BRANCH IF MS BYTE <> 0
6625 ee1c 4f                           CLRA                ; CLEAR MS BYTE
6626 ee1d e6 03              L8AB9     LDB  $03,X          ; GET LS BYTE OF LINE NUMBER
6627 ee1f 6a 04                        DEC  $04,X          ; DECREMENT ZERO CHECK FLAG
6628 ee21 27 01                        BEQ  L8AC0          ; BRANCH IF IS BYTE <> 0
6629 ee23 5f                           CLRB                ; CLEAR LS BYTE
6630 ee24 ed 01              L8AC0     STD  $01,X          ; SAVE BINARY LINE NUMBER
6631 ee26 dd 2b                        STD  BINVAL         ; SAVE TRIAL LINE NUMBER
6632 ee28 bd d4 a5                     JSR  LAD01          ; FIND RAM ADDRESS OF A BASIC LINE NUMBER
6633 ee2b 9e 0f              L8AC7     LDX  TEMPTR         ; GET BACK POINTER TO START OF PACKED LINE NUMBER
6634 ee2d 25 e1                        BLO  L8AAC          ; BRANCH IF NO LINE NUMBER MATCH FOUND
6635 ee2f dc 47                        LDD  V47            ; GET START ADDRESS OF LINE NUMBER
6636 ee31 6c 80                        INC  ,X+            ; * SET 1ST BYTE = 2, TO INDICATE LINE NUMBER EXISTS IF CHECKING FOR
6637                         *              ; * EXISTENCE OF LINE NUMBER, SET IT = 1 IF INSERTING LINE NUMBERS
6638                         
6639 ee33 ed 84                        STD  ,X             ; SAVE RAM ADDRESS OF CORRECT LINE NUMBER
6640 ee35 20 c6                        BRA  L8A99          ; GO GET ANOTHER CHARACTER
6641 ee37 6f 84              L8AD3     CLR  ,X             ; CLEAR CARRY FLAG AND 1ST BYTE
6642 ee39 ae 01                        LDX  $01,X          ; POINT X TO RAM ADDRESS OF CORRECT LINE NUMBER
6643 ee3b ae 02                        LDX  $02,X          ; PUT CORRECT LINE NUMBER INTO (X)
6644 ee3d 9f 47                        STX  V47            ; SAVE IT TEMPORARILY
6645 ee3f 20 ea                        BRA  L8AC7          ; GO INSERT IT INTO BASIC LINE
6646 ee41 9e 19              L8ADD     LDX  TXTTAB         ; GET BEGINNING OF BASIC PROGRAM
6647 ee43 20 04                        BRA  L8AE5
6648 ee45 9e 83              L8AE1     LDX  CHARAD         ; *GET CURRENT INPUT POINTER
6649 ee47 30 01                        LEAX $01,X          ; *AND BUMP IT ONE
6650 ee49 8d 9f              L8AE5     BSR  L8A86          ; RETURN IF END OF PROGRAM
6651 ee4b 30 02                        LEAX $02,X          ; SKIP PAST NEXT LINE ADDRESS
6652 ee4d 30 01              L8AE9     LEAX $01,X          ; ADVANCE POINTER BY ONE
6653 ee4f 9f 83              L8AEB     STX  CHARAD         ; SAVE NEW BASIC INPUT POINTER
6654 ee51 9d 7c              L8AED     JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
6655 ee53 4d                 L8AEF     TSTA                ; CHECK THE CHARACTER
6656 ee54 27 ef                        BEQ  L8AE1          ; BRANCH IF END OF LINE
6657 ee56 2a f9                        BPL  L8AED          ; BRANCH IF NOT A TOKEN
6658 ee58 9e 83                        LDX  CHARAD         ; GET CURRENT INPUT POINTER
6659 ee5a 81 ff                        CMPA #$FF           ; IS THIS A SECONDARY TOKEN?
6660 ee5c 27 ef                        BEQ  L8AE9          ; YES - IGNORE IT
6661 ee5e 81 a2                        CMPA #TOK_THEN      ; TOKEN FOR THEN?
6662 ee60 27 12                        BEQ  L8B13          ; YES
6663 ee62 81 84                        CMPA #TOK_ELSE      ; TOKEN FOR ELSE?
6664 ee64 27 0e                        BEQ  L8B13          ; YES
6665 ee66 81 81                        CMPA #TOK_GO        ; TOKEN FOR GO?
6666 ee68 26 e7                        BNE  L8AED          ; NO
6667 ee6a 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6668 ee6c 81 a0                        CMPA #TOK_TO        ; TOKEN FOR TO?
6669 ee6e 27 04                        BEQ  L8B13          ; YES
6670 ee70 81 a1                        CMPA #TOK_SUB       ; TOKEN FOR SUB?
6671 ee72 26 db                        BNE  L8AEB          ; NO
6672 ee74 9d 7c              L8B13     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6673 ee76 25 04                        BLO  L8B1B          ; BRANCH IF NUMERIC
6674 ee78 9d 82              L8B17     JSR  GETCCH         ; GET CURRENT BASIC INPUT CHARRACTER
6675 ee7a 20 d7                        BRA  L8AEF          ; KEEP CHECKING THE LINE
6676 ee7c 9e 83              L8B1B     LDX  CHARAD         ; GET CURRENT INPUT ADDRESS
6677 ee7e 34 10                        PSHS X              ; SAVE IT ON THE STACK
6678 ee80 bd d7 17                     JSR  LAF67          ; CONVERT DECIMAL BASIC NUMBER TO BINARY
6679 ee83 9e 83                        LDX  CHARAD         ; GET CURRENT INPUT POINTER
6680 ee85 a6 82              L8B24     LDA  ,-X            ; GET PREVIOUS INPUT CHARACTER
6681 ee87 bd f1 ec                     JSR  L90AA          ; CLEAR CARRY IF NUMERIC INPUT VALUE
6682 ee8a 25 f9                        BLO  L8B24          ; BRANCH IF NON-NUMERIC
6683 ee8c 30 01                        LEAX $01,X          ; MOVE POINTER UP ONE
6684 ee8e 1f 10                        TFR  X,D            ; NOW ACCD POINTS TO ONE PAST END OF LINE NUMBER
6685 ee90 e0 61                        SUBB $01,S          ; SUBTRACT PRE-NUMERIC POINTER LS BYTE
6686 ee92 c0 05                        SUBB #$05           ; MAKE SURE THERE ARE AT LEAST 5 CHARACTERS IN THE NUMERIC LINE
6687                         *
6688 ee94 27 20                        BEQ  L8B55          ; BRANCH IF EXACTLY 5
6689 ee96 25 0a                        BLO  L8B41          ; BRANCH IF < 5
6690 ee98 33 84                        LEAU ,X             ; TRANSFER X TO U
6691 ee9a 50                           NEGB                ; NEGATE B
6692 ee9b 30 85                        LEAX B,X            ; MOVE X BACK B BYTES
6693 ee9d bd ed 2b                     JSR  L89B8          ; *MOVE BYTES FROM (U) TO (X) UNTIL
6694                         *         *U   = END OF BASIC; (I) = NEW END OF BASIC
6695 eea0 20 14                        BRA  L8B55
6696                         * FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER
6697 eea2 9f 47              L8B41     STX  V47            ; SAVE END OF NUMERIC VALUE
6698 eea4 9e 1b                        LDX  VARTAB         ; GET END OF BASIC PROGRAM
6699 eea6 9f 43                        STX  V43            ; SAVE IT
6700 eea8 50                           NEGB                ; NEGATE B
6701 eea9 30 85                        LEAX B,X            ; ADD IT TO END OF NUMERIC POiNTER
6702 eeab 9f 41                        STX  V41            ; SAVE POINTER
6703 eead 9f 1b                        STX  VARTAB         ; STORE END OF BASIC PROGRAM
6704 eeaf bd d3 de                     JSR  LAC1E          ; ACCD = TOP OF ARRAYS - CHECK FOR ENOUGH ROOM
6705 eeb2 9e 45                        LDX  V45            ; * GET AND SAVE THE
6706 eeb4 9f 83                        STX  CHARAD         ; * NEW CURRENT INPUT POINTER
6707 eeb6 35 10              L8B55     PULS X              ; RESTORE POINTER TO START OF NUMERIC VALUE
6708 eeb8 86 01                        LDA  #$01           ; NEW LINE NUMBER FLAG
6709 eeba a7 84                        STA  ,X             ; * SAVE NEW LINE FLAG
6710 eebc a7 02                        STA  $02,X          ; *
6711 eebe a7 04                        STA  $04,X          ; *
6712 eec0 d6 2b                        LDB  BINVAL         ; GET MS BYTE OF BINARY LINE NUMBER
6713 eec2 26 04                        BNE  L8B67          ; BRANCH IF IT IS NOT ZERO
6714 eec4 c6 01                        LDB  #$01           ; ; SAVE A 1 IF BYTE IS 0; OTHERWISE, BASIC WILL
6715                         *              ; THINK IT IS THE END OF A LINE
6716 eec6 6c 02                        INC  $02,X          ; IF 2,X = 2, THEN PREVIOUS BYTE WAS A ZERO
6717 eec8 e7 01              L8B67     STB  $01,X          ; SAVE MS BYTE OF BINARY LINE NUMBER
6718 eeca d6 2c                        LDB  BINVAL+1       ; GET IS BYTE OF BINARY LINE NUMBER
6719 eecc 26 04                        BNE  L8B71          ; BRANCH IF NOT A ZERO BYTE
6720 eece c6 01                        LDB  #$01           ; SAVE A 1 IF BYTE IS A 0
6721 eed0 6c 04                        INC  $04,X          ; IF 4,X = 2, THEN PREVIOUS BYTE WAS A 0
6722 eed2 e7 03              L8B71     STB  $03,X          ; SAVE LS BYTE OF BINARY LINE NUMBER
6723 eed4 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6724 eed6 81 2c                        CMPA #',            ; IS IT A COMMA?
6725 eed8 27 9a                        BEQ  L8B13          ; YES - PROCESS ANOTHER NUMERIC VALUE
6726 eeda 20 9c                        BRA  L8B17          ; NO - GO GET AND PROCESS AN INPUT CHARACTER
6727 eedc 9e 19              L8B7B     LDX  TXTTAB         ; POINT X TO START OF BASIC PROGRAM
6728 eede 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
6729 eee0 30 01              L8B7F     LEAX $01,X          ; MOVE POINTER UP ONE
6730 eee2 ec 02                        LDD  $02,X          ; GET ADDRESS OF NEXT LINE
6731 eee4 dd 68                        STD  CURLIN         ; SAVE IT IN CURLIN
6732 eee6 bd ed ea                     JSR  L8A86          ; RETURN IF END OF PROGRAM
6733 eee9 30 03                        LEAX $03,X          ; SKIP OVER ADDRESS OF NEXT LINE AND 1ST BYTE OF LINE NUMBER
6734 eeeb 30 01              L8B8A     LEAX $01,X          ; MOVE POINTER UP ONE
6735 eeed a6 84              L8B8C     LDA  ,X             ; GET CURRENT CHARACTER
6736 eeef 27 ef                        BEQ  L8B7F          ; BRANCH IF END OF LINE
6737 eef1 4a                           DECA                ; INPUT CHARACTER = 1? - VALID LINE NUMBER
6738 eef2 27 1b                        BEQ  L8BAE          ; YES
6739 eef4 80 02                        SUBA #$02           ; INPUT CHARACTER 3? - UL LINE NUMBER
6740 eef6 26 f3                        BNE  L8B8A          ; NO
6741 eef8 34 10                        PSHS X              ; SAVE CURRENT POSITION OF INPUT POINTER
6742 eefa 8e ef 39                     LDX  #L8BD9-1       ; POINT X TO 'UL' MESSAGE
6743 eefd bd e0 e8                     JSR  LB99C          ; PRINT STRING TO THE SCREEN
6744 ef00 ae e4                        LDX  ,S             ; GET INPUT POINTER
6745 ef02 ec 01                        LDD  $01,X          ; GET THE UNDEFINED LINE NUMBER
6746 ef04 bd e5 18                     JSR  LBDCC          ; CONVERT NUMBER IN ACCD TO DECIMAL AND DISPLAY IT
6747 ef07 bd e5 11                     JSR  LBDC5          ; PRINT 'IN XXXX' XXXX = CURRENT LINE NUMBER
6748 ef0a bd e0 a8                     JSR  LB958          ; SEND A CR TO CONSOLE OUT
6749 ef0d 35 10                        PULS X              ; GET INPUT POINTER BACK
6750 ef0f 34 10              L8BAE     PSHS X              ; SAVE CURRENT POSITION OF INPUT POINTER
6751 ef11 ec 01                        LDD  $01,X          ; LOAD ACCD WITH BINARY VALUE OF LINE NUMBER
6752 ef13 dd 52                        STD  FPA0+2         ; SAVE IN BOTTOM 2 BYTES OF FPA0
6753 ef15 bd eb c4                     JSR  L880E          ; ADJUST REST OF FPA0 AS AN INTEGER
6754 ef18 bd e5 25                     JSR  LBDD9          ; CONVERT FPA0 TO ASCII, STORE IN LINE NUMBER
6755 ef1b 35 40                        PULS U              ; LOAD U WITH PREVIOUS ADDRESS OF INPUT POINTER
6756 ef1d c6 05                        LDB  #$05           ; EACH EXPANDED LINE NUMBER USES 5 BYTES
6757 ef1f 30 01              L8BBE     LEAX $01,X          ; MOVE POINTER FORWARD ONE
6758 ef21 a6 84                        LDA  ,X             ; GET AN ASCII BYTE
6759 ef23 27 05                        BEQ  L8BC9          ; BRANCH IF END OF NUMBER
6760 ef25 5a                           DECB                ; DECREMENT BYTE COUNTER
6761 ef26 a7 c0                        STA  ,U+            ; STORE ASCII NUMBER IN BASIC LINE
6762 ef28 20 f5                        BRA  L8BBE          ; CHECK FOR ANOTHER DIGIT
6763 ef2a 30 c4              L8BC9     LEAX ,U             ; TRANSFER NEW LINE POINTER TO (X)
6764 ef2c 5d                           TSTB                ; DOES THE NEW LINE NUMBER REQUIRE 5 BYTES?
6765 ef2d 27 be                        BEQ  L8B8C          ; YES - GO GET ANOTHER INPUT CHARACTER
6766 ef2f 31 c4                        LEAY ,U             ; SAVE NEW LINE POINTER IN Y
6767 ef31 33 c5                        LEAU B,U            ; POINT U TO END OF 5 BYTE PACKED LINE NUMBER BLOCK
6768 ef33 bd ed 2b                     JSR  L89B8          ; MOVE BYTES FROM (U) TO (X) UNTIL END OF PROGRAM
6769 ef36 30 a4                        LEAX ,Y             ; LOAD (X) WITH NEW LINE POINTER
6770 ef38 20 b3                        BRA  L8B8C          ; GO GET ANOTHER INPUT CHARACTER
6771                         
6772 ef3a 55 4c 20           L8BD9     FCC  "UL "          ; UNKNOWN LINE NUMBER MESSAGE
6773 ef3d 00                           FCB  0
6774                         
6775                         
6776 ef3e bd de c7           HEXDOL    JSR  LB740          ; CONVERT FPA0 INTO A POSITIVE 2 BYTE INTEGER
6777 ef41 8e 01 f0                     LDX  #STRBUF+2      ; POINT TO TEMPORARY BUFFER
6778 ef44 c6 04                        LDB  #$04           ; CONVERT 4 NIBBLES
6779 ef46 34 04              L8BE5     PSHS B              ; SAVE NIBBLE COUNTER
6780 ef48 5f                           CLRB                ; CLEAR CARRY FLAG
6781 ef49 86 04                        LDA  #$04           ; 4 SHIFTS
6782 ef4b 08 53              L8BEA     ASL  FPA0+3         ; * SHIFT BOTTOM TWO BYTES OF
6783 ef4d 09 52                        ROL  FPA0+2         ; * FPA0 LEFT ONE BIT (X2)
6784 ef4f 59                           ROLB                ; IF OVERFLOW, ACCB <> 0
6785 ef50 4a                           DECA                ; * DECREMENT SHIFT COUNTER AND
6786 ef51 26 f8                        BNE  L8BEA          ; * BRANCH IF NOT DONE
6787 ef53 5d                           TSTB                ; CHECK FOR OVERFLOW
6788 ef54 26 0a                        BNE  L8BFF          ; BRANCH IF OVERFLOW
6789 ef56 a6 e4                        LDA  ,S             ; * GET NIBBLE COUNTER,
6790 ef58 4a                           DECA                ; * DECREMENT IT AND
6791 ef59 27 05                        BEQ  L8BFF          ; * BRANCH IF DONE
6792 ef5b 8c 01 f0                     CMPX #STRBUF+2      ; DO NOT DO A CONVERSION UNTIL A NON-ZERO
6793 ef5e 27 0c                        BEQ  L8C0B          ; BYTE IS FOUND - LEADING ZERO SUPPRESSION
6794 ef60 cb 30              L8BFF     ADDB #'0            ; ADD IN ASCII ZERO
6795 ef62 c1 39                        CMPB #'9            ; COMPARE TO ASCII 9
6796 ef64 23 02                        BLS  L8C07          ; BRANCH IF < 9
6797 ef66 cb 07                        ADDB #7             ; ADD ASCII OFFSET IF HEX LETTER
6798 ef68 e7 80              L8C07     STB  ,X+            ; STORE HEX VALUE AND ADVANCE POINTER
6799 ef6a 6f 84                        CLR  ,X             ; CLEAR NEXT BYTE - END OF STRING FLAG
6800 ef6c 35 04              L8C0B     PULS B              ; * GET NIBBLE COUNTER,
6801 ef6e 5a                           DECB                ; * DECREMENT IT AND
6802 ef6f 26 d5                        BNE  L8BE5          ; * BRANCH IF NOT DONE
6803 ef71 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF STACK
6804 ef73 8e 01 ef                     LDX  #STRBUF+1      ; RESET POINTER
6805 ef76 7e dc 9f                     JMP  LB518          ; SAVE STRING ON STRING STACK
6806                         * PROCESS EXCLAMATION POINT
6807 ef79 86 01              L8E37     LDA  #$01           ; * SET SPACES
6808 ef7b 97 99                        STA  VD9            ; * COUNTER = 1
6809                         * PROCESS STRING ITEM - LIST
6810 ef7d 5a                 L8E3B     DECB                ; DECREMENT FORMAT STRING LENGTH COUNTER
6811 ef7e bd f1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <>0
6812 ef81 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6813 ef83 10 27 00 93                  LBEQ L8ED8          ; EXIT PRINT USING IF END OF LINE
6814 ef87 d7 93                        STB  VD3            ; SAVE REMAINDER FORMAT STRING LENGTH
6815 ef89 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
6816 ef8c bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
6817 ef8f 9e 52                        LDX  FPA0+2         ; * GET ITEM - LIST DESCRIPTOR ADDRESS
6818 ef91 9f 4d                        STX  V4D            ; * AND SAVE IT IN V4D
6819 ef93 d6 99                        LDB  VD9            ; GET SPACES COUNTER
6820 ef95 bd de 34                     JSR  LB6AD          ; PUT ACCB BYTES INTO STRING SPACE & PUT DESCRIPTOR ON STRING STACK
6821 ef98 bd e0 eb                     JSR  LB99F          ; PRINT THE FORMATTED STRING TO CONSOLE OUT
6822                         * PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING < FORMAT STRING LENGTH
6823 ef9b 9e 52                        LDX  FPA0+2         ; POINT X TO FORMATTED STRING DESCRIPTOR ADDRESS
6824 ef9d d6 99                        LDB  VD9            ; GET SPACES COUNTER
6825 ef9f e0 84                        SUBB ,X             ; SUBTRACT LENGTH OF FORMATTED STRING
6826 efa1 5a                 L8E5F     DECB                ; DECREMENT DIFFERENCE
6827 efa2 10 2b 01 4f                  LBMI L8FB3          ; GO INTERPRET ANOTHER ITEM - LIST
6828 efa6 bd e0 f8                     JSR  LB9AC          ; PAD FORMAT STRING WITH A SPACE
6829 efa9 20 f6                        BRA  L8E5F          ; KEEP PADDING
6830                         * PERCENT SIGN - PROCESS A %SPACES% COMMAND
6831 efab d7 93              L8E69     STB  VD3            ; * SAVE THE CURRENT FORMAT STRING
6832 efad 9f 0f                        STX  TEMPTR         ; * COUNTER AND POINTER
6833 efaf 86 02                        LDA  #$02           ; INITIAL SPACES COUNTER = 2
6834 efb1 97 99                        STA  VD9            ; SAVE IN SPACES COUNTER
6835 efb3 a6 84              L8E71     LDA  ,X             ; GET A CHARACTER FROM FORMAT STRING
6836 efb5 81 25                        CMPA #'%            ; COMPARE TO TERMINATOR CHARACTER
6837 efb7 27 c4                        BEQ  L8E3B          ; BRANCH IF END OF SPACES COMMAND
6838 efb9 81 20                        CMPA #'             ; BLANK
6839 efbb 26 07                        BNE  L8E82          ; BRANCH IF ILLEGAL CHARACTER
6840 efbd 0c 99                        INC  VD9            ; ADD ONE TO SPACES COUNTER
6841 efbf 30 01                        LEAX $01,X          ; MOVE FORMAT POINTER UP ONE
6842 efc1 5a                           DECB                ; DECREMENT LENGTH COUNTER
6843 efc2 26 ef                        BNE  L8E71          ; BRANCH IF NOT END OF FORMAT STRING
6844 efc4 9e 0f              L8E82     LDX  TEMPTR         ; * RESTORE CURRENT FORMAT STRING COUNTER
6845 efc6 d6 93                        LDB  VD3            ; * AND POINTER TO POSITION BEFORE SPACES COMMAND
6846 efc8 86 25                        LDA  #'%            ; SEND A '%' TO CONSOLE OUT AS A DEBUGGING AID
6847                         * ERROR PROCESSOR - ILLEGAL CHARACTER OR BAD SYNTAX IN FORMAT STRING
6848 efca bd f1 1a           L8E88     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
6849 efcd bd d0 17                     JSR  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
6850 efd0 20 29                        BRA  L8EB9          ; GET NEXT CHARACTER IN FORMAT STRING
6851                         
6852                         * PRINT RAM HOOK
6853 efd2 81 b1              XVEC9     CMPA #TOK_USING     ; USING TOKEN
6854 efd4 27 01                        BEQ  L8E95          ; BRANCH IF PRINT USING
6855 efd6 39                           RTS
6856                         
6857                         * PRINT USING
6858                         * VDA IS USED AS A STATUS BYTE: BIT 6 = COMMA FORCE
6859                         * BIT 5=LEADING ASTERISK FORCE; BIT 4 = FLOATING $ FORCE
6860                         * BIT 3 = PRE SIGN FORCE; BIT 2 = POST SIGN FORCE; BIT 0 = EXPONENTIAL FORCE
6861 efd7 32 62              L8E95     LEAS $02,S          ; PURGE RETURN ADDRESS OFF THE STACK
6862 efd9 bd d8 e4                     JSR  LB158          ; EVALUATE FORMAT STRING
6863 efdc bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
6864 efdf c6 3b                        LDB  #';            ; CHECK FOR ITEM LIST SEPARATOR
6865 efe1 bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR ;
6866 efe4 9e 52                        LDX  FPA0+2         ; * GET FORMAT STRING DESCRIPTOR ADDRESS
6867 efe6 9f 95                        STX  VD5            ; * AND SAVE IT IN VD5
6868 efe8 20 06                        BRA  L8EAE          ; GO PROCESS FORMAT STRING
6869 efea 96 97              L8EA8     LDA  VD7            ; *CHECK NEXT PRINT ITEM FLAG AND
6870 efec 27 08                        BEQ  L8EB4          ; *'FC' ERROR IF NO FURTHER PRINT ITEMS
6871 efee 9e 95                        LDX  VD5            ; RESET FORMAT STRING POINTER TO START OF STRING
6872 eff0 0f 97              L8EAE     CLR  VD7            ; RESET NEXT PRINT ITEM FLAG
6873 eff2 e6 84                        LDB  ,X             ; GET LENGTH OF FORMAT STRING
6874 eff4 26 03                        BNE  L8EB7          ; INTERPRET FORMAT STRING IF LENGTH > 0
6875 eff6 7e db d1           L8EB4     JMP  LB44A          ; 'FC' ERROR IF FORMAT STRING = NULL
6876 eff9 ae 02              L8EB7     LDX  $02,X          ; POINT X TO START OF FORMAT STRING
6877                         * INTERPRET THE FORMAT STRING
6878 effb 0f 9a              L8EB9     CLR  VDA            ; CLEAR THE STATUS BYTE
6879 effd 0f 99              L8EBB     CLR  VD9            ; CLEAR LEFT DIGIT COUNTER
6880 efff a6 80                        LDA  ,X+            ; GET A CHARACTER FROM FORMAT STRING
6881 f001 81 21                        CMPA #'!            ; EXCLAMATION POINT?
6882 f003 10 27 ff 72                  LBEQ L8E37          ; YES - STRING TYPE FORMAT
6883 f007 81 23                        CMPA #'#            ; NUMBER SIGN? (DIGIT LOCATOR)
6884 f009 27 5b                        BEQ  L8F24          ; YES - NUMERIC TYPE FORMAT
6885 f00b 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH
6886 f00c 26 16                        BNE  L8EE2          ; BRANCH IF NOT DONE
6887 f00e bd f1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
6888 f011 bd d0 17                     JSR  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
6889 f014 9d 82              L8ED2     JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
6890 f016 26 d2                        BNE  L8EA8          ; BRANCH IF NOT END OF LINE
6891 f018 96 97                        LDA  VD7            ; GET NEXT PRINT ITEM FLAG
6892 f01a 26 03              L8ED8     BNE  L8EDD          ; BRANCH IF MORE PRINT ITEMS
6893 f01c bd e0 a8                     JSR  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
6894 f01f 9e 95              L8EDD     LDX  VD5            ; POINT X TO FORMAT STRING DESCRIPTOR
6895 f021 7e dd e0                     JMP  LB659          ; RETURN ADDRESS AND LENGTH OF FORMAT STRING - EXIT PRINT USING
6896 f024 81 2b              L8EE2     CMPA #'+            ; CHECK FOR '+' (PRE-SIGN FORCE)
6897 f026 26 09                        BNE  L8EEF          ; NO PLUS
6898 f028 bd f1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
6899 f02b 86 08                        LDA  #$08           ; * LOAD THE STATUS BYTE WITH 8;
6900 f02d 97 9a                        STA  VDA            ; * PRE-SIGN FORCE FLAG
6901 f02f 20 cc                        BRA  L8EBB          ; INTERPRET THE REST OF THE FORMAT STRING
6902 f031 81 2e              L8EEF     CMPA #'.            ; DECIMAL POINT?
6903 f033 27 4e                        BEQ  L8F41          ; YES
6904 f035 81 25                        CMPA #'%            ; PERCENT SIGN?
6905 f037 10 27 ff 70                  LBEQ L8E69          ; YES
6906 f03b a1 84                        CMPA ,X             ; COMPARE THE PRESENT FORMAT STRING INPUT
6907                         *              ; CHARACTER TO THE NEXT ONE IN THE STRING
6908 f03d 26 8b              L8EFB     BNE  L8E88          ; NO MATCH - ILLEGAL CHARACTER
6909                         * TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING
6910 f03f 81 24                        CMPA #'$            ; DOLLAR SIGN?
6911 f041 27 19                        BEQ  L8F1A          ; YES - MAKE THE DOLLAR SIGN FLOAT
6912 f043 81 2a                        CMPA #'*            ; ASTERISK?
6913 f045 26 f6                        BNE  L8EFB          ; NO - ILLEGAL CHARACTER
6914 f047 96 9a                        LDA  VDA            ; * GRAB THE STATUS BYTE AND BET BIT 5
6915 f049 8a 20                        ORA  #$20           ; * TO INDICATE THAT THE OUTPUT WILL
6916 f04b 97 9a                        STA  VDA            ; * BE LEFT PADDED WITH ASTERISKS
6917 f04d c1 02                        CMPB #2             ; * CHECK TO SEE IF THE $$ ARE THE LAST TWO
6918 f04f 25 11                        BLO  L8F20          ; * CHARACTERS IN THE FORMAT STRING AND BRANCH IF SO
6919 f051 a6 01                        LDA  $01,X          ; GET THE NEXT CHARACTER AFTER **
6920 f053 81 24                        CMPA #'$            ; CHECK FOR **$
6921 f055 26 0b                        BNE  L8F20          ; CHECK FOR MORE CHARACTERS
6922 f057 5a                           DECB                ; DECREMENT STRING LENGTH COUNTER
6923 f058 30 01                        LEAX $01,X          ; MOVE FORMAT STRING POINTER UP ONE
6924 f05a 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER - FOR ASTERISK PAD AND
6925                         *              ; FLOATING DOLLAR SIGN COMBINATION
6926 f05c 96 9a              L8F1A     LDA  VDA            ; * GET THE STATUS BYTE AND SET
6927 f05e 8a 10                        ORA  #$10           ; * BIT 4 TO INDICATE A
6928 f060 97 9a                        STA  VDA            ; * FLOATING DOLLAR SIGN
6929 f062 30 01              L8F20     LEAX $01,X          ; MOVE FORMAT STRING POINTER UP ONE
6930 f064 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT (FLOATING $ OR ASTERISK PAD)
6931                         * PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT IN THE FORMAT STRING
6932 f066 0f 98              L8F24     CLR  VD8            ; CLEAR THE RIGHT DIGIT COUNTER
6933 f068 0c 99              L8F26     INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER
6934 f06a 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH COUNTER
6935 f06b 27 49                        BEQ  L8F74          ; BRANCH IF END OF FORMAT STRING
6936 f06d a6 80                        LDA  ,X+            ; GET THE NEXT FORMAT CHARACTER
6937 f06f 81 2e                        CMPA #'.            ; DECIMAL POINT?
6938 f071 27 1e                        BEQ  L8F4F          ; YES
6939 f073 81 23                        CMPA #'#            ; NUMBER SIGN?
6940 f075 27 f1                        BEQ  L8F26          ; YES
6941 f077 81 2c                        CMPA #',            ; COMMA?
6942 f079 26 21                        BNE  L8F5A          ; NO
6943 f07b 96 9a                        LDA  VDA            ; * GET THE STATUS BYTE
6944 f07d 8a 40                        ORA  #$40           ; * AND SET BIT 6 WHICH IS THE
6945 f07f 97 9a                        STA  VDA            ; * COMMA SEPARATOR FLAG
6946 f081 20 e5                        BRA  L8F26          ; PROCESS MORE CHARACTERS TO LEFT OF DECIMAL POINT
6947                         * PROCESS DECIMAL POINT IF NO DIGITS TO LEFT OF IT
6948 f083 a6 84              L8F41     LDA  ,X             ; GET NEXT FORMAT CHARACTER
6949 f085 81 23                        CMPA #'#            ; IS IT A NUMBER SIGN?
6950 f087 10 26 ff 3f                  LBNE L8E88          ; NO
6951 f08b 86 01                        LDA  #1             ; * SET THE RIGHT DIGIT COUNTER TO 1 -
6952 f08d 97 98                        STA  VD8            ; * ALLOW ONE SPOT FOR DECIMAL POINT
6953 f08f 30 01                        LEAX $01,X          ; MOVE FORMAT POINTER UP ONE
6954                         * PROCESS DIGITS TO RIGHT OF DECIMAL POINT
6955 f091 0c 98              L8F4F     INC  VD8            ; ADD ONE TO RIGHT DIGIT COUNTER
6956 f093 5a                           DECB                ; DECREMENT FORMAT LENGTH COUNTER
6957 f094 27 20                        BEQ  L8F74          ; BRANCH IF END OF FORMAT STRING
6958 f096 a6 80                        LDA  ,X+            ; GET A CHARACTER FROM FORMAT STRING
6959 f098 81 23                        CMPA #'#            ; IS IT NUMBER SIGN?
6960 f09a 27 f5                        BEQ  L8F4F          ; YES - KEEP CHECKING
6961                         * CHECK FOR EXPONENTIAL FORCE
6962 f09c 81 5e              L8F5A     CMPA #$5E           ; CHECK FOR UP ARROW
6963 f09e 26 16                        BNE  L8F74          ; NO UP ARROW
6964 f0a0 a1 84                        CMPA ,X             ; IS THE NEXT CHARACTER AN UP ARROW?
6965 f0a2 26 12                        BNE  L8F74          ; NO
6966 f0a4 a1 01                        CMPA $01,X          ; AND THE NEXT CHARACTER?
6967 f0a6 26 0e                        BNE  L8F74          ; NO
6968 f0a8 a1 02                        CMPA $02,X          ; HOW ABOUT THE 4TH CHARACTER?
6969 f0aa 26 0a                        BNE  L8F74          ; NO, ALSO
6970 f0ac c1 04                        CMPB #4             ; * CHECK TO SEE IF THE 4 UP ARROWS ARE IN THE
6971 f0ae 25 06                        BLO  L8F74          ; * FORMAT STRING AND BRANCH IF NOT
6972 f0b0 c0 04                        SUBB #4             ; * MOVE POINTER UP 4 AND SUBTRACT
6973 f0b2 30 04                        LEAX $04,X          ; * FOUR FROM LENGTH
6974 f0b4 0c 9a                        INC  VDA            ; INCREMENT STATUS BYTE - EXPONENTIAL FORM
6975                         
6976                         * CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMAT STRING
6977 f0b6 30 1f              L8F74     LEAX -1,X           ; MOVE POINTER BACK ONE
6978 f0b8 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER FOR PRE-SIGN FORCE
6979 f0ba 96 9a                        LDA  VDA            ; * PRE-SIGN
6980 f0bc 85 08                        BITA #$08           ; * FORCE AND
6981 f0be 26 18                        BNE  L8F96          ; * BRANCH IF SET
6982 f0c0 0a 99                        DEC  VD9            ; DECREMENT LEFT DIGIT - NO PRE-SIGN FORCE
6983 f0c2 5d                           TSTB                ; * CHECK LENGTH COUNTER AND BRANCH
6984 f0c3 27 13                        BEQ  L8F96          ; * IF END OF FORMAT STRING
6985 f0c5 a6 84                        LDA  ,X             ; GET NEXT FORMAT STRING CHARACTER
6986 f0c7 80 2d                        SUBA #'-            ; CHECK FOR MINUS SIGN
6987 f0c9 27 06                        BEQ  L8F8F          ; BRANCH IF MINUS SIGN
6988 f0cb 81 fe                        CMPA #$FE           ; * WAS CMPA #('+')-('-')
6989 f0cd 26 09                        BNE  L8F96          ; BRANCH IF NO PLUS SIGN
6990 f0cf 86 08                        LDA  #$08           ; GET THE PRE-SIGN FORCE FLAG
6991 f0d1 8a 04              L8F8F     ORA  #$04           ; 'OR' IN POST-SIGN FORCE FLAG
6992 f0d3 9a 9a                        ORA  VDA            ; 'OR' IN THE STATUS BYTE
6993 f0d5 97 9a                        STA  VDA            ; SAVE THE STATUS BYTE
6994 f0d7 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH
6995                         
6996                         * EVALUATE NUMERIC ITEM-LIST
6997 f0d8 9d 82              L8F96     JSR  GETCCH         ; GET CURRENT CHARACTER
6998 f0da 10 27 ff 3c                  LBEQ L8ED8          ; BRANCH IF END OF LINE
6999 f0de d7 93                        STB  VD3            ; SAVE FORMAT STRING LENGTH WHEN FORMAT EVALUATION ENDED
7000 f0e0 bd d8 cd                     JSR  LB141          ; EVALUATE EXPRESSION
7001 f0e3 96 99                        LDA  VD9            ; GET THE LEFT DIGIT COUNTER
7002 f0e5 9b 98                        ADDA VD8            ; ADD IT TO THE RIGHT DIGIT COUNTER
7003 f0e7 81 11                        CMPA #17            ; *
7004 f0e9 10 22 ea e4                  LBHI LB44A          ; *'FC' ERROR IF MORE THAN 16 DIGITS AND DECIMAL POiNT
7005 f0ed bd f1 27                     JSR  L8FE5          ; CONVERT ITEM-LIST TO FORMATTED ASCII STRING
7006 f0f0 30 1f                        LEAX -1,X           ; MOVE BUFFER POINTER BACK ONE
7007 f0f2 bd e0 e8                     JSR  LB99C          ; DISPLAY THE FORMATTED STRING TO CONSOLE OUT
7008 f0f5 0f 97              L8FB3     CLR  VD7            ; RESET NEXT PRINT ITEM FLAG
7009 f0f7 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
7010 f0f9 27 0d                        BEQ  L8FC6          ; BRANCH IF END OF LINE
7011 f0fb 97 97                        STA  VD7            ; SAVE CURRENT CHARACTER (<>0) IN NEXT PRINT ITEM FLAG
7012 f0fd 81 3b                        CMPA #';            ; * CHECK FOR ; - ITEM-LIST SEPARATOR AND
7013 f0ff 27 05                        BEQ  L8FC4          ; * BRANCH IF SEMICOLON
7014 f101 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
7015 f104 20 02                        BRA  L8FC6          ; PROCESS NEXT PRINT ITEM
7016 f106 9d 7c              L8FC4     JSR  GETNCH         ; GET NEXT INPUT CHARACTER
7017 f108 9e 95              L8FC6     LDX  VD5            ; GET FORMAT STRING DESCRIPTOR ADDRESS
7018 f10a e6 84                        LDB  ,X             ; GET LENGTH OF FORMAT STRING
7019 f10c d0 93                        SUBB VD3            ; SUBTRACT AMOUNT OF FORMAT STRING LEFT AFTER LAST PRINT ITEM
7020 f10e ae 02                        LDX  $02,X          ; *GET FORMAT STRING START ADDRESS AND ADVANCE
7021 f110 3a                           ABX                 ; *POINTER TO START OF UNUSED FORMAT STRING
7022 f111 d6 93                        LDB  VD3            ; * GET AMOUNT OF UNUSED FORMAT STRING
7023 f113 10 26 fe e4                  LBNE L8EB9          ; * REINTERPRET FORMAT STRING FROM THAT POINT
7024 f117 7e f0 14                     JMP  L8ED2          ; REINTERPRET FORMAT STRING FROM THE START IF ENTIRELY
7025                         *         USED ON LAST PRINT ITEM
7026                         
7027                         * PRINT A '+' TO CONSOLE OUT IF THE STATUS BYTE <> 0
7028 f11a 34 02              L8FD8     PSHS A              ; RESTORE ACCA AND RETURN
7029 f11c 86 2b                        LDA  #'+            ; GET ASCII PLUS SIGN
7030 f11e 0d 9a                        TST  VDA            ; * CHECK THE STATUS BYTE AND
7031 f120 27 03                        BEQ  L8FE3          ; * RETURN IF = 0
7032 f122 bd d0 17                     JSR  PUTCHR         ; SEND A CHARACTER TO CONSOLE OUT
7033 f125 35 82              L8FE3     PULS A,PC           ; RETURN ACCA AND RETURN
7034                         
7035                         * CONVERT ITEM-LIST TO DECIMAL ASCII STRING
7036 f127 ce 01 f2           L8FE5     LDU  #STRBUF+4      ; POINT U TO STRING BUFFER
7037 f12a c6 20                        LDB  #SPACE         ; BLANK
7038 f12c 96 9a                        LDA  VDA            ; * GET THE STATUS FLAG AND
7039 f12e 85 08                        BITA #$08           ; * CHECK FOR A PRE-SIGN FORCE
7040 f130 27 02                        BEQ  L8FF2          ; * BRANCH IF NO PRE-SIGN FORCE
7041 f132 c6 2b                        LDB  #'+            ; PLUS SIGN
7042 f134 0d 54              L8FF2     TST  FP0SGN         ; CHECK THE SIGN OF FPA0
7043 f136 2a 04                        BPL  L8FFA          ; BRANCH IF POSITIVE
7044 f138 0f 54                        CLR  FP0SGN         ; FORCE FPA0 SIGN TO BE POSITIVE
7045 f13a c6 2d                        LDB  #'-            ; MINUS SIGN
7046 f13c e7 c0              L8FFA     STB  ,U+            ; SAVE THE SIGN IN BUFFER
7047 f13e c6 30                        LDB  #'0            ; * PUT A ZERO INTO THE BUFFER
7048 f140 e7 c0                        STB  ,U+            ; *
7049 f142 84 01                        ANDA #$01           ; * CHECK THE EXPONENTIAL FORCE FLAG IN
7050 f144 10 26 01 07                  LBNE L910D          ; * THE STATUS BYTE - BRANCH IF ACTIVE
7051 f148 8e e5 0c                     LDX  #LBDC0         ; POINT X TO FLOATING POINT 1E + 09
7052 f14b bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO (X)
7053 f14e 2b 15                        BMI  L9023          ; BRANCH IF FPA0 < 1E+09
7054 f150 bd e5 25                     JSR  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
7055 f153 a6 80              L9011     LDA  ,X+            ; * ADVANCE POINTER TO END OF
7056 f155 26 fc                        BNE  L9011          ; * ASCII STRING (ZERO BYTE)
7057 f157 a6 82              L9015     LDA  ,-X            ; MOVE THE
7058 f159 a7 01                        STA  $01,X          ; ENTIRE STRING
7059 f15b 8c 01 f1                     CMPX #STRBUF+3      ; UP ONE
7060 f15e 26 f7                        BNE  L9015          ; BYTE
7061 f160 86 25                        LDA  #'%            ; * INSERT A % SIGN AT START OF
7062 f162 a7 84                        STA  ,X             ; * STRING - OVERFLOW ERROR
7063 f164 39                           RTS
7064                         
7065 f165 96 4f              L9023     LDA  FP0EXP         ; GET EXPONENT OF FPA0
7066 f167 97 47                        STA  V47            ; AND SAVE IT IN V74
7067 f169 27 03                        BEQ  L902C          ; BRANCH IF FPA0 = 0
7068 f16b bd f3 0f                     JSR  L91CD          ; CONVERT FPA0 TO NUMBER WITH 9 SIGNIFICANT
7069                         *              ; PLACES TO LEFT OF DECIMAL POINT
7070 f16e 96 47              L902C     LDA  V47            ; GET BASE 10 EXPONENT OFFSET
7071 f170 10 2b 00 81                  LBMI L90B3          ; BRANCH IF FPA0 < 100,000,000
7072 f174 40                           NEGA                ; * CALCULATE THE NUMBER OF LEADING ZEROES TO INSERT -
7073 f175 9b 99                        ADDA VD9            ; * SUBTRACT BASE 10 EXPONENT OFFSET AND 9 (FPA0 HAS
7074 f177 80 09                        SUBA #$09           ; * 9 PLACES TO LEFT OF EXPONENT) FROM LEFT DIGIT COUNTER
7075 f179 bd f2 2c                     JSR  L90EA          ; PUT ACCA ZEROES IN STRING BUFFER
7076 f17c bd f3 a5                     JSR  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
7077 f17f bd f3 44                     JSR  L9202          ; CONVERT FPA0 TO DECIMAL ASCII IN THE STRING BUFFER
7078 f182 96 47                        LDA  V47            ; * GET BASE 10 EXPONENT AND PUT THAT MANY
7079 f184 bd f3 c3                     JSR  L9281          ; * ZEROES IN STRING BUFFER - STOP AT DECIMAL POINT
7080 f187 96 47                        LDA  V47            ; WASTED INSTRUCTION - SERVES NO PURPOSE
7081 f189 bd f3 8b                     JSR  L9249          ; CHECK FOR DECIMAL POINT
7082 f18c 96 98                        LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
7083 f18e 26 02                        BNE  L9050          ; BRANCH IF RIGHT DIGlT COUNTER <> 0
7084 f190 33 5f                        LEAU -1,U           ; * MOVE BUFFER POINTER BACK ONE - DELETE
7085                         *                             ; * DECIMAL POINT IF NO RIGHT DIGITS SPECiFIED
7086 f192 4a                 L9050     DECA                ; SUBTRACT ONE (DECIMAL POINT)
7087 f193 bd f2 2c                     JSR  L90EA          ; PUT ACCA ZEROES INTO BUFFER (TRAILING ZEROES)
7088 f196 bd f2 c7           L9054     JSR  L9185          ; INSERT ASTERISK PADDING, FLOATING $, AND POST-SIGN
7089 f199 4d                           TSTA                ; WAS THERE A POST-SIGN?
7090 f19a 27 06                        BEQ  L9060          ; NO
7091 f19c c1 2a                        CMPB #'*            ; IS THE FIRST CHARACTER AN $?
7092 f19e 27 02                        BEQ  L9060          ; YES
7093 f1a0 e7 c0                        STB  ,U+            ; STORE THE POST-SIGN
7094 f1a2 6f c4              L9060     CLR  ,U             ; CLEAR THE LAST CHARACTER IN THE BUFFER
7095                         *
7096                         * REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE
7097                         * STRING BUFFER TO THE LEFT OF THE DECIMAL POINT
7098 f1a4 8e 01 f1                     LDX  #STRBUF+3      ; POINT X TO THE START OF THE BUFFER
7099 f1a7 30 01              L9065     LEAX $01,X          ; MOVE BUFFER POINTER UP ONE
7100 f1a9 9f 0f                        STX  TEMPTR         ; SAVE BUFFER POINTER IN TEMPTR
7101 f1ab 96 3a                        LDA  VARPTR+1       ; * GET ADDRESS OF DECIMAL POINT IN BUFFER, SUBTRACT
7102 f1ad 90 10                        SUBA TEMPTR+1       ; * CURRENT POSITION AND SUBTRACT LEFT DIGIT COUNTER -
7103 f1af 90 99                        SUBA VD9            ; * THE RESULT WILL BE ZERO WHEN TEMPTR+1 IS POINTING
7104                         *              ; * TO THE FIRST DIGIT OF THE FORMAT STRING
7105 f1b1 27 38                        BEQ  L90A9          ; RETURN IF NO DIGITS TO LEFT OF THE DECiMAL POINT
7106 f1b3 a6 84                        LDA  ,X             ; GET THE CURRENT BUFFER CHARACTER
7107 f1b5 81 20                        CMPA #SPACE         ; SPACE?
7108 f1b7 27 ee                        BEQ  L9065          ; YES - ADVANCE POINTER
7109 f1b9 81 2a                        CMPA #'*            ; ASTERISK?
7110 f1bb 27 ea                        BEQ  L9065          ; YES - ADVANCE POINTER
7111 f1bd 4f                           CLRA                ; A ZERO ON THE STACK IS END OF DATA POINTER
7112 f1be 34 02              L907C     PSHS A              ; PUSH A CHARACTER ONTO THE STACK
7113 f1c0 a6 80                        LDA  ,X+            ; GET NEXT CHARACTER FROM BUFFER
7114 f1c2 81 2d                        CMPA #'-            ; MINUS SIGN?
7115 f1c4 27 f8                        BEQ  L907C          ; YES
7116 f1c6 81 2b                        CMPA #'+            ; PLUS SIGN?
7117 f1c8 27 f4                        BEQ  L907C          ; YES
7118 f1ca 81 24                        CMPA #'$            ; DOLLAR SIGN?
7119 f1cc 27 f0                        BEQ  L907C          ; YES
7120 f1ce 81 30                        CMPA #'0            ; ZERO?
7121 f1d0 26 0e                        BNE  L909E          ; NO - ERROR
7122 f1d2 a6 01                        LDA  $01,X          ; GET CHARACTER FOLLOWING ZERO
7123 f1d4 8d 16                        BSR  L90AA          ; CLEAR CARRY IF NUMERIC
7124 f1d6 25 08                        BLO  L909E          ; BRANCH IF NOT A NUMERIC CHARACTER - ERROR
7125 f1d8 35 02              L9096     PULS A              ; * PULL A CHARACTER OFF OF THE STACK
7126 f1da a7 82                        STA  ,-X            ; * AND PUT IT BACK IN THE STRING BUFFER
7127 f1dc 26 fa                        BNE  L9096          ; * KEEP GOING UNTIL ZERO FLAG
7128 f1de 20 c7                        BRA  L9065          ; KEEP CLEANING UP THE INPUT BUFFER
7129 f1e0 35 02              L909E     PULS A              ;
7130 f1e2 4d                           TSTA                ; * THE STACK AND EXIT WHEN
7131 f1e3 26 fb                        BNE  L909E          ; * ZERO FLAG FOUND
7132 f1e5 9e 0f                        LDX  TEMPTR         ; GET THE STRING BUFFER START POINTER
7133 f1e7 86 25                        LDA  #'%            ; * PUT A % SIGN BEFORE THE ERROR POSITION TO
7134 f1e9 a7 82                        STA  ,-X            ; * INDICATE AN ERROR
7135 f1eb 39                 L90A9     RTS
7136                         *
7137                         * CLEAR CARRY IF NUMERIC
7138 f1ec 81 30              L90AA     CMPA #'0            ; ASCII ZERO
7139 f1ee 25 04                        BLO  L90B2          ; RETURN IF ACCA < ASCII 0
7140 f1f0 80 3a                        SUBA #$3A           ; *  #'9'+1
7141 f1f2 80 c6                        SUBA #$C6           ; * #-('9'+1)  CARRY CLEAR IF NUMERIC
7142 f1f4 39                 L90B2     RTS
7143                         *
7144                         * PROCESS AN ITEM-LIST WHICH IS < 100,000,000
7145 f1f5 96 98              L90B3     LDA  VD8            ; GET RIGHT DIGIT COUNTER
7146 f1f7 27 01                        BEQ  L90B8          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT OF DECIMAL PT
7147 f1f9 4a                           DECA                ; SUBTRACT ONE FOR DECIMAL POINT
7148 f1fa 9b 47              L90B8     ADDA V47            ; *ADD THE BASE 10 EXPONENT OFFSET - ACCA CONTAINS THE
7149                         *         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO THE SPECIFIED
7150                         *         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMAL POINT
7151 f1fc 2b 01                        BMI  L90BD          ; IF ACCA >= 0 THEN NO SHIFTS ARE REQUIRED
7152 f1fe 4f                           CLRA                ; FORCE SHIFT COUNTER = 0
7153 f1ff 34 02              L90BD     PSHS A              ; SAVE INITIAL SHIFT COUNTER ON THE STACK
7154 f201 2a 0a              L90BF     BPL  L90CB          ; EXIT ROUTINE IF POSITIVE
7155 f203 34 02                        PSHS A              ; SAVE SHIFT COUNTER ON STACK
7156 f205 bd e2 ce                     JSR  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT ONE DIGIT TO RIGHT
7157 f208 35 02                        PULS A              ; GET SHIFT COUNTER FROM THE STACK
7158 f20a 4c                           INCA                ; BUMP SHIFT COUNTER UP BY ONE
7159 f20b 20 f4                        BRA  L90BF          ; CHECK FOR FURTHER DIVISION
7160 f20d 96 47              L90CB     LDA  V47            ; * GET BASE 10 EXPONENT OFFSET, ADD INITIAL SHIFT COUNTER
7161 f20f a0 e0                        SUBA ,S+            ; * AND SAVE NEW BASE 10 EXPONENT OFFSET - BECAUSE
7162 f211 97 47                        STA  V47            ; * FPA0 WAS SHIFTED ABOVE
7163 f213 8b 09                        ADDA #$09           ; * ADD NINE (SIGNIFICANT PLACES) AND BRANCH IF THERE ARE NO
7164 f215 2b 19                        BMI  L90EE          ; * ZEROES TO THE LEFT OF THE DECIMAL POINT IN THIS PRINT ITEM
7165 f217 96 99                        LDA  VD9            ; *DETERMINE HOW MANY FILLER ZEROES TO THE LEFT OF THE DECIMAL
7166 f219 80 09                        SUBA #$09           ; *POINT. GET THE NUMBER OF FORMAT PLACES TO LEFT OF DECIMAL
7167 f21b 90 47                        SUBA V47            ; *POINT, SUBTRACT THE BASE 10 EXPONENT OFFSET AND THE CONSTANT 9
7168 f21d 8d 0d                        BSR  L90EA          ; *(UNNORMALIZATION)-THEN OUTPUT THAT MANY ZEROES TO THE BUFFER
7169 f21f bd f3 a5                     JSR  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
7170 f222 20 1d                        BRA  L90FF          ; PROCESS THE REMAINDER OF THE PRINT ITEM
7171                         *
7172                         * PUT (ACCA+1) ASCII ZEROES IN BUFFER
7173 f224 34 02              L90E2     PSHS A              ; SAVE ZERO COUNTER
7174 f226 86 30                        LDA  #'0            ; * INSERT A ZERO INTO
7175 f228 a7 c0                        STA  ,U+            ; * THE BUFFER
7176 f22a 35 02                        PULS A              ; RESTORE ZERO COUNTER
7177                         
7178                         * PUT ACCA ASCII ZEROES INTO THE BUFFER
7179 f22c 4a                 L90EA     DECA                ; DECREMENT ZERO COUNTER
7180 f22d 2a f5                        BPL  L90E2          ; BRANCH IF NOT DONE
7181 f22f 39                           RTS
7182                         
7183 f230 96 99              L90EE     LDA  VD9            ; * GET THE LEFT DIGIT COUNTER AND PUT
7184 f232 8d f8                        BSR  L90EA          ; * THAT MANY ZEROES IN THE STRiNG BUFFER
7185 f234 bd f3 8f                     JSR  L924D          ; PUT THE DECIMAL POINT IN THE STRING BUFFER
7186 f237 86 f7                        LDA  #-9            ; *DETERMINE HOW MANY FILLER ZEROES BETWEEN THE DECIMAL POINT
7187 f239 90 47                        SUBA V47            ; *AND SIGNIFICANT DATA. SUBTRACT BASE 10 EXPONENT FROM -9
7188 f23b 8d ef                        BSR  L90EA          ; *(UNNORMALIZATION) AND OUTPUT THAT MANY ZEROES TO BUFFER
7189 f23d 0f 45                        CLR  V45            ; CLEAR THE DECIMAL POINT COUNTER - SUPPRESS THE DECIMAL POINT
7190 f23f 0f 97                        CLR  VD7            ; CLEAR THE COMMA COUNTER - SUPPRESS COMMAS
7191 f241 bd f3 44           L90FF     JSR  L9202          ; DECODE FPA0 INTO A DECIMAL ASCII STRING
7192 f244 96 98                        LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
7193 f246 26 02                        BNE  L9108          ; BRANCH IF RIGHT DIGIT COUNTER <> 0
7194 f248 de 39                        LDU  VARPTR         ; RESET BUFFER PTR TO THE DECIMAL POINT IF NO DIGITS TO RIGHT
7195 f24a 9b 47              L9108     ADDA V47            ; *ADD BASE 10 EXPONENT - A POSITIVE ACCA WILL CAUSE THAT MANY
7196                         * *FILLER ZEROES TO BE OUTPUT ; TO THE RIGHT OF LAST SIGNIFICANT DATA
7197                         *         *SIGNIFICANT DATA
7198 f24c 16 ff 43                     LBRA L9050          ; INSERT LEADING ASTERISKS, FLOATING DOLLAR SIGN, ETC
7199                         *
7200                         * FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FORMAT
7201 f24f 96 4f              L910D     LDA  FP0EXP         ; * GET EXPONENT OF FPA0 AND
7202 f251 34 02                        PSHS A              ; * SAVE IT ON THE STACK
7203 f253 27 03                        BEQ  L9116          ; BRANCH IF FPA0 = 0
7204 f255 bd f3 0f                     JSR  L91CD          ; *CONVERT FPA0 INTO A NUMBER WITH 9 SIGNIFICANT
7205                         *         *DIGITS TO THE LEFT OF THE DECIMAL POINT
7206 f258 96 98              L9116     LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
7207 f25a 27 01                        BEQ  L911B          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT
7208 f25c 4a                           DECA                ; SUBTRACT ONE FOR THE DECIMAL POINT
7209 f25d 9b 99              L911B     ADDA VD9            ; ADD TO THE LEFT DIGIT COUNTER
7210 f25f 7f 01 f1                     CLR  STRBUF+3       ; CLEAR BUFFER BYTE AS TEMPORARY STORAGE LOCATION
7211 f262 d6 9a                        LDB  VDA            ; * GET THE STATUS BYTE FOR A
7212 f264 c4 04                        ANDB #$04           ; * POST-BYTE FORCE; BRANCH IF
7213 f266 26 03                        BNE  L9129          ; * A POST-BYTE FORCE
7214 f268 73 01 f1                     COM  STRBUF+3       ; TOGGLE BUFFER BYTE TO -1 IF NO POST-BYTE FORCE
7215 f26b bb 01 f1           L9129     ADDA STRBUF+3       ; SUBTRACT 1 IF NO POST BYTE FORCE
7216 f26e 80 09                        SUBA #$09           ; *SUBTRACT 9 (DUE TO THE CONVERSION TO 9
7217                         *         *SIGNIFICANT DIGITS TO LEFT OF DECIMAL POINT)
7218 f270 34 02                        PSHS A              ; * SAVE SHIFT COUNTER ON THE STACK - ACCA CONTAINS THE NUMBER
7219                         *         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE NUMBER OF
7220                         *         FORMATTED PLACES TO THE RIGHT OF THE DECIMAL POINT.
7221 f272 2a 0a              L9130     BPL  L913C          ; NO MORE SHIFTS WHEN ACCA >= 0
7222 f274 34 02                        PSHS A              ; SAVE SHIFT COUNTER
7223 f276 bd e2 ce                     JSR  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT TO RIGHT ONE
7224 f279 35 02                        PULS A              ; RESTORE THE SHIFT COUNTER
7225 f27b 4c                           INCA                ; ADD 1 TO SHIFT COUNTER
7226 f27c 20 f4                        BRA  L9130          ; CHECK FOR FURTHER SHIFTING (DIVISION)
7227 f27e a6 e4              L913C     LDA  ,S             ; *GET THE INITIAL VALUE OF THE SHIFT COUNTER
7228 f280 2b 01                        BMI  L9141          ; *AND BRANCH IF SHIFTING HAS TAKEN PLACE
7229 f282 4f                           CLRA                ; RESET ACCA IF NO SHIFTING HAS TAKEN PLACE
7230 f283 40                 L9141     NEGA                ; *CALCULATE THE POSITION OF THE DECIMAL POINT BY
7231 f284 9b 99                        ADDA VD9            ; *NEGATING SHIFT COUNTER, ADDING THE LEFT DIGIT COUNTER
7232 f286 4c                           INCA                ; *PLUS ONE AND THE POST-BYTE POSlTION, IF USED
7233 f287 bb 01 f1                     ADDA STRBUF+3       ; *
7234 f28a 97 45                        STA  V45            ; SAVE DECIMAL POINT COUNTER
7235 f28c 0f 97                        CLR  VD7            ; CLEAR COMMA COUNTER - NO COMMAS INSERTED
7236 f28e bd f3 44                     JSR  L9202          ; CONVERT FPA0 INTO ASCII DECIMAL STRING
7237 f291 35 02                        PULS A              ; * GET THE INITIAL VALUE OF SHIFT COUNTER AND
7238 f293 bd f3 c3                     JSR  L9281          ; * INSERT THAT MANY ZEROES INTO THE BUFFER
7239 f296 96 98                        LDA  VD8            ; *GET THE RIGHT DIGIT COUNTER AND BRANCH
7240 f298 26 02                        BNE  L915A          ; *IF NOT ZERO
7241 f29a 33 5f                        LEAU -1,U           ; MOVE BUFFER POINTER BACK ONE
7242                         
7243                         * CALCULATE VALUE OF EXPONENT AND PUT IN STRING BUFFER
7244 f29c e6 e0              L915A     LDB  ,S+            ; GET ORIGINAL EXPONENT OF FPA0
7245 f29e 27 09                        BEQ  L9167          ; BRANCH IF EXPONENT = 0
7246 f2a0 d6 47                        LDB  V47            ; GET BASE 10 EXPONENT
7247 f2a2 cb 09                        ADDB #$09           ; ADD 9 FOR 9 SIGNIFICANT DIGIT CONVERSION
7248 f2a4 d0 99                        SUBB VD9            ; SUBTRACT LEFT DIGIT COUNTER
7249 f2a6 f0 01 f1                     SUBB STRBUF+3       ; ADD ONE TO EXPONENT IF POST-SIGN FORCE
7250 f2a9 86 2b              L9167     LDA  #'+            ; PLUS SIGN
7251 f2ab 5d                           TSTB                ; TEST EXPONENT
7252 f2ac 2a 03                        BPL  L916F          ; BRANCH IF POSITIVE EXPONENT
7253 f2ae 86 2d                        LDA  #'-            ; MINUS SIGN
7254 f2b0 50                           NEGB                ; CONVERT EXPONENT TO POSITIVE NUMBER
7255 f2b1 a7 41              L916F     STA  $01,U          ; PUT SIGN OF EXPONENT IN STRING BUFFER
7256 f2b3 86 45                        LDA  #'E            ; * PUT AN 'E' (EXPONENTIATION FLAG) IN
7257 f2b5 a7 c1                        STA  ,U++           ; * BUFFER AND SKIP OVER THE SIGN
7258 f2b7 86 2f                        LDA  #$2F           ; * WAS LDA #'0'-1
7259                         *CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACCA
7260 f2b9 4c                 L9177     INCA                ; ADD ONE TO TENS DIGIT COUNTER
7261 f2ba c0 0a                        SUBB #10            ; *SUBTRACT 10 FROM EXPONENT AND ADD ONE TO TENS
7262 f2bc 24 fb                        BCC  L9177          ; * DIGIT IF NO CARRY. TENS DIGIT DONE IF THERE IS A CARRY
7263 f2be cb 3a                        ADDB #$3A           ; WAS ADDB #'9'+1
7264 f2c0 ed c1                        STD  ,U++           ; SAVE EXPONENT IN BUFFER
7265 f2c2 6f c4                        CLR  ,U             ; CLEAR FINAL BYTE IN BUFFER - PRINT TERMINATOR
7266 f2c4 7e f1 96                     JMP  L9054          ; INSERT ASTERISK PADDING, FLOATING DOLLAR SIGN, ETC.
7267                         
7268                         * INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN
7269 f2c7 8e 01 f2           L9185     LDX  #STRBUF+4      ; POINT X TO START OF PRINT ITEM BUFFER
7270 f2ca e6 84                        LDB  ,X             ; * GET SIGN BYTE OF ITEM-LIST BUFFER
7271 f2cc 34 04                        PSHS B              ; * AND SAVE IT ON THE STACK
7272 f2ce 86 20                        LDA  #SPACE         ; DEFAULT PAD WITH BLANKS
7273 f2d0 d6 9a                        LDB  VDA            ; * GET STATUS BYTE AND CHECK FOR
7274 f2d2 c5 20                        BITB #$20           ; * ASTERISK LEFT PADDING
7275 f2d4 35 04                        PULS B              ; GET SIGN BYTE AGAIN
7276 f2d6 27 08                        BEQ  L919E          ; BRANCH IF NO PADDING
7277 f2d8 86 2a                        LDA  #'*            ; PAD WITH ASTERISK
7278 f2da c1 20                        CMPB #SPACE         ; WAS THE FIRST BYTE A BLANK (POSITIVE)?
7279 f2dc 26 02                        BNE  L919E          ; NO
7280 f2de 1f 89                        TFR  A,B            ; TRANSFER PAD CHARACTER TO ACCB
7281 f2e0 34 04              L919E     PSHS B              ; SAVE FIRST CHARACTER ON STACK
7282 f2e2 a7 80              L91A0     STA  ,X+            ; STORE PAD CHARACTER IN BUFFER
7283 f2e4 e6 84                        LDB  ,X             ; GET NEXT CHARACTER IN BUFFER
7284 f2e6 27 10                        BEQ  L91B6          ; INSERT A ZERO IF END OF BUFFER
7285 f2e8 c1 45                        CMPB #'E            ; * CHECK FOR AN 'E' AND
7286 f2ea 27 0c                        BEQ  L91B6          ; * PUT A ZERO BEFORE IT
7287 f2ec c1 30                        CMPB #'0            ; * REPLACE LEADING ZEROES WITH
7288 f2ee 27 f2                        BEQ  L91A0          ; * PAD CHARACTERS
7289 f2f0 c1 2c                        CMPB #',            ; * REPLACE LEADING COMMAS
7290 f2f2 27 ee                        BEQ  L91A0          ; * WITH PAD CHARACTERS
7291 f2f4 c1 2e                        CMPB #'.            ; * CHECK FOR DECIMAL POINT
7292 f2f6 26 04                        BNE  L91BA          ; * AND DON'T PUT A ZERO BEFORE IT
7293 f2f8 86 30              L91B6     LDA  #'0            ; * REPLACE PREVIOUS CHARACTER
7294 f2fa a7 82                        STA  ,-X            ; * WITH A ZERO
7295 f2fc 96 9a              L91BA     LDA  VDA            ; * GET STATUS BYTE, CHECK
7296 f2fe 85 10                        BITA #$10           ; * FOR FLOATING $
7297 f300 27 04                        BEQ  L91C4          ; * BRANCH IF NO FLOATING $
7298 f302 c6 24                        LDB  #'$            ; * STORE A $ IN
7299 f304 e7 82                        STB  ,-X            ; * BUFFER
7300 f306 84 04              L91C4     ANDA #$04           ; CHECK PRE-SIGN FLAG
7301 f308 35 04                        PULS B              ; GET SIGN CHARACTER
7302 f30a 26 02                        BNE  L91CC          ; RETURN IF POST-SIGN REQUIRED
7303 f30c e7 82                        STB  ,-X            ; STORE FIRST CHARACTER
7304 f30e 39                 L91CC     RTS
7305                         *
7306                         * CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN X 10**M.
7307                         * THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPONENT).
7308 f30f 34 40              L91CD     PSHS U              ; SAVE BUFFER POINTER
7309 f311 4f                           CLRA                ; INITIAL EXPONENT OFFSET = 0
7310 f312 97 47              L91D0     STA  V47            ; SAVE EXPONENT OFFSET
7311 f314 d6 4f                        LDB  FP0EXP         ; GET EXPONENT OF FPA0
7312 f316 c1 80                        CMPB #$80           ; * COMPARE TO EXPONENT OF .5
7313 f318 22 11                        BHI  L91E9          ; * AND BRANCH IF FPA0 > = 1.0
7314                         
7315                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1
7316 f31a 8e e5 0c                     LDX  #LBDC0         ; POINT X TO FP NUMBER (1E+09)
7317 f31d bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY 1E+09
7318 f320 96 47                        LDA  V47            ; GET EXPONENT OFFSET
7319 f322 80 09                        SUBA #$09           ; SUBTRACT 9 (BECAUSE WE MULTIPLIED BY 1E+09 ABOVE)
7320 f324 20 ec                        BRA  L91D0          ; CHECK TO SEE IF > 1.0
7321 f326 bd e2 ce           L91E4     JSR  LBB82          ; DIVIDE FPA0 BY 10
7322 f329 0c 47                        INC  V47            ; INCREMENT EXPONENT OFFSET
7323 f32b 8e e5 07           L91E9     LDX  #LBDBB         ; POINT X TO FP NUMBER (999,999,999)
7324 f32e bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO X
7325 f331 2e f3                        BGT  L91E4          ; BRANCH IF FPA0 > 999,999,999
7326 f333 8e e5 02           L91F1     LDX  #LBDB6         ; POINT X TO FP NUMBER (99,999,999.9)
7327 f336 bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO X
7328 f339 2e 07                        BGT  L9200          ; RETURN IF 999,999,999 > FPA0 > 99,999,999.9
7329 f33b bd e2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
7330 f33e 0a 47                        DEC  V47            ; DECREMENT EXPONENT OFFSET
7331 f340 20 f1                        BRA  L91F1          ; KEEP UNNORMALIZING
7332 f342 35 c0              L9200     PULS U,PC           ; RESTORE BUFFER POINTER AND RETURN
7333                         *
7334                         * CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT
7335                         * INTO A DECIMAL ASCII STRING IN THE BUFFER
7336 f344 34 40              L9202     PSHS U              ; SAVE BUFFER POINTER
7337 f346 bd e1 00                     JSR  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
7338 f349 bd e4 14                     JSR  LBCC8          ; CONVERT FPA0 TO INTEGER FORMAT
7339 f34c 35 40                        PULS U              ; RESTORE BUFFER POINTER
7340                         *
7341                         * CONVERT FPA0 INTO A DECIMAL ASCII STRING
7342 f34e 8e e6 11                     LDX  #LBEC5         ; POINT X TO UNNORMALIZED POWERS OF 10
7343 f351 c6 80                        LDB  #$80           ; INITIALIZE DIGIT COUNTER TO 0 + $80.
7344                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
7345                         * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
7346                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB
7347                         * IS HOW THIS ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURRING.
7348 f353 8d 36              L9211     BSR  L9249          ; CHECK FOR COMMA INSERTION
7349 f355 96 53              L9213     LDA  FPA0+3         ; * 'ADD' A POWER OF 10 MANTISSA TO FPA0.
7350 f357 ab 03                        ADDA $03,X          ; * IF THE MANTISSA IS NEGATIVE, A SUBTRACTION
7351 f359 97 53                        STA  FPA0+3         ; * WILL BE WHAT REALLY TAKES PLACE.
7352 f35b 96 52                        LDA  FPA0+2         ; *
7353 f35d a9 02                        ADCA $02,X          ; *
7354 f35f 97 52                        STA  FPA0+2         ; *
7355 f361 96 51                        LDA  FPA0+1         ; *
7356 f363 a9 01                        ADCA $01,X          ; *
7357 f365 97 51                        STA  FPA0+1         ; *
7358 f367 96 50                        LDA  FPA0           ; *
7359 f369 a9 84                        ADCA ,X             ; *
7360 f36b 97 50                        STA  FPA0           ; *
7361 f36d 5c                           INCB                ; ADD ONE TO DIGIT COUNTER
7362 f36e 56                           RORB                ; ROTATE CARRY INTO BIT 7
7363 f36f 59                           ROLB                ; * SET OVERFLOW FLAG - BRANCH IF CARRY SET AND
7364 f370 28 e3                        BVC  L9213          ; * ADDING MANTISSA OR CARRY CLEAR AND SUBTRACTING MANTISSA
7365 f372 24 03                        BCC  L9235          ; BRANCH IF SUBTRACTING MANTISSA
7366 f374 c0 0b                        SUBB #10+1          ; WAS SUBB #10+1
7367 f376 50                           NEGB                ; * IF ADDING MANTISSA
7368 f377 cb 2f              L9235     ADDB #$2F           ; WAS ADDB #'0'-1
7369 f379 30 04                        LEAX $04,X          ; MOVE TO NEXT POWER OF 10 MANTISSA
7370 f37b 1f 98                        TFR  B,A            ; SAVE DIGIT IN ACCA
7371 f37d 84 7f                        ANDA #$7F           ; MASK OFF ADD/SUBTRACT FLAG (BIT 7)
7372 f37f a7 c0                        STA  ,U+            ; STORE DIGIT IN BUFFER
7373 f381 53                           COMB                ; TOGGLE ADD/SUBTRACT FLAG
7374 f382 c4 80                        ANDB #$80           ; MASK OFF EVERYTHING BUT ADD/SUB FLAG
7375 f384 8c e6 35                     CMPX #LBEE9         ; COMPARE TO END OF UNNORMALIZED POWERS OF 10
7376 f387 26 ca                        BNE  L9211          ; BRANCH IF NOT DONE
7377 f389 6f c4                        CLR  ,U             ; PUT A ZERO AT END OF INTEGER
7378                         
7379                         * DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA INSERTION
7380 f38b 0a 45              L9249     DEC  V45            ; DECREMENT DECIMAL POINT COUNTER
7381 f38d 26 09                        BNE  L9256          ; NOT TIME FOR DECIMAL POINT
7382 f38f df 39              L924D     STU  VARPTR         ; SAVE BUFFER POINTER-POSITION OF THE DECIMAL POINT
7383 f391 86 2e                        LDA  #'.            ; * STORE A DECIMAL
7384 f393 a7 c0                        STA  ,U+            ; * POINT IN THE OUTPUT BUFFER
7385 f395 0f 97                        CLR  VD7            ; * CLEAR COMMA COUNTER - NOW IT WILL TAKE 255
7386                         *                             ; * DECREMENTS BEFORE ANOTHER COMMA WILL BE INSERTED
7387 f397 39                           RTS
7388 f398 0a 97              L9256     DEC  VD7            ; DECREMENT COMMA COUNTER
7389 f39a 26 08                        BNE  L9262          ; RETURN IF NOT TIME FOR COMMA
7390 f39c 86 03                        LDA  #$03           ; * RESET COMMA COUNTER TO 3; THREE
7391 f39e 97 97                        STA  VD7            ; * DIGITS BETWEEN COMMAS
7392 f3a0 86 2c                        LDA  #',            ; * PUT A COMMA INTO
7393 f3a2 a7 c0                        STA  ,U+            ; * THE BUFFER
7394 f3a4 39                 L9262     RTS
7395                         
7396                         * INITIALIZE DECIMAL POINT AND COMMA COUNTERS
7397 f3a5 96 47              L9263     LDA  V47            ; GET THE BASE 10 EXPONENT OFFSET
7398 f3a7 8b 0a                        ADDA #10            ; * ADD 10 (FPA0 WAS 'NORMALIZED' TO 9 PLACES LEFT
7399 f3a9 97 45                        STA  V45            ; * OF DECIMAL POINT) - SAVE IN DECIMAL POINT COUNTER
7400 f3ab 4c                           INCA                ; ADD ONE FOR THE DECIMAL POINT
7401 f3ac 80 03              L926A     SUBA #$03           ; * DIVIDE DECIMAL POINT COUNTER BY 3; LEAVE
7402 f3ae 24 fc                        BCC  L926A          ; * THE REMAINDER IN ACCA
7403 f3b0 8b 05                        ADDA #$05           ; CONVERT REMAINDER INTO A NUMBER FROM 1-3
7404 f3b2 97 97                        STA  VD7            ; SAVE COMMA COUNTER
7405 f3b4 96 9a                        LDA  VDA            ; GET STATUS BYTE
7406 f3b6 84 40                        ANDA #$40           ; CHECK FOR COMMA FLAG
7407 f3b8 26 02                        BNE  L927A          ; BRANCH IF COMMA FLAG ACTIVE
7408 f3ba 97 97                        STA  VD7            ; CLEAR COMMA COUNTER - 255 DIGITS OUTPUT BEFORE A COMMA
7409 f3bc 39                 L927A     RTS
7410                         *
7411                         * INSERT ACCA ZEROES INTO THE BUFFER
7412 f3bd 34 02              L927B     PSHS A              ; SAVE ZEROES COUNTER
7413 f3bf 8d ca                        BSR  L9249          ; CHECK FOR DECIMAL POINT
7414 f3c1 35 02                        PULS A              ; RESTORE ZEROES COUNTER
7415 f3c3 4a                 L9281     DECA                ; * DECREMENT ZEROES COUNTER AND
7416 f3c4 2b 0a                        BMI  L928E          ; * RETURN IF < 0
7417 f3c6 34 02                        PSHS A              ; SAVE ZEROES COUNTER
7418 f3c8 86 30                        LDA  #'0            ; * PUT A ZERO INTO
7419 f3ca a7 c0                        STA  ,U+            ; * THE BUFFER
7420 f3cc a6 e0                        LDA  ,S+            ; RESTORE THE ZEROES COUNTER
7421 f3ce 26 ed                        BNE  L927B          ; BRANCH IF NOT DONE
7422 f3d0 39                 L928E     RTS
7423                         
7424                         
7425                         * LINE
7426 f3d1 81 89              LINE      CMPA #TOK_INPUT     ; 'INPUT' TOKEN
7427 f3d3 10 27 f9 5c                  LBEQ L89C0          ; GO DO 'LINE INPUT' COMMAND
7428 f3d7 7e da 03                     JMP  LB277          ; 'SYNTAX ERROR' IF NOT "LINE INPUT"
7429                         
7430                         * END OF EXTENDED BASIC
7431                         
7432 f3da ff ff ff ff ff ff          FILL    $FF, $F800-*   ; Fill ROM with FFs until start of ASSIST09
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff
7433                         
7434                         *************************************
7435                         * COPYRIGHT (C) MOTOROLA, INC. 1979 *
7436                         *************************************
7437                         
7438                         *************************************
7439                         * THIS IS THE BASE ASSIST09 ROM.
7440                         * IT MAY RUN WITH OR WITHOUT THE
7441                         * EXTENSION ROM WHICH
7442                         * WHEN PRESENT WILL BE AUTOMATICALLY
7443                         * INCORPORATED BY THE BLDVTR
7444                         * SUBROUTINE.
7445                         *************************************
7446                         
7447                         *********************************************
7448                         * GLOBAL MODULE EQUATES
7449                         ********************************************
7450 f800                    ROMBEG  EQU     $F800           ; ROM START ASSEMBLY ADDRESS
7451 ffff7800                    RAMOFS  EQU     -$8800          ; ROM OFFSET TO RAM WORK PAGE
7452 0800                    ROMSIZ  EQU     2048            ; ROM SIZE
7453 f000                    ROM2OF  EQU     ROMBEG-ROMSIZ   ; START OF EXTENSION ROM
7454 a000                    ACIA    EQU     $A000           ; DEFAULT ACIA ADDRESS
7455 0000                    PTM     EQU     $0000           ; DEFAULT PTM ADDRESS
7456 0000                    DFTCHP  EQU     0               ; DEFAULT CHARACTER PAD COUNT
7457 0005                    DFTNLP  EQU     5               ; DEFAULT NEW LINE PAD COUNT
7458 003e                    PROMPT  EQU     '>              ; PROMPT CHARACTER
7459 0008                    NUMBKP  EQU     8               ; NUMBER OF BREAKPOINTS
7460                         *********************************************
7461                         
7462                         *********************************************
7463                         * MISCELANEOUS EQUATES
7464                         *********************************************
7465 0004                    EOT     EQU     $04             ; END OF TRANSMISSION
7466 0007                    BELL    EQU     $07             ; BELL CHARACTER
7467 000a                    LF      EQU     $0A             ; LINE FEED
7468                         *CR     EQU     $0D             ; CARRIAGE RETURN
7469 0010                    DLE     EQU     $10             ; DATA LINK ESCAPE
7470 0018                    CAN     EQU     $18             ; CANCEL (CTL-X)
7471                         
7472                         * PTM ACCESS DEFINITIONS
7473 0001                    PTMSTA  EQU     PTM+1           ; READ STATUS REGISTER
7474 0000                    PTMC13  EQU     PTM             ; CONTROL REGISTERS 1 AND 3
7475 0001                    PTMC2   EQU     PTM+1           ; CONTROL REGISTER 2
7476 0002                    PTMTM1  EQU     PTM+2           ; LATCH 1
7477 0004                    PTMTM2  EQU     PTM+4           ; LATCH 2
7478 0006                    PTMTM3  EQU     PTM+6           ; LATCH 3
7479 008c                    SKIP2   EQU     $8C             ; "CMPX #" OPCODE - SKIPS TWO BYTES
7480                         
7481                         *******************************************
7482                         * ASSIST09 MONITOR SWI FUNCTIONS
7483                         * THE FOLLOWING EQUATES DEFINE FUNCTIONS PROVIDED
7484                         * BY THE ASSIST09 MONITOR VIA THE SWI INSTRUCTION.
7485                         ******************************************
7486 0000                    INCHNP  EQU     0               ; INPUT CHAR IN A REG - NO PARITY
7487 0001                    OUTCH   EQU     1               ; OUTPUT CHAR FROM A REG
7488 0002                    PDATA1  EQU     2               ; OUTPUT STRING
7489 0003                    PDATA   EQU     3               ; OUTPUT CR/LF THEN STRING
7490 0004                    OUT2HS  EQU     4               ; OUTPUT TWO HEX AND SPACE
7491 0005                    OUT4HS  EQU     5               ; OUTPUT FOUR HEX AND SPACE
7492 0006                    PCRLF   EQU     6               ; OUTPUT CR/LF
7493 0007                    SPACEF  EQU     7               ; OUTPUT A SPACE
7494 0008                    MONITR  EQU     8               ; ENTER ASSIST09 MONITOR
7495 0009                    VCTRSW  EQU     9               ; VECTOR EXAMINE/SWITCH
7496 000a                    BRKPT   EQU     10              ; USER PROGRAM BREAKPOINT
7497 000b                    PAUSE   EQU     11              ; TASK PAUSE FUNCTION
7498 000b                    NUMFUN  EQU     11              ; NUMBER OF AVAILABLE FUNCTIONS
7499                         
7500                         * NEXT SUB-CODES FOR ACCESSING THE VECTOR TABLE.
7501                         * THEY ARE EQUIVALENT TO OFFSETS IN THE TABLE.
7502                         * RELATIVE POSITIONING MUST BE MAINTAINED
7503                         
7504 0000                    .AVTBL  EQU     0               ; ADDRESS OF VECTOR TABLE
7505 0002                    .CMDL1  EQU     2               ; FIRST COMMAND LIST
7506 0004                    .RSVD   EQU     4               ; RESERVED HARDWARE VECTOR
7507 0006                    .SWI3   EQU     6               ; SWI3 ROUTINE
7508 0008                    .SWI2   EQU     8               ; SWI2 ROUTINE
7509 000a                    .FIRQ   EQU     10              ; FIRQ ROUTINE
7510 000c                    .IRQ    EQU     12              ; IRQ ROUTINE
7511 000e                    .SWI    EQU     14              ; SWI ROUTINE
7512 0010                    .NMI    EQU     16              ; NMI ROUTINE
7513 0012                    .RESET  EQU     18              ; RESET ROUTINE
7514 0014                    .CION   EQU     20              ; CONSOLE ON
7515 0016                    .CIDTA  EQU     22              ; CONSOLE INPUT DATA
7516 0018                    .CIOFF  EQU     24              ; CONSOLE INPUT OFF
7517 001a                    .COON   EQU     26              ; CONSOLE OUTPUT ON
7518 001c                    .CODTA  EQU     28              ; CONSOLE OUTPUT DATA
7519 001e                    .COOFF  EQU     30              ; CONSOLE OUTPUT OFF
7520 0020                    .HSDTA  EQU     32              ; HIGH SPEED PRINTDATA
7521 0022                    .BSON   EQU     34              ; PUNCH/LOAD ON
7522 0024                    .BSDTA  EQU     36              ; PUNCH/LOAD DATA
7523 0026                    .BSOFF  EQU     38              ; PUNCH/LOAD OFF
7524 0028                    .PAUSE  EQU     40              ; TASK PAUSE ROUTINE
7525 002a                    .EXPAN  EQU     42              ; EXPRESSION ANALYZER
7526 002c                    .CMDL2  EQU     44              ; SECOND COMMAND LIST
7527 002e                    .ACIA   EQU     46              ; ACIA ADDRESS
7528 0030                    .PAD    EQU     48              ; CHARACTER PAD AND NEW LINE PAD
7529 0032                    .ECHO   EQU     50              ; ECHO/LOAD AND NULL BKPT FLAG
7530 0034                    .PTM    EQU     52              ; PTM ADDRESS
7531 001b                    NUMVTR  EQU     52/2+1          ; NUMBER OF VECTORS
7532 0034                    HIVTR   EQU     52              ; HIGHEST VECTOR OFFSET
7533                         
7534                         ******************************************
7535                         *           WORK AREA
7536                         * THIS WORK AREA IS ASSIGNED TO THE PAGE ADDRESSED BY
7537                         * -$1800,PCR FROM THE BASE ADDRESS OF THE ASSIST09
7538                         * ROM. THE DIRECT PAGE REGISTER DURING MOST ROUTINE
7539                         * OPERATIONS WILL POINT TO THIS WORK AREA. THE STACK
7540                         * INITIALLY STARTS UNDER THE RESERVED WORK AREAS AS
7541                         * DEFINED HEREIN.
7542                         ******************************************
7543 7000                    WORKPG  EQU     ROMBEG+RAMOFS   ; SETUP DIRECT PAGE ADDRESS
7544                         *       SETDP   =WORKPG         ; NOTIFY ASSEMBLER
7545 7100                            ORG     WORKPG+256      ; READY PAGE DEFINITIONS
7546                         
7547                         * THE FOLLOWING THRU BKPTOP MUST RESIDE IN THIS ORDER
7548                         * FOR PROPER INITIALIZATION
7549 70fc                            ORG     *-4
7550 70fc                    PAUSER  EQU     *               ; PAUSE ROUTINE
7551 70fb                            ORG     *-1
7552 70fb                    SWIBFL  EQU     *               ; BYPASS SWI AS BREAKPOINT FLAG
7553 70fa                            ORG     *-1
7554 70fa                    BKPTCT  EQU     *               ; BREAKPOINT COUNT
7555 70f8                            ORG     *-2             ; SLEVEL EQU
7556 70f8                    SLEVEL  EQU     *               ; STACK TRACE LEVEL
7557 70c2                            ORG     -NUMVTR*2+*
7558 70c2                    VECTAB  EQU     *               ; VECTOR TABLE
7559 70b2                            ORG     -2*NUMBKP+*
7560 70b2                    BKPTBL  EQU     *               ; BREAKPOINT TABLE
7561 70a2                            ORG     -2*NUMBKP+*
7562 70a2                    BKPTOP  EQU     *               ; BREAKPOINT OPCODE TABLE
7563 70a0                            ORG     *-2
7564 70a0                    WINDOW  EQU     *               ; WINDOW
7565 709e                            ORG     *-2
7566 709e                    ADDR    EQU     *               ; ADDRESS POINTER VALUE
7567 709d                            ORG     *-1
7568 709d                    BASEPG  EQU     *               ; BASE PAGE VALUE
7569 709b                            ORG     *-2
7570 709b                    NUMBER  EQU     *               ; BINARY BUILD AREA
7571 7099                            ORG     *-2
7572 7099                    LASTOP  EQU     *               ; LAST OPCODE TRACED
7573 7097                            ORG     *-2
7574 7097                    RSTACK  EQU     *               ; RESET STACK POINTER
7575 7095                            ORG     *-2
7576 7095                    PSTACK  EQU     *               ; COMMAND RECOVERY STACK
7577 7093                            ORG     *-2
7578 7093                    PCNTER  EQU     *               ; LAST PROGRAM COUNTER
7579 7091                            ORG     *-2
7580 7091                    TRACEC  EQU     *               ; TRACE COUNT
7581 7090                            ORG     *-1
7582 7090                    SWICNT  EQU     *               ; TRACE "SWI" NEST LEVEL COUNT
7583 708f                            ORG     *-1             ; (MISFLG MUST FOLLOW SWICNT)
7584 708f                    MISFLG  EQU     *               ; LOAD CMD/THRU BREAKPOINT FLAG
7585 708e                            ORG     *-1
7586 708e                    DELIM   EQU     *               ; EXPRESSION DELIMITER/WORK BYTE
7587 7066                            ORG     *-40
7588 7066                    ROM2WK  EQU     *               ; EXTENSION ROM RESERVED AREA
7589 7051                            ORG     *-21
7590 7051                    TSTACK  EQU     *               ; TEMPORARY STACK HOLD
7591 7051                    STACK   EQU     *               ; START OF INITIAL STACK
7592                         
7593                         ******************************************
7594                         * DEFAULT THE ROM BEGINNING ADDRESS TO 'ROMBEG'
7595                         * ASSIST09 IS POSITION ADDRESS INDEPENDENT, HOWEVER
7596                         * WE ASSEMBLE ASSUMING CONTROL OF THE HARDWARE VECTORS.
7597                         * NOTE THAT THE WORK RAM PAGE MUST BE 'RAMOFS'
7598                         * FROM THE ROM BEGINNING ADDRESS.
7599                         ********************************************
7600 f800                            ORG     ROMBEG          ; ROM ASSEMBLY/DEFAULT ADDRESS
7601                         
7602                         *****************************************************
7603                         * BLDVTR - BUILD ASSIST09 VECTOR TABLE
7604                         * HARDWARE RESET CALLS THIS SUBROUTINE TO BUILD THE
7605                         * ASSIST09 VECTOR TABLE. THIS SUBROUTINE RESIDES AT
7606                         * THE FIRST BYTE OF THE ASSIST09 ROM, AND CAN BE
7607                         * CALLED VIA EXTERNAL CONTROL CODE FOR REMOTE
7608                         * ASSIST09 EXECUTION.
7609                         * INPUT: S->VALID STACK RAM
7610                         * OUTPUT: U->VECTOR TABLE ADDRESS
7611                         * DPR->ASSIST09 WORK AREA PAGE
7612                         * THE VECTOR TABLE AND DEFAULTS ARE INITIALIZED
7613                         * ALL REGISTERS VOLATILE
7614                         *************************************************
7615 f800 30 8d 78 be        BLDVTR  LEAX    VECTAB,PCR      ; ADDRESS VECTOR TABLE
7616 f804 1f 10                      TFR     X,D             ; OBTAIN BASE PAGE ADDRESS
7617 f806 1f 8b                      TFR     A,DP            ; SETUP DPR
7618 f808 97 9d                      STA     <BASEPG         ; STORE FOR QUICK REFERENCE
7619 f80a 33 84                      LEAU    ,X              ; RETURN TABLE TO CALLER
7620 f80c 31 8c 35                   LEAY    <INITVT,PCR     ; LOAD FROM ADDR
7621 f80f ef 81                      STU     ,X++            ; INIT VECTOR TABLE ADDRESS
7622 f811 c6 16                      LDB     #NUMVTR-5       ; NUMBER RELOCATABLE VECTORS
7623 f813 34 04                      PSHS    B               ; STORE INDEX ON STACK
7624 f815 1f 20              BLD2    TFR     Y,D             ; PREPARE ADDRESS RESOLVE
7625 f817 e3 a1                      ADDD    ,Y++            ; TO ABSOLUTE ADDRESS
7626 f819 ed 81                      STD     ,X++            ; INTO VECTOR TABLE
7627 f81b 6a e4                      DEC     ,S              ; COUNT DOWN
7628 f81d 26 f6                      BNE     BLD2            ; BRANCH IF MORE TO INSERT
7629 f81f c6 0d                      LDB     #INTVE-INTVS    ; STATIC VALUE INIT LENGTH
7630 f821 a6 a0              BLD3    LDA     ,Y+             ; LOAD NEXT BYTE
7631 f823 a7 80                      STA     ,X+             ; STORE INTO POSITION
7632 f825 5a                         DECB                    ; COUNT DOWN
7633 f826 26 f9                      BNE     BLD3            ; LOOP UNTIL DONE
7634 f828 31 8d f7 d4                LEAY    ROM2OF,PCR      ; TEST POSSIBLE EXTENSION ROM
7635 f82c 8e 20 fe                   LDX     #$20FE          ; LOAD "BRA *" FLAG PATTERN
7636 f82f ac a1                      CMPX    ,Y++            ; ? EXTENDED ROM HERE
7637 f831 26 02                      BNE     BLDRTN          ; BRANCH NOT OUR ROM TO RETURN
7638 f833 ad a4                      JSR     ,Y              ; CALL EXTENDED ROM INITIALIZE
7639 f835 35 84              BLDRTN  PULS    PC,B            ; RETURN TO INITIALIZER
7640                         
7641                         *****************************************************
7642                         *                RESET ENTRY POINT
7643                         * HARDWARE RESET ENTERS HERE IF ASSIST09 IS ENABLED
7644                         * TO RECEIVE THE MC6809 HARDWARE VECTORS. WE CALL
7645                         * THE BLDVTR SUBROUTINE TO INITIALIZE THE VECTOR
7646                         * TABLE, STACK, AND THEN FIREUP THE MONITOR VIA SWI
7647                         * CALL.
7648                         *******************************************************
7649 f837 32 8d 78 16        RESET   LEAS    STACK,PCR       ; SETUP INITIAL STACK
7650 f83b 8d c3                      BSR     BLDVTR          ; BUILD VECTOR TABLE
7651 f83d 4f                 RESET2  CLRA                    ; ISSUE STARTUP MESSAGE
7652 f83e 1f 8b                      TFR     A,DP            ; DEFAULT TO PAGE ZERO
7653 f840 3f                         SWI                     ; PERFORM MONITOR FIREUP
7654 f841 08                         FCB     MONITR          ; TO ENTER COMMAND PROCESSING
7655 f842 20 f9                      BRA     RESET2          ; REENTER MONITOR IF 'CONTINUE'
7656                         
7657                         ******************************************************
7658                         *        INITVT - INITIAL VECTOR TABLE
7659                         * THIS TABLE IS RELOCATED TO RAM AND REPRESENTS THE
7660                         * INITIAL STATE OF THE VECTOR TABLE. ALL ADDRESSES
7661                         * ARE CONVERTED TO ABSOLUTE FORM. THIS TABLE STARTS
7662                         * WITH THE SECOND ENTRY, ENDS WITH STATIC CONSTANT
7663                         * INITIALIZATION DATA WHICH CARRIES BEYOND THE TABLE.
7664                         ************************************************
7665 f844 01 5c              INITVT  FDB     CMDTBL-*        ; DEFAULT FIRST COMMAND TABLE
7666 f846 02 8e                      FDB     RSRVDR-*        ; DEFAULT UNDEFINED HARDWARE VECTOR
7667 f848 02 8c                      FDB     SWI3R-*         ; DEFAULT SWI3
7668 f84a 02 8a                      FDB     SWI2R-*         ; DEFAULT SWI2
7669 f84c 02 6c                      FDB     FIRQR-*         ; DEFAULT FIRQ
7670 f84e 02 86                      FDB     IRQR-*          ; DEFAULT IRQ ROUTINE
7671 f850 00 45                      FDB     SWIR-*          ; DEFAULT SWI ROUTINE
7672 f852 02 27                      FDB     NMIR-*          ; DEFAULT NMI ROUTINE
7673 f854 ff e3                      FDB     RESET-*         ; RESTART VECTOR
7674 f856 02 8c                      FDB     CION-*          ; DEFAULT CION
7675 f858 02 80                      FDB     CIDTA-*         ; DEFAULT CIDTA
7676 f85a 02 92                      FDB     CIOFF-*         ; DEFAULT CIOFF
7677 f85c 02 86                      FDB     COON-*          ; DEFAULT COON
7678 f85e 02 8f                      FDB     CODTA-*         ; DEFAULT CODTA
7679 f860 02 8c                      FDB     COOFF-*         ; DEFAULT COOFF
7680 f862 03 96                      FDB     HSDTA-*         ; DEFAULT HSDTA
7681 f864 02 b3                      FDB     BSON-*          ; DEFAULT BSON
7682 f866 02 ce                      FDB     BSDTA-*         ; DEFAULT BSDTA
7683 f868 02 bb                      FDB     BSOFF-*         ; DEFAULT BSOFF
7684 f86a 78 92                      FDB     PAUSER-*        ; DEFAULT PAUSE ROUTINE
7685 f86c 04 79                      FDB     EXP1-*          ; DEFAULT EXPRESSION ANALYZER
7686 f86e 01 2d                      FDB     CMDTB2-*        ; DEFAULT SECOND COMMAND TABLE
7687                         * CONSTANTS
7688 f870 a0 00              INTVS   FDB     ACIA            ; DEFAULT ACIA
7689 f872 00 05                      FCB     DFTCHP,DFTNLP   ; DEFAULT NULL PADDS
7690 f874 00 00                      FDB     0               ; DEFAULT ECHO
7691 f876 00 00                      FDB     PTM             ; DEFAULT PTM
7692 f878 00 00                      FDB     0               ; INITIAL STACK TRACE LEVEL
7693 f87a 00                         FCB     0               ; INITIAL BREAKPOINT COUNT
7694 f87b 00                         FCB     0               ; SWI BREAKPOINT LEVEL
7695 f87c 39                         FCB     $39             ; DEFAULT PAUSE ROUTINE (RTS)
7696 f87d                    INTVE   EQU     *
7697                         *B
7698                         ***********************************************
7699                         *            ASSIST09 SWI HANDLER
7700                         * THE SWI HANDLER PROVIDES ALL INTERFACING NECESSARY
7701                         * FOR A USER PROGRAM. A FUNCTION BYTE IS ASSUMED TO
7702                         * FOLLOW THE SWI INSTRUCTION. IT IS BOUND CHECKED
7703                         * AND THE PROPER ROUTINE IS GIVEN CONTROL. THIS
7704                         * INVOCATION MAY ALSO BE A BREAKPOINT INTERRUPT.
7705                         * IF SO, THE BREAKPOINT HANDLER IS ENTERED.
7706                         * INPUT: MACHINE STATE DEFINED FOR SWI
7707                         * OUTPUT: VARIES ACCORDING TO FUNCTION CALLED. PC ON
7708                         * CALLERS STACK INCREMENTED BY ONE IF VALID CALL.
7709                         * VOLATILE REGISTERS: SEE FUNCTIONS CALLED
7710                         * STATE: RUNS DISABLED UNLESS FUNCTION CLEARS I FLAG.
7711                         ************************************************
7712                         * SWI FUNCTION VECTOR TABLE
7713 f87d 01 90              SWIVTB  FDB     ZINCH-SWIVTB    ; INCHNP
7714 f87f 01 ad                      FDB     ZOTCH1-SWIVTB   ; OUTCH
7715 f881 01 c7                      FDB     ZPDTA1-SWIVTB   ; PDATA1
7716 f883 01 bf                      FDB     ZPDATA-SWIVTB   ; PDATA
7717 f885 01 71                      FDB     ZOT2HS-SWIVTB   ; OUT2HS
7718 f887 01 6f                      FDB     ZOT4HS-SWIVTB   ; OUT4HS
7719 f889 01 bc                      FDB     ZPCRLF-SWIVTB   ; PCRLF
7720 f88b 01 75                      FDB     ZSPACE-SWIVTB   ; SPACE
7721 f88d 00 55                      FDB     ZMONTR-SWIVTB   ; MONITR
7722 f88f 01 79                      FDB     ZVSWTH-SWIVTB   ; VCTRSW
7723 f891 02 52                      FDB     ZBKPNT-SWIVTB   ; BREAKPOINT
7724 f893 01 cd                      FDB     ZPAUSE-SWIVTB   ; TASK PAUSE
7725                         
7726 f895 6a 8d 77 f7        SWIR    DEC     SWICNT,PCR      ; UP "SWI" LEVEL FOR TRACE
7727 f899 17 02 21                   LBSR    LDDP            ; SETUP PAGE AND VERIFY STACK
7728                         * CHECK FOR BREAKPOINT TRAP
7729 f89c ee 6a                      LDU     10,S            ; LOAD PROGRAM COUNTER
7730 f89e 33 5f                      LEAU    -1,U            ; BACK TO SWI ADDRESS
7731 f8a0 0d fb                      TST     <SWIBFL         ; ? THIS "SWI" BREAKPOINT
7732 f8a2 26 11                      BNE     SWIDNE          ; BRANCH IF SO TO LET THROUGH
7733 f8a4 17 06 97                   LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
7734 f8a7 50                         NEGB                    ; OBTAIN POSITIVE COUNT
7735 f8a8 5a                 SWILP   DECB                    ; COUNT DOWN
7736 f8a9 2b 0a                      BMI     SWIDNE          ; BRANCH WHEN DONE
7737 f8ab 11 a3 a1                   CMPU    ,Y++            ; ? WAS THIS A BREAKPOINT
7738 f8ae 26 f8                      BNE     SWILP           ; BRANCH IF NOT
7739 f8b0 ef 6a                      STU     10,S            ; SET PROGRAM COUNTER BACK
7740 f8b2 16 02 1a                   LBRA    ZBKPNT          ; GO DO BREAKPOINT
7741 f8b5 0f fb              SWIDNE  CLR     <SWIBFL         ; CLEAR IN CASE SET
7742 f8b7 37 06                      PULU    D               ; OBTAIN FUNCTION BYTE, UP PC
7743 f8b9 c1 0b                      CMPB    #NUMFUN         ; ? TOO HIGH
7744 f8bb 10 22 02 0b                LBHI    ERROR           ; YES, DO BREAKPOINT
7745 f8bf ef 6a                      STU     10,S            ; BUMP PROGRAM COUNTER PAST SWI
7746 f8c1 58                         ASLB                    ; FUNCTION CODE TIMES TWO
7747 f8c2 33 8c b8                   LEAU    SWIVTB,PCR      ; OBTAIN VECTOR BRANCH ADDRESS
7748 f8c5 ec c5                      LDD     B,U             ; LOAD OFFSET
7749 f8c7 6e cb                      JMP     D,U             ; JUMP TO ROUTINE
7750                         
7751                         **********************************************
7752                         * REGISTERS TO FUNCTION ROUTINES:
7753                         *  DP-> WORK AREA PAGE
7754                         *  D,Y,U=UNRELIABLE           X=AS CALLED FROM USER
7755                         *  S=AS FROM SWI INTERRUPT
7756                         *********************************************
7757                         
7758                         **************************************************
7759                         *            [SWI FUNCTION 8]
7760                         *              MONITOR ENTRY
7761                         *  FIREUP THE ASSIST09 MONITOR.
7762                         *  THE STACK WITH ITS VALUES FOR THE DIRECT PAGE
7763                         *  REGISTER AND CONDITION CODE FLAGS ARE USED AS IS.
7764                         *   1) INITIALIZE CONSOLE I/O
7765                         *   2) OPTIONALLY PRINT SIGNON
7766                         *   3) INITIALIZE PTM FOR SINGLE STEPPING
7767                         *   4) ENTER COMMAND PROCESSOR
7768                         * INPUT: A=0 INIT CONSOLE AND PRINT STARTUP MESSAGE
7769                         *        A#0 OMIT CONSOLE INIT AND STARTUP MESSAGE
7770                         *************************************************
7771                         
7772 f8c9 41 53 53 49 53 54  SIGNON  FCC     /ASSIST09/      ; SIGNON EYE-CATCHER
     30 39
7773 f8d1 04                         FCB     EOT
7774 f8d2 10 df 97           ZMONTR  STS     <RSTACK         ; SAVE FOR BAD STACK RECOVERY
7775 f8d5 6d 61                      TST     1,S             ; ? INIT CONSOLE AND SEND MSG
7776 f8d7 26 0d                      BNE     ZMONT2          ; BRANCH IF NOT
7777 f8d9 ad 9d 77 f9                JSR     [VECTAB+.CION,PCR] ; READY CONSOLE INPUT
7778 f8dd ad 9d 77 fb                JSR     [VECTAB+.COON,PCR] ; READY CONSOLE OUTPUT
7779 f8e1 30 8c e5                   LEAX    SIGNON,PCR         ; READY SIGNON EYE-CATCHER
7780 f8e4 3f                         SWI                     ; PERFORM
7781 f8e5 03                         FCB     PDATA           ; PRINT STRING
7782 f8e6 9e f6              ZMONT2  LDX     <VECTAB+.PTM    ; LOAD PTM ADDRESS
7783 f8e8 27 0d                      BEQ     CMD             ; BRANCH IF NOT TO USE A PTM
7784 f8ea 6f 02                      CLR     PTMTM1-PTM,X    ; SET LATCH TO CLEAR RESET
7785 f8ec 6f 03                      CLR     PTMTM1+1-PTM,X  ; AND SET GATE HIGH
7786 f8ee cc 01 a6                   LDD     #$01A6          ; SETUP TIMER 1 MODE
7787 f8f1 a7 01                      STA     PTMC2-PTM,X     ; SETUP FOR CONTROL REGISTER1
7788 f8f3 e7 84                      STB     PTMC13-PTM,X    ; SET OUTPUT ENABLED/
7789                         * SINGLE SHOT/ DUAL 8 BIT/INTERNAL MODE/OPERATE
7790 f8f5 6f 01                      CLR     PTMC2-PTM,X     ; SET CR2 BACK TO RESET FORM
7791                         * FALL INTO COMMAND PROCESSOR
7792                         
7793                         ***************************************************
7794                         *          COMMAND HANDLER
7795                         *  BREAKPOINTS ARE REMOVED AT THIS TIME.
7796                         *  PROMPT FOR A COMMAND, AND STORE ALL CHARACTERS
7797                         *  UNTIL A SEPARATOR ON THE STACK.
7798                         *  SEARCH FOR FIRST MATCHING COMMAND SUBSET,
7799                         *  CALL IT OR GIVE '?' RESPONSE.
7800                         *  DURING COMMAND SEARCH:
7801                         *      B=OFFSET TO NEXT ENTRY ON X
7802                         *      U=SAVED S
7803                         *      U-1=ENTRY SIZE+2
7804                         *      U-2=VALID NUMBER FLAG (>=0 VALID)/COMPARE CNT
7805                         *      U-3=CARRIAGE RETURN FLAG (0=CR HAS BEEN DONE)
7806                         *      U-4=START OF COMMAND STORE
7807                         *      S+0=END OF COMMAND STORE
7808                         ***********************************************
7809                         
7810 f8f7 3f                 CMD     SWI                     ; TO NEW LINE
7811 f8f8 06                         FCB     PCRLF           ; FUNCTION
7812                         * DISARM THE BREAKPOINTS
7813 f8f9 17 06 42           CMDNEP  LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
7814 f8fc 2a 0c                      BPL     CMDNOL          ; BRANCH IF NOT ARMED OR NONE
7815 f8fe 50                         NEGB                    ; MAKE POSITIVE
7816 f8ff d7 fa                      STB     <BKPTCT         ; FLAG AS DISARMED
7817 f901 5a                 CMDDDL  DECB                    ; ? FINISHED
7818 f902 2b 06                      BMI     CMDNOL          ; BRANCH IF SO
7819 f904 a6 30                      LDA     -NUMBKP*2,Y     ; LOAD OPCODE STORED
7820 f906 a7 b1                      STA     [,Y++]          ; STORE BACK OVER "SWI"
7821 f908 20 f7                      BRA     CMDDDL          ; LOOP UNTIL DONE
7822 f90a ae 6a              CMDNOL  LDX     10,S            ; LOAD USERS PROGRAM COUNTER
7823 f90c 9f 93                      STX     <PCNTER         ; SAVE FOR EXPRESSION ANALYZER
7824 f90e 86 3e                      LDA     #PROMPT         ; LOAD PROMPT CHARACTER
7825 f910 3f                         SWI                     ; SEND TO OUTPUT HANDLER
7826 f911 01                         FCB     OUTCH           ; FUNCTION
7827 f912 33 e4                      LEAU    ,S              ; REMEMBER STACK RESTORE ADDRESS
7828 f914 df 95                      STU     <PSTACK         ; REMEMBER STACK FOR ERROR USE
7829 f916 4f                         CLRA                    ; PREPARE ZERO
7830 f917 5f                         CLRB                    ; PREPARE ZERO
7831 f918 dd 9b                      STD     <NUMBER         ; CLEAR NUMBER BUILD AREA
7832 f91a dd 8f                      STD     <MISFLG         ; CLEAR MISCEL. AND SWICNT FLAGS
7833 f91c dd 91                      STD     <TRACEC         ; CLEAR TRACE COUNT
7834 f91e c6 02                      LDB     #2              ; SET D TO TWO
7835 f920 34 07                      PSHS    D,CC            ; PLACE DEFAULTS ONTO STACK
7836                         * CHECK FOR "QUICK" COMMANDS.
7837 f922 17 04 50                   LBSR    READC           ; OBTAIN FIRST CHARACTER
7838 f925 30 8d 05 7d                LEAX    CDOT+2,PCR      ; PRESET FOR SINGLE TRACE
7839 f929 81 2e                      CMPA    #'.             ; ? QUICK TRACE
7840 f92b 27 5a                      BEQ     CMDXQT          ; BRANCH EQUAL FOR TRACE ONE
7841 f92d 30 8d 04 e5                LEAX    CMPADP+2,PCR    ; READY MEMORY ENTRY POINT
7842 f931 81 2f                      CMPA    #'/             ; ? OPEN LAST USED MEMORY
7843 f933 27 52                      BEQ     CMDXQT          ; BRANCH TO DO IT IF SO
7844                         * PROCESS NEXT CHARACTER
7845 f935 81 20              CMD2    CMPA    #'              ; ? BLANK OR DELIMITER
7846 f937 23 14                      BLS    CMDGOT           ; BRANCH YES, WE HAVE IT
7847 f939 34 02                      PSHS   A                ; BUILD ONTO STACK
7848 f93b 6c 5f                      INC    -1,U             ; COUNT THIS CHARACTER
7849 f93d 81 2f                      CMPA   #'/              ; ? MEMORY COMMAND
7850 f93f 27 4f                      BEQ    CMDMEM           ; BRANCH IF SO
7851 f941 17 04 07                   LBSR   BLDHXC           ; TREAT AS HEX VALUE
7852 f944 27 02                      BEQ    CMD3             ; BRANCH IF STILL VALID NUMBER
7853 f946 6a 5e                      DEC    -2,U             ; FLAG AS INVALID NUMBER
7854 f948 17 04 2a           CMD3    LBSR   READC            ; OBTAIN NEXT CHARACTER
7855 f94b 20 e8                      BRA    CMD2             ; TEST NEXT CHARACTER
7856                         * GOT COMMAND, NOW SEARCH TABLES
7857 f94d 80 0d              CMDGOT  SUBA   #CR              ; SET ZERO IF CARRIAGE RETURN
7858 f94f a7 5d                      STA    -3,U             ; SETUP FLAG
7859 f951 9e c4                      LDX    <VECTAB+.CMDL1   ; START WITH FIRST CMD LIST
7860 f953 e6 80              CMDSCH  LDB    ,X+              ; LOAD ENTRY LENGTH
7861 f955 2a 10                      BPL    CMDSME           ; BRANCH IF NOT LIST END
7862 f957 9e ee                      LDX    <VECTAB+.CMDL2   ; NOW TO SECOND CMD LITS
7863 f959 5c                         INCB                    ; ? TO CONTINUE TO DEFAULT LIST
7864 f95a 27 f7                      BEQ     CMDSCH          ; BRANCH IF SO
7865 f95c 10 de 95           CMDBAD  LDS     <PSTACK         ; RESTORE STACK
7866 f95f 30 8d 01 56                LEAX    ERRMSG,PCR      ; POINT TO ERROR STRING
7867 f963 3f                         SWI                     ; SEND OUT
7868 f964 02                         FCB     PDATA1          ; TO CONSOLE
7869 f965 20 90                      BRA     CMD             ; AND TRY AGAIN
7870                         * SEARCH NEXT ENTRY
7871 f967 5a                 CMDSME  DECB                    ; TAKE ACCOUNT OF LENGTH BYTE
7872 f968 e1 5f                      CMPB    -1,U            ; ? ENTERED LONGER THAN ENTRY
7873 f96a 24 03                      BHS     CMDSIZ          ; BRANCH IF NOT TOO LONG
7874 f96c 3a                 CMDFLS  ABX                     ; SKIP TO NEXT ENTRY
7875 f96d 20 e4                      BRA     CMDSCH          ; AND TRY NEXT
7876 f96f 31 5d              CMDSIZ  LEAY    -3,U            ; PREPARE TO COMPARE
7877 f971 a6 5f                      LDA     -1,U            ; LOAD SIZE+2
7878 f973 80 02                      SUBA    #2              ; TO ACTUAL SIZE ENTERED
7879 f975 a7 5e                      STA     -2,U            ; SAVE SIZE FOR COUNTDOWN
7880 f977 5a                 CMDCMP  DECB                    ; DOWN ONE BYTE
7881 f978 a6 80                      LDA     ,X+             ; NEXT COMMAND CHARACTER
7882 f97a a1 a2                      CMPA    ,-Y             ; ? SAME AS THAT ENTERED
7883 f97c 26 ee                      BNE     CMDFLS          ; BRANCH TO FLUSH IF NOT
7884 f97e 6a 5e                      DEC     -2,U            ; COUNT DOWN LENGTH OF ENTRY
7885 f980 26 f5                      BNE     CMDCMP          ; BRANCH IF MORE TO TEST
7886 f982 3a                         ABX                     ; TO NEXT ENTRY
7887 f983 ec 1e                      LDD     -2,X            ; LOAD OFFSET
7888 f985 30 8b                      LEAX    D,X             ; COMPUTE ROUTINE ADDRESS+2
7889 f987 6d 5d              CMDXQT  TST     -3,U            ; SET CC FOR CARRIAGE RETURN TEST
7890 f989 32 c4                      LEAS    ,U              ; DELETE STACK WORK AREA
7891 f98b ad 1e                      JSR     -2,X            ; CALL COMMAND
7892 f98d 16 ff 7a                   LBRA    CMDNOL          ; GO GET NEXT COMMAND
7893 f990 6d 5e              CMDMEM  TST     -2,U            ; ? VALID HEX NUMBER ENTERED
7894 f992 2b c8                      BMI     CMDBAD          ; BRANCH ERROR IF NOT
7895 f994 30 88 ae                   LEAX    <CMEMN-CMPADP,X ; TO DIFFERENT ENTRY
7896 f997 dc 9b                      LDD     <NUMBER         ; LOAD NUMBER ENTERED
7897 f999 20 ec                      BRA     CMDXQT          ; AND ENTER MEMORY COMMAND
7898                         
7899                         ** COMMANDS ARE ENTERED AS A SUBROUTINE WITH:
7900                         **    DPR->ASSIST09 DIRECT PAGE WORK AREA
7901                         **    Z=1 CARRIAGE RETURN ENTERED
7902                         **    Z=0 NON CARRIAGE RETURN DELIMITER
7903                         **    S=NORMAL RETURN ADDRESS
7904                         ** THE LABEL "CMDBAD" MAY BE ENTERED TO ISSUE AN
7905                         ** AN ERROR FLAG (*).
7906                         **************************************************
7907                         *       ASSIST09 COMMAND TABLES
7908                         * THESE ARE THE DEFAULT COMMAND TABLES. EXTERNAL
7909                         * TABLES OF THE SAME FORMAT MAY EXTEND/REPLACE
7910                         * THESE BY USING THE VECTOR SWAP FUNCTION.
7911                         *
7912                         * ENTRY FORMAT:
7913                         *    +0...TOTAL SIZE OF ENTRY (INCLUDING THIS BYTE)
7914                         *    +1...COMMAND STRING
7915                         *    +N...TWO BYTE OFFSET TO COMMAND (ENTRYADDR-*)
7916                         *
7917                         * THE TABLES TERMINATE WITH A ONE BYTE -1 OR -2.
7918                         * THE -1 CONTINUES THE COMMAND SEARCH WITH THE
7919                         *        SECOND COMMAND TABLE.
7920                         * THE -2 TERMINATES COMMAND SEARCHES.
7921                         *****************************************************
7922                         
7923                         * THIS IS THE DEFAULT LIST FOR THE SECOND COMMAND
7924                         * LIST ENTRY.
7925                         
7926 f99b 04                 CMDTB2  FCB     4               ; TABLE ENTRY LENGTH
7927 f99c 55                         FCC     'U'             ; 'UNASSEMBLE' COMMAND
7928 f99d c6 63                      FDB     CUNAS-*         ; POINTER TO COMMAND (RELATIVE TO HERE)
7929 f99f fe                         FCB     -2              ; -2 INDICATES END OF TABLE
7930                         
7931                         * THIS IS THE DEFAULT LIST FOR THE FIRST COMMAND
7932                         * LIST ENTRY.
7933                         
7934 f9a0                    CMDTBL  EQU     *               ; MONITOR COMMAND TABLE
7935 f9a0 04                         FCB     4
7936 f9a1 42                         FCC     /B/             ; 'BREAKPOINT' COMMAND
7937 f9a2 05 45                      FDB     CBKPT-*
7938 f9a4 04                         FCB     4
7939 f9a5 43                         FCC     /C/             ; 'CALL' COMMAND
7940 f9a6 04 0f                      FDB     CCALL-*
7941 f9a8 04                         FCB     4
7942 f9a9 44                         FCC     /D/             ; 'DISPLAY' COMMAND
7943 f9aa 04 95                      FDB     CDISP-*
7944 f9ac 04                         FCB     4
7945 f9ad 45                         FCC     /E/             ; 'ENCODE' COMMAND
7946 f9ae 05 97                      FDB     CENCDE-*
7947 f9b0 04                         FCB     4
7948 f9b1 47                         FCC     /G/             ; 'GO' COMMAND
7949 f9b2 03 ca                      FDB     CGO-*
7950 f9b4 04                         FCB     4
7951 f9b5 4c                         FCC     /L/             ; 'LOAD' COMMAND
7952 f9b6 04 d5                      FDB     CLOAD-*
7953 f9b8 04                         FCB     4
7954 f9b9 4d                         FCC     /M/             ; 'MEMORY' COMMAND
7955 f9ba 04 05                      FDB     CMEM-*
7956 f9bc 04                         FCB     4
7957 f9bd 4e                         FCC     /N/             ; 'NULLS' COMMAND
7958 f9be 04 f5                      FDB     CNULLS-*
7959 f9c0 04                         FCB     4
7960 f9c1 4f                         FCC     /O/             ; 'OFFSET' COMMAND
7961 f9c2 05 02                      FDB     COFFS-*
7962 f9c4 04                         FCB     4
7963 f9c5 50                         FCC     /P/             ; 'PUNCH' COMMAND
7964 f9c6 04 a7                      FDB     CPUNCH-*
7965 f9c8 04                         FCB     4
7966 f9c9 52                         FCC     /R/             ; 'REGISTERS' COMMAND
7967 f9ca 02 7c                      FDB     CREG-*
7968                         ;       FCB     4
7969                         ;       FCC     /S/             ; 'STLEVEL' COMMAND - NOT SUPPORTED IN THIS VERSION
7970                         ;       FDB     CSTLEV-*
7971                         ;       FCB     4
7972                         ;       FCC     /T/             ; 'TRACE' COMMAND - NOT SUPPORTED IN THIS VERSION
7973                         ;       FDB     CTRACE-*
7974 f9cc 04                         FCB     4
7975 f9cd 56                         FCC     /V/             ; 'VERIFY' COMMAND
7976 f9ce 04 cf                      FDB     CVER-*
7977 f9d0 04                         FCB     4
7978 f9d1 57                         FCC     /W/             ; 'WINDOW' COMMAND
7979 f9d2 04 68                      FDB     CWINDO-*
7980 f9d4 ff                         FCB     -1              ; END, CONTINUE WITH THE SECOND
7981                         
7982                         *************************************************
7983                         *             [SWI FUNCTIONS 4 AND 5]
7984                         *      4 - OUT2HS - DECODE BYTE TO HEX AND ADD SPACE
7985                         *      5 - OUT4HS - DECODE WORD TO HEX AND ADD SPACE
7986                         * INPUT: X->BYTE OR WORD TO DECODE
7987                         * OUTPUT: CHARACTERS SENT TO OUTPUT HANDLER
7988                         *         X->NEXT BYTE OR WORD
7989                         *************************************************
7990 f9d5 a6 80              ZOUT2H  LDA     ,X+             ; LOAD NEXT BYTE
7991 f9d7 34 06                      PSHS    D               ; SAVE - DO NOT REREAD
7992 f9d9 c6 10                      LDB     #16             ; SHIFT BY 4 BITS
7993 f9db 3d                         MUL                     ; WITH MULTIPLY
7994 f9dc 8d 04                      BSR     ZOUTHX          ; SEND OUT AS HEX
7995 f9de 35 06                      PULS    D               ; RESTORE BYTES
7996 f9e0 84 0f                      ANDA    #$0F            ; ISOLATE RIGHT HEX
7997 f9e2 8b 90              ZOUTHX  ADDA    #$90            ; PREPARE A-F ADJUST
7998 f9e4 19                         DAA                     ; ADJUST
7999 f9e5 89 40                      ADCA    #$40            ; PREPARE CHARACTER BITS
8000 f9e7 19                         DAA                     ; ADJUST
8001 f9e8 6e 9d 76 f2        SEND    JMP     [VECTAB+.CODTA,PCR] ; SEND TO OUT HANDLER
8002                         
8003 f9ec 8d e7              ZOT4HS  BSR     ZOUT2H          ; CONVERT FIRST BYTE
8004 f9ee 8d e5              ZOT2HS  BSR     ZOUT2H          ; CONVERT BYTE TO HEX
8005 f9f0 af 64                      STX     4,S             ; UPDATE USERS X REGISTER
8006                         * FALL INTO SPACE ROUTINE
8007                         
8008                         *************************************************
8009                         *            [SWI FUNCTION 7]
8010                         *         SPACE - SEND BLANK TO OUTPUT HANDLER
8011                         * INPUT: NONE
8012                         * OUTPUT: BLANK SEND TO CONSOLE HANDLER
8013                         *************************************************
8014 f9f2 86 20              ZSPACE  LDA     #'              ; LOAD BLANK
8015 f9f4 20 3d                      BRA     ZOTCH2          ; SEND AND RETURN
8016                         
8017                         ***********************************************
8018                         *             [SWI FUNCTION 9]
8019                         *          SWAP VECTOR TABLE ENTRY
8020                         * INPUT: A=VECTOR TABLE CODE (OFFSET)
8021                         * X=0 OR REPLACEMENT VALUE
8022                         * OUTPUT: X=PREVIOUS VALUE
8023                         ***********************************************
8024 f9f6 a6 61              ZVSWTH  LDA     1,S             ; LOAD REQUESTERS A
8025 f9f8 81 34                      CMPA    #HIVTR          ; ? SUB-CODE TOO HIGH
8026 f9fa 22 39                      BHI     ZOTCH3          ; IGNORE CALL IF SO
8027 f9fc 10 9e c2                   LDY     <VECTAB+.AVTBL  ; LOAD VECTOR TABLE ADDRESS
8028 f9ff ee a6                      LDU     A,Y             ; U=OLD ENTRY
8029 fa01 ef 64                      STU     4,S             ; RETURN OLD VALUE TO CALLERS X
8030 fa03 af 7e                      STX     -2,S            ; ? X=0
8031 fa05 27 2e                      BEQ     ZOTCH3          ; YES, DO NOT CHANGE ENTRY
8032 fa07 af a6                      STX     A,Y             ; REPLACE ENTRY
8033 fa09 20 2a                      BRA     ZOTCH3          ; RETURN FROM SWI
8034                         *D
8035                         
8036                         ************************************************
8037                         *               [SWI FUNCTION 0]
8038                         *  INCHNP - OBTAIN INPUT CHAR IN A (NO PARITY)
8039                         * NULLS AND RUBOUTS ARE IGNORED.
8040                         * AUTOMATIC LINE FEED IS SENT UPON RECEIVING A
8041                         * CARRIAGE RETURN.
8042                         * UNLESS WE ARE LOADING FROM TAPE.
8043                         ************************************************
8044 fa0b 8d 5d              ZINCHP  BSR     XQPAUS          ; RELEASE PROCESSOR
8045 fa0d 8d 5f              ZINCH   BSR     XQCIDT          ; CALL INPUT DATA APPENDAGE
8046 fa0f 24 fa                      BCC     ZINCHP          ; LOOP IF NONE AVAILABLE
8047 fa11 4d                         TSTA                    ; ? TEST FOR NULL
8048 fa12 27 f9                      BEQ     ZINCH           ; IGNORE NULL
8049 fa14 81 7f                      CMPA    #$7F            ; ? RUBOUT
8050 fa16 27 f5                      BEQ     ZINCH           ; BRANCH YES TO IGNORE
8051 fa18 a7 61                      STA     1,S             ; STORE INTO CALLERS A
8052 fa1a 0d 8f                      TST     <MISFLG         ; ? LOAD IN PROGRESS
8053 fa1c 26 17                      BNE     ZOTCH3          ; BRANCH IF SO TO NOT ECHO
8054 fa1e 81 0d                      CMPA    #CR             ; ? CARRIAGE RETURN
8055 fa20 26 04                      BNE     ZIN2            ; NO, TEST ECHO BYTE
8056 fa22 86 0a                      LDA     #LF             ; LOAD LINE FEED
8057 fa24 8d c2                      BSR     SEND            ; ALWAYS ECHO LINE FEED
8058 fa26 0d f4              ZIN2    TST     <VECTAB+.ECHO   ; ? ECHO DESIRED
8059 fa28 26 0b                      BNE     ZOTCH3          ; NO, RETURN
8060                         * FALL THROUGH TO OUTCH
8061                         ************************************************
8062                         *            [SWI FUNCTION 1]
8063                         *        OUTCH - OUTPUT CHARACTER FROM A
8064                         * INPUT: NONE
8065                         * OUTPUT: IF LINEFEED IS THE OUTPUT CHARACTER THEN
8066                         * C=0 NO CTL-X RECEIVED, C=1 CTL-X RECEIVED
8067                         ************************************************
8068 fa2a a6 61              ZOTCH1  LDA     1,S             ; LOAD CHARACTER TO SEND
8069 fa2c 30 8c 09                   LEAX    <ZPCRLS,PCR     ; DEFAULT FOR LINE FEED
8070 fa2f 81 0a                      CMPA    #LF             ; ? LINE FEED
8071 fa31 27 0f                      BEQ     ZPDTLP          ; BRANCH TO CHECK PAUSE IF SO
8072 fa33 8d b3              ZOTCH2  BSR     SEND            ; SEND TO OUTPUT ROUTINE
8073 fa35 0c 90              ZOTCH3  INC     <SWICNT         ; BUMP UP "SWI" TRACE NEST LEVEL
8074 fa37 3b                         RTI                     ; RETURN FROM "SWI" FUNCTION
8075                         
8076                         **************************************************
8077                         * [SWI FUNCTION 6]
8078                         * PCRLF - SEND CR/LF TO CONSOLE HANDLER
8079                         * INPUT: NONE
8080                         * OUTPUT: CR AND LF SENT TO HANDLER
8081                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
8082                         **************************************************
8083 fa38 04                 ZPCRLS  FCB     EOT             ; NULL STRING
8084 fa39 30 8c fc           ZPCRLF LEAX     ZPCRLS,PCR      ; READY CR,LF STRING
8085                         * FALL INTO CR/LF CODE
8086                         
8087                         **************************************************
8088                         * [SWI FUNCTION 3]
8089                         * PDATA - OUTPUT CR/LF AND STRING
8090                         * INPUT: X->STRING
8091                         * OUTPUT: CR/LF AND STRING SENT TO OUTPUT CONSOLE
8092                         * HANDLER.
8093                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
8094                         * NOTE: LINE FEED MUST FOLLOW CARRIAGE RETURN FOR
8095                         * PROPER PUNCH DATA.
8096                         **************************************************
8097                         
8098 fa3c 86 0d              ZPDATA  LDA     #CR             ; LOAD CARRIAGE RETURN
8099 fa3e 8d a8                      BSR     SEND            ; SEND IT
8100 fa40 86 0a                      LDA     #LF             ; LOAD LINE FEED
8101                         * FALL INTO PDATA1
8102                         
8103                         *************************************************
8104                         * [SWI FUNCTION 2]
8105                         * PDATA1 - OUTPUT STRING TILL EOT ($04)
8106                         * THIS ROUTINE PAUSES IF AN INPUT BYTE BECOMES
8107                         * AVAILABLE DURING OUTPUT TRANSMISSION UNTIL A
8108                         * SECOND IS RECEIVED.
8109                         * INPUT: X->STRING
8110                         * OUTPUT: STRING SENT TO OUTPUT CONSOLE DRIVER
8111                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
8112                         *************************************************
8113                         
8114 fa42 8d a4              ZPDTLP  BSR     SEND            ; SEND CHARACTER TO DRIVER
8115 fa44 a6 80              ZPDTA1  LDA     ,X+             ; LOAD NEXT CHARACTER
8116 fa46 81 04                      CMPA    #EOT            ; ? EOT
8117 fa48 26 f8                      BNE     ZPDTLP          ; LOOP IF NOT
8118                         * FALL INTO PAUSE CHECK FUNCTION
8119                         
8120                         ********************************************
8121                         * [SWI FUNCTION 12]
8122                         * PAUSE - RETURN TO TASK DISPATCHING AND CHECK
8123                         * FOR FREEZE CONDITION OR CTL-X BREAK
8124                         * THIS FUNCTION ENTERS THE TASK PAUSE HANDLER SO
8125                         * OPTIONALLY OTHER 6809 PROCESSES MAY GAIN CONTROL.
8126                         * UPON RETURN, CHECK FOR A 'FREEZE' CONDITION
8127                         * WITH A RESULTING WAIT LOOP, OR CONDITION CODE
8128                         * RETURN IF A CONTROL-X IS ENTERED FROM THE INPUT
8129                         * HANDLER.
8130                         * OUTPUT: C=1 IF CTL-X HAS ENTERED, C=0 OTHERWISE
8131                         ******************************************
8132                         
8133 fa4a 8d 1e              ZPAUSE  BSR     XQPAUS          ; RELEASE CONTROL AT EVERY LINE
8134 fa4c 8d 06                      BSR     CHKABT          ; CHECK FOR FREEZE OR ABORT
8135 fa4e 1f a9                      TFR     CC,B            ; PREPARE TO REPLACE CC
8136 fa50 e7 e4                      STB     ,S              ; OVERLAY OLD ONE ON STACK
8137 fa52 20 e1                      BRA     ZOTCH3          ; RETURN FROM "SWI"
8138                         
8139                         * CHKABT - SCAN FOR INPUT PAUSE/ABORT DURING OUTPUT
8140                         * OUTPUT: C=0 OK, C=1 ABORT (CTL-X ISSUED)
8141                         * VOLATILE: U,X,D
8142 fa54 8d 18              CHKABT  BSR     XQCIDT          ; ATTEMPT INPUT
8143 fa56 24 05                      BCC     CHKRTN          ; BRANCH NO TO RETURN
8144 fa58 81 18                      CMPA    #CAN            ; ? CTL-X FOR ABORT
8145 fa5a 26 02                      BNE     CHKWT           ; BRANCH NO TO PAUSE
8146 fa5c 53                 CHKSEC  COMB                    ; SET CARRY
8147 fa5d 39                 CHKRTN  RTS                     ; RETURN TO CALLER WITH CC SET
8148 fa5e 8d 0a              CHKWT   BSR     XQPAUS          ; PAUSE FOR A MOMENT
8149 fa60 8d 0c                      BSR     XQCIDT          ; ? KEY FOR START
8150 fa62 24 fa                      BCC     CHKWT           ; LOOP UNTIL RECEIVED
8151 fa64 81 18                      CMPA    #CAN            ; ? ABORT SIGNALED FROM WAIT
8152 fa66 27 f4                      BEQ     CHKSEC          ; BRANCH YES
8153 fa68 4f                         CLRA                    ; SET C=0 FOR NO ABORT
8154 fa69 39                         RTS                     ; AND RETURN
8155                         
8156                         * SAVE MEMORY WITH JUMPS
8157 fa6a 6e 9d 76 7c        XQPAUS  JMP   [VECTAB+.PAUSE,PCR] ; TO PAUSE ROUTINE
8158 fa6e ad 9d 76 66        XQCIDT  JSR   [VECTAB+.CIDTA,PCR] ; TO INPUT ROUTINE
8159 fa72 84 7f                      ANDA  #$7F              ; STRIP PARITY
8160 fa74 39                         RTS                     ; RETURN TO CALLER
8161                         
8162                         ********************************************
8163                         * NMI DEFAULT INTERRUPT HANDLER
8164                         * THE NMI HANDLER IS USED FOR TRACING INSTRUCTIONS.
8165                         * TRACE PRINTOUTS OCCUR ONLY AS LONG AS THE STACK
8166                         * TRACE LEVEL IS NOT BREACHED BY FALLING BELOW IT.
8167                         * TRACING CONTINUES UNTIL THE COUNT TURNS ZERO OR
8168                         * A CTL-X IS ENTERED FROM THE INPUT CONSOLE DEVICE.
8169                         *********************************************
8170                         
8171 fa75 4f 50 2d 04        MSHOWP  FCB     'O,'P,'-,EOT    ; OPCODE PREP
8172                         
8173 fa79 8d 42              NMIR    BSR     LDDP            ; LOAD PAGE AND VERIFY STACK
8174 fa7b 0d 8f                      TST     <MISFLG         ; ? THRU A BREAKPOINT
8175 fa7d 26 34                      BNE     NMICON          ; BRANCH IF SO TO CONTINUE
8176 fa7f 0d 90                      TST     <SWICNT         ; ? INHIBIT "SWI" DURING TRACE
8177 fa81 2b 29                      BMI     NMITRC          ; BRANCH YES
8178 fa83 30 6c                      LEAX    12,S            ; OBTAIN USERS STACK POINTER
8179 fa85 9c f8                      CMPX    <SLEVEL         ; ? TO TRACE HERE
8180 fa87 25 23                      BLO     NMITRC          ; BRANCH IF TOO LOW TO DISPLAY
8181 fa89 30 8c e9                   LEAX    MSHOWP,PCR      ; LOAD OP PREP
8182 fa8c 3f                         SWI                     ; SEND TO CONSOLE
8183 fa8d 02                         FCB     PDATA1          ; FUNCTION
8184 fa8e 09 8e                      ROL     <DELIM          ; SAVE CARRY BIT
8185 fa90 30 8d 76 05                LEAX    LASTOP,PCR      ; POINT TO LAST OP
8186 fa94 3f                         SWI                     ; SEND OUT AS HEX
8187 fa95 05                         FCB     OUT4HS          ; FUNCTION
8188 fa96 8d 17                      BSR     REGPRS          ; FOLLOW MEMORY WITH REGISTERS
8189 fa98 25 37                      BCS     ZBKCMD          ; BRANCH IF "CANCEL"
8190 fa9a 06 8e                      ROR     <DELIM          ; RESTORE CARRY BIT
8191 fa9c 25 33                      BCS     ZBKCMD          ; BRANCH IF "CANCEL"
8192 fa9e 9e 91                      LDX     <TRACEC         ; LOAD TRACE COUNT
8193 faa0 27 2f                      BEQ     ZBKCMD          ; IF ZERO TO COMMAND HANDLER
8194 faa2 30 1f                      LEAX    -1,X            ; MINUS ONE
8195 faa4 9f 91                      STX     <TRACEC         ; REFRESH
8196 faa6 27 29                      BEQ     ZBKCMD          ; STOP TRACE WHEN ZERO
8197 faa8 8d aa                      BSR     CHKABT          ; ? ABORT THE TRACE
8198 faaa 25 25                      BCS     ZBKCMD          ; BRANCH YES TO COMMAND HANDLER
8199 faac 16 03 f7           NMITRC  LBRA    CTRCE3          ; NO, TRACE ANOTHER INSTRUCTION
8200                         
8201 faaf 17 01 b9           REGPRS  LBSR    REGPRT          ; PRINT REGISTERS AS FROM COMMAND
8202 fab2 39                         RTS                     ; RETURN TO CALLER
8203                         
8204                         * JUST EXECUTED THRU A BRKPNT. NOW CONTINUE NORMALLY
8205                         
8206 fab3 0f 8f              NMICON  CLR     <MISFLG        ; CLEAR THRU FLAG
8207 fab5 17 02 eb                   LBSR    ARMBK2         ; ARM BREAKPOINTS
8208 fab8 3b                 RTI     RTI                    ; AND CONTINUE USERS PROGRAM
8209                         
8210                         * LDDP - SETUP DIRECT PAGE REGISTER, VERIFY STACK.
8211                         * AN INVALID STACK CAUSES A RETURN TO THE COMMAND
8212                         * HANDLER.
8213                         * INPUT: FULLY STACKED REGISTERS FROM AN INTERRUPT
8214                         * OUTPUT: DPR LOADED TO WORK PAGE
8215                         
8216 fab9 3f 07 20 04        ERRMSG  FCB     '?,BELL,$20,EOT ; ERROR RESPONSE
8217                         
8218 fabd e6 8d 75 dc        LDDP    LDB     BASEPG,PCR      ; LOAD DIRECT PAGE HIGH BYTE
8219 fac1 1f 9b                      TFR     B,DP            ; SETUP DIRECT PAGE REGISTER
8220 fac3 a1 63                      CMPA    3,S             ; ? IS STACK VALID
8221 fac5 27 25                      BEQ     RTS             ; YES, RETURN
8222 fac7 10 de 97                   LDS     <RSTACK         ; RESET TO INITIAL STACK POINTER
8223 faca 30 8c ec           ERROR   LEAX    ERRMSG,PCR      ; LOAD ERROR REPORT
8224 facd 3f                         SWI                     ; SEND OUT BEFORE REGISTERS
8225 face 03                         FCB     PDATA           ; ON NEXT LINE
8226                         * FALL INTO BREAKPOINT HANDLER
8227                         
8228                         **********************************************
8229                         * [SWI FUNCTION 10]
8230                         * BREAKPOINT PROGRAM FUNCTION
8231                         * PRINT REGISTERS AND GO TO COMMAND HANLER
8232                         ***********************************************
8233                         
8234 facf 8d de              ZBKPNT  BSR     REGPRS          ; PRINT OUT REGISTERS
8235 fad1 16 fe 25           ZBKCMD  LBRA    CMDNEP          ; NOW ENTER COMMAND HANDLER
8236                         
8237                         ********************************************
8238                         * IRQ, RESERVED, SWI2 AND SWI3 INTERRUPT HANDLERS
8239                         * THE DEFAULT HANDLING IS TO CAUSE A BREAKPOINT.
8240                         ********************************************
8241 fad4                    SWI2R   EQU     *               ; SWI2 ENTRY
8242 fad4                    SWI3R   EQU     *               ; SWI3 ENTRY
8243 fad4                    IRQR    EQU     *               ; IRQ ENTRY
8244 fad4 8d e7              RSRVDR  BSR     LDDP            ; SET BASE PAGE, VALIDATE STACK
8245 fad6 20 f7                      BRA     ZBKPNT          ; FORCE A BREAKPOINT
8246                         
8247                         ******************************************
8248                         * FIRQ HANDLER
8249                         * JUST RETURN FOR THE FIRQ INTERRUPT
8250                         ******************************************
8251 fab8                    FIRQR   EQU     RTI             ; IMMEDIATE RETURN
8252                         
8253                         **************************************************
8254                         * DEFAULT I/O DRIVERS
8255                         **************************************************
8256                         * CIDTA - RETURN CONSOLE INPUT CHARACTER
8257                         * OUTPUT: C=0 IF NO DATA READY, C=1 A=CHARACTER
8258                         * U VOLATILE
8259                         
8260 fad8 de f0              CIDTA   LDU     <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
8261 fada a6 c4                      LDA     ,U              ; LOAD STATUS REGISTER
8262 fadc 44                         LSRA                    ; TEST RECEIVER REGISTER FLAG
8263 fadd 24 02                      BCC     CIRTN           ; RETURN IF NOTHING
8264 fadf a6 41                      LDA     1,U             ; LOAD DATA BYTE
8265 fae1 39                 CIRTN   RTS                     ; RETURN TO CALLER
8266                         
8267                         * CION - INPUT CONSOLE INITIALIZATION
8268                         * COON - OUTPUT CONSOLE INITIALIZATION
8269                         * A,X VOLATILE
8270 fae2                    CION   EQU      *
8271 fae2 86 13              COON   LDA      #$13            ; RESET ACIA CODE
8272 fae4 9e f0                     LDX      <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
8273 fae6 a7 84                     STA      ,X              ; STORE INTO STATUS REGISTER
8274 fae8 86 15                     LDA      #$15            ; SET CONTROL
8275 faea a7 84                     STA      ,X              ; REGISTER UP
8276 faec 39                 RTS    RTS                      ; RETURN TO CALLER
8277                         
8278                         * THE FOLLOWING HAVE NO DUTIES TO PERFORM
8279 faec                    CIOFF EQU       RTS             ; CONSOLE INPUT OFF
8280 faec                    COOFF EQU       RTS             ; CONSOLE OUTPUT OFF
8281                         
8282                         * CODTA - OUTPUT CHARACTER TO CONSOLE DEVICE
8283                         * INPUT: A=CHARACTER TO SEND
8284                         * OUTPUT: CHAR SENT TO TERMINAL WITH PROPER PADDING
8285                         * ALL REGISTERS TRANSPARENT
8286                         
8287 faed 34 47              CODTA   PSHS    U,D,CC          ; SAVE REGISTERS,WORK BYTE
8288 faef de f0                      LDU     <VECTAB+.ACIA   ; ADDRESS ACIA
8289 faf1 8d 1b                      BSR     CODTAO          ; CALL OUTPUT CHAR SUBROUTINE
8290 faf3 81 10                      CMPA    #DLE            ; ? DATA LINE ESCAPE
8291 faf5 27 12                      BEQ     CODTRT          ; YES, RETURN
8292 faf7 d6 f2                      LDB     <VECTAB+.PAD    ; DEFAULT TO CHAR PAD COUNT
8293 faf9 81 0d                      CMPA    #CR             ; ? CR
8294 fafb 26 02                      BNE     CODTPD          ; BRANCH NO
8295 fafd d6 f3                      LDB     <VECTAB+.PAD+1  ; LOAD NEW LINE PAD COUNT
8296 faff 4f                 CODTPD  CLRA                    ; CREATE NULL
8297 fb00 e7 e4                      STB     ,S              ; SAVE COUNT
8298 fb02 8c                         FCB     SKIP2           ; ENTER LOOP
8299 fb03 8d 09              CODTLP  BSR     CODTAO          ; SEND NULL
8300 fb05 6a e4                      DEC     ,S              ; ? FINISHED
8301 fb07 2a fa                      BPL     CODTLP          ; NO, CONTINUE WITH MORE
8302 fb09 35 c7              CODTRT  PULS    PC,U,D,CC       ; RESTORE REGISTERS AND RETURN
8303                         
8304 fb0b 17 ff 5c           CODTAD  LBSR    XQPAUS          ; TEMPORARY GIVE UP CONTROL
8305 fb0e e6 c4              CODTAO  LDB     ,U              ; LOAD ACIA CONTROL REGISTER
8306 fb10 c5 02                      BITB    #$02            ; ? TX REGISTER CLEAR >LSAB FIXME
8307 fb12 27 f7                      BEQ     CODTAD          ; RELEASE CONTROL IF NOT
8308 fb14 a7 41                      STA     1,U             ; STORE INTO DATA REGISTER
8309 fb16 39                         RTS                     ; RETURN TO CALLER
8310                         *E
8311                         
8312                         * BSON - TURN ON READ/VERIFY/PUNCH MECHANISM
8313                         * A IS VOLATILE
8314                         
8315 fb17 86 11              BSON    LDA     #$11            ; SET READ CODE
8316 fb19 6d 66                      TST     6,S             ; ? READ OR VERIFY
8317 fb1b 26 01                      BNE     BSON2           ; BRANCH YES
8318 fb1d 4c                         INCA                    ; SET TO WRITE
8319 fb1e 3f                 BSON2   SWI                     ; PERFORM OUTPUT
8320 fb1f 01                         FCB     OUTCH           ; FUNCTION
8321 fb20 0c 8f                      INC     <MISFLG         ; SET LOAD IN PROGRESS FLAG
8322 fb22 39                         RTS                     ; RETURN TO CALLER
8323                         
8324                         * BSOFF - TURN OFF READ/VERIFY/PUNCH MECHANISM
8325                         * A,X VOLATILE
8326                         
8327 fb23 86 14              BSOFF   LDA     #$14            ; TO DC4 - STOP
8328 fb25 3f                         SWI                     ; SEND OUT
8329 fb26 01                         FCB     OUTCH           ; FUNCTION
8330 fb27 4a                         DECA                    ; CHANGE TO DC3 (X-OFF)
8331 fb28 3f                         SWI                     ; SEND OUT
8332 fb29 01                         FCB     OUTCH           ; FUNCTION
8333 fb2a 0a 8f                      DEC     <MISFLG         ; CLEAR LOAD IN PROGRESS FLAG
8334 fb2c 8e 61 a8                   LDX     #25000          ; DELAY 1 SECOND (2MHZ CLOCK)
8335 fb2f 30 1f              BSOFLP  LEAX    -1,X            ; COUNT DOWN
8336 fb31 26 fc                      BNE     BSOFLP          ; LOOP TILL DONE
8337 fb33 39                         RTS                     ; RETURN TO CALLER
8338                         
8339                         * BSDTA - READ/VERIFY/PUNCH HANDLER
8340                         * INPUT: S+6=CODE BYTE, VERIFY(-1),PUNCH(0),LOAD(1)
8341                         * S+4=START ADDRESS
8342                         * S+2=STOP ADDRESS
8343                         * S+0=RETURN ADDRESS
8344                         * OUTPUT: Z=1 NORMAL COMPLETION, Z=0 INVALID LOAD/VER
8345                         * REGISTERS ARE VOLATILE
8346 fb34 ee 62              BSDTA   LDU     2,S             ; U=TO ADDRESS OR OFFSET
8347 fb36 6d 66                      TST     6,S             ; ? PUNCH
8348 fb38 27 54                      BEQ     BSDPUN          ; BRANCH YES
8349                         
8350                         * DURING READ/VERIFY: S+2=MSB ADDRESS SAVE BYTE
8351                         * S+1=BYTE COUNTER
8352                         * S+0=CHECKSUM
8353                         * U HOLDS OFFSET
8354 fb3a 32 7d                      LEAS    -3,S            ; ROOM FOR WORK/COUNTER/CHECKSUM
8355 fb3c 3f                 BSDLD1  SWI                     ; GET NEXT CHARACTER
8356 fb3d 00                         FCB     INCHNP          ; FUNCTION
8357 fb3e 81 53              BSDLD2  CMPA    #'S             ; ? START OF S1/S9
8358 fb40 26 fa                      BNE     BSDLD1          ; BRANCH NOT
8359 fb42 3f                         SWI                     ; GET NEXT CHARACTER
8360 fb43 00                         FCB     INCHNP          ; FUNCTION
8361 fb44 81 39                      CMPA    #'9             ; ? HAVE S9
8362 fb46 27 22                      BEQ     BSDSRT          ; YES, RETURN GOOD CODE
8363 fb48 81 31                      CMPA    #'1             ; ? HAVE NEW RECORD
8364 fb4a 26 f2                      BNE     BSDLD2          ; BRANCH IF NOT
8365 fb4c 6f e4                      CLR     ,S              ; CLEAR CHECKSUM
8366 fb4e 8d 21                      BSR     BYTE            ; OBTAIN BYTE COUNT
8367 fb50 e7 61                      STB     1,S             ; SAVE FOR DECREMENT
8368                         
8369                         * READ ADDRESS
8370 fb52 8d 1d                      BSR     BYTE            ; OBTAIN HIGH VALUE
8371 fb54 e7 62                      STB     2,S             ; SAVE IT
8372 fb56 8d 19                      BSR     BYTE            ; OBTAIN LOW VALUE
8373 fb58 a6 62                      LDA     2,S             ; MAKE D=VALUE
8374 fb5a 31 cb                      LEAY    D,U             ; Y=ADDRESS+OFFSET
8375                         * STORE TEXT
8376 fb5c 8d 13              BSDNXT  BSR     BYTE            ; NEXT BYTE
8377 fb5e 27 0c                      BEQ     BSDEOL          ; BRANCH IF CHECKSUM
8378 fb60 6d 69                      TST     9,S             ; ? VERIFY ONLY
8379 fb62 2b 02                      BMI     BSDCMP          ; YES, ONLY COMPARE
8380 fb64 e7 a4                      STB     ,Y              ; STORE INTO MEMORY
8381 fb66 e1 a0              BSDCMP  CMPB    ,Y+             ; ? VALID RAM
8382 fb68 27 f2                      BEQ     BSDNXT          ; YES, CONTINUE READING
8383 fb6a 35 92              BSDSRT  PULS    PC,X,A          ; RETURN WITH Z SET PROPER
8384 fb6c 4c                 BSDEOL  INCA                    ; ? VALID CHECKSUM
8385 fb6d 27 cd                      BEQ     BSDLD1          ; BRANCH YES
8386 fb6f 20 f9                      BRA     BSDSRT          ; RETURN Z=0 INVALID
8387                         
8388                         * BYTE BUILDS 8 BIT VALUE FROM TWO HEX DIGITS IN
8389 fb71 8d 12              BYTE    BSR     BYTHEX         ; OBTAIN FIRST HEX
8390 fb73 c6 10                      LDB     #16            ; PREPARE SHIFT
8391 fb75 3d                         MUL                    ; OVER TO A
8392 fb76 8d 0d                      BSR     BYTHEX         ; OBTAIN SECOND HEX
8393 fb78 34 04                      PSHS    B              ; SAVE HIGH HEX
8394 fb7a ab e0                      ADDA    ,S+            ; COMBINE BOTH SIDES
8395 fb7c 1f 89                      TFR     A,B            ; SEND BACK IN B
8396 fb7e ab 62                      ADDA    2,S            ; COMPUTE NEW CHECKSUM
8397 fb80 a7 62                      STA     2,S            ; STORE BACK
8398 fb82 6a 63                      DEC     3,S            ; DECREMENT BYTE COUNT
8399 fb84 39                 BYTRTS  RTS                    ; RETURN TO CALLER
8400                         
8401 fb85 3f                 BYTHEX  SWI                    ; GET NEXT HEX
8402 fb86 00                         FCB     INCHNP         ; CHARACTER
8403 fb87 17 01 d4                   LBSR    CNVHEX         ; CONVERT TO HEX
8404 fb8a 27 f8                      BEQ     BYTRTS         ; RETURN IF VALID HEX
8405 fb8c 35 f2                      PULS    PC,U,Y,X,A     ; RETURN TO CALLER WITH Z=0
8406                         
8407                         * PUNCH STACK USE: S+8=TO ADDRESS
8408                         *                  S+6=RETURN ADDRESS
8409                         *                  S+4=SAVED PADDING VALUES
8410                         *                  S+2 FROM ADDRESS
8411                         *                  S+1=FRAME COUNT/CHECKSUM
8412                         *                  S+0=BYTE COUNT
8413                         
8414 fb8e de f2              BSDPUN  LDU     <VECTAB+.PAD    ; LOAD PADDING VALUES
8415 fb90 ae 64                      LDX     4,S             ; X=FROM ADDRESS
8416 fb92 34 56                      PSHS    U,X,D           ; CREATE STACK WORK AREA
8417 fb94 cc 00 18                   LDD     #24             ; SET A=0, B=24
8418 fb97 d7 f2                      STB     <VECTAB+.PAD    ; SETUP 24 CHARACTER PADS
8419 fb99 3f                         SWI                     ; SEND NULLS OUT
8420 fb9a 01                         FCB     OUTCH           ; FUNCTION
8421 fb9b c6 04                      LDB     #4              ; SETUP NEW LINE PAD TO 4
8422 fb9d dd f2                      STD     <VECTAB+.PAD    ; SETUP PUNCH PADDING
8423                         * CALCULATE SIZE
8424 fb9f ec 68              BSPGO   LDD     8,S             ; LOAD TO
8425 fba1 a3 62                      SUBD    2,S             ; MINUS FROM=LENGTH
8426 fba3 10 83 00 18                CMPD    #24             ; ? MORE THAN 23
8427 fba7 25 02                      BLO     BSPOK           ; NO, OK
8428 fba9 c6 17                      LDB     #23             ; FORCE TO 23 MAX
8429 fbab 5c                 BSPOK   INCB                    ; PREPARE COUNTER
8430 fbac e7 e4                      STB     ,S              ; STORE BYTE COUNT
8431 fbae cb 03                      ADDB    #3              ; ADJUST TO FRAME COUNT
8432 fbb0 e7 61                      STB     1,S             ; SAVE
8433                         
8434                         *PUNCH CR,LF,NULS,S,1
8435 fbb2 30 8c 33                  LEAX     <BSPSTR,PCR     ; LOAD START RECORD HEADER
8436 fbb5 3f                        SWI                      ; SEND OUT
8437 fbb6 03                        FCB      PDATA           ; FUNCTION
8438                         * SEND FRAME COUNT
8439 fbb7 5f                        CLRB                     ; INITIALIZE CHECKSUM
8440 fbb8 30 61                     LEAX     1,S             ; POINT TO FRAME COUNT AND ADDR
8441 fbba 8d 27                     BSR      BSPUN2          ; SEND FRAME COUNT
8442                         *DATA ADDRESS
8443 fbbc 8d 25                    BSR       BSPUN2          ; SEND ADDRESS HI
8444 fbbe 8d 23                    BSR       BSPUN2          ; SEND ADDRESS LOW
8445                         *PUNCH DATA
8446 fbc0 ae 62                     LDX      2,S             ; LOAD START DATA ADDRESS
8447 fbc2 8d 1f              BSPMRE BSR      BSPUN2          ; SEND OUT NEXT BYTE
8448 fbc4 6a e4                     DEC      ,S              ; ? FINAL BYTE
8449 fbc6 26 fa                     BNE      BSPMRE          ; LOOP IF NOT DONE
8450 fbc8 af 62                     STX      2,S             ; UPDATE FROM ADDRESS VALUE
8451                         *PUNCH CHECKSUM
8452 fbca 53                        COMB                     ; COMPLEMENT
8453 fbcb e7 61                     STB      1,S             ; STORE FOR SENDOUT
8454 fbcd 30 61                     LEAX     1,S             ; POINT TO IT
8455 fbcf 8d 14                     BSR      BSPUNC          ; SEND OUT AS HEX
8456 fbd1 ae 68                     LDX      8,S             ; LOAD TOP ADDRESS
8457 fbd3 ac 62                     CMPX     2,S             ; ? DONE
8458 fbd5 24 c8                     BHS      BSPGO           ; BRANCH NOT
8459 fbd7 30 8c 11                  LEAX     <BSPEOF,PCR     ; PREPARE END OF FILE
8460 fbda 3f                        SWI                      ; SEND OUT STRING
8461 fbdb 03                        FCB      PDATA           ; FUNCTION
8462 fbdc ec 64                     LDD      4,S             ; RECOVER PAD COUNTS
8463 fbde dd f2                     STD      <VECTAB+.PAD    ; RESTORE
8464 fbe0 4f                        CLRA                     ; SET Z=1 FOR OK RETURN
8465 fbe1 35 d6                     PULS     PC,U,X,D        ; RETURN WITH OK CODE
8466 fbe3 eb 84              BSPUN2 ADDB     ,X              ; ADD TO CHECKSUM
8467 fbe5 16 fd ed           BSPUNC LBRA     ZOUT2H          ; SEND OUT AS HEX AND RETURN
8468                         
8469 fbe8 53 01 04           BSPSTR FCB      'S,1,EOT        ; CR,LF,NULLS,S,1
8470 fbeb 53 39 30 33 30 30  BSPEOF FCC      /S9030000FC/         ; EOF STRING
     30 30 46 43
8471 fbf5 0d 0a 04                  FCB      CR,LF,EOT
8472                         
8473                         * HSDTA - HIGH SPEED PRINT MEMORY
8474                         * INPUT: S+4=START ADDRESS
8475                         * S+2=STOP ADDRESS
8476                         * S+0=RETURN ADDRESS
8477                         * X,D VOLATILE
8478                         
8479                         * SEND TITLE
8480                         
8481 fbf8 3f                 HSDTA   SWI                     ; SEND NEW LINE
8482 fbf9 06                         FCB     PCRLF           ; FUNCTION
8483 fbfa c6 06                      LDB     #6              ; PREPARE 6 SPACES
8484 fbfc 3f                 HSBLNK  SWI                     ; SEND BLANK
8485 fbfd 07                         FCB     SPACEF          ; FUNCTION
8486 fbfe 5a                         DECB                    ; COUNT DOWN
8487 fbff 26 fb                      BNE     HSBLNK          ; LOOP IF MORE
8488 fc01 5f                         CLRB                    ; SETUP BYTE COUNT
8489 fc02 1f 98              HSHTTL  TFR     B,A             ; PREPARE FOR CONVERT
8490 fc04 17 fd db                   LBSR    ZOUTHX          ; CONVERT TO A HEX DIGIT
8491 fc07 3f                         SWI                     ; SEND BLANK
8492 fc08 07                         FCB     SPACEF          ; FUNCTION
8493 fc09 3f                         SWI                     ; SEND ANOTHER
8494 fc0a 07                         FCB     SPACEF          ; BLANK
8495 fc0b 5c                         INCB                    ; UP ANOTHER
8496 fc0c c1 10                      CMPB    #$10            ; ? PAST 'F'
8497 fc0e 25 f2                      BLO     HSHTTL          ; LOOP UNTIL SO
8498 fc10 3f                 HSHLNE  SWI                     ; TO NEXT LINE
8499 fc11 06                         FCB     PCRLF           ; FUNCTION
8500 fc12 25 2f                      BCS     HSDRTN          ; RETURN IF USER ENTERED CTL-X
8501 fc14 30 64                      LEAX    4,S             ; POINT AT ADDRESS TO CONVERT
8502 fc16 3f                         SWI                     ; PRINT OUT ADDRESS
8503 fc17 05                         FCB     OUT4HS          ; FUNCTION
8504 fc18 ae 64                      LDX     4,S             ; LOAD ADDRESS PROPER
8505 fc1a c6 10                      LDB     #16             ; NEXT SIXTEEN
8506 fc1c 3f                 HSHNXT  SWI                     ; CONVERT BYTE TO HEX AND SEND
8507 fc1d 04                         FCB     OUT2HS          ; FUNCTION
8508 fc1e 5a                         DECB                    ; COUNT DOWN
8509 fc1f 26 fb                      BNE     HSHNXT          ; LOOP IF NOT SIXTEENTH
8510 fc21 3f                         SWI                     ; SEND BLANK
8511 fc22 07                         FCB     SPACEF          ; FUNCTION
8512 fc23 ae 64                      LDX     4,S             ; RELOAD FROM ADDRESS
8513 fc25 c6 10                      LDB     #16             ; COUNT
8514 fc27 a6 80              HSHCHR  LDA     ,X+             ; NEXT BYTE
8515 fc29 2b 04                      BMI     HSHDOT          ; TOO LARGE, TO A DOT
8516 fc2b 81 20                      CMPA    #'              ; ? LOWER THAN A BLANK
8517 fc2d 24 02                      BHS     HSHCOK          ; NO, BRANCH OK
8518 fc2f 86 2e              HSHDOT  LDA     #'.             ; CONVERT INVALID TO A BLANK
8519 fc31 3f                 HSHCOK  SWI                     ; SEND CHARACTER
8520 fc32 01                         FCB     OUTCH           ; FUNCTION
8521 fc33 5a                         DECB                    ; ? DONE
8522 fc34 26 f1                      BNE     HSHCHR          ; BRANCH NO
8523 fc36 ac 62                      CPX     2,S             ; ? PAST LAST ADDRESS
8524 fc38 24 09                      BHS     HSDRTN          ; QUIT IF SO
8525 fc3a af 64                      STX     4,S             ; UPDATE FROM ADDRESS
8526 fc3c a6 65                      LDA     5,S             ; LOAD LOW BYTE ADDRESS
8527 fc3e 48                         ASLA                    ; ? TO SECTION BOUNDARY
8528 fc3f 26 cf                      BNE     HSHLNE          ; BRANCH IF NOT
8529 fc41 20 b5                      BRA     HSDTA           ; BRANCH IF SO
8530 fc43 3f                 HSDRTN  SWI                     ; SEND NEW LINE
8531 fc44 06                         FCB     PCRLF           ; FUNCTION
8532 fc45 39                         RTS                     ; RETURN TO CALLER
8533                         *F
8534                         
8535                         ***********************************************
8536                         *     A S S I S T 0 9    C O M M A N D S
8537                         ***********************************************
8538                         
8539                         *************REGISTERS - DISPLAY AND CHANGE REGISTERS
8540 fc46 8d 23              CREG    BSR     REGPRT          ; PRINT REGISTERS
8541 fc48 4c                         INCA                    ; SET FOR CHANGE FUNCTION
8542 fc49 8d 21                      BSR     REGCHG          ; GO CHANGE, DISPLAY REGISTERS
8543 fc4b 39                         RTS                     ; RETURN TO COMMAND PROCESSOR
8544                         
8545                         ********************************************
8546                         * REGPRT - PRINT/CHANGE REGISTERS SUBROUTINE
8547                         * WILL ABORT TO 'CMDBAD' IF OVERFLOW DETECTED DURING
8548                         * A CHANGE OPERATION. CHANGE DISPLAYS REGISTERS WHEN
8549                         * DONE.
8550                         
8551                         * REGISTER MASK LIST CONSISTS OF:
8552                         * A) CHARACTERS DENOTING REGISTER
8553                         * B) ZERO FOR ONE BYTE, -1 FOR TWO
8554                         * C) OFFSET ON STACK TO REGISTER POSITION
8555                         * INPUT: SP+4=STACKED REGISTERS
8556                         * A=0 PRINT, A#0 PRINT AND CHANGE
8557                         * OUTPUT: (ONLY FOR REGISTER DISPLAY)
8558                         * C=1 CONTROL-X ENTERED, C=0 OTHERWISE
8559                         * VOLATILE: D,X (CHANGE)
8560                         * B,X (DISPLAY)
8561                         *******************************************
8562                         
8563 fc4c 50 43 ff 13        REGMSK  FCB     'P,'C,-1,19     ; PC REG
8564 fc50 41 00 0a                   FCB     'A,0,10         ; A REG
8565 fc53 42 00 0b                   FCB     'B,0,11         ; B REG
8566 fc56 58 ff 0d                   FCB     'X,-1,13        ; X REG
8567 fc59 59 ff 0f                   FCB     'Y,-1,15        ; Y REG
8568 fc5c 55 ff 11                   FCB     'U,-1,17        ; U REG
8569 fc5f 53 ff 01                   FCB     'S,-1,1         ; S REG
8570 fc62 43 43 00 09                FCB     'C,'C,0,9       ; CC REG
8571 fc66 44 50 00 0c                FCB     'D,'P,0,12      ; DP REG
8572 fc6a 00                         FCB     0               ; END OF LIST
8573                         
8574 fc6b 4f                 REGPRT  CLRA                    ; SETUP PRINT ONLY FLAG
8575 fc6c 30 e8 10           REGCHG  LEAX    4+12,S          ; READY STACK VALUE
8576 fc6f 34 32                      PSHS    Y,X,A           ; SAVE ON STACK WITH OPTION
8577 fc71 31 8c d8                   LEAY    REGMSK,PCR      ; LOAD REGISTER MASK
8578 fc74 ec a0              REGP1   LDD     ,Y+             ; LOAD NEXT CHAR OR <=0
8579 fc76 4d                         TSTA                    ; ? END OF CHARACTERS
8580 fc77 2f 04                      BLE     REGP2           ; BRANCH NOT CHARACTER
8581 fc79 3f                         SWI                     ; SEND TO CONSOLE
8582 fc7a 01                         FCB     OUTCH           ; FUNCTION BYTE
8583 fc7b 20 f7                      BRA     REGP1           ; CHECK NEXT
8584 fc7d 86 2d              REGP2   LDA     #'-             ; READY '-'
8585 fc7f 3f                         SWI                     ; SEND OUT
8586 fc80 01                         FCB     OUTCH           ; WITH OUTCH
8587 fc81 30 e5                      LEAX    B,S             ; X->REGISTER TO PRINT
8588 fc83 6d e4                      TST     ,S              ; ? CHANGE OPTION
8589 fc85 26 12                      BNE     REGCNG          ; BRANCH YES
8590 fc87 6d 3f                      TST     -1,Y            ; ? ONE OR TWO BYTES
8591 fc89 27 03                      BEQ     REGP3           ; BRANCH ZERO MEANS ONE
8592 fc8b 3f                         SWI                     ; PERFORM WORD HEX
8593 fc8c 05                         FCB     OUT4HS          ; FUNCTION
8594 fc8d 8c                         FCB     SKIP2           ; SKIP BYTE PRINT
8595 fc8e 3f                 REGP3   SWI                     ; PERFORM BYTE HEX
8596 fc8f 04                         FCB     OUT2HS          ; FUNCTION
8597 fc90 ec a0              REG4    LDD     ,Y+             ; TO FRONT OF NEXT ENTRY
8598 fc92 5d                         TSTB                    ; ? END OF ENTRIES
8599 fc93 26 df                      BNE     REGP1           ; LOOP IF MORE
8600 fc95 3f                         SWI                     ; FORCE NEW LINE
8601 fc96 06                         FCB     PCRLF           ; FUNCTION
8602 fc97 35 b2              REGRTN  PULS    PC,Y,X,A        ; RESTORE STACK AND RETURN
8603                         
8604 fc99 8d 40              REGCNG  BSR     BLDNNB          ; INPUT BINARY NUMBER
8605 fc9b 27 10                      BEQ     REGNXC          ; IF CHANGE THEN JUMP
8606 fc9d 81 0d                      CMPA    #CR             ; ? NO MORE DESIRED
8607 fc9f 27 1e                      BEQ     REGAGN          ; BRANCH NOPE
8608 fca1 e6 3f                      LDB     -1,Y            ; LOAD SIZE FLAG
8609 fca3 5a                         DECB                    ; MINUS ONE
8610 fca4 50                         NEGB                    ; MAKE POSITIVE
8611 fca5 58                         ASLB                    ; TIMES TWO (=2 OR =4)
8612 fca6 3f                 REGSKP  SWI                     ; PERFORM SPACES
8613 fca7 07                         FCB     SPACEF          ; FUNCTION
8614 fca8 5a                         DECB
8615 fca9 26 fb                      BNE     REGSKP          ; LOOP IF MORE
8616 fcab 20 e3                      BRA     REG4            ; CONTINUE WITH NEXT REGISTER
8617 fcad a7 e4              REGNXC  STA     ,S              ; SAVE DELIMITER IN OPTION
8618                         *                               ; (ALWAYS > 0)
8619 fcaf dc 9b                      LDD     <NUMBER         ; OBTAIN BINARY RESULT
8620 fcb1 6d 3f                      TST     -1,Y            ; ? TWO BYTES WORTH
8621 fcb3 26 02                      BNE     REGTWO          ; BRANCH YES
8622 fcb5 a6 82                      LDA     ,-X             ; SETUP FOR TWO
8623 fcb7 ed 84              REGTWO  STD     ,X              ; STORE IN NEW VALUE
8624 fcb9 a6 e4                      LDA     ,S              ; RECOVER DELIMITER
8625 fcbb 81 0d                      CMPA    #CR             ; ? END OF CHANGES
8626 fcbd 26 d1                      BNE     REG4            ; NO, KEEP ON TRUCK'N
8627                         * MOVE STACKED DATA TO NEW STACK IN CASE STACK
8628                         * POINTER HAS CHANGED
8629 fcbf 30 8d 73 8e        REGAGN  LEAX    TSTACK,PCR      ; LOAD TEMP AREA
8630 fcc3 c6 15                      LDB     #21             ; LOAD COUNT
8631 fcc5 35 02              REGTF1  PULS    A               ; NEXT BYTE
8632 fcc7 a7 80                      STA     ,X+             ; STORE INTO TEMP
8633 fcc9 5a                         DECB                    ; COUNT DOWN
8634 fcca 26 f9                      BNE     REGTF1          ; LOOP IF MORE
8635 fccc 10 ee 88 ec                LDS     -20,X           ; LOAD NEW STACK POINTER
8636 fcd0 c6 15                      LDB     #21             ; LOAD COUNT AGAIN
8637 fcd2 a6 82              REGTF2 LDA      ,-X             ; NEXT TO STORE
8638 fcd4 34 02                     PSHS     A               ; BACK ONTO NEW STACK
8639 fcd6 5a                        DECB                     ; COUNT DOWN
8640 fcd7 26 f9                     BNE      REGTF2          ; LOOP IF MORE
8641 fcd9 20 bc                     BRA      REGRTN          ; GO RESTART COMMAND
8642                         
8643                         *********************************************
8644                         * BLDNUM - BUILDS BINARY VALUE FROM INPUT HEX
8645                         * THE ACTIVE EXPRESSION HANDLER IS USED.
8646                         * INPUT: S=RETURN ADDRESS
8647                         * OUTPUT: A=DELIMITER WHICH TERMINATED VALUE
8648                         * (IF DELM NOT ZERO)
8649                         * "NUMBER"=WORD BINARY RESULT
8650                         * Z=1 IF INPUT RECEIVED, Z=0 IF NO HEX RECEIVED
8651                         * REGISTERS ARE TRANSPARENT
8652                         **********************************************
8653                         * EXECUTE SINGLE OR EXTENDED ROM EXPRESSION HANDLER
8654                         *
8655                         * THE FLAG "DELIM" IS USED AS FOLLOWS:
8656                         * DELIM=0 NO LEADING BLANKS, NO FORCED TERMINATOR
8657                         * DELIM=CHR ACCEPT LEADING 'CHR'S, FORCED TERMINATOR
8658 fcdb 4f                 BLDNNB  CLRA                    ; NO DYNAMIC DELIMITER
8659 fcdc 8c                         FCB     SKIP2           ; SKIP NEXT INSTRUCTION
8660                         * BUILD WITH LEADING BLANKS
8661 fcdd 86 20              BLDNUM  LDA     #'              ; ALLOW LEADING BLANKS
8662 fcdf 97 8e                      STA     <DELIM          ; STORE AS DELIMITER
8663 fce1 6e 9d 74 07                JMP     [VECTAB+.EXPAN,PCR]   ; TO EXP ANALYZER
8664                         * THIS IS THE DEFAULT SINGLE ROM ANALYZER. WE ACCEPT:
8665                         * 1) HEX INPUT
8666                         * 2) 'M' FOR LAST MEMORY EXAMINE ADDRESS
8667                         * 3) 'P' FOR PROGRAM COUNTER ADDRESS
8668                         * 4) 'W' FOR WINDOW VALUE
8669                         * 5) '@' FOR INDIRECT VALUE
8670                         
8671 fce5 34 14              EXP1    PSHS    X,B             ; SAVE REGISTERS
8672 fce7 8d 5c              EXPDLM  BSR     BLDHXI          ; CLEAR NUMBER, CHECK FIRST CHAR
8673 fce9 27 18                      BEQ     EXP2            ; IF HEX DIGIT CONTINUE BUILDING
8674                         * SKIP BLANKS IF DESIRED
8675 fceb 91 8e                      CMPA    <DELIM          ; ? CORRECT DELIMITER
8676 fced 27 f8                      BEQ     EXPDLM          ; YES, IGNORE IT
8677                         * TEST FOR M OR P
8678 fcef 9e 9e                      LDX     <ADDR           ; DEFAULT FOR 'M'
8679 fcf1 81 4d                      CMPA    #'M             ; ? MEMORY EXAMINE ADDR WANTED
8680 fcf3 27 16                      BEQ     EXPTDL          ; BRANCH IF SO
8681 fcf5 9e 93                      LDX     <PCNTER         ; DEFAULT FOR 'P'
8682 fcf7 81 50                      CMPA    #'P             ; ? LAST PROGRAM COUNTER WANTED
8683 fcf9 27 10                      BEQ     EXPTDL          ; BRANCH IF SO
8684 fcfb 9e a0                      LDX     <WINDOW         ; DEFAULT TO WINDOW
8685 fcfd 81 57                      CMPA    #'W             ; ? WINDOW WANTED
8686 fcff 27 0a                      BEQ     EXPTDL
8687                         
8688 fd01 35 94              EXPRTN  PULS    PC,X,B          ; RETURN AND RESTORE REGISTERS
8689                         * GOT HEX, NOW CONTINUE BUILDING
8690 fd03 8d 44              EXP2    BSR     BLDHEX          ; COMPUTE NEXT DIGIT
8691 fd05 27 fc                      BEQ     EXP2            ; CONTINUE IF MORE
8692 fd07 20 0a                      BRA     EXPCDL          ; SEARCH FOR +/-
8693                         * STORE VALUE AND CHECK IF NEED DELIMITER
8694 fd09 ae 84              EXPTDI  LDX     ,X              ; INDIRECTION DESIRED
8695 fd0b 9f 9b              EXPTDL  STX     <NUMBER         ; STORE RESULT
8696 fd0d 0d 8e                      TST     <DELIM          ; ? TO FORCE A DELIMITER
8697 fd0f 27 f0                      BEQ     EXPRTN          ; RETURN IF NOT WITH VALUE
8698 fd11 8d 62                      BSR     READC           ; OBTAIN NEXT CHARACTER
8699                         * TEST FOR + OR -
8700 fd13 9e 9b              EXPCDL  LDX     <NUMBER         ; LOAD LAST VALUE
8701 fd15 81 2b                      CMPA    #'+             ; ? ADD OPERATOR
8702 fd17 26 0e                      BNE     EXPCHM          ; BRANCH NOT
8703 fd19 8d 23                      BSR     EXPTRM          ; COMPUTE NEXT TERM
8704 fd1b 34 02                      PSHS    A               ; SAVE DELIMITER
8705 fd1d dc 9b                      LDD     <NUMBER         ; LOAD NEW TERM
8706 fd1f 30 8b              EXPADD  LEAX    D,X             ; ADD TO X
8707 fd21 9f 9b                      STX     <NUMBER         ; STORE AS NEW RESULT
8708 fd23 35 02                      PULS    A               ; RESTORE DELIMITER
8709 fd25 20 ec                      BRA     EXPCDL          ; NOW TEST IT
8710 fd27 81 2d              EXPCHM  CMPA    #'-             ; ? SUBTRACT OPERATOR
8711 fd29 27 07                      BEQ     EXPSUB          ; BRANCH IF SO
8712 fd2b 81 40                      CMPA    #'@             ; ? INDIRECTION DESIRED
8713 fd2d 27 da                      BEQ     EXPTDI          ; BRANCH IF SO
8714 fd2f 5f                         CLRB                    ; SET DELIMITER RETURN
8715 fd30 20 cf                      BRA     EXPRTN          ; AND RETURN TO CALLER
8716 fd32 8d 0a              EXPSUB  BSR     EXPTRM          ; OBTAIN NEXT TERM
8717 fd34 34 02                      PSHS    A               ; SAVE DELIMITER
8718 fd36 dc 9b                      LDD     <NUMBER         ; LOAD UP NEXT TERM
8719 fd38 40                         NEGA                    ; NEGATE A
8720 fd39 50                         NEGB                    ; NEGATE B
8721 fd3a 82 00                      SBCA    #0              ; CORRECT FOR A
8722 fd3c 20 e1                      BRA     EXPADD          ; GO ADD TO EXPRESSION
8723                         * COMPUTE NEXT EXPRESSION TERM
8724                         * OUTPUT: X=OLD VALUE
8725                         * 'NUMBER'=NEXT TERM
8726 fd3e 8d 9d              EXPTRM  BSR     BLDNUM          ; OBTAIN NEXT VALUE
8727 fd40 27 32                      BEQ     CNVRTS          ; RETURN IF VALID NUMBER
8728 fd42 16 fc 17           BLDBAD  LBRA    CMDBAD          ; ABORT COMMAND IF INVALID
8729                         
8730                         *********************************************
8731                         * BUILD BINARY VALUE USING INPUT CHARACTERS.
8732                         * INPUT: A=ASCII HEX VALUE OR DELIMITER
8733                         * SP+0=RETURN ADDRESS
8734                         * SP+2=16 BIT RESULT AREA
8735                         * OUTPUT: Z=1 A=BINARY VALUE
8736                         * Z=0 IF INVALID HEX CHARACTER (A UNCHANGED)
8737                         * VOLATILE: D
8738                         ****************************************
8739 fd45 0f 9b              BLDHXI  CLR     <NUMBER         ; CLEAR NUMBER
8740 fd47 0f 9c                      CLR     <NUMBER+1       ; CLEAR NUMBER
8741 fd49 8d 2a              BLDHEX  BSR     READC           ; GET INPUT CHARACTER
8742 fd4b 8d 11              BLDHXC  BSR     CNVHEX          ; CONVERT AND TEST CHARACTER
8743 fd4d 26 25                      BNE     CNVRTS          ; RETURN IF NOT A NUMBER
8744 fd4f c6 10                      LDB     #16             ; PREPARE SHIFT
8745 fd51 3d                         MUL                     ; BY FOUR PLACES
8746 fd52 86 04                      LDA     #4              ; ROTATE BINARY INTO VALUE
8747 fd54 58                 BLDSHF  ASLB                    ; OBTAIN NEXT BIT
8748 fd55 09 9c                      ROL     <NUMBER+1       ; INTO LOW BYTE
8749 fd57 09 9b                      ROL     <NUMBER         ; INTO HI BYTE
8750 fd59 4a                         DECA                    ; COUNT DOWN
8751 fd5a 26 f8                      BNE     BLDSHF          ; BRANCH IF MORE TO DO
8752 fd5c 20 14                      BRA     CNVOK           ; SET GOOD RETURN CODE
8753                         
8754                         ****************************************
8755                         * CONVERT ASCII CHARACTER TO BINARY BYTE
8756                         * INPUT: A=ASCII
8757                         * OUTPUT: Z=1 A=BINARY VALUE
8758                         * Z=0 IF INVALID
8759                         * ALL REGISTERS TRANSPARENT
8760                         * (A UNALTERED IF INVALID HEX)
8761                         **************************************
8762 fd5e 81 30              CNVHEX  CMPA    #'0             ; ? LOWER THAN A ZERO
8763 fd60 25 12                      BLO     CNVRTS          ; BRANCH NOT VALUE
8764 fd62 81 39                      CMPA    #'9             ; ? POSSIBLE A-F
8765 fd64 2f 0a                      BLE     CNVGOT          ; BRANCH NO TO ACCEPT
8766 fd66 81 41                      CMPA    #'A             ; ? LESS THEN TEN
8767 fd68 25 0a                      BLO     CNVRTS          ; RETURN IF MINUS (INVALID)
8768 fd6a 81 46                      CMPA    #'F             ; ? NOT TOO LARGE
8769 fd6c 22 06                      BHI     CNVRTS          ; NO, RETURN TOO LARGE
8770 fd6e 80 07                      SUBA    #7              ; DOWN TO BINARY
8771 fd70 84 0f              CNVGOT  ANDA    #$0F            ; CLEAR HIGH HEX
8772 fd72 1a 04              CNVOK   ORCC    #4              ; FORCE ZERO ON FOR VALID HEX
8773 fd74 39                 CNVRTS  RTS                     ; RETURN TO CALLER
8774                         
8775                         * GET INPUT CHAR, ABORT COMMAND IF CONTROL-X (CANCEL)
8776 fd75 3f                 READC    SWI                    ; GET NEXT CHARACTER
8777 fd76 00                          FCB    INCHNP          ; FUNCTION
8778 fd77 81 18                       CMPA   #CAN            ; ? ABORT COMMAND
8779 fd79 27 c7                       BEQ    BLDBAD          ; BRANCH TO ABORT IF SO
8780 fd7b 39                          RTS                    ; RETURN TO CALLER
8781                         *G
8782                         
8783                         ***************GO - START PROGRAM EXECUTION
8784 fd7c 8d 01              CGO      BSR    GOADDR          ; BUILD ADDRESS IF NEEDED
8785 fd7e 3b                          RTI                    ; START EXECUTING
8786                         
8787                         * FIND OPTIONAL NEW PROGRAM COUNTER. ALSO ARM THE
8788                         * BREAKPOINTS.
8789 fd7f 35 30              GOADDR   PULS   Y,X             ; RECOVER RETURN ADDRESS
8790 fd81 34 10                       PSHS   X               ; STORE RETURN BACK
8791 fd83 26 19                       BNE    GONDFT          ; IF NO CARRIAGE RETURN THEN NEW PC
8792                         
8793                         * DEFAULT PROGRAM COUNTER, SO FALL THROUGH IF
8794                         * IMMEDIATE BREAKPOINT.
8795 fd85 17 01 b6                    LBSR   CBKLDR          ; SEARCH BREAKPOINTS
8796 fd88 ae 6c                       LDX    12,S            ; LOAD PROGRAM COUNTER
8797 fd8a 5a                 ARMBLP  DECB                    ; COUNT DOWN
8798 fd8b 2b 16                      BMI     ARMBK2          ; DONE, NONE TO SINGLE TRACE
8799 fd8d a6 30                      LDA     -NUMBKP*2,Y     ; PRE-FETCH OPCODE
8800 fd8f ac a1                      CMPX    ,Y++            ; ? IS THIS A BREAKPOINT
8801 fd91 26 f7                      BNE     ARMBLP          ; LOOP IF NOT
8802 fd93 81 3f                      CMPA    #$3F            ; ? SWI BREAKPOINTED
8803 fd95 26 02                      BNE     ARMNSW          ; NO, SKIP SETTING OF PASS FLAG
8804 fd97 97 fb                      STA     <SWIBFL         ; SHOW UPCOMING SWI NOT BRKPNT
8805 fd99 0c 8f              ARMNSW  INC     <MISFLG         ; FLAG THRU A BREAKPOINT
8806 fd9b 16 01 06                   LBRA    CDOT            ; DO SINGLE TRACE W/O BREAKPOINTS
8807                         
8808                         * OBTAIN NEW PROGRAM COUNTER
8809 fd9e 17 00 bb           GONDFT  LBSR    CDNUM           ; OBTAIN NEW PROGRAM COUNTER
8810 fda1 ed 6c                      STD     12,S            ; STORE INTO STACK
8811 fda3 17 01 98           ARMBK2  LBSR    CBKLDR          ; OBTAIN TABLE
8812 fda6 00 fa                      NEG     <BKPTCT         ; COMPLEMENT TO SHOW ARMED
8813 fda8 5a                 ARMLOP  DECB                    ; ? DONE
8814 fda9 2b c9                      BMI     CNVRTS          ; RETURN WHEN DONE
8815 fdab a6 b4                      LDA     [,Y]            ; LOAD OPCODE
8816 fdad a7 30                      STA     -NUMBKP*2,Y     ; STORE INTO OPCODE TABLE
8817 fdaf 86 3f                      LDA     #$3F            ; READY "SWI" OPCODE
8818 fdb1 a7 b1                      STA     [,Y++]          ; STORE AND MOVE UP TABLE
8819 fdb3 20 f3                      BRA     ARMLOP          ; AND CONTINUE
8820                         
8821                         *******************CALL - CALL ADDRESS AS SUBROUTINE
8822 fdb5 8d c8              CCALL   BSR     GOADDR          ; FETCH ADDRESS IF NEEDED
8823 fdb7 35 7f                      PULS    U,Y,X,DP,D,CC   ; RESTORE USERS REGISTERS
8824 fdb9 ad f1                      JSR     [,S++]          ; CALL USER SUBROUTINE
8825 fdbb 3f                 CGOBRK  SWI                     ; PERFORM BREAKPOINT
8826 fdbc 0a                         FCB     BRKPT           ; FUNCTION
8827 fdbd 20 fc                      BRA     CGOBRK          ; LOOP UNTIL USER CHANGES PC
8828                         
8829                         ****************MEMORY - DISPLAY/CHANGE MEMORY
8830                         * CMEMN AND CMPADP ARE DIRECT ENTRY POINTS FROM
8831                         * THE COMMAND HANDLER FOR QUICK COMMANDS
8832 fdbf 17 00 9a           CMEM    LBSR    CDNUM           ; OBTAIN ADDRESS
8833 fdc2 dd 9e              CMEMN   STD     <ADDR           ; STORE DEFAULT
8834 fdc4 9e 9e              CMEM2   LDX     <ADDR           ; LOAD POINTER
8835 fdc6 17 fc 0c                   LBSR    ZOUT2H          ; SEND OUT HEX VALUE OF BYTE
8836 fdc9 86 2d                      LDA     #'-             ; LOAD DELIMITER
8837 fdcb 3f                         SWI                     ; SEND OUT
8838 fdcc 01                         FCB     OUTCH           ; FUNCTION
8839 fdcd 17 ff 0b           CMEM4   LBSR    BLDNNB          ; OBTAIN NEW BYTE VALUE
8840 fdd0 27 0a                      BEQ     CMENUM          ; BRANCH IF NUMBER
8841                         * COMA - SKIP BYTE
8842 fdd2 81 2c                      CMPA    #',             ; ? COMMA
8843 fdd4 26 0e                      BNE     CMNOTC          ; BRANCH NOT
8844 fdd6 9f 9e                      STX     <ADDR           ; UPDATE POINTER
8845 fdd8 30 01                      LEAX    1,X             ; TO NEXT BYTE
8846 fdda 20 f1                      BRA     CMEM4           ; AND INPUT IT
8847 fddc d6 9c              CMENUM  LDB     <NUMBER+1       ; LOAD LOW BYTE VALUE
8848 fdde 8d 47                      BSR     MUPDAT          ; GO OVERLAY MEMORY BYTE
8849 fde0 81 2c                      CMPA    #',             ; ? CONTINUE WITH NO DISPLAY
8850 fde2 27 e9                      BEQ     CMEM4           ; BRANCH YES
8851                         * QUOTED STRING
8852 fde4 81 27              CMNOTC  CMPA    #$27            ; ? QUOTED STRING
8853 fde6 26 0c                      BNE     CMNOTQ          ; BRANCH NO
8854 fde8 8d 8b              CMESTR  BSR     READC           ; OBTAIN NEXT CHARACTER
8855 fdea 81 27                      CMPA    #$27            ; ? END OF QUOTED STRING
8856 fdec 27 0c                      BEQ     CMSPCE          ; YES, QUIT STRING MODE
8857 fdee 1f 89                      TFR     A,B             ; TO B FOR SUBROUTINE
8858 fdf0 8d 35                      BSR     MUPDAT          ; GO UPDATE BYTE
8859 fdf2 20 f4                      BRA     CMESTR          ; GET NEXT CHARACTER
8860                         * BLANK - NEXT BYTE
8861 fdf4 81 20              CMNOTQ  CMPA    #$20            ; ? BLANK FOR NEXT BYTE
8862 fdf6 26 06                      BNE     CMNOTB          ; BRANCH NOT
8863 fdf8 9f 9e                      STX     <ADDR           ; UPDATE POINTER
8864 fdfa 3f                 CMSPCE  SWI                     ; GIVE SPACE
8865 fdfb 07                         FCB     SPACEF          ; FUNCTION
8866 fdfc 20 c6                      BRA     CMEM2           ; NOW PROMPT FOR NEXT
8867                         
8868                         * LINE FEED - NEXT BYTE WITH ADDRESS
8869 fdfe 81 0a              CMNOTB  CMPA    #LF             ; ? LINE FEED FOR NEXT BYTE
8870 fe00 26 08                      BNE     CMNOTL          ; BRANCH NO
8871 fe02 86 0d                      LDA     #CR             ; GIVE CARRIAGE RETURN
8872 fe04 3f                         SWI                     ; TO CONSOLE
8873 fe05 01                         FCB     OUTCH           ; HANDLER
8874 fe06 9f 9e                      STX     <ADDR           ; STORE NEXT ADDRESS
8875 fe08 20 0a                      BRA     CMPADP          ; BRANCH TO SHOW
8876                         
8877                         * UP ARROW - PREVIOUS BYTE AND ADDRESS
8878 fe0a 81 5e              CMNOTL  CMPA    #'^             ; ? UP ARROW FOR PREVIOUS BYTE
8879 fe0c 26 0a                      BNE     CMNOTU          ; BRANCH NOT
8880 fe0e 30 1e                      LEAX    -2,X            ; DOWN TO PREVIOUS BYTE
8881 fe10 9f 9e                      STX     <ADDR           ; STORE NEW POINTER
8882 fe12 3f                 CMPADS  SWI                     ; FORCE NEW LINE
8883 fe13 06                         FCB     PCRLF           ; FUNCTION
8884 fe14 8d 07              CMPADP  BSR     PRTADR          ; GO PRINT ITS VALUE
8885 fe16 20 ac                      BRA     CMEM2           ; THEN PROMPT FOR INPUT
8886                         
8887                         * SLASH - NEXT BYTE WITH ADDRESS
8888 fe18 81 2f              CMNOTU  CMPA    #'/             ; ? SLASH FOR CURRENT DISPLAY
8889 fe1a 27 f6                      BEQ     CMPADS          ; YES, SEND ADDRESS
8890 fe1c 39                         RTS                     ; RETURN FROM COMMAND
8891                         
8892                         * PRINT CURRENT ADDRESS
8893 fe1d 9e 9e              PRTADR  LDX     <ADDR           ; LOAD POINTER VALUE
8894 fe1f 34 10                      PSHS    X               ; SAVE X ON STACK
8895 fe21 30 e4                      LEAX    ,S              ; POINT TO IT FOR DISPLAY
8896 fe23 3f                         SWI                     ; DISPLAY POINTER IN HEX
8897 fe24 05                         FCB     OUT4HS          ; FUNCTION
8898 fe25 35 90                      PULS    PC,X            ; RECOVER POINTER AND RETURN
8899                         
8900                         * UPDATE BYTE
8901 fe27 9e 9e              MUPDAT  LDX     <ADDR           ; LOAD NEXT BYTE POINTER
8902 fe29 e7 80                      STB     ,X+             ; STORE AND INCREMENT X
8903 fe2b e1 1f                      CMPB    -1,X            ; ? SUCCESFULL STORE
8904 fe2d 26 03                      BNE     MUPBAD          ; BRANCH FOR '?' IF NOT
8905 fe2f 9f 9e                      STX     <ADDR           ; STORE NEW POINTER VALUE
8906 fe31 39                         RTS                     ; BACK TO CALLER
8907 fe32 34 02              MUPBAD  PSHS    A               ; SAVE A REGISTER
8908 fe34 86 3f                      LDA     #'?             ; SHOW INVALID
8909 fe36 3f                         SWI                     ; SEND OUT
8910 fe37 01                         FCB     OUTCH           ; FUNCTION
8911 fe38 35 82                      PULS    PC,A            ; RETURN TO CALLER
8912                         
8913                         ********************WINDOW - SET WINDOW VALUE
8914 fe3a 8d 20              CWINDO  BSR     CDNUM           ; OBTAIN WINDOW VALUE
8915 fe3c dd a0                      STD     <WINDOW         ; STORE IT IN
8916 fe3e 39                         RTS                     ; END COMMAND
8917                         
8918                         ******************DISPLAY - HIGH SPEED DISPLAY MEMORY
8919 fe3f 8d 1b              CDISP   BSR     CDNUM           ; FETCH ADDRESS
8920 fe41 c4 f0                      ANDB    #$F0            ; FORCE TO 16 BOUNDARY
8921 fe43 1f 02                      TFR     D,Y             ; SAVE IN Y
8922 fe45 30 2f                      LEAX    15,Y            ; DEFAULT LENGTH
8923 fe47 25 04                      BCS     CDISPS          ; BRANCH IF END OF INPUT
8924 fe49 8d 11                      BSR     CDNUM           ; OBTAIN COUNT
8925 fe4b 30 ab                      LEAX    D,Y             ; ASSUME COUNT, COMPUTE END ADDR
8926 fe4d 34 30              CDISPS  PSHS    Y,X             ; SETUP PARAMETERS FOR HSDATA
8927 fe4f 10 a3 62                   CMPD    2,S             ; ? WAS IT COUNT
8928 fe52 23 02                      BLS     CDCNT           ; BRANCH YES
8929 fe54 ed e4                      STD     ,S              ; STORE HIGH ADDRESS
8930 fe56 ad 9d 72 88        CDCNT   JSR     [VECTAB+.HSDTA,PCR] ; CALL PRINT ROUTINE
8931 fe5a 35 e0                      PULS    PC,U,Y          ; CLEAN STACK AND END COMMAND
8932                         
8933                         * OBTAIN NUMBER - ABORT IF NONE
8934                         * ONLY DELIMITERS OF CR, BLANK, OR '/' ARE ACCEPTED
8935                         * OUTPUT: D=VALUE, C=1 IF CARRIAGE RETURN DELMITER,
8936                         * ELSE C=0
8937 fe5c 17 fe 7e           CDNUM   LBSR    BLDNUM          ; OBTAIN NUMBER
8938 fe5f 26 09                      BNE     CDBADN          ; BRANCH IF INVALID
8939 fe61 81 2f                      CMPA    #'/             ; ? VALID DELIMITER
8940 fe63 22 05                      BHI     CDBADN          ; BRANCH IF NOT FOR ERROR
8941 fe65 81 0e                      CMPA    #CR+1           ; LEAVE COMPARE FOR CARRIAGE RET
8942 fe67 dc 9b                      LDD     <NUMBER         ; LOAD NUMBER
8943 fe69 39                         RTS                     ; RETURN WITH COMPARE
8944 fe6a 16 fa ef           CDBADN  LBRA    CMDBAD          ; RETURN TO ERROR MECHANISM
8945                         
8946                         *****************PUNCH - PUNCH MEMORY IN S1-S9 FORMAT
8947 fe6d 8d ed              CPUNCH  BSR     CDNUM           ; OBTAIN START ADDRESS
8948 fe6f 1f 02                      TFR     D,Y             ; SAVE IN Y
8949 fe71 8d e9                      BSR     CDNUM           ; OBTAIN END ADDRESS
8950 fe73 6f e2                      CLR     ,-S             ; SETUP PUNCH FUNCTION CODE
8951 fe75 34 26                      PSHS    Y,D             ; STORE VALUES ON STACK
8952 fe77 ad 9d 72 69        CCALBS  JSR     [VECTAB+.BSON,PCR] ; INITIALIZE HANDLER
8953 fe7b ad 9d 72 67                JSR     [VECTAB+.BSDTA,PCR] ; PERFORM FUNCTION
8954 fe7f 34 01                      PSHS    CC              ; SAVE RETURN CODE
8955 fe81 ad 9d 72 63                JSR     [VECTAB+.BSOFF,PCR] ; TURN OFF HANDLER
8956 fe85 35 01                      PULS    CC              ; OBTAIN CONDITION CODE SAVED
8957 fe87 26 e1                      BNE     CDBADN          ; BRANCH IF ERROR
8958 fe89 35 b2                      PULS    PC,Y,X,A        ; RETURN FROM COMMAND
8959                         
8960                         *****************LOAD - LOAD MEMORY FROM S1-S9 FORMAT
8961 fe8b 8d 01              CLOAD   BSR     CLVOFS          ; CALL SETUP AND PASS CODE
8962 fe8d 01                         FCB     1               ; LOAD FUNCTION CODE FOR PACKET
8963                         
8964 fe8e 33 f1              CLVOFS  LEAU    [,S++]          ; LOAD CODE IN HIGH BYTE OF U
8965 fe90 33 d4                      LEAU    [,U]            ; NOT CHANGING CC AND RESTORE S
8966 fe92 27 03                      BEQ     CLVDFT          ; BRANCH IF CARRIAGE RETURN NEXT
8967 fe94 8d c6                      BSR     CDNUM           ; OBTAIN OFFSET
8968 fe96 8c                         FCB     SKIP2           ; SKIP DEFAULT OFFSET
8969 fe97 4f                 CLVDFT  CLRA                    ; CREATE ZERO OFFSET
8970 fe98 5f                         CLRB                    ; AS DEFAULT
8971 fe99 34 4e                      PSHS    U,DP,D          ; SETUP CODE, NULL WORD, OFFSET
8972 fe9b 20 da                      BRA     CCALBS          ; ENTER CALL TO BS ROUTINES
8973                         
8974                         ******************VERIFY - COMPARE MEMORY WITH FILES
8975 fe9d 8d ef              CVER    BSR     CLVOFS          ; COMPUTE OFFSET IF ANY
8976 fe9f ff                         FCB     -1              ; VERIFY FNCTN CODE FOR PACKET
8977                         
8978                         *******************TRACE - TRACE INSTRUCTIONS
8979                         ******************* . - SINGLE STEP TRACE
8980 fea0 8d ba              CTRACE  BSR     CDNUM           ; OBTAIN TRACE COUNT
8981 fea2 dd 91                      STD     <TRACEC         ; STORE COUNT
8982 fea4 32 62              CDOT    LEAS    2,S             ; RID COMMAND RETURN FROM STACK
8983 fea6 ee f8 0a           CTRCE3  LDU     [10,S]          ; LOAD OPCODE TO EXECUTE
8984 fea9 df 99                      STU     <LASTOP         ; STORE FOR TRACE INTERRUPT
8985 feab de f6                      LDU     <VECTAB+.PTM    ; LOAD PTM ADDRESS
8986 fead cc 07 01                   LDD     #$0701          ; 7,1 CYCLES DOWN+CYCLES UP
8987 feb0 ed 42                      STD     PTMTM1-PTM,U    ; START NMI TIMEOUT
8988 feb2 3b                         RTI                     ; RETURN FOR ONE INSTRUCTION
8989                         
8990                         *************NULLS  -  SET NEW LINE AND CHAR PADDING
8991 feb3 8d a7              CNULLS  BSR     CDNUM           ; OBTAIN NEW LINE PAD
8992 feb5 dd f2                      STD     <VECTAB+.PAD    ; RESET VALUES
8993 feb7 39                         RTS                     ; END COMMAND
8994                         
8995                         ******************STLEVEL - SET STACK TRACE LEVEL
8996 feb8 27 05              CSTLEV  BEQ     STLDFT          ; TAKE DEFAULT
8997 feba 8d a0                      BSR     CDNUM           ; OBTAIN NEW STACK LEVEL
8998 febc dd f8                      STD     <SLEVEL         ; STORE NEW ENTRY
8999 febe 39                         RTS                     ; TO COMMAND HANDLER
9000 febf 30 6e              STLDFT  LEAX    14,S            ; COMPUTE NMI COMPARE
9001 fec1 9f f8                      STX     <SLEVEL         ; AND STORE IT
9002 fec3 39                         RTS                     ; END COMMAND
9003                         
9004                         ******************OFFSET - COMPUTE SHORT AND LONG
9005                         ******************                  BRANCH OFFSETS
9006 fec4 8d 96              COFFS   BSR     CDNUM           ; OBTAIN INSTRUCTION ADDRESS
9007 fec6 1f 01                      TFR     D,X             ; USE AS FROM ADDRESS
9008 fec8 8d 92                      BSR     CDNUM           ; OBTAIN TO ADDRESS
9009                         * D=TO INSTRUCTION, X=FROM INSTRUCTION OFFSET BYTE(S)
9010 feca 30 01                      LEAX    1,X             ; ADJUST FOR *+2 SHORT BRANCH
9011 fecc 34 30                      PSHS    Y,X             ; STORE WORK WORD AND VALUE ON S
9012 fece a3 e4                      SUBD    ,S              ; FIND OFFSET
9013 fed0 ed e4                      STD     ,S              ; SAVE OVER STACK
9014 fed2 30 61                      LEAX    1,S             ; POINT FOR ONE BYTE DISPLAY
9015 fed4 1d                         SEX                     ; SIGN EXTEND LOW BYTE
9016 fed5 a1 e4                      CMPA    ,S              ; ? VALID ONE BYTE OFFSET
9017 fed7 26 02                      BNE     COFNO1          ; BRANCH IF NOT
9018 fed9 3f                         SWI                     ; SHOW ONE BYTE OFFSET
9019 feda 04                         FCB     OUT2HS          ; FUNCTION
9020 fedb ee e4              COFNO1  LDU     ,S              ; RELOAD OFFSET
9021 fedd 33 5f                      LEAU    -1,U            ; CONVERT TO LONG BRANCH OFFSET
9022 fedf ef 84                      STU     ,X              ; STORE BACK WHERE X POINTS NOW
9023 fee1 3f                         SWI                     ; SHOW TWO BYTE OFFSET
9024 fee2 05                         FCB     OUT4HS          ; FUNCTION
9025 fee3 3f                         SWI                     ; FORCE NEW LINE
9026 fee4 06                         FCB     PCRLF           ; FUNCTION
9027 fee5 35 96                      PULS    PC,X,D          ; RESTORE STACK AND END COMMAND
9028                         *H
9029                         
9030                         *************BREAKPOINT - DISPLAY/ENTER/DELETE/CLEAR
9031                         *************             BREAKPOINTS
9032 fee7 27 23              CBKPT   BEQ     CBKDSP          ; BRANCH DISPLAY OF JUST 'B'
9033 fee9 17 fd f1                   LBSR    BLDNUM          ; ATTEMPT VALUE ENTRY
9034 feec 27 2c                      BEQ     CBKADD          ; BRANCH TO ADD IF SO
9035 feee 81 2d                      CMPA    #'-             ; ? CORRECT DELIMITER
9036 fef0 26 3f                      BNE     CBKERR          ; NO, BRANCH FOR ERROR
9037 fef2 17 fd e8                   LBSR    BLDNUM          ; ATTEMPT DELETE VALUE
9038 fef5 27 03                      BEQ     CBKDLE          ; GOT ONE, GO DELETE IT
9039 fef7 0f fa                      CLR     <BKPTCT         ; WAS 'B -', SO ZERO COUNT
9040 fef9 39                 CBKRTS  RTS                     ; END COMMAND
9041                         * DELETE THE ENTRY
9042 fefa 8d 40              CBKDLE  BSR     CBKSET          ; SETUP REGISTERS AND VALUE
9043 fefc 5a                 CBKDLP  DECB                    ; ? ANY ENTRIES IN TABLE
9044 fefd 2b 32                      BMI     CBKERR          ; BRANCH NO, ERROR
9045 feff ac a1                      CMPX    ,Y++            ; ? IS THIS THE ENTRY
9046 ff01 26 f9                      BNE     CBKDLP          ; NO, TRY NEXT
9047                         * FOUND, NOW MOVE OTHERS UP IN ITS PLACE
9048 ff03 ae a1              CBKDLM  LDX     ,Y++            ; LOAD NEXT ONE UP
9049 ff05 af 3c                      STX     -4,Y            ; MOVE DOWN BY ONE
9050 ff07 5a                         DECB                    ; ? DONE
9051 ff08 2a f9                      BPL     CBKDLM          ; NO, CONTINUE MOVE
9052 ff0a 0a fa                      DEC     <BKPTCT         ; DECREMENT BREAKPOINT COUNT
9053 ff0c 8d 2e              CBKDSP  BSR     CBKSET          ; SETUP REGISTERS AND LOAD VALUE
9054 ff0e 27 e9                      BEQ     CBKRTS          ; RETURN IF NONE TO DISPLY
9055 ff10 30 a1              CBKDSL  LEAX    ,Y++            ; POINT TO NEXT ENTRY
9056 ff12 3f                         SWI                     ; DISPLAY IN HEX
9057 ff13 05                         FCB     OUT4HS          ; FUNCTION
9058 ff14 5a                         DECB                    ; COUNT DOWN
9059 ff15 26 f9                      BNE     CBKDSL          ; LOOP IF NGABLE RAM
9060 ff17 3f                         SWI                     ; SKIP TO NEW LINK
9061 ff18 06                         FCB     PCRLF           ; FUNCTIONRTS
9062 ff19 39                         RTS
9063                         
9064                         * ADD NEW ENTRY
9065 ff1a 8d 20              CBKADD  BSR     CBKSET          ; SETUP REGISTERS
9066 ff1c c1 08                      CMPB    #NUMBKP         ; ? ALREADY FULL
9067 ff1e 27 11                      BEQ     CBKERR          ; BRANCH ERROR IF SO
9068 ff20 a6 84                      LDA     ,X              ; LOAD BYTE TO TRAP
9069 ff22 e7 84                      STB     ,X              ; TRY TO CHANGE
9070 ff24 e1 84                      CMPB    ,X              ; ? CHANGEABLE RAM
9071 ff26 26 09                      BNE     CBKERR          ; BRANCH ERROR IF NOT
9072 ff28 a7 84                      STA ,X                  ; RESTORE BYTE
9073 ff2a 5a                 CBKADL  DECB                    ; COUNT DOWN
9074 ff2b 2b 07                      BMI     CBKADT          ; BRANCH IF DONE TO ADD IT
9075 ff2d ac a1                      CMPX    ,Y++            ; ? ENTRY ALREADY HERE
9076 ff2f 26 f9                      BNE     CBKADL          ; LOOP IF NOT
9077 ff31 16 fa 28           CBKERR  LBRA    CMDBAD          ; RETURN TO ERROR PRODUCE
9078 ff34 af a4              CBKADT  STX ,Y                  ; ADD THIS ENTRY
9079 ff36 6f 31                      CLR     -NUMBKP*2+1,Y   ; CLEAR OPTIONAL BYTE
9080 ff38 0c fa                      INC     <BKPTCT         ; ADD ONE TO COUNT
9081 ff3a 20 d0                      BRA     CBKDSP          ; AND NOW DISPLAY ALL OF 'EM
9082                         * SETUP REGISTERS FOR SCAN
9083 ff3c 9e 9b              CBKSET  LDX     <NUMBER         ; LOAD VALUE DESIRED
9084 ff3e 31 8d 71 70        CBKLDR  LEAY    BKPTBL,PCR      ; LOAD START OF TABLE
9085 ff42 d6 fa                      LDB     <BKPTCT         ; LOAD ENTRY COUNT
9086 ff44 39                         RTS                     ; RETURN
9087                         
9088                         *****************ENCODE  -  ENCODE A POSTBYTE
9089 ff45 6f e2              CENCDE  CLR     ,-S             ; DEFAULT TO NOT INDIRECT
9090 ff47 5f                         CLRB                    ; ZERO POSTBYTE VALUE
9091 ff48 30 8c 3f                   LEAX    <CONV1,PCR      ; START TABLE SEARCH
9092 ff4b 3f                         SWI                     ; OBTAIN FIRST CHARACTER
9093 ff4c 00                         FCB     INCHNP          ; FUNCTION
9094 ff4d 81 5b                      CMPA    #'[             ; ? INDIRECT HERE
9095 ff4f 26 06                      BNE     CEN2            ; BRANCH IF NOT
9096 ff51 86 10                      LDA     #$10            ; SET INDIRECT BIT ON
9097 ff53 a7 e4                      STA     ,S              ; SAVE FOR LATER
9098 ff55 3f                 CENGET  SWI                     ; OBTAIN NEXT CHARACTER
9099 ff56 00                         FCB     INCHNP          ; FUNCTION
9100 ff57 81 0d              CEN2    CMPA    #CR             ; ? END OF ENTRY
9101 ff59 27 0c                      BEQ     CEND1           ; BRANCH YES
9102 ff5b 6d 84              CENLP1  TST     ,X              ; ? END OF TABLE
9103 ff5d 2b d2                      BMI     CBKERR          ; BRANCH ERROR IF SO
9104 ff5f a1 81                      CMPA    ,X++            ; ? THIS THE CHARACTER
9105 ff61 26 f8                      BNE     CENLP1          ; BRANCH IF NOT
9106 ff63 eb 1f                      ADDB    -1,X            ; ADD THIS VALUE
9107 ff65 20 ee                      BRA     CENGET          ; GET NEXT INPUT
9108 ff67 30 8c 49           CEND1   LEAX    <CONV2,PCR      ; POINT AT TABLE 2
9109 ff6a 1f 98                      TFR     B,A             ; SAVE COPY IN A
9110 ff6c 84 60                      ANDA    #$60            ; ISOLATE REGISTER MASK
9111 ff6e aa e4                      ORA     ,S              ; ADD IN INDIRECTION BIT
9112 ff70 a7 e4                      STA     ,S              ; SAVE BACK AS POSTBYTE SKELETON
9113 ff72 c4 9f                      ANDB    #$9F            ; CLEAR REGISTER BITS
9114 ff74 6d 84              CENLP2  TST     ,X              ; ? END OF TABLE
9115 ff76 27 b9                      BEQ     CBKERR          ; BRANCH ERROR IF SO
9116 ff78 e1 81                      CMPB    ,X++            ; ? SAME VALUE
9117 ff7a 26 f8                      BNE     CENLP2          ; LOOP IF NOT
9118 ff7c e6 1f                      LDB     -1,X            ; LOAD RESULT VALUE
9119 ff7e ea e4                      ORB     ,S              ; ADD TO BASE SKELETON
9120 ff80 e7 e4                      STB     ,S              ; SAVE POSTBYTE ON STACK
9121 ff82 30 e4                      LEAX    ,S              ; POINT TO IT
9122 ff84 3f                         SWI                     ; SEND OUT AS HEX
9123 ff85 04                         FCB     OUT2HS          ; FUNCTION
9124 ff86 3f                         SWI                     ; TO NEXT LINE
9125 ff87 06                         FCB     PCRLF           ; FUNCTION
9126 ff88 35 84                      PULS    PC,B            ; END OF COMMAND
9127                         
9128                         * TABLE ONE DEFINES VALID INPUT IN SEQUENCE
9129                         CONV1
9130 ff8a 41 04 42 05 44 06          FCB     'A,$04,'B,$05,'D,$06,'H,$01
     48 01
9131 ff92 48 01 48 01 48 00          FCB     'H,$01,'H,$01,'H,$00,',,$00
     2c 00
9132 ff9a 2d 09 2d 01 53 70          FCB     '-,$09,'-,$01,'S,$70,'Y,$30
     59 30
9133 ffa2 55 50 58 10 2b 07          FCB     'U,$50,'X,$10,'+,$07,'+,$01
     2b 01
9134 ffaa 50 80 43 00 52 00          FCB     'P,$80,'C,$00,'R,$00,'],$00
     5d 00
9135 ffb2 ff                         FCB     $FF             ; END OF TABLE
9136                         
9137                         * CONV2 USES ABOVE CONVERSION TO SET POSTBYTE
9138                         * BIT SKELETON.
9139                         CONV2
9140 ffb3 10 84 11 00                FDB     $1084,$1100     ; R,      H,R
9141 ffb7 12 88 13 89                FDB     $1288,$1389     ; HH,R    HHHH,R
9142 ffbb 14 86 15 85                FDB     $1486,$1585     ; A,R     B,R
9143 ffbf 16 8b 17 80                FDB     $168B,$1780     ; D,R     ,R+
9144 ffc3 18 81 19 82                FDB     $1881,$1982     ; ,R++    ,-R
9145 ffc7 1a 83 82 8c                FDB     $1A83,$828C     ; ,--R    HH,PCR
9146 ffcb 83 8d 03 9f                FDB     $838D,$039F     ; HHHH,PCR [HHHH]
9147 ffcf 00                         FCB     0               ; END OF TABLE
9148                         
9149                         ****************************************************
9150                         *            DEFAULT INTERRUPT TRANSFERS           *
9151                         ****************************************************
9152 ffd0 6e 9d 70 f2        RSRVD   JMP     [VECTAB+.RSVD,PCR]      ; RESERVED VECTOR
9153 ffd4 6e 9d 70 f0        SWI3    JMP     [VECTAB+.SWI3,PCR]      ; SWI3 VECTOR
9154 ffd8 6e 9d 70 ee        SWI2    JMP     [VECTAB+.SWI2,PCR]      ; SWI2 VECTOR
9155 ffdc 6e 9d 70 ec        FIRQ    JMP     [VECTAB+.FIRQ,PCR]      ; FIRQ VECTOR
9156 ffe0 6e 9d 70 ea        IRQ     JMP     [VECTAB+.IRQ,PCR]       ; IRQ VECTOR
9157 ffe4 6e 9d 70 e8        SWI     JMP     [VECTAB+.SWI,PCR]       ; SWI VECTOR
9158 ffe8 6e 9d 70 e6        NMI     JMP     [VECTAB+.NMI,PCR]       ; NMI VECTOR
9159                         
9160                         ******************************************************
9161                         *            ASSIST09 HARDWARE VECTOR TABLE
9162                         * THIS TABLE IS USED IF THE ASSIST09 ROM ADDRESSES
9163                         * THE MC6809 HARDWARE VECTORS.
9164                         ******************************************************
9165 fff0                            ORG     ROMBEG+ROMSIZ-16 ; SETUP HARDWARE VECTORS
9166 fff0 ff d0                      FDB     RSRVD           ; RESERVED SLOT
9167 fff2 ff d4                      FDB     SWI3            ; SOFTWARE INTERRUPT 3
9168 fff4 ff d8                      FDB     SWI2            ; SOFTWARE INTERRUPT 2
9169 fff6 ff dc                      FDB     FIRQ            ; FAST INTERRUPT REQUEST
9170 fff8 ff e0                      FDB     IRQ             ; INTERRUPT REQUEST
9171 fffa ff e4                      FDB     SWI             ; SOFTWARE INTERRUPT
9172 fffc ff e8                      FDB     NMI             ; NON-MASKABLE INTERRUPT
9173 fffe f8 37                      FDB     RESET           ; RESTART
