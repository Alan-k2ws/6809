0001                         ;
0002                         ; 6809 Disassembler
0003                         ;
0004                         ; Copyright (C) 2019 by Jeff Tranter <tranter@pobox.com>
0005                         ;
0006                         ; Licensed under the Apache License, Version 2.0 (the "License");
0007                         ; you may not use this file except in compliance with the License.
0008                         ; You may obtain a copy of the License at
0009                         ;
0010                         ;   http://www.apache.org/licenses/LICENSE-2.0
0011                         ;
0012                         ; Unless required by applicable law or agreed to in writing, software
0013                         ; distributed under the License is distributed on an "AS IS" BASIS,
0014                         ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0015                         ; See the License for the specific language governing permissions and
0016                         ; limitations under the License.
0017                         ;
0018                         ; Revision History
0019                         ; Version Date         Comments
0020                         ; 0.0     29-Jan-2019  First version started, based on 6502 code.
0021                         ; 0.1     03-Feb-2019  All instructions now supported.
0022                         ; 0.2     05-Feb-2019  Integrated into ASSSIST09/BASIC ROM.
0023                         
0024                         ; Character defines
0025                         
0026 000d                    RET     EQU     $0D             ; Carriage return
0027 0020                    SP      EQU     $20             ; Space
0028                         
0029 0018                    PAGELEN EQU     24              ; Number of instructions to show before waiting for keypress
0030                         
0031                         ; Start address for RAM variables
0032 5ff0                            ORG     $5FF0
0033                         
0034                         ; Variables
0035                         
0036 5ff0                    ADRS    RMB     2               ; Current address to disassemble
0037 5ff2                    OPCODE  RMB     1               ; Opcode of instruction
0038 5ff3                    AM      RMB     1               ; Addressing mode of instruction
0039 5ff4                    OPTYPE  RMB     1               ; Instruction type
0040 5ff5                    POSTBYT RMB     1               ; Post byte (for indexed addressing)
0041 5ff6                    LENG    RMB     1               ; Length of instruction
0042 5ff7                    TEMP    RMB     2               ; Temp variable (used by print routines)
0043 5ff9                    TEMP1   RMB     2               ; Temp variable
0044 5ffb                    FIRST   RMB     1               ; Flag used to indicate first time an item printed
0045 5ffc                    PAGE23  RMB     1               ; Flag indicating page2/3 instruction when non-zero
0046                         
0047                         ; Instructions. Matches indexes into entries in table MNEMONICS.
0048                         
0049 0000                    OP_INV   EQU    $00
0050 0001                    OP_ABX   EQU    $01
0051 0002                    OP_ADCA  EQU    $02
0052 0003                    OP_ADCB  EQU    $03
0053 0004                    OP_ADDA  EQU    $04
0054 0005                    OP_ADDB  EQU    $05
0055 0006                    OP_ADDD  EQU    $06
0056 0007                    OP_ANDA  EQU    $07
0057 0008                    OP_ANDB  EQU    $08
0058 0009                    OP_ANDCC EQU    $09
0059 000a                    OP_ASL   EQU    $0A
0060 000b                    OP_ASLA  EQU    $0B
0061 000c                    OP_ASLB  EQU    $0C
0062 000d                    OP_ASR   EQU    $0D
0063 000e                    OP_ASRA  EQU    $0E
0064 000f                    OP_ASRB  EQU    $0F
0065 0010                    OP_BCC   EQU    $10
0066 0011                    OP_BCS   EQU    $11
0067 0012                    OP_BEQ   EQU    $12
0068 0013                    OP_BGE   EQU    $13
0069 0014                    OP_BGT   EQU    $14
0070 0015                    OP_BHI   EQU    $15
0071 0016                    OP_BHS   EQU    $16
0072 0017                    OP_BITA  EQU    $17
0073 0018                    OP_BITB  EQU    $18
0074 0019                    OP_BLE   EQU    $19
0075 001a                    OP_BLO   EQU    $1A
0076 001b                    OP_BLS   EQU    $1B
0077 001c                    OP_BLT   EQU    $1C
0078 001d                    OP_BMI   EQU    $1D
0079 001e                    OP_BNE   EQU    $1E
0080 001f                    OP_BPL   EQU    $1F
0081 0020                    OP_BRA   EQU    $20
0082 0021                    OP_BRN   EQU    $21
0083 0022                    OP_BSR   EQU    $22
0084 0023                    OP_BVC   EQU    $23
0085 0024                    OP_BVS   EQU    $24
0086 0025                    OP_CLR   EQU    $25
0087 0026                    OP_CLRA  EQU    $26
0088 0027                    OP_CLRB  EQU    $27
0089 0028                    OP_CMPA  EQU    $28
0090 0029                    OP_CMPB  EQU    $29
0091 002a                    OP_CMPD  EQU    $2A
0092 002b                    OP_CMPS  EQU    $2B
0093 002c                    OP_CMPU  EQU    $2C
0094 002d                    OP_CMPX  EQU    $2D
0095 002e                    OP_CMPY  EQU    $2E
0096 002f                    OP_COMA  EQU    $2F
0097 0030                    OP_COMB  EQU    $30
0098 0031                    OP_COM   EQU    $31
0099 0032                    OP_CWAI  EQU    $32
0100 0033                    OP_DAA   EQU    $33
0101 0034                    OP_DEC   EQU    $34
0102 0035                    OP_DECA  EQU    $35
0103 0036                    OP_DECB  EQU    $36
0104 0037                    OP_EORA  EQU    $37
0105 0038                    OP_EORB  EQU    $38
0106 0039                    OP_EXG   EQU    $39
0107 003a                    OP_INC   EQU    $3A
0108 003b                    OP_INCA  EQU    $3B
0109 003c                    OP_INCB  EQU    $3C
0110 003d                    OP_JMP   EQU    $3D
0111 003e                    OP_JSR   EQU    $3E
0112 003f                    OP_LBCC  EQU    $3F
0113 0040                    OP_LBCS  EQU    $40
0114 0041                    OP_LBEQ  EQU    $41
0115 0042                    OP_LBGE  EQU    $42
0116 0043                    OP_LBGT  EQU    $43
0117 0044                    OP_LBHI  EQU    $44
0118 0045                    OP_LBHS  EQU    $45
0119 0046                    OP_LBLE  EQU    $46
0120 0047                    OP_LBLO  EQU    $47
0121 0048                    OP_LBLS  EQU    $48
0122 0049                    OP_LBLT  EQU    $49
0123 004a                    OP_LBMI  EQU    $4A
0124 004b                    OP_LBNE  EQU    $4B
0125 004c                    OP_LBPL  EQU    $4C
0126 004d                    OP_LBRA  EQU    $4D
0127 004e                    OP_LBRN  EQU    $4E
0128 004f                    OP_LBSR  EQU    $4F
0129 0050                    OP_LBVC  EQU    $50
0130 0051                    OP_LBVS  EQU    $51
0131 0052                    OP_LDA   EQU    $52
0132 0053                    OP_LDB   EQU    $53
0133 0054                    OP_LDD   EQU    $54
0134 0055                    OP_LDS   EQU    $55
0135 0056                    OP_LDU   EQU    $56
0136 0057                    OP_LDX   EQU    $57
0137 0058                    OP_LDY   EQU    $58
0138 0059                    OP_LEAS  EQU    $59
0139 005a                    OP_LEAU  EQU    $5A
0140 005b                    OP_LEAX  EQU    $5B
0141 005c                    OP_LEAY  EQU    $5C
0142 005d                    OP_LSL   EQU    $5D
0143 005e                    OP_LSLA  EQU    $5E
0144 005f                    OP_LSLB  EQU    $5F
0145 0060                    OP_LSR   EQU    $60
0146 0061                    OP_LSRA  EQU    $61
0147 0062                    OP_LSRB  EQU    $62
0148 0063                    OP_MUL   EQU    $63
0149 0064                    OP_NEG   EQU    $64
0150 0065                    OP_NEGA  EQU    $65
0151 0066                    OP_NEGB  EQU    $66
0152 0067                    OP_NOP   EQU    $67
0153 0068                    OP_ORA   EQU    $68
0154 0069                    OP_ORB   EQU    $69
0155 006a                    OP_ORCC  EQU    $6A
0156 006b                    OP_PSHS  EQU    $6B
0157 006c                    OP_PSHU  EQU    $6C
0158 006d                    OP_PULS  EQU    $6D
0159 006e                    OP_PULU  EQU    $6E
0160 006f                    OP_ROL   EQU    $6F
0161 0070                    OP_ROLA  EQU    $70
0162 0071                    OP_ROLB  EQU    $71
0163 0072                    OP_ROR   EQU    $72
0164 0073                    OP_RORA  EQU    $73
0165 0074                    OP_RORB  EQU    $74
0166 0075                    OP_RTI   EQU    $75
0167 0076                    OP_RTS   EQU    $76
0168 0077                    OP_SBCA  EQU    $77
0169 0078                    OP_SBCB  EQU    $78
0170 0079                    OP_SEX   EQU    $79
0171 007a                    OP_STA   EQU    $7A
0172 007b                    OP_STB   EQU    $7B
0173 007c                    OP_STD   EQU    $7C
0174 007d                    OP_STS   EQU    $7D
0175 007e                    OP_STU   EQU    $7E
0176 007f                    OP_STX   EQU    $7F
0177 0080                    OP_STY   EQU    $80
0178 0081                    OP_SUBA  EQU    $81
0179 0082                    OP_SUBB  EQU    $82
0180 0083                    OP_SUBD  EQU    $83
0181 0084                    OP_SWI   EQU    $84
0182 0085                    OP_SWI2  EQU    $85
0183 0086                    OP_SWI3  EQU    $86
0184 0087                    OP_SYNC  EQU    $87
0185 0088                    OP_TFR   EQU    $88
0186 0089                    OP_TST   EQU    $89
0187 008a                    OP_TSTA  EQU    $8A
0188 008b                    OP_TSTB  EQU    $8B
0189                         
0190                         ; Addressing Modes. OPCODES table lists these for each instruction.
0191                         ; LENGTHS lists the instruction length for each addressing mode.
0192                         ; Need to distinguish relative modes that are 2 and 3 (long) bytes.
0193                         ; Some immediate are 2 and some 3 bytes.
0194                         ; Indexed modes can be longer depending on postbyte.
0195                         ; Page 2 and 3 opcodes are one byte longer (prefixed by 10 or 11)
0196                         
0197 0000                    AM_INVALID      EQU     0       ; $01 (1)
0198 0001                    AM_INHERENT     EQU     1       ; RTS (1)
0199 0002                    AM_IMMEDIATE8   EQU     2       ; LDA #$12 (2)
0200 0003                    AM_IMMEDIATE16  EQU     3       ; LDD #$1234 (3)
0201 0004                    AM_DIRECT       EQU     4       ; LDA $12 (2)
0202 0005                    AM_EXTENDED     EQU     5       ; LDA $1234 (3)
0203 0006                    AM_RELATIVE8    EQU     6       ; BSR $1234 (2)
0204 0007                    AM_RELATIVE16   EQU     7       ; LBSR $1234 (3)
0205 0008                    AM_INDEXED      EQU     8       ; LDA 0,X (2+)
0206                         
0207                         ; *** CODE ***
0208                         
0209 c000                      ORG     $C000
0210                         
0211                         ; Main program. Disassembles a page at a time. Can be run directly or
0212                         ; as an ASSIST09 monitor external command. Gets start address from
0213                         ; command line.
0214                         
0215 c000 17 3e 61           CUNAS:  LBSR    CDNUM           ; Parse command line, return 16-bit number in D
0216 c003 fd 5f f0                   STD     ADRS            ; Store it
0217 c006 86 18              PAGE:   LDA     #PAGELEN        ; Number of instruction to disassemble per page
0218 c008 34 02              DIS:    PSHS    A               ; Save A
0219 c00a 17 00 97                   LBSR    DISASM          ; Do disassembly of one instruction
0220 c00d 35 02                      PULS    A               ; Restore A
0221 c00f 4a                         DECA                    ; Decrement count
0222 c010 26 f6                      BNE     DIS             ; Go back and repeat until a page has been done
0223 c012 30 8d 0b a8                LEAX    MSG2,PCR        ; Display message to press a key
0224 c016 17 00 84                   LBSR    PrintString
0225 c019 8d 63              BADKEY: BSR     GetChar         ; Wait for keyboard input
0226 c01b 8d 11                      BSR     PrintCR
0227 c01d 81 20                      CMPA    #SP             ; Space key pressed?
0228 c01f 27 e5                      BEQ     PAGE            ; If so, display next page
0229 c021 81 51                      CMPA    #'Q             ; Q key pressed?
0230 c023 27 08                      BEQ     RETN            ; If so, return
0231 c025 81 71                      CMPA    #'q             ; q key pressed?
0232 c027 27 04                      BEQ     RETN            ; If so, return
0233 c029 8d 72                      BSR     PrintString     ; Bad key, prompt and try again
0234 c02b 20 ec                      BRA     BADKEY
0235 c02d 39                 RETN:   RTS                     ; Return to caller
0236                         
0237                         ; *** Utility Functions ***
0238                         ; Some of these call ASSIST09 ROM monitor routines.
0239                         
0240                         ; Print CR/LF to the console.
0241                         ; Registers changed: none
0242                         PrintCR:
0243 c02e 34 02                      PSHS    A               ; Save A
0244 c030 86 0d                      LDA     #RET
0245 c032 8d 47                      BSR     PrintChar
0246 c034 86 0a                      LDA     #LF
0247 c036 8d 43                      BSR     PrintChar
0248 c038 35 02                      PULS    A               ; Restore A
0249 c03a 39                         RTS
0250                         
0251                         ; Print dollar sign to the console.
0252                         ; Registers changed: none
0253                         PrintDollar:
0254 c03b 34 02                      PSHS    A               ; Save A
0255 c03d 86 24                      LDA     #'$
0256 c03f 8d 3a                      BSR     PrintChar
0257 c041 35 02                      PULS    A               ; Restore A
0258 c043 39                         RTS
0259                         
0260                         ; Print comma to the console.
0261                         ; Registers changed: none
0262                         PrintComma:
0263 c044 34 02                      PSHS    A               ; Save A
0264 c046 86 2c                      LDA     #',
0265 c048 8d 31                      BSR     PrintChar
0266 c04a 35 02                      PULS    A               ; Restore A
0267 c04c 39                         RTS
0268                         
0269                         ; Print left square bracket to the console.
0270                         ; Registers changed: none
0271                         PrintLBracket:
0272 c04d 34 02                      PSHS    A               ; Save A
0273 c04f 86 5b                      LDA     #'[
0274 c051 8d 28                      BSR     PrintChar
0275 c053 35 02                      PULS    A               ; Restore A
0276 c055 39                         RTS
0277                         
0278                         ; Print right square bracket to the console.
0279                         ; Registers changed: none
0280                         PrintRBracket:
0281 c056 34 02                      PSHS    A               ; Save A
0282 c058 86 5d                      LDA     #']
0283 c05a 8d 1f                      BSR     PrintChar
0284 c05c 35 02                      PULS    A               ; Restore A
0285 c05e 39                         RTS
0286                         
0287                         ; Print space sign to the console.
0288                         ; Registers changed: none
0289                         PrintSpace:
0290 c05f 3f                         SWI
0291 c060 07                         FCB     SPACEF
0292 c061 39                         RTS
0293                         
0294                         ; Print two spaces to the console.
0295                         ; Registers changed: none
0296                         Print2Spaces:
0297 c062 34 02                      PSHS    A               ; Save A
0298 c064 86 20                      LDA     #SP
0299 c066 8d 13                      BSR     PrintChar
0300 c068 8d 11                      BSR     PrintChar
0301 c06a 35 02                      PULS    A               ; Restore A
0302 c06c 39                         RTS
0303                         
0304                         ; Print several space characters.
0305                         ; A contains number of spaces to print.
0306                         ; Registers changed: none
0307                         PrintSpaces:
0308 c06d 34 02                      PSHS    A               ; Save registers used
0309 c06f 81 00              PS1:    CMPA    #0              ; Is count zero?
0310 c071 27 05                      BEQ     PS2             ; Is so, done
0311 c073 8d ea                      BSR     PrintSpace      ; Print a space
0312 c075 4a                         DECA                    ; Decrement count
0313 c076 20 f7                      BRA     PS1             ; Check again
0314 c078 35 02              PS2:    PULS    A               ; Restore registers used
0315 c07a 39                         RTS
0316                         
0317                         ; Print character to the console
0318                         ; A contains character to print.
0319                         ; Registers changed: none
0320                         PrintChar:
0321 c07b 3f                         SWI                     ; Call ASSIST09 monitor function
0322 c07c 01                         FCB     OUTCH           ; Service code byte
0323 c07d 39                         RTS
0324                         
0325                         ; Get character from the console
0326                         ; A contains character read. Blocks until key pressed. Character is
0327                         ; echoed. Ignores NULL ($00) and RUBOUT ($7F). CR ($OD) is converted
0328                         ; to LF ($0A).
0329                         ; Registers changed: none (flags may change). Returns char in A.
0330                         GetChar:
0331 c07e 3f                         SWI                     ; Call ASSIST09 monitor function
0332 c07f 00                         FCB     INCHNP          ; Service code byte
0333 c080 39                         RTS
0334                         
0335                         ; Print a byte as two hex digits followed by a space.
0336                         ; A contains byte to print.
0337                         ; Registers changed: none
0338                         PrintByte:
0339 c081 34 16                      PSHS    A,B,X           ; Save registers used
0340 c083 b7 5f f7                   STA     TEMP            ; Needs to be in memory so we can point to it
0341 c086 30 8d 9f 6d                LEAX    TEMP,PCR        ; Get pointer to it
0342 c08a 3f                         SWI                     ; Call ASSIST09 monitor function
0343 c08b 04                         FCB     OUT2HS          ; Service code byte
0344 c08c 35 16                      PULS    X,B,A           ; Restore registers used
0345 c08e 39                         RTS
0346                         
0347                         ; Print a word as four hex digits followed by a space.
0348                         ; X contains word to print.
0349                         ; Registers changed: none
0350                         PrintAddress:
0351 c08f 34 16                      PSHS    A,B,X           ; Save registers used
0352 c091 bf 5f f7                   STX     TEMP            ; Needs to be in memory so we can point to it
0353 c094 30 8d 9f 5f                LEAX    TEMP,PCR        ; Get pointer to it
0354 c098 3f                         SWI                     ; Call ASSIST09 monitor function
0355 c099 05                         FCB     OUT4HS          ; Service code byte
0356 c09a 35 16                      PULS    X,B,A           ; Restore registers used
0357 c09c 39                         RTS
0358                         
0359                         ; Print a string.
0360                         ; X points to start of string to display.
0361                         ; String must be terminated in EOT character.
0362                         ; Registers changed: none
0363                         PrintString:
0364 c09d 34 10                      PSHS    X               ; Save registers used
0365 c09f 3f                         SWI                     ; Call ASSIST09 monitor function
0366 c0a0 02                         FCB     PDATA1          ; Service code byte
0367 c0a1 35 10                      PULS    X               ; Restore registers used
0368 c0a3 39                         RTS
0369                         
0370                         ; Disassemble instruction at address ADRS. On return, ADRS points to
0371                         ; next instruction so it can be called again.
0372                         
0373 c0a4 7f 5f fc           DISASM: CLR     PAGE23          ; Clear page2/3 flag
0374 c0a7 ae 8d 9f 45                LDX     ADRS,PCR        ; Get address of instruction
0375 c0ab e6 84                      LDB     ,X              ; Get instruction op code
0376 c0ad c1 10                      CMPB    #$10            ; Is it a page 2 16-bit opcode prefix with 10?
0377 c0af 27 07                      BEQ     handle10        ; If so, do special handling
0378 c0b1 c1 11                      CMPB    #$11            ; Is it a page 3 16-bit opcode prefix with 11?
0379 c0b3 27 53                      BEQ     handle11        ; If so, do special handling
0380 c0b5 16 00 a1                   LBRA    not1011         ; If not, handle as normal case
0381                         
0382                         handle10:                       ; Handle page 2 instruction
0383 c0b8 86 01                      LDA     #1              ; Set page2/3 flag
0384 c0ba b7 5f fc                   STA     PAGE23
0385 c0bd e6 01                      LDB     1,X             ; Get real opcode
0386 c0bf f7 5f f2                   STB     OPCODE          ; Save it.
0387 c0c2 30 8d 0a 5f                LEAX    PAGE2,PCR       ; Pointer to start of table
0388 c0c6 4f                         CLRA                    ; Set index into table to zero
0389                         search10:
0390 c0c7 e1 86                      CMPB    A,X             ; Check for match of opcode in table
0391 c0c9 27 1f                      BEQ     found10         ; Branch if found
0392 c0cb 8b 03                      ADDA    #3              ; Advance to next entry in table (entries are 3 bytes long)
0393 c0cd 6d 86                      TST     A,X             ; Check entry
0394 c0cf 27 02                      BEQ     notfound10      ; If zero, then reached end of table
0395 c0d1 20 f4                      BRA     search10        ; If not, keep looking
0396                         
0397                         notfound10:                     ; Instruction not found, so is invalid.
0398 c0d3 86 10                      LDA     #$10            ; Set opcode to 10
0399 c0d5 b7 5f f2                   STA     OPCODE
0400 c0d8 86 00                      LDA     #OP_INV         ; Set as instruction type invalid
0401 c0da b7 5f f4                   STA     OPTYPE
0402 c0dd 86 00                      LDA     #AM_INVALID     ; Set as addressing mode invalid
0403 c0df b7 5f f3                   STA     AM
0404 c0e2 86 01                      LDA     #1              ; Set length to one
0405 c0e4 b7 5f f6                   STA     LENG
0406 c0e7 16 00 91                   LBRA    dism            ; Disassemble as normal
0407                         
0408                         found10:                        ; Found entry in table
0409 c0ea 8b 01                      ADDA    #1              ; Advance to instruction type entry in table
0410 c0ec e6 86                      LDB     A,X             ; Get instruction type
0411 c0ee f7 5f f4                   STB     OPTYPE          ; Save it
0412 c0f1 8b 01                      ADDA    #1              ; Advanced to address mode entry in table
0413 c0f3 e6 86                      LDB     A,X             ; Get address mode
0414 c0f5 f7 5f f3                   STB     AM              ; Save it
0415 c0f8 4f                         CLRA                    ; Clear MSB of D, addressing mode is now in A:B (D)
0416 c0f9 1f 01                      TFR     D,X             ; Put addressing mode in X
0417 c0fb e6 89 c8 f8                LDB     LENGTHS,X       ; Get instruction length from table
0418 c0ff f7 5f f6                   STB     LENG            ; Store it
0419 c102 7c 5f f6                   INC     LENG            ; Add one because it is a two byte op code
0420 c105 16 00 73                   LBRA    dism            ; Continue normal disassembly processing.
0421                         
0422                         handle11:                       ; Same logic as above, but use table for page 3 opcodes.
0423 c108 86 01                      LDA     #1              ; Set page2/3 flag
0424 c10a b7 5f fc                   STA     PAGE23
0425 c10d e6 01                      LDB     1,X             ; Get real opcode
0426 c10f f7 5f f2                   STB     OPCODE          ; Save it.
0427 c112 30 8d 0a 82                LEAX    PAGE3,PCR       ; Pointer to start of table
0428 c116 4f                         CLRA                    ; Set index into table to zero
0429                         search11:
0430 c117 e1 86                      CMPB    A,X             ; Check for match of opcode in table
0431 c119 27 1f                      BEQ     found11         ; Branch if found
0432 c11b 8b 03                      ADDA    #3              ; Advance to next entry in table (entries are 3 bytes long)
0433 c11d 6d 86                      TST     A,X             ; Check entry
0434 c11f 27 02                      BEQ     notfound11      ; If zero, then reached end of table
0435 c121 20 f4                      BRA     search11        ; If not, keep looking
0436                         
0437                         notfound11:                     ; Instruction not found, so is invalid.
0438 c123 86 11                      LDA     #$11            ; Set opcode to 10
0439 c125 b7 5f f2                   STA     OPCODE
0440 c128 86 00                      LDA     #OP_INV         ; Set as instruction type invalid
0441 c12a b7 5f f4                   STA     OPTYPE
0442 c12d 86 00                      LDA     #AM_INVALID     ; Set as addressing mode invalid
0443 c12f b7 5f f3                   STA     AM
0444 c132 86 01                      LDA     #1              ; Set length to one
0445 c134 b7 5f f6                   STA     LENG
0446 c137 16 00 41                   LBRA    dism            ; Disassemble as normal
0447                         
0448                         found11:                        ; Found entry in table
0449 c13a 8b 01                      ADDA    #1              ; Advance to instruction type entry in table
0450 c13c e6 86                      LDB     A,X             ; Get instruction type
0451 c13e f7 5f f4                   STB     OPTYPE          ; Save it
0452 c141 8b 01                      ADDA    #1              ; Advanced to address mode entry in table
0453 c143 e6 86                      LDB     A,X             ; Get address mode
0454 c145 f7 5f f3                   STB     AM              ; Save it
0455 c148 4f                         CLRA                    ; Clear MSB of D, addressing mode is now in A:B (D)
0456 c149 1f 01                      TFR     D,X             ; Put addressing mode in X
0457 c14b e6 89 c8 f8                LDB     LENGTHS,X       ; Get instruction length from table
0458 c14f f7 5f f6                   STB     LENG            ; Store it
0459 c152 7c 5f f6                   INC     LENG            ; Add one because it is a two byte op code
0460 c155 16 00 23                   LBRA    dism            ; Continue normal disassembly processing.
0461 c158 39                         RTS
0462                         
0463                         not1011:
0464 c159 f7 5f f2                   STB     OPCODE          ; Save the op code
0465 c15c 4f                         CLRA                    ; Clear MSB of D
0466 c15d 1f 01                      TFR     D,X             ; Put op code in X
0467 c15f e6 89 c9 25                LDB     OPCODES,X       ; Get opcode type from table
0468 c163 f7 5f f4                   STB     OPTYPE          ; Store it
0469 c166 f6 5f f2                   LDB     OPCODE          ; Get op code again
0470 c169 1f 01                      TFR     D,X             ; Put opcode in X
0471 c16b e6 89 ca 25                LDB     MODES,X         ; Get addressing mode type from table
0472 c16f f7 5f f3                   STB     AM              ; Store it
0473 c172 1f 01                      TFR     D,X             ; Put addressing mode in X
0474 c174 e6 89 c8 f8                LDB     LENGTHS,X       ; Get instruction length from table
0475 c178 f7 5f f6                   STB     LENG            ; Store it
0476                         
0477                         ; If addressing mode is indexed, get and save the indexed addressing
0478                         ; post byte.
0479                         
0480 c17b b6 5f f3           dism:   LDA     AM              ; Get addressing mode
0481 c17e 81 08                      CMPA    #AM_INDEXED     ; Is it indexed mode?
0482 c180 26 22                      BNE     NotIndexed      ; Branch if not
0483 c182 ae 8d 9e 6a                LDX     ADRS,PCR        ; Get address of op code
0484                                                         ; If it is a page2/3 instruction, op code is the next byte after ADRS
0485 c186 7d 5f fc                   TST     PAGE23          ; Page2/3 instruction?
0486 c189 27 04                      BEQ     norm            ; Branch of not
0487 c18b a6 02                      LDA     2,X             ; Post byte is two past ADRS
0488 c18d 20 02                      BRA     getpb
0489 c18f a6 01              norm:   LDA     1,X             ; Get next byte (the post byte)
0490 c191 b7 5f f5           getpb:  STA     POSTBYT         ; Save it
0491                         
0492                         ; Determine number of additional bytes for indexed addressing based on
0493                         ; postbyte. If most significant bit is 0, there are no additional
0494                         ; bytes and we can skip the rest of the check.
0495                         
0496 c194 2a 0e                      BPL     NotIndexed      ; Branch of MSB is zero
0497                         
0498                         ; Else if most significant bit is 1, mask off all but low order 5 bits
0499                         ; and look up length in table.
0500                         
0501 c196 84 1f                      ANDA    #%00011111      ; Mask off bits
0502 c198 30 8d 07 69                LEAX    POSTBYTES,PCR   ; Lookup table of lengths
0503 c19c a6 86                      LDA     A,X             ; Get table entry
0504 c19e bb 5f f6                   ADDA    LENG            ; Add to instruction length
0505 c1a1 b7 5f f6                   STA     LENG            ; Save new length
0506                         
0507                         NotIndexed:
0508                         
0509                         ; Print address followed by a space
0510 c1a4 ae 8d 9e 48                LDX     ADRS,PCR
0511 c1a8 17 fe e4                   LBSR    PrintAddress
0512                         
0513                         ; Print one more space
0514                         
0515 c1ab 17 fe b1                   LBSR    PrintSpace
0516                         
0517                         ; Print the op code bytes based on the instruction length
0518                         
0519 c1ae f6 5f f6                   LDB     LENG            ; Number of bytes in instruction
0520 c1b1 ae 8d 9e 3b                LDX     ADRS,PCR        ; Pointer to start of instruction
0521 c1b5 a6 80              opby:   LDA     ,X+             ; Get instruction byte and increment pointer
0522 c1b7 17 fe c7                   LBSR    PrintByte       ; Print it, followed by a space
0523 c1ba 5a                         DECB                    ; Decrement byte count
0524 c1bb 26 f8                      BNE     opby            ; Repeat until done
0525                         
0526                         ; Print needed remaining spaces to pad out to correct column
0527                         
0528 c1bd 30 8d 07 40                LEAX    PADDING,PCR     ; Pointer to start of lookup table
0529 c1c1 b6 5f f6                   LDA     LENG            ; Number of bytes in instruction
0530 c1c4 4a                         DECA                    ; Subtract 1 since table starts at 1, not 0
0531 c1c5 a6 86                      LDA     A,X             ; Get number of spaces to print
0532 c1c7 17 fe a3                   LBSR    PrintSpaces
0533                         
0534                         ; If a page2/3 instruction, advance ADRS to the next byte which points
0535                         ; to the real op code.
0536                         
0537 c1ca 7d 5f fc                   TST     PAGE23          ; Flag set
0538 c1cd 27 09                      BEQ     noinc           ; Branch if not
0539 c1cf fc 5f f0                   LDD     ADRS            ; Increment 16-bit address
0540 c1d2 c3 00 01                   ADDD    #1
0541 c1d5 fd 5f f0                   STD     ADRS
0542                         
0543                         ; Get and print mnemonic (4 chars)
0544                         
0545 c1d8 f6 5f f4           noinc   LDB     OPTYPE          ; Get instruction type to index into table
0546 c1db 4f                         CLRA                    ; Clear MSB of D
0547 c1dc 58                         ASLB                    ; 16-bit shift of D: Rotate B, MSB into Carry
0548 c1dd 49                         ROLA                    ; Rotate A, Carry into LSB
0549 c1de 58                         ASLB                    ; Do it twice to multiple by four
0550 c1df 49                         ROLA                    ;
0551 c1e0 30 8d 04 e4                LEAX    MNEMONICS,PCR   ; Pointer to start of table
0552 c1e4 b7 5f f9                   STA     TEMP1           ; Save value of A
0553 c1e7 a6 8b                      LDA     D,X             ; Get first char of mnemonic
0554 c1e9 17 fe 8f                   LBSR    PrintChar       ; Print it
0555 c1ec b6 5f f9                   LDA     TEMP1           ; Restore value of A
0556 c1ef 5c                         INCB                    ; Advance pointer
0557 c1f0 a6 8b                      LDA     D,X             ; Get second char of mnemonic
0558 c1f2 17 fe 86                   LBSR    PrintChar       ; Print it
0559 c1f5 b6 5f f9                   LDA     TEMP1           ; Restore value of A
0560 c1f8 5c                         INCB                    ; Advance pointer
0561 c1f9 a6 8b                      LDA     D,X             ; Get third char of mnemonic
0562 c1fb 17 fe 7d                   LBSR    PrintChar       ; Print it
0563 c1fe b6 5f f9                   LDA     TEMP1           ; Restore value of A
0564 c201 5c                         INCB                    ; Advance pointer
0565 c202 a6 8b                      LDA     D,X             ; Get fourth char of mnemonic
0566 c204 17 fe 74                   LBSR    PrintChar       ; Print it
0567                         
0568                         ; Display any operands based on addressing mode and call appropriate
0569                         ; routine. TODO: Could use a lookup table for this.
0570                         
0571 c207 b6 5f f3                   LDA     AM              ; Get addressing mode
0572 c20a 81 00                      CMPA    #AM_INVALID
0573 c20c 27 2e                      BEQ     DO_INVALID
0574 c20e 81 01                      CMPA    #AM_INHERENT
0575 c210 27 39                      BEQ     DO_INHERENT
0576 c212 81 02                      CMPA    #AM_IMMEDIATE8
0577 c214 27 38                      BEQ     DO_IMMEDIATE8
0578 c216 81 03                      CMPA    #AM_IMMEDIATE16
0579 c218 10 27 01 af                LBEQ    DO_IMMEDIATE16
0580 c21c 81 04                      CMPA    #AM_DIRECT
0581 c21e 10 27 01 c4                LBEQ    DO_DIRECT
0582 c222 81 05                      CMPA    #AM_EXTENDED
0583 c224 10 27 01 d0                LBEQ    DO_EXTENDED
0584 c228 81 06                      CMPA    #AM_RELATIVE8
0585 c22a 10 27 01 e0                LBEQ    DO_RELATIVE8
0586 c22e 81 07                      CMPA    #AM_RELATIVE16
0587 c230 10 27 01 f5                LBEQ    DO_RELATIVE16
0588 c234 81 08                      CMPA    #AM_INDEXED
0589 c236 10 27 02 09                LBEQ    DO_INDEXED
0590 c23a 20 00                      BRA     DO_INVALID      ; Should never be reached
0591                         
0592                         DO_INVALID:                     ; Display "   ; INVALID"
0593 c23c 86 0f                      LDA     #15             ; Want 15 spaces
0594 c23e 17 fe 2c                   LBSR    PrintSpaces
0595 c241 30 8d 09 6f                LEAX    MSG1,PCR
0596 c245 17 fe 55                   LBSR    PrintString
0597 c248 16 04 67                   LBRA    done
0598                         
0599                         DO_INHERENT:                    ; Nothing else to do
0600 c24b 16 04 64                   LBRA    done
0601                         
0602                         DO_IMMEDIATE8:
0603 c24e b6 5f f4                   LDA     OPTYPE          ; Get opcode type
0604 c251 81 88                      CMPA    #OP_TFR         ; Is is TFR?
0605 c253 27 33                      BEQ     XFREXG          ; Handle special case of TFR
0606 c255 81 39                      CMPA    #OP_EXG         ; Is is EXG?
0607 c257 27 2f                      BEQ     XFREXG          ; Handle special case of EXG
0608                         
0609 c259 81 6d                      CMPA    #OP_PULS        ; Is is PULS?
0610 c25b 10 27 00 ad                LBEQ    PULPSH
0611 c25f 81 6e                      CMPA    #OP_PULU        ; Is is PULU?
0612 c261 10 27 00 a7                LBEQ    PULPSH
0613 c265 81 6b                      CMPA    #OP_PSHS        ; Is is PSHS?
0614 c267 10 27 00 a1                LBEQ    PULPSH
0615 c26b 81 6c                      CMPA    #OP_PSHU        ; Is is PSHU?
0616 c26d 10 27 00 9b                LBEQ    PULPSH
0617                         
0618                                                         ; Display "  #$nn"
0619 c271 17 fd ee                   LBSR    Print2Spaces    ; Two spaces
0620 c274 86 23                      LDA     #'#             ; Number sign
0621 c276 17 fe 02                   LBSR    PrintChar
0622 c279 17 fd bf                   LBSR    PrintDollar     ; Dollar sign
0623 c27c ae 8d 9d 70                LDX     ADRS,PCR        ; Get address of op code
0624 c280 a6 01                      LDA     1,X             ; Get next byte (immediate data)
0625 c282 17 fd fc                   LBSR    PrintByte       ; Print as hex value
0626 c285 16 04 2a                   LBRA    done
0627                         
0628                         XFREXG:                         ; Handle special case of TFR and EXG
0629                                                         ; Display "  r1,r2"
0630 c288 17 fd d7                   LBSR    Print2Spaces    ; Two spaces
0631 c28b ae 8d 9d 61                LDX     ADRS,PCR        ; Get address of op code
0632 c28f a6 01                      LDA     1,X             ; Get next byte (postbyte)
0633 c291 84 f0                      ANDA    #%11110000      ; Mask out source register bits
0634 c293 44                         LSRA                    ; Shift into low order bits
0635 c294 44                         LSRA
0636 c295 44                         LSRA
0637 c296 44                         LSRA
0638 c297 8d 0e                      BSR     TFREXGRegister  ; Print source register name
0639 c299 86 2c                      LDA     #',             ; Print comma
0640 c29b 17 fd dd                   LBSR    PrintChar
0641 c29e a6 01                      LDA     1,X             ; Get postbyte again
0642 c2a0 84 0f                      ANDA    #%00001111      ; Mask out destination register bits
0643 c2a2 8d 03                      BSR     TFREXGRegister  ; Print destination register name
0644 c2a4 16 04 0b                   LBRA    done
0645                         
0646                         ; Look up register name (in A) from Transfer/Exchange postbyte. 4 LSB
0647                         ; bits determine the register name. Value is printed. Invalid value
0648                         ; is shown as '?'.
0649                         ; Value:    0 1 2 3 4 5  8 9 10 11
0650                         ; Register: D X Y U S PC A B CC DP
0651                         
0652                         TFREXGRegister:
0653 c2a7 81 00                      CMPA    #0
0654 c2a9 26 04                      BNE     Try1
0655 c2ab 86 44                      LDA     #'D
0656 c2ad 20 50                      BRA     Print1Reg
0657 c2af 81 01              Try1:   CMPA    #1
0658 c2b1 26 04                      BNE     Try2
0659 c2b3 86 58                      LDA     #'X
0660 c2b5 20 48                      BRA     Print1Reg
0661 c2b7 81 02              Try2:   CMPA    #2
0662 c2b9 26 04                      BNE     Try3
0663 c2bb 86 59                      LDA     #'Y
0664 c2bd 20 40                      BRA     Print1Reg
0665 c2bf 81 03              Try3:   CMPA    #3
0666 c2c1 26 04                      BNE     Try4
0667 c2c3 86 55                      LDA     #'U
0668 c2c5 20 38                      BRA     Print1Reg
0669 c2c7 81 04              Try4:   CMPA    #4
0670 c2c9 26 04                      BNE     Try5
0671 c2cb 86 53                      LDA     #'S
0672 c2cd 20 30                      BRA     Print1Reg
0673 c2cf 81 05              Try5:   CMPA    #5
0674 c2d1 26 06                      BNE     Try8
0675 c2d3 86 50                      LDA     #'P
0676 c2d5 c6 43                      LDB     #'C
0677 c2d7 20 2a                      BRA     Print2Reg
0678 c2d9 81 08              Try8:   CMPA    #8
0679 c2db 26 04                      BNE     Try9
0680 c2dd 86 41                      LDA     #'A
0681 c2df 20 1e                      BRA     Print1Reg
0682 c2e1 81 09              Try9:   CMPA    #9
0683 c2e3 26 04                      BNE     Try10
0684 c2e5 86 42                      LDA     #'B
0685 c2e7 20 16                      BRA     Print1Reg
0686 c2e9 81 0a              Try10:  CMPA    #10
0687 c2eb 26 06                      BNE     Try11
0688 c2ed 86 43                      LDA     #'C
0689 c2ef c6 43                      LDB     #'C
0690 c2f1 20 10                      BRA     Print2Reg
0691 c2f3 81 0b              Try11:  CMPA    #11
0692 c2f5 26 06                      BNE     Inv
0693 c2f7 86 44                      LDA     #'D
0694 c2f9 c6 50                      LDB     #'P
0695 c2fb 20 06                      BRA     Print2Reg
0696 c2fd 86 3f              Inv:    LDA     #'?             ; Invalid
0697                                                         ; Fall through
0698                         Print1Reg:
0699 c2ff 17 fd 79                   LBSR   PrintChar        ; Print character
0700 c302 39                         RTS
0701                         Print2Reg:
0702 c303 17 fd 75                   LBSR   PrintChar        ; Print first character
0703 c306 1f 98                      TFR    B,A
0704 c308 17 fd 70                   LBSR   PrintChar        ; Print second character
0705 c30b 39                         RTS
0706                         
0707                         ; Handle PSHS/PSHU/PULS/PULU instruction operands
0708                         ; Format is a register list, eg; "  A,B,X"
0709                         
0710                         PULPSH:
0711 c30c 17 fd 53                   LBSR    Print2Spaces    ; Two spaces
0712 c30f 86 01                      LDA     #1
0713 c311 b7 5f fb                   STA     FIRST           ; Flag set before any items printed
0714 c314 ae 8d 9c d8                LDX     ADRS,PCR        ; Get address of op code
0715 c318 a6 01                      LDA     1,X             ; Get next byte (postbyte)
0716                         
0717                         ; Postbyte bits indicate registers to push/pull when 1.
0718                         ; 7  6   5 4 3  2 1 0
0719                         ; PC S/U Y X DP B A CC
0720                         
0721                         ; TODO: Could simplify this with shifting and lookup table.
0722                         
0723 c31a 85 80                      BITA    #%10000000      ; Bit 7 set?
0724 c31c 27 0d                      BEQ     bit6
0725 c31e 34 06                      PSHS    A,B
0726 c320 86 50                      LDA     #'P
0727 c322 c6 43                      LDB     #'C
0728 c324 8d dd                      BSR     Print2Reg       ; Print PC
0729 c326 7f 5f fb                   CLR     FIRST
0730 c329 35 06                      PULS    A,B
0731 c32b 85 40              bit6:   BITA    #%01000000      ; Bit 6 set?
0732 c32d 27 21                      BEQ     bit5
0733                         
0734                         ; Need to show S or U depending on instruction
0735                         
0736 c32f 34 02                      PSHS    A               ; Save postbyte
0737 c331 b6 5f f4                   LDA     OPTYPE          ; Get opcode type
0738 c334 81 6d                      CMPA    #OP_PULS
0739 c336 27 12                      BEQ     printu
0740 c338 81 6b                      CMPA    #OP_PSHS
0741 c33a 27 0e                      BEQ     printu
0742 c33c 17 00 81                   LBSR    PrintCommaIfNotFirst
0743 c33f 86 53                      LDA     #'S             ; Print S
0744 c341 8d bc              pr1     BSR     Print1Reg
0745 c343 7f 5f fb                   CLR     FIRST
0746 c346 35 02                      PULS    A
0747 c348 20 06                      bra     bit5
0748 c34a 8d 74              printu: BSR     PrintCommaIfNotFirst
0749 c34c 86 55                      LDA     #'U             ; Print U
0750 c34e 20 f1                      bra     pr1
0751 c350 85 20              bit5:   BITA    #%00100000      ; Bit 5 set?
0752 c352 27 0d                      BEQ     bit4
0753 c354 34 02                      PSHS    A
0754 c356 8d 68                      BSR     PrintCommaIfNotFirst
0755 c358 86 59                      LDA     #'Y
0756 c35a 8d a3                      BSR     Print1Reg       ; Print Y
0757 c35c 7f 5f fb                   CLR     FIRST
0758 c35f 35 02                      PULS    A
0759 c361 85 10              bit4:   BITA    #%00010000      ; Bit 4 set?
0760 c363 27 0d                      BEQ     bit3
0761 c365 34 02                      PSHS    A
0762 c367 8d 57                      BSR     PrintCommaIfNotFirst
0763 c369 86 58                      LDA     #'X
0764 c36b 8d 92                      BSR     Print1Reg       ; Print X
0765 c36d 7f 5f fb                   CLR     FIRST
0766 c370 35 02                      PULS    A
0767 c372 85 08              bit3:   BITA    #%00001000      ; Bit 3 set?
0768 c374 27 0f                      BEQ     bit2
0769 c376 34 06                      PSHS    A,B
0770 c378 8d 46                      BSR     PrintCommaIfNotFirst
0771 c37a 86 44                      LDA     #'D
0772 c37c c6 50                      LDB     #'P
0773 c37e 8d 83                      BSR     Print2Reg       ; Print DP
0774 c380 7f 5f fb                   CLR     FIRST
0775 c383 35 06                      PULS    A,B
0776 c385 85 04              bit2:   BITA    #%00000100      ; Bit 2 set?
0777 c387 27 0e                      BEQ     bit1
0778 c389 34 02                      PSHS    A
0779 c38b 8d 33                      BSR     PrintCommaIfNotFirst
0780 c38d 86 42                      LDA     #'B
0781 c38f 17 ff 6d                   LBSR    Print1Reg       ; Print B
0782 c392 7f 5f fb                   CLR     FIRST
0783 c395 35 02                      PULS    A
0784 c397 85 02              bit1:   BITA    #%00000010      ; Bit 1 set?
0785 c399 27 0e                      BEQ     bit0
0786 c39b 34 02                      PSHS    A
0787 c39d 8d 21                      BSR     PrintCommaIfNotFirst
0788 c39f 86 41                      LDA     #'A
0789 c3a1 17 ff 5b                   LBSR    Print1Reg       ; Print A
0790 c3a4 7f 5f fb                   CLR     FIRST
0791 c3a7 35 02                      PULS    A
0792 c3a9 85 01              bit0:   BITA    #%00000001      ; Bit 0 set?
0793 c3ab 27 10                      BEQ     done1
0794 c3ad 34 06                      PSHS    A,B
0795 c3af 8d 0f                      BSR     PrintCommaIfNotFirst
0796 c3b1 86 43                      LDA     #'C
0797 c3b3 c6 43                      LDB     #'C
0798 c3b5 17 ff 4b                   LBSR    Print2Reg       ; Print CC
0799 c3b8 7f 5f fb                   CLR     FIRST
0800 c3bb 35 06                      PULS    A,B
0801 c3bd 16 02 f2           done1   LBRA    done
0802                         
0803                         ; Print comma if FIRST flag is not set.
0804                         PrintCommaIfNotFirst:
0805 c3c0 7d 5f fb                   TST     FIRST
0806 c3c3 26 05                      BNE     ret1
0807 c3c5 86 2c                      LDA     #',
0808 c3c7 17 fc b1                   LBSR    PrintChar
0809 c3ca 39                 ret1:   RTS
0810                         
0811                         DO_IMMEDIATE16:                 ; Display "  #$nnnn"
0812 c3cb 17 fc 94                   LBSR    Print2Spaces    ; Two spaces
0813 c3ce 86 23                      LDA     #'#             ; Number sign
0814 c3d0 17 fc a8                   LBSR    PrintChar
0815 c3d3 17 fc 65                   LBSR    PrintDollar     ; Dollar sign
0816 c3d6 ae 8d 9c 16                LDX     ADRS,PCR        ; Get address of op code
0817 c3da a6 01                      LDA     1,X             ; Get first byte (immediate data MSB)
0818 c3dc e6 02                      LDB     2,X             ; Get second byte (immediate data LSB)
0819 c3de 1f 01                      TFR     D,X             ; Put in X to print
0820 c3e0 17 fc ac                   LBSR    PrintAddress    ; Print as hex value
0821 c3e3 16 02 cc                   LBRA    done
0822                         
0823                         DO_DIRECT:                      ; Display "  $nn"
0824 c3e6 17 fc 79                   LBSR    Print2Spaces    ; Two spaces
0825 c3e9 17 fc 4f                   LBSR    PrintDollar     ; Dollar sign
0826 c3ec ae 8d 9c 00                LDX     ADRS,PCR        ; Get address of op code
0827 c3f0 a6 01                      LDA     1,X             ; Get next byte (byte data)
0828 c3f2 17 fc 8c                   LBSR    PrintByte       ; Print as hex value
0829 c3f5 16 02 ba                   LBRA    done
0830                         
0831                         DO_EXTENDED:                    ; Display "  $nnnn"
0832 c3f8 17 fc 67                   LBSR    Print2Spaces    ; Two spaces
0833 c3fb 17 fc 3d                   LBSR    PrintDollar     ; Dollar sign
0834 c3fe ae 8d 9b ee                LDX     ADRS,PCR        ; Get address of op code
0835 c402 a6 01                      LDA     1,X             ; Get first byte (address MSB)
0836 c404 e6 02                      LDB     2,X             ; Get second byte (address LSB)
0837 c406 1f 01                      TFR     D,X             ; Put in X to print
0838 c408 17 fc 84                   LBSR    PrintAddress    ; Print as hex value
0839 c40b 16 02 a4                   LBRA    done
0840                         
0841                         DO_RELATIVE8:                   ; Display "  $nnnn"
0842 c40e 17 fc 51                   LBSR    Print2Spaces    ; Two spaces
0843 c411 17 fc 27                   LBSR    PrintDollar     ; Dollar sign
0844                         
0845                         ; Destination address for relative branch is address of opcode + (sign
0846                         ; extended)offset + 2, e.g.
0847                         ;   $1015 + $(FF)FC + 2 = $1013
0848                         ;   $101B + $(00)27 + 2 = $1044
0849                         
0850 c414 ae 8d 9b d8                LDX     ADRS,PCR        ; Get address of op code
0851 c418 e6 01                      LDB     1,X             ; Get first byte (8-bit branch offset)
0852 c41a 1d                         SEX                     ; Sign extend to 16 bits
0853 c41b f3 5f f0                   ADDD    ADRS            ; Add address of op code
0854 c41e c3 00 02                   ADDD    #2              ; Add 2
0855 c421 1f 01                      TFR     D,X             ; Put in X to print
0856 c423 17 fc 69                   LBSR    PrintAddress    ; Print as hex value
0857 c426 16 02 89                   LBRA    done
0858                         
0859                         DO_RELATIVE16:                  ; Display "  $nnnn"
0860 c429 17 fc 36                   LBSR    Print2Spaces    ; Two spaces
0861 c42c 17 fc 0c                   LBSR    PrintDollar     ; Dollar sign
0862                         
0863                         ; Destination address calculation is similar to above, except offset
0864                         ; is 16 bits and need to add 3.
0865                         
0866 c42f ae 8d 9b bd                LDX     ADRS,PCR        ; Get address of op code
0867 c433 ec 01                      LDD     1,X             ; Get next 2 bytes (16-bit branch offset)
0868 c435 f3 5f f0                   ADDD    ADRS            ; Add address of op code
0869 c438 c3 00 03                   ADDD    #3              ; Add 3
0870 c43b 1f 01                      TFR     D,X             ; Put in X to print
0871 c43d 17 fc 4f                   LBSR    PrintAddress    ; Print as hex value
0872 c440 16 02 6f                   LBRA    done
0873                         
0874                         DO_INDEXED:
0875 c443 17 fc 1c                   LBSR    Print2Spaces    ; Two spaces
0876                         
0877                         ; Addressing modes are determined by the postbyte:
0878                         ;
0879                         ; Postbyte  Format  Additional Bytes
0880                         ; --------  ------  ----------------
0881                         ; 0RRnnnnn  n,R     0
0882                         ; 1RR00100  ,R      0
0883                         ; 1RR01000  n,R     1
0884                         ; 1RR01001  n,R     2
0885                         ; 1RR00110  A,R     0
0886                         ; 1RR00101  B,R     0
0887                         ; 1RR01011  D,R     0
0888                         ; 1RR00000  ,R+     0
0889                         ; 1RR00001  ,R++    0
0890                         ; 1RR00010  ,-R     0
0891                         ; 1RR00011  ,--R    0
0892                         ; 1xx01100  n,PCR   1
0893                         ; 1xx01101  n,PCR   2
0894                         ; 1RR10100  [,R]    0
0895                         ; 1RR11000  [n,R]   1
0896                         ; 1RR11001  [n,R]   2
0897                         ; 1RR10110  [A,R]   0
0898                         ; 1RR10101  [B,R]   0
0899                         ; 1RR11011  [D,R]   0
0900                         ; 1RR10001  [,R++]  0
0901                         ; 1RR10011  [,--R]  0
0902                         ; 1xx11100  [n,PCR] 1
0903                         ; 1xx11101  [n,PCR] 2
0904                         ; 10011111  [n]     2
0905                         ;
0906                         ; Where RR: 00=X 01=Y 10=U 11=S
0907                         
0908 c446 b6 5f f5                   LDA     POSTBYT         ; Get postbyte
0909 c449 2b 14                      BMI     ind2            ; Branch if MSB is 1
0910                         
0911                                                         ; Format is 0RRnnnnn  n,R
0912 c44b 84 1f                      ANDA    #%00011111      ; Get 5-bit offset
0913 c44d 17 fb eb                   LBSR    PrintDollar     ; Dollar sign
0914 c450 17 fc 2e                   LBSR    PrintByte       ; Print offset
0915 c453 17 fb ee                   LBSR    PrintComma      ; Print comma
0916 c456 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0917 c459 17 02 35                   LBSR    PrintRegister   ; Print register name
0918 c45c 16 02 53                   LBRA    done
0919                         ind2:
0920 c45f 84 9f                      ANDA    #%10011111      ; Mask out register bits
0921 c461 81 84                      CMPA    #%10000100      ; Check against pattern
0922 c463 26 0c                      BNE     ind3
0923                                                         ; Format is 1RR00100  ,R
0924 c465 17 fb dc                   LBSR    PrintComma      ; Print comma
0925 c468 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0926 c46b 17 02 23                   LBSR    PrintRegister   ; Print register name
0927 c46e 16 02 41                   LBRA    done
0928                         ind3:
0929 c471 81 88                      CMPA    #%10001000      ; Check against pattern
0930 c473 26 18                      BNE     ind4
0931                                                         ; Format is 1RR01000  n,R
0932 c475 ae 8d 9b 77                LDX     ADRS,PCR
0933 c479 a6 02                      LDA     2,X             ; Get 8-bit offset
0934 c47b 17 fb bd                   LBSR    PrintDollar     ; Dollar sign
0935 c47e 17 fc 00                   LBSR    PrintByte       ; Display it
0936 c481 17 fb c0                   LBSR    PrintComma      ; Print comma
0937 c484 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0938 c487 17 02 07                   LBSR    PrintRegister   ; Print register name
0939 c48a 16 02 25                   LBRA    done
0940                         ind4:
0941 c48d 81 89                      CMPA    #%10001001      ; Check against pattern
0942 c48f 26 1a                      BNE     ind5
0943                                                         ; Format is 1RR01001  n,R
0944 c491 ae 8d 9b 5b                LDX     ADRS,PCR
0945 c495 ec 02                      LDD     2,X             ; Get 16-bit offset
0946 c497 1f 01                      TFR     D,X
0947 c499 17 fb 9f                   LBSR    PrintDollar     ; Dollar sign
0948 c49c 17 fb f0                   LBSR    PrintAddress    ; Display it
0949 c49f 17 fb a2                   LBSR    PrintComma      ; Print comma
0950 c4a2 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0951 c4a5 17 01 e9                   LBSR    PrintRegister   ; Print register name
0952 c4a8 16 02 07                   LBRA    done
0953                         ind5:
0954 c4ab 81 86                      CMPA    #%10000110      ; Check against pattern
0955 c4ad 26 11                      BNE     ind6
0956                                                         ; Format is 1RR00110  A,R
0957 c4af 86 41                      LDA     #'A
0958 c4b1 17 fb c7                   LBSR    PrintChar       ; Print A
0959 c4b4 17 fb 8d           commar: LBSR    PrintComma      ; Print comma
0960 c4b7 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0961 c4ba 17 01 d4                   LBSR    PrintRegister   ; Print register name
0962 c4bd 16 01 f2                   LBRA    done
0963                         ind6:
0964 c4c0 81 85                      CMPA    #%10000101      ; Check against pattern
0965 c4c2 26 07                      BNE     ind7
0966                                                         ; Format is 1RR00101  B,R
0967 c4c4 86 42                      LDA     #'B
0968 c4c6 17 fb b2                   LBSR    PrintChar
0969 c4c9 20 e9                      BRA     commar
0970                         ind7:
0971 c4cb 81 8b                      CMPA    #%10001011      ; Check against pattern
0972 c4cd 26 07                      BNE     ind8
0973                                                         ; Format is 1RR01011  D,R
0974 c4cf 86 44                      LDA     #'D
0975 c4d1 17 fb a7                   LBSR    PrintChar
0976 c4d4 20 de                      BRA     commar
0977                         ind8:
0978 c4d6 81 80                      CMPA    #%10000000      ; Check against pattern
0979 c4d8 26 11                      BNE     ind9
0980                                                         ; Format is 1RR00000  ,R+
0981 c4da 17 fb 67                   LBSR    PrintComma      ; Print comma
0982 c4dd b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0983 c4e0 17 01 ae                   LBSR    PrintRegister   ; Print register name
0984 c4e3 86 2b                      LDA     #'+             ; Print plus
0985 c4e5 17 fb 93                   LBSR    PrintChar
0986 c4e8 16 01 c7                   LBRA    done
0987                         ind9:
0988 c4eb 81 81                      CMPA    #%10000001      ; Check against pattern
0989 c4ed 26 14                      BNE     ind10
0990                                                         ; Format is 1RR00001  ,R++
0991 c4ef 17 fb 52                   LBSR    PrintComma      ; Print comma
0992 c4f2 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
0993 c4f5 17 01 99                   LBSR    PrintRegister   ; Print register name
0994 c4f8 86 2b                      LDA     #'+             ; Print plus twice
0995 c4fa 17 fb 7e                   LBSR    PrintChar
0996 c4fd 17 fb 7b                   LBSR    PrintChar
0997 c500 16 01 af                   LBRA    done
0998                         ind10:
0999 c503 81 82                      CMPA    #%10000010      ; Check against pattern
1000 c505 26 11                      BNE     ind11
1001                                                         ; Format is 1RR00010  ,-R
1002 c507 17 fb 3a                   LBSR    PrintComma      ; Print comma
1003 c50a 86 2d                      LDA     #'-             ; Print minus
1004 c50c 17 fb 6c                   LBSR    PrintChar
1005 c50f b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1006 c512 17 01 7c                   LBSR    PrintRegister   ; Print register name
1007 c515 16 01 9a                   LBRA    done
1008                         ind11:
1009 c518 81 83                      CMPA    #%10000011      ; Check against pattern
1010 c51a 26 14                      BNE     ind12
1011                                                         ; Format is 1RR00011  ,--R
1012 c51c 17 fb 25                   LBSR    PrintComma      ; Print comma
1013 c51f 86 2d                      LDA     #'-             ; Print minus twice
1014 c521 17 fb 57                   LBSR    PrintChar
1015 c524 17 fb 54                   LBSR    PrintChar
1016 c527 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1017 c52a 17 01 64                   LBSR    PrintRegister   ; Print register name
1018 c52d 16 01 82                   LBRA    done
1019                         ind12:
1020 c530 81 8c                      CMPA    #%10001100      ; Check against pattern
1021 c532 26 15                      BNE     ind13
1022                                                         ; Format is 1xx01100  n,PCR
1023 c534 ae 8d 9a b8                LDX     ADRS,PCR
1024 c538 a6 02                      LDA     2,X             ; Get 8-bit offset
1025 c53a 17 fa fe                   LBSR    PrintDollar     ; Dollar sign
1026 c53d 17 fb 41                   LBSR    PrintByte       ; Display it
1027 c540 17 fb 01                   LBSR    PrintComma      ; Print comma
1028 c543 17 01 64                   LBSR    PrintPCR        ; Print PCR
1029 c546 16 01 69                   LBRA    done
1030                         ind13:
1031 c549 81 8d                      CMPA    #%10001101      ; Check against pattern
1032 c54b 26 17                      BNE     ind14
1033                                                         ; Format is 1xx01101  n,PCR
1034 c54d ae 8d 9a 9f                LDX     ADRS,PCR
1035 c551 ec 02                      LDD     2,X             ; Get 16-bit offset
1036 c553 1f 01                      TFR     D,X
1037 c555 17 fa e3                   LBSR    PrintDollar     ; Dollar sign
1038 c558 17 fb 34                   LBSR    PrintAddress    ; Display it
1039 c55b 17 fa e6                   LBSR    PrintComma      ; Print comma
1040 c55e 17 01 49                   LBSR    PrintPCR        ; Print PCR
1041 c561 16 01 4e                   LBRA    done
1042                         ind14:
1043 c564 81 94                      CMPA    #%10010100      ; Check against pattern
1044 c566 26 12                      BNE     ind15
1045                                                         ; Format is 1RR10100  [,R]
1046 c568 17 fa e2                   LBSR    PrintLBracket   ; Print left bracket
1047 c56b 17 fa d6                   LBSR    PrintComma      ; Print comma
1048 c56e b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1049 c571 17 01 1d                   LBSR    PrintRegister   ; Print register name
1050 c574 17 fa df                   LBSR    PrintRBracket   ; Print right bracket
1051 c577 16 01 38                   LBRA    done
1052                         ind15:
1053 c57a 81 98                      CMPA    #%10011000      ; Check against pattern
1054 c57c 26 1e                      BNE     ind16
1055                                                         ; Format is 1RR11000  [n,R]
1056 c57e 17 fa cc                   LBSR    PrintLBracket   ; Print left bracket
1057 c581 ae 8d 9a 6b                LDX     ADRS,PCR
1058 c585 a6 02                      LDA     2,X             ; Get 8-bit offset
1059 c587 17 fa b1                   LBSR    PrintDollar     ; Dollar sign
1060 c58a 17 fa f4                   LBSR    PrintByte       ; Display it
1061 c58d 17 fa b4                   LBSR    PrintComma      ; Print comma
1062 c590 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1063 c593 17 00 fb                   LBSR    PrintRegister   ; Print register name
1064 c596 17 fa bd                   LBSR    PrintRBracket   ; Print right bracket
1065 c599 16 01 16                   LBRA    done
1066                         ind16:
1067 c59c 81 99                      CMPA    #%10011001      ; Check against pattern
1068 c59e 26 20                      BNE     ind17
1069                                                         ; Format is 1RR11001  [n,R]
1070 c5a0 17 fa aa                   LBSR    PrintLBracket   ; Print left bracket
1071 c5a3 ae 8d 9a 49                LDX     ADRS,PCR
1072 c5a7 ec 02                      LDD     2,X             ; Get 16-bit offset
1073 c5a9 1f 01                      TFR     D,X
1074 c5ab 17 fa 8d                   LBSR    PrintDollar     ; Dollar sign
1075 c5ae 17 fa de                   LBSR    PrintAddress    ; Display it
1076 c5b1 17 fa 90                   LBSR    PrintComma      ; Print comma
1077 c5b4 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1078 c5b7 17 00 d7                   LBSR    PrintRegister   ; Print register name
1079 c5ba 17 fa 99                   LBSR    PrintRBracket   ; Print right bracket
1080 c5bd 16 00 f2                   LBRA    done
1081                         ind17:
1082 c5c0 81 96                      CMPA    #%10010110      ; Check against pattern
1083 c5c2 26 17                      BNE     ind18
1084                                                         ; Format is 1RR10110  [A,R]
1085 c5c4 17 fa 86                   LBSR    PrintLBracket   ; Print left bracket
1086 c5c7 86 41                      LDA     #'A
1087 c5c9 17 fa af                   LBSR    PrintChar       ; Print A
1088 c5cc 17 fa 75           comrb:  LBSR    PrintComma      ; Print comma
1089 c5cf b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1090 c5d2 17 00 bc                   LBSR    PrintRegister   ; Print register name
1091 c5d5 17 fa 7e                   LBSR    PrintRBracket   ; Print right bracket
1092 c5d8 16 00 d7                   LBRA    done
1093                         ind18:
1094 c5db 81 95                      CMPA    #%10010101      ; Check against pattern
1095 c5dd 26 0a                      BNE     ind19
1096                                                         ; Format is 1RR10101  [B,R]
1097 c5df 17 fa 6b                   LBSR    PrintLBracket   ; Print left bracket
1098 c5e2 86 42                      LDA     #'B
1099 c5e4 17 fa 94                   LBSR    PrintChar
1100 c5e7 20 e3                      BRA     comrb
1101                         ind19:
1102 c5e9 81 9b                      CMPA    #%10011011      ; Check against pattern
1103 c5eb 26 0a                      BNE     ind20
1104                                                         ; Format is 1RR11011  [D,R]
1105 c5ed 17 fa 5d                   LBSR    PrintLBracket   ; Print left bracket
1106 c5f0 86 44                      LDA     #'D
1107 c5f2 17 fa 86                   LBSR    PrintChar
1108 c5f5 20 d5                      BRA     comrb
1109                         ind20:
1110 c5f7 81 91                      CMPA    #%10010001      ; Check against pattern
1111 c5f9 26 1a                      BNE     ind21
1112                                                         ; Format is 1RR10001  [,R++]
1113 c5fb 17 fa 4f                   LBSR    PrintLBracket   ; Print left bracket
1114 c5fe 17 fa 43                   LBSR    PrintComma      ; Print comma
1115 c601 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1116 c604 17 00 8a                   LBSR    PrintRegister   ; Print register name
1117 c607 86 2b                      LDA     #'+             ; Print plus twice
1118 c609 17 fa 6f                   LBSR    PrintChar
1119 c60c 17 fa 6c                   LBSR    PrintChar
1120 c60f 17 fa 44                   LBSR    PrintRBracket   ; Print right bracket
1121 c612 16 00 9d                   LBRA    done
1122                         ind21:
1123 c615 81 93                      CMPA    #%10010011      ; Check against pattern
1124 c617 26 1a                      BNE     ind22
1125                                                         ; Format is 1RR10011  [,--R]
1126 c619 17 fa 31                   LBSR    PrintLBracket   ; Print left bracket
1127 c61c 17 fa 25                   LBSR    PrintComma      ; Print comma
1128 c61f 86 2d                      LDA     #'-             ; Print minus twice
1129 c621 17 fa 57                   LBSR    PrintChar
1130 c624 17 fa 54                   LBSR    PrintChar
1131 c627 b6 5f f5                   LDA     POSTBYT         ; Get postbyte again
1132 c62a 17 00 64                   LBSR    PrintRegister   ; Print register name
1133 c62d 17 fa 26                   LBSR    PrintRBracket   ; Print right bracket
1134 c630 16 00 7f                   LBRA    done
1135                         ind22:
1136 c633 81 9c                      CMPA    #%10011100      ; Check against pattern
1137 c635 26 1b                      BNE     ind23
1138                                                         ; Format is 1xx11100  [n,PCR]
1139 c637 17 fa 13                   LBSR    PrintLBracket   ; Print left bracket
1140 c63a ae 8d 99 b2                LDX     ADRS,PCR
1141 c63e a6 02                      LDA     2,X             ; Get 8-bit offset
1142 c640 17 f9 f8                   LBSR    PrintDollar     ; Dollar sign
1143 c643 17 fa 3b                   LBSR    PrintByte       ; Display it
1144 c646 17 f9 fb                   LBSR    PrintComma      ; Print comma
1145 c649 17 00 5e                   LBSR    PrintPCR        ; Print PCR
1146 c64c 17 fa 07                   LBSR    PrintRBracket   ; Print right bracket
1147 c64f 16 00 60                   LBRA    done
1148                         ind23:
1149 c652 81 9d                      CMPA    #%10011101      ; Check against pattern
1150 c654 26 1d                      BNE     ind24
1151                                                         ; Format is 1xx11101  [n,PCR]
1152 c656 17 f9 f4                   LBSR    PrintLBracket   ; Print left bracket
1153 c659 ae 8d 99 93                LDX     ADRS,PCR
1154 c65d ec 02                      LDD     2,X             ; Get 16-bit offset
1155 c65f 1f 01                      TFR     D,X
1156 c661 17 f9 d7                   LBSR    PrintDollar     ; Dollar sign
1157 c664 17 fa 28                   LBSR    PrintAddress    ; Display it
1158 c667 17 f9 da                   LBSR    PrintComma      ; Print comma
1159 c66a 17 00 3d                   LBSR    PrintPCR        ; Print PCR
1160 c66d 17 f9 e6                   LBSR    PrintRBracket   ; Print right bracket
1161 c670 16 00 3f                   LBRA    done
1162                         ind24:
1163 c673 81 9f                      CMPA    #%10011111      ; Check against pattern
1164 c675 26 17                      BNE     ind25
1165                                                         ; Format is 1xx11111  [n]
1166 c677 17 f9 d3                   LBSR    PrintLBracket   ; Print left bracket
1167 c67a ae 8d 99 72                LDX     ADRS,PCR
1168 c67e ec 02                      LDD     2,X             ; Get 16-bit offset
1169 c680 1f 01                      TFR     D,X
1170 c682 17 f9 b6                   LBSR    PrintDollar     ; Dollar sign
1171 c685 17 fa 07                   LBSR    PrintAddress    ; Display it
1172 c688 17 f9 cb                   LBSR    PrintRBracket   ; Print right bracket
1173 c68b 16 00 24                   LBRA    done
1174                         ind25:                          ; Should never be reached
1175 c68e 16 00 21                   LBRA    done
1176                         
1177                         ; Print register name encoded in bits 5 and 6 of A for indexed
1178                         ; addressing: xRRxxxxx where RR: 00=X 01=Y 10=U 11=S
1179                         ; Registers changed: X
1180                         PrintRegister:
1181 c691 34 02                      PSHS    A               ; Save A
1182 c693 84 60                      ANDA    #%01100000      ; Mask out other bits
1183 c695 44                         LSRA                    ; Shift into 2 LSB
1184 c696 44                         LSRA
1185 c697 44                         LSRA
1186 c698 44                         LSRA
1187 c699 44                         LSRA
1188 c69a 30 8d 00 08                LEAX    REGTABLE,PCR    ; Lookup table of register name characters
1189 c69e a6 86                      LDA     A,X             ; Get character
1190 c6a0 17 f9 d8                   LBSR    PrintChar       ; Print it
1191 c6a3 35 02                      PULS    A               ; Restore A
1192 c6a5 39                         RTS                     ; Return
1193                         REGTABLE:
1194 c6a6 58 59 55 53                FCC     "XYUS"
1195                         
1196                         
1197                         ; Print the string "PCR" on the console.
1198                         ; Registers changed: X
1199                         PrintPCR:
1200 c6aa 30 8d 05 38                LEAX    MSG3,PCR        ; "PCR" string
1201 c6ae 17 f9 ec                   LBSR    PrintString
1202 c6b1 39                         RTS
1203                         
1204                         ; Print final CR
1205                         
1206 c6b2 17 f9 79           done:   LBSR    PrintCR
1207                         
1208                         ; Update address to next instruction
1209                         ; If it was a page 2/3 instruction, we need to subtract one from the
1210                         ; length to account for ADRS being moved to the second byte of the
1211                         ; instruction.
1212                         
1213 c6b5 7d 5f fc                   TST     PAGE23          ; Flag set
1214 c6b8 27 03                      BEQ     not23           ; Branch if not
1215 c6ba 7a 5f f6                   DEC     LENG            ; Decrement length
1216 c6bd 4f                 not23:  CLRA                    ; Clear MSB of D
1217 c6be f6 5f f6                   LDB     LENG            ; Get length byte in LSB of D
1218 c6c1 f3 5f f0                   ADDD    ADRS            ; Add to address
1219 c6c4 fd 5f f0                   STD     ADRS            ; Write new address
1220                         
1221                         ; Return
1222 c6c7 39                         RTS
1223                         
1224                         ; *** DATA
1225                         
1226                         ; Table of instruction strings. 4 bytes per table entry
1227                         MNEMONICS:
1228 c6c8 3f 3f 3f 20                FCC     "??? "          ; $00
1229 c6cc 41 42 58 20                FCC     "ABX "          ; $01
1230 c6d0 41 44 43 41                FCC     "ADCA"          ; $02
1231 c6d4 41 44 43 42                FCC     "ADCB"          ; $03
1232 c6d8 41 44 44 41                FCC     "ADDA"          ; $04
1233 c6dc 41 44 44 42                FCC     "ADDB"          ; $05
1234 c6e0 41 44 44 44                FCC     "ADDD"          ; $06
1235 c6e4 41 4e 44 41                FCC     "ANDA"          ; $07
1236 c6e8 41 4e 44 42                FCC     "ANDB"          ; $08
1237 c6ec 41 4e 44 43                FCC     "ANDC"          ; $09 Should really  be "ANDCC"
1238 c6f0 41 53 4c 20                FCC     "ASL "          ; $0A
1239 c6f4 41 53 4c 41                FCC     "ASLA"          ; $0B
1240 c6f8 41 53 4c 42                FCC     "ASLB"          ; $0C
1241 c6fc 41 53 52 20                FCC     "ASR "          ; $0D
1242 c700 41 53 52 41                FCC     "ASRA"          ; $0E
1243 c704 41 53 52 42                FCC     "ASRB"          ; $0F
1244 c708 42 43 43 20                FCC     "BCC "          ; $10
1245 c70c 42 43 53 20                FCC     "BCS "          ; $11
1246 c710 42 45 51 20                FCC     "BEQ "          ; $12
1247 c714 42 47 45 20                FCC     "BGE "          ; $13
1248 c718 42 47 54 20                FCC     "BGT "          ; $14
1249 c71c 42 48 49 20                FCC     "BHI "          ; $15
1250 c720 42 48 53 20                FCC     "BHS "          ; $16
1251 c724 42 49 54 41                FCC     "BITA"          ; $17
1252 c728 42 49 54 42                FCC     "BITB"          ; $18
1253 c72c 42 4c 45 20                FCC     "BLE "          ; $19
1254 c730 42 4c 4f 20                FCC     "BLO "          ; $1A
1255 c734 42 4c 53 20                FCC     "BLS "          ; $1B
1256 c738 42 4c 54 20                FCC     "BLT "          ; $1C
1257 c73c 42 4d 49 20                FCC     "BMI "          ; $1D
1258 c740 42 4e 45 20                FCC     "BNE "          ; $1E
1259 c744 42 50 4c 20                FCC     "BPL "          ; $1F
1260 c748 42 52 41 20                FCC     "BRA "          ; $20
1261 c74c 42 52 4e 20                FCC     "BRN "          ; $21
1262 c750 42 53 52 20                FCC     "BSR "          ; $22
1263 c754 42 56 43 20                FCC     "BVC "          ; $23
1264 c758 42 56 53 20                FCC     "BVS "          ; $24
1265 c75c 43 4c 52 20                FCC     "CLR "          ; $25
1266 c760 43 4c 52 41                FCC     "CLRA"          ; $26
1267 c764 43 4c 52 42                FCC     "CLRB"          ; $27
1268 c768 43 4d 50 41                FCC     "CMPA"          ; $28
1269 c76c 43 4d 50 42                FCC     "CMPB"          ; $29
1270 c770 43 4d 50 44                FCC     "CMPD"          ; $2A
1271 c774 43 4d 50 53                FCC     "CMPS"          ; $2B
1272 c778 43 4d 50 55                FCC     "CMPU"          ; $2C
1273 c77c 43 4d 50 58                FCC     "CMPX"          ; $2D
1274 c780 43 4d 50 59                FCC     "CMPY"          ; $2E
1275 c784 43 4f 4d 41                FCC     "COMA"          ; $2F
1276 c788 43 4f 4d 42                FCC     "COMB"          ; $30
1277 c78c 43 4f 4d 20                FCC     "COM "          ; $31
1278 c790 43 57 41 49                FCC     "CWAI"          ; $32
1279 c794 44 41 41 20                FCC     "DAA "          ; $33
1280 c798 44 45 43 20                FCC     "DEC "          ; $34
1281 c79c 44 45 43 41                FCC     "DECA"          ; $35
1282 c7a0 44 45 43 42                FCC     "DECB"          ; $36
1283 c7a4 45 4f 52 41                FCC     "EORA"          ; $37
1284 c7a8 45 4f 52 42                FCC     "EORB"          ; $38
1285 c7ac 45 58 47 20                FCC     "EXG "          ; $39
1286 c7b0 49 4e 43 20                FCC     "INC "          ; $3A
1287 c7b4 49 4e 43 41                FCC     "INCA"          ; $3B
1288 c7b8 49 4e 43 42                FCC     "INCB"          ; $3C
1289 c7bc 4a 4d 50 20                FCC     "JMP "          ; $3D
1290 c7c0 4a 53 52 20                FCC     "JSR "          ; $3E
1291 c7c4 4c 42 43 43                FCC     "LBCC"          ; $3F
1292 c7c8 4c 42 43 53                FCC     "LBCS"          ; $40
1293 c7cc 4c 42 45 51                FCC     "LBEQ"          ; $41
1294 c7d0 4c 42 47 45                FCC     "LBGE"          ; $42
1295 c7d4 4c 42 47 54                FCC     "LBGT"          ; $43
1296 c7d8 4c 42 48 49                FCC     "LBHI"          ; $44
1297 c7dc 4c 42 48 53                FCC     "LBHS"          ; $45
1298 c7e0 4c 42 4c 45                FCC     "LBLE"          ; $46
1299 c7e4 4c 42 4c 4f                FCC     "LBLO"          ; $47
1300 c7e8 4c 42 4c 53                FCC     "LBLS"          ; $48
1301 c7ec 4c 42 4c 54                FCC     "LBLT"          ; $49
1302 c7f0 4c 42 4d 49                FCC     "LBMI"          ; $4A
1303 c7f4 4c 42 4e 45                FCC     "LBNE"          ; $4B
1304 c7f8 4c 42 50 4c                FCC     "LBPL"          ; $4C
1305 c7fc 4c 42 52 41                FCC     "LBRA"          ; $4D
1306 c800 4c 42 52 4e                FCC     "LBRN"          ; $4E
1307 c804 4c 42 53 52                FCC     "LBSR"          ; $4F
1308 c808 4c 42 56 43                FCC     "LBVC"          ; $50
1309 c80c 4c 42 56 53                FCC     "LBVS"          ; $51
1310 c810 4c 44 41 20                FCC     "LDA "          ; $52
1311 c814 4c 44 42 20                FCC     "LDB "          ; $53
1312 c818 4c 44 44 20                FCC     "LDD "          ; $54
1313 c81c 4c 44 53 20                FCC     "LDS "          ; $55
1314 c820 4c 44 55 20                FCC     "LDU "          ; $56
1315 c824 4c 44 58 20                FCC     "LDX "          ; $57
1316 c828 4c 44 59 20                FCC     "LDY "          ; $58
1317 c82c 4c 45 41 53                FCC     "LEAS"          ; $59
1318 c830 4c 45 41 55                FCC     "LEAU"          ; $5A
1319 c834 4c 45 41 58                FCC     "LEAX"          ; $5B
1320 c838 4c 45 41 59                FCC     "LEAY"          ; $5C
1321 c83c 4c 53 4c 20                FCC     "LSL "          ; $5D
1322 c840 4c 53 4c 41                FCC     "LSLA"          ; $5E
1323 c844 4c 53 4c 42                FCC     "LSLB"          ; $5F
1324 c848 4c 53 52 20                FCC     "LSR "          ; $60
1325 c84c 4c 53 52 41                FCC     "LSRA"          ; $61
1326 c850 4c 53 52 42                FCC     "LSRB"          ; $62
1327 c854 4d 55 4c 20                FCC     "MUL "          ; $63
1328 c858 4e 45 47 20                FCC     "NEG "          ; $64
1329 c85c 4e 45 47 41                FCC     "NEGA"          ; $65
1330 c860 4e 45 47 42                FCC     "NEGB"          ; $66
1331 c864 4e 4f 50 20                FCC     "NOP "          ; $67
1332 c868 4f 52 41 20                FCC     "ORA "          ; $68
1333 c86c 4f 52 42 20                FCC     "ORB "          ; $69
1334 c870 4f 52 43 43                FCC     "ORCC"          ; $6A
1335 c874 50 53 48 53                FCC     "PSHS"          ; $6B
1336 c878 50 53 48 55                FCC     "PSHU"          ; $6C
1337 c87c 50 55 4c 53                FCC     "PULS"          ; $6D
1338 c880 50 55 4c 55                FCC     "PULU"          ; $6E
1339 c884 52 4f 4c 20                FCC     "ROL "          ; $6F
1340 c888 52 4f 4c 41                FCC     "ROLA"          ; $70
1341 c88c 52 4f 4c 42                FCC     "ROLB"          ; $71
1342 c890 52 4f 52 20                FCC     "ROR "          ; $72
1343 c894 52 4f 52 41                FCC     "RORA"          ; $73
1344 c898 52 4f 52 42                FCC     "RORB"          ; $74
1345 c89c 52 54 49 20                FCC     "RTI "          ; $75
1346 c8a0 52 54 53 20                FCC     "RTS "          ; $76
1347 c8a4 53 42 43 41                FCC     "SBCA"          ; $77
1348 c8a8 53 42 43 42                FCC     "SBCB"          ; $78
1349 c8ac 53 45 58 20                FCC     "SEX "          ; $79
1350 c8b0 53 54 41 20                FCC     "STA "          ; $7A
1351 c8b4 53 54 42 20                FCC     "STB "          ; $7B
1352 c8b8 53 54 44 20                FCC     "STD "          ; $7C
1353 c8bc 53 54 53 20                FCC     "STS "          ; $7D
1354 c8c0 53 54 55 20                FCC     "STU "          ; $7E
1355 c8c4 53 54 58 20                FCC     "STX "          ; $7F
1356 c8c8 53 54 59 20                FCC     "STY "          ; $80
1357 c8cc 53 55 42 41                FCC     "SUBA"          ; $81
1358 c8d0 53 55 42 42                FCC     "SUBB"          ; $82
1359 c8d4 53 55 42 44                FCC     "SUBD"          ; $83
1360 c8d8 53 57 49 20                FCC     "SWI "          ; $84
1361 c8dc 53 57 49 32                FCC     "SWI2"          ; $85
1362 c8e0 53 57 49 33                FCC     "SWI3"          ; $86
1363 c8e4 53 59 4e 43                FCC     "SYNC"          ; $87
1364 c8e8 54 46 52 20                FCC     "TFR "          ; $88
1365 c8ec 54 53 54 20                FCC     "TST "          ; $89
1366 c8f0 54 53 54 41                FCC     "TSTA"          ; $8A
1367 c8f4 54 53 54 42                FCC     "TSTB"          ; $8B
1368                         
1369                         ; Lengths of instructions given an addressing mode. Matches values of
1370                         ; AM_* Indexed addessing instructions lenth can increase due to post
1371                         ; byte.
1372                         LENGTHS:
1373 c8f8 01                         FCB     1               ; 0 AM_INVALID
1374 c8f9 01                         FCB     1               ; 1 AM_INHERENT
1375 c8fa 02                         FCB     2               ; 2 AM_IMMEDIATE8
1376 c8fb 03                         FCB     3               ; 3 AM_IMMEDIATE16
1377 c8fc 02                         FCB     2               ; 4 AM_DIRECT
1378 c8fd 03                         FCB     3               ; 5 AM_EXTENDED
1379 c8fe 02                         FCB     2               ; 6 AM_RELATIVE8
1380 c8ff 03                         FCB     3               ; 7 AM_RELATIVE16
1381 c900 02                         FCB     2               ; 8 AM_INDEXED
1382                         
1383                         ; Lookup table to return needed remaining spaces to print to pad out
1384                         ; instruction to correct column in disassembly.
1385                         ; # bytes: 1 2 3 4
1386                         ; Padding: 9 6 3 0
1387                         PADDING:
1388 c901 0a 07 04 01                FCB     10, 7, 4, 1
1389                         
1390                         ; Lookup table to return number of additional bytes for indexed
1391                         ; addressing based on low order 5 bits of postbyte. Based on
1392                         ; detailed list of values below.
1393                         
1394                         POSTBYTES:
1395 c905 00 00 00 00 00 00          FCB     0, 0, 0, 0, 0, 0, 0, 0
     00 00
1396 c90d 01 02 00 00 01 02          FCB     1, 2, 0, 0, 1, 2, 0, 0
     00 00
1397 c915 00 00 00 00 00 00          FCB     0, 0, 0, 0, 0, 0, 0, 0
     00 00
1398 c91d 01 02 00 00 01 02          FCB     1, 2, 0, 0, 1, 2, 0, 2
     00 02
1399                         
1400                         ; Pattern:  # Extra bytes:
1401                         ; --------  --------------
1402                         ; 0XXXXXXX   0
1403                         ; 1XX00000   0
1404                         ; 1XX00001   0
1405                         ; 1XX00010   0
1406                         ; 1XX00011   0
1407                         ; 1XX00100   0
1408                         ; 1X000101   0
1409                         ; 1XX00110   0
1410                         ; 1XX00111   0 (INVALID)
1411                         ; 1XX01000   1
1412                         ; 1XX01001   2
1413                         ; 1XX01010   0 (INVALID)
1414                         ; 1XX01011   0
1415                         ; 1XX01100   1
1416                         ; 1XX01101   2
1417                         ; 1XX01110   0 (INVALID)
1418                         ; 1XX01111   0 (INVALID)
1419                         ; 1XX10000   0 (INVALID)
1420                         ; 1XX10001   0
1421                         ; 1XX10010   0 (INVALID)
1422                         ; 1XX10011   0
1423                         ; 1XX10100   0
1424                         ; 1XX10101   0
1425                         ; 1XX10110   0
1426                         ; 1XX10111   0 (INVALID)
1427                         ; 1XX11000   1
1428                         ; 1XX11001   2
1429                         ; 1XX11010   0 (INVALID)
1430                         ; 1XX11011   0
1431                         ; 1XX11100   1
1432                         ; 1XX11101   2
1433                         ; 1XX11110   0 (INVALID)
1434                         ; 1XX11111   2
1435                         
1436                         ; Opcodes. Listed in order indexed by op code. Defines the mnemonic.
1437                         OPCODES:
1438 c925 64                         FCB     OP_NEG          ; 00
1439 c926 00                         FCB     OP_INV          ; 01
1440 c927 00                         FCB     OP_INV          ; 02
1441 c928 30                         FCB     OP_COMB         ; 03
1442 c929 60                         FCB     OP_LSR          ; 04
1443 c92a 00                         FCB     OP_INV          ; 05
1444 c92b 72                         FCB     OP_ROR          ; 06
1445 c92c 0d                         FCB     OP_ASR          ; 07
1446 c92d 0a                         FCB     OP_ASL          ; 08 OR LSL
1447 c92e 6f                         FCB     OP_ROL          ; 09
1448 c92f 34                         FCB     OP_DEC          ; 0A
1449 c930 00                         FCB     OP_INV          ; 0B
1450 c931 3a                         FCB     OP_INC          ; 0C
1451 c932 89                         FCB     OP_TST          ; 0D
1452 c933 3d                         FCB     OP_JMP          ; 0E
1453 c934 25                         FCB     OP_CLR          ; 0F
1454                         
1455 c935 00                         FCB     OP_INV          ; 10 Page 2 extended opcodes (see other table)
1456 c936 00                         FCB     OP_INV          ; 11 Page 3 extended opcodes (see other table)
1457 c937 67                         FCB     OP_NOP          ; 12
1458 c938 87                         FCB     OP_SYNC         ; 13
1459 c939 00                         FCB     OP_INV          ; 14
1460 c93a 00                         FCB     OP_INV          ; 15
1461 c93b 4d                         FCB     OP_LBRA         ; 16
1462 c93c 4f                         FCB     OP_LBSR         ; 17
1463 c93d 00                         FCB     OP_INV          ; 18
1464 c93e 33                         FCB     OP_DAA          ; 19
1465 c93f 6a                         FCB     OP_ORCC         ; 1A
1466 c940 00                         FCB     OP_INV          ; 1B
1467 c941 09                         FCB     OP_ANDCC        ; 1C
1468 c942 79                         FCB     OP_SEX          ; 1D
1469 c943 39                         FCB     OP_EXG          ; 1E
1470 c944 88                         FCB     OP_TFR          ; 1F
1471                         
1472 c945 20                         FCB     OP_BRA          ; 20
1473 c946 21                         FCB     OP_BRN          ; 21
1474 c947 15                         FCB     OP_BHI          ; 22
1475 c948 1b                         FCB     OP_BLS          ; 23
1476 c949 16                         FCB     OP_BHS          ; 24
1477 c94a 1a                         FCB     OP_BLO          ; 25
1478 c94b 1e                         FCB     OP_BNE          ; 26
1479 c94c 12                         FCB     OP_BEQ          ; 27
1480 c94d 23                         FCB     OP_BVC          ; 28
1481 c94e 24                         FCB     OP_BVS          ; 29
1482 c94f 1f                         FCB     OP_BPL          ; 2A
1483 c950 1d                         FCB     OP_BMI          ; 2B
1484 c951 13                         FCB     OP_BGE          ; 2C
1485 c952 1c                         FCB     OP_BLT          ; 2D
1486 c953 14                         FCB     OP_BGT          ; 2E
1487 c954 19                         FCB     OP_BLE          ; 2F
1488                         
1489 c955 5b                         FCB     OP_LEAX         ; 30
1490 c956 5c                         FCB     OP_LEAY         ; 31
1491 c957 59                         FCB     OP_LEAS         ; 32
1492 c958 5a                         FCB     OP_LEAU         ; 33
1493 c959 6b                         FCB     OP_PSHS         ; 34
1494 c95a 6d                         FCB     OP_PULS         ; 35
1495 c95b 6c                         FCB     OP_PSHU         ; 36
1496 c95c 6e                         FCB     OP_PULU         ; 37
1497 c95d 00                         FCB     OP_INV          ; 38
1498 c95e 76                         FCB     OP_RTS          ; 39
1499 c95f 01                         FCB     OP_ABX          ; 3A
1500 c960 75                         FCB     OP_RTI          ; 3B
1501 c961 32                         FCB     OP_CWAI         ; 3C
1502 c962 63                         FCB     OP_MUL          ; 3D
1503 c963 00                         FCB     OP_INV          ; 3E
1504 c964 84                         FCB     OP_SWI          ; 3F
1505                         
1506 c965 65                         FCB     OP_NEGA         ; 40
1507 c966 00                         FCB     OP_INV          ; 41
1508 c967 00                         FCB     OP_INV          ; 42
1509 c968 2f                         FCB     OP_COMA         ; 43
1510 c969 61                         FCB     OP_LSRA         ; 44
1511 c96a 00                         FCB     OP_INV          ; 45
1512 c96b 73                         FCB     OP_RORA         ; 46
1513 c96c 0e                         FCB     OP_ASRA         ; 47
1514 c96d 0b                         FCB     OP_ASLA         ; 48
1515 c96e 70                         FCB     OP_ROLA         ; 49
1516 c96f 35                         FCB     OP_DECA         ; 4A
1517 c970 00                         FCB     OP_INV          ; 4B
1518 c971 3b                         FCB     OP_INCA         ; 4C
1519 c972 8a                         FCB     OP_TSTA         ; 4D
1520 c973 00                         FCB     OP_INV          ; 4E
1521 c974 26                         FCB     OP_CLRA         ; 4F
1522                         
1523 c975 66                         FCB     OP_NEGB         ; 50
1524 c976 00                         FCB     OP_INV          ; 51
1525 c977 00                         FCB     OP_INV          ; 52
1526 c978 30                         FCB     OP_COMB         ; 53
1527 c979 62                         FCB     OP_LSRB         ; 54
1528 c97a 00                         FCB     OP_INV          ; 55
1529 c97b 74                         FCB     OP_RORB         ; 56
1530 c97c 0f                         FCB     OP_ASRB         ; 57
1531 c97d 0c                         FCB     OP_ASLB         ; 58
1532 c97e 71                         FCB     OP_ROLB         ; 59
1533 c97f 36                         FCB     OP_DECB         ; 5A
1534 c980 00                         FCB     OP_INV          ; 5B
1535 c981 3c                         FCB     OP_INCB         ; 5C
1536 c982 8b                         FCB     OP_TSTB         ; 5D
1537 c983 00                         FCB     OP_INV          ; 5E
1538 c984 27                         FCB     OP_CLRB         ; 5F
1539                         
1540 c985 64                         FCB     OP_NEG          ; 60
1541 c986 00                         FCB     OP_INV          ; 61
1542 c987 00                         FCB     OP_INV          ; 62
1543 c988 31                         FCB     OP_COM          ; 63
1544 c989 60                         FCB     OP_LSR          ; 64
1545 c98a 00                         FCB     OP_INV          ; 65
1546 c98b 72                         FCB     OP_ROR          ; 66
1547 c98c 0d                         FCB     OP_ASR          ; 67
1548 c98d 0a                         FCB     OP_ASL          ; 68
1549 c98e 6f                         FCB     OP_ROL          ; 69
1550 c98f 34                         FCB     OP_DEC          ; 6A
1551 c990 00                         FCB     OP_INV          ; 6B
1552 c991 3a                         FCB     OP_INC          ; 6C
1553 c992 89                         FCB     OP_TST          ; 6D
1554 c993 3d                         FCB     OP_JMP          ; 6E
1555 c994 25                         FCB     OP_CLR          ; 6F
1556                         
1557 c995 64                         FCB     OP_NEG          ; 70
1558 c996 00                         FCB     OP_INV          ; 71
1559 c997 00                         FCB     OP_INV          ; 72
1560 c998 31                         FCB     OP_COM          ; 73
1561 c999 60                         FCB     OP_LSR          ; 74
1562 c99a 00                         FCB     OP_INV          ; 75
1563 c99b 72                         FCB     OP_ROR          ; 76
1564 c99c 0d                         FCB     OP_ASR          ; 77
1565 c99d 0a                         FCB     OP_ASL          ; 78
1566 c99e 6f                         FCB     OP_ROL          ; 79
1567 c99f 34                         FCB     OP_DEC          ; 7A
1568 c9a0 00                         FCB     OP_INV          ; 7B
1569 c9a1 3a                         FCB     OP_INC          ; 7C
1570 c9a2 89                         FCB     OP_TST          ; 7D
1571 c9a3 3d                         FCB     OP_JMP          ; 7E
1572 c9a4 25                         FCB     OP_CLR          ; 7F
1573                         
1574 c9a5 81                         FCB     OP_SUBA         ; 80
1575 c9a6 28                         FCB     OP_CMPA         ; 81
1576 c9a7 77                         FCB     OP_SBCA         ; 82
1577 c9a8 83                         FCB     OP_SUBD         ; 83
1578 c9a9 07                         FCB     OP_ANDA         ; 84
1579 c9aa 17                         FCB     OP_BITA         ; 85
1580 c9ab 52                         FCB     OP_LDA          ; 86
1581 c9ac 00                         FCB     OP_INV          ; 87
1582 c9ad 37                         FCB     OP_EORA         ; 88
1583 c9ae 02                         FCB     OP_ADCA         ; 89
1584 c9af 68                         FCB     OP_ORA          ; 8A
1585 c9b0 04                         FCB     OP_ADDA         ; 8B
1586 c9b1 2d                         FCB     OP_CMPX         ; 8C
1587 c9b2 22                         FCB     OP_BSR          ; 8D
1588 c9b3 57                         FCB     OP_LDX          ; 8E
1589 c9b4 00                         FCB     OP_INV          ; 8F
1590                         
1591 c9b5 81                         FCB     OP_SUBA         ; 90
1592 c9b6 28                         FCB     OP_CMPA         ; 91
1593 c9b7 77                         FCB     OP_SBCA         ; 92
1594 c9b8 83                         FCB     OP_SUBD         ; 93
1595 c9b9 07                         FCB     OP_ANDA         ; 94
1596 c9ba 17                         FCB     OP_BITA         ; 95
1597 c9bb 52                         FCB     OP_LDA          ; 96
1598 c9bc 7a                         FCB     OP_STA          ; 97
1599 c9bd 37                         FCB     OP_EORA         ; 98
1600 c9be 02                         FCB     OP_ADCA         ; 99
1601 c9bf 68                         FCB     OP_ORA          ; 9A
1602 c9c0 04                         FCB     OP_ADDA         ; 9B
1603 c9c1 2d                         FCB     OP_CMPX         ; 9C
1604 c9c2 3e                         FCB     OP_JSR          ; 9D
1605 c9c3 57                         FCB     OP_LDX          ; 9E
1606 c9c4 7f                         FCB     OP_STX          ; 9F
1607                         
1608 c9c5 81                         FCB     OP_SUBA         ; A0
1609 c9c6 28                         FCB     OP_CMPA         ; A1
1610 c9c7 77                         FCB     OP_SBCA         ; A2
1611 c9c8 83                         FCB     OP_SUBD         ; A3
1612 c9c9 07                         FCB     OP_ANDA         ; A4
1613 c9ca 17                         FCB     OP_BITA         ; A5
1614 c9cb 52                         FCB     OP_LDA          ; A6
1615 c9cc 7a                         FCB     OP_STA          ; A7
1616 c9cd 37                         FCB     OP_EORA         ; A8
1617 c9ce 02                         FCB     OP_ADCA         ; A9
1618 c9cf 68                         FCB     OP_ORA          ; AA
1619 c9d0 04                         FCB     OP_ADDA         ; AB
1620 c9d1 2d                         FCB     OP_CMPX         ; AC
1621 c9d2 3e                         FCB     OP_JSR          ; AD
1622 c9d3 57                         FCB     OP_LDX          ; AE
1623 c9d4 7f                         FCB     OP_STX          ; AF
1624                         
1625 c9d5 81                         FCB     OP_SUBA         ; B0
1626 c9d6 28                         FCB     OP_CMPA         ; B1
1627 c9d7 77                         FCB     OP_SBCA         ; B2
1628 c9d8 83                         FCB     OP_SUBD         ; B3
1629 c9d9 07                         FCB     OP_ANDA         ; B4
1630 c9da 17                         FCB     OP_BITA         ; B5
1631 c9db 52                         FCB     OP_LDA          ; B6
1632 c9dc 7a                         FCB     OP_STA          ; B7
1633 c9dd 37                         FCB     OP_EORA         ; B8
1634 c9de 02                         FCB     OP_ADCA         ; B9
1635 c9df 68                         FCB     OP_ORA          ; BA
1636 c9e0 04                         FCB     OP_ADDA         ; BB
1637 c9e1 2d                         FCB     OP_CMPX         ; BC
1638 c9e2 3e                         FCB     OP_JSR          ; BD
1639 c9e3 57                         FCB     OP_LDX          ; BE
1640 c9e4 7f                         FCB     OP_STX          ; BF
1641                         
1642 c9e5 82                         FCB     OP_SUBB         ; C0
1643 c9e6 29                         FCB     OP_CMPB         ; C1
1644 c9e7 78                         FCB     OP_SBCB         ; C2
1645 c9e8 06                         FCB     OP_ADDD         ; C3
1646 c9e9 08                         FCB     OP_ANDB         ; C4
1647 c9ea 18                         FCB     OP_BITB         ; C5
1648 c9eb 53                         FCB     OP_LDB          ; C6
1649 c9ec 00                         FCB     OP_INV          ; C7
1650 c9ed 38                         FCB     OP_EORB         ; C8
1651 c9ee 03                         FCB     OP_ADCB         ; C9
1652 c9ef 69                         FCB     OP_ORB          ; CA
1653 c9f0 05                         FCB     OP_ADDB         ; CB
1654 c9f1 54                         FCB     OP_LDD          ; CC
1655 c9f2 00                         FCB     OP_INV          ; CD
1656 c9f3 56                         FCB     OP_LDU          ; CE
1657 c9f4 00                         FCB     OP_INV          ; CF
1658                         
1659 c9f5 82                         FCB     OP_SUBB         ; D0
1660 c9f6 29                         FCB     OP_CMPB         ; D1
1661 c9f7 78                         FCB     OP_SBCB         ; D2
1662 c9f8 06                         FCB     OP_ADDD         ; D3
1663 c9f9 08                         FCB     OP_ANDB         ; D4
1664 c9fa 18                         FCB     OP_BITB         ; D5
1665 c9fb 53                         FCB     OP_LDB          ; D6
1666 c9fc 7b                         FCB     OP_STB          ; D7
1667 c9fd 38                         FCB     OP_EORB         ; D8
1668 c9fe 03                         FCB     OP_ADCB         ; D9
1669 c9ff 69                         FCB     OP_ORB          ; DA
1670 ca00 05                         FCB     OP_ADDB         ; DB
1671 ca01 54                         FCB     OP_LDD          ; DC
1672 ca02 7c                         FCB     OP_STD          ; DD
1673 ca03 56                         FCB     OP_LDU          ; DE
1674 ca04 7e                         FCB     OP_STU          ; DF
1675                         
1676 ca05 82                         FCB     OP_SUBB         ; E0
1677 ca06 29                         FCB     OP_CMPB         ; E1
1678 ca07 78                         FCB     OP_SBCB         ; E2
1679 ca08 06                         FCB     OP_ADDD         ; E3
1680 ca09 08                         FCB     OP_ANDB         ; E4
1681 ca0a 18                         FCB     OP_BITB         ; E5
1682 ca0b 53                         FCB     OP_LDB          ; E6
1683 ca0c 7b                         FCB     OP_STB          ; E7
1684 ca0d 38                         FCB     OP_EORB         ; E8
1685 ca0e 03                         FCB     OP_ADCB         ; E9
1686 ca0f 69                         FCB     OP_ORB          ; EA
1687 ca10 05                         FCB     OP_ADDB         ; EB
1688 ca11 54                         FCB     OP_LDD          ; EC
1689 ca12 7c                         FCB     OP_STD          ; ED
1690 ca13 56                         FCB     OP_LDU          ; EE
1691 ca14 7e                         FCB     OP_STU          ; EF
1692                         
1693 ca15 82                         FCB     OP_SUBB         ; F0
1694 ca16 29                         FCB     OP_CMPB         ; F1
1695 ca17 78                         FCB     OP_SBCB         ; F2
1696 ca18 06                         FCB     OP_ADDD         ; F3
1697 ca19 08                         FCB     OP_ANDB         ; F4
1698 ca1a 18                         FCB     OP_BITB         ; F5
1699 ca1b 53                         FCB     OP_LDB          ; F6
1700 ca1c 7b                         FCB     OP_STB          ; F7
1701 ca1d 38                         FCB     OP_EORB         ; F8
1702 ca1e 03                         FCB     OP_ADCB         ; F9
1703 ca1f 69                         FCB     OP_ORB          ; FA
1704 ca20 05                         FCB     OP_ADDB         ; FB
1705 ca21 54                         FCB     OP_LDD          ; FC
1706 ca22 7c                         FCB     OP_STD          ; FD
1707 ca23 56                         FCB     OP_LDU          ; FE
1708 ca24 7e                         FCB     OP_STU          ; FF
1709                         
1710                         ; Table of addressing modes. Listed in order,indexed by op code.
1711                         MODES:
1712 ca25 04                         FCB     AM_DIRECT       ; 00
1713 ca26 00                         FCB     AM_INVALID      ; 01
1714 ca27 00                         FCB     AM_INVALID      ; 02
1715 ca28 04                         FCB     AM_DIRECT       ; 03
1716 ca29 04                         FCB     AM_DIRECT       ; 04
1717 ca2a 00                         FCB     AM_INVALID      ; 05
1718 ca2b 04                         FCB     AM_DIRECT       ; 06
1719 ca2c 04                         FCB     AM_DIRECT       ; 07
1720 ca2d 04                         FCB     AM_DIRECT       ; 08
1721 ca2e 04                         FCB     AM_DIRECT       ; 09
1722 ca2f 04                         FCB     AM_DIRECT       ; 0A
1723 ca30 00                         FCB     AM_INVALID      ; 0B
1724 ca31 04                         FCB     AM_DIRECT       ; 0C
1725 ca32 04                         FCB     AM_DIRECT       ; 0D
1726 ca33 04                         FCB     AM_DIRECT       ; 0E
1727 ca34 04                         FCB     AM_DIRECT       ; 0F
1728                         
1729 ca35 00                         FCB     AM_INVALID      ; 10 Page 2 extended opcodes (see other table)
1730 ca36 00                         FCB     AM_INVALID      ; 11 Page 3 extended opcodes (see other table)
1731 ca37 01                         FCB     AM_INHERENT     ; 12
1732 ca38 01                         FCB     AM_INHERENT     ; 13
1733 ca39 00                         FCB     AM_INVALID      ; 14
1734 ca3a 00                         FCB     AM_INVALID      ; 15
1735 ca3b 07                         FCB     AM_RELATIVE16   ; 16
1736 ca3c 07                         FCB     AM_RELATIVE16   ; 17
1737 ca3d 00                         FCB     AM_INVALID      ; 18
1738 ca3e 01                         FCB     AM_INHERENT     ; 19
1739 ca3f 02                         FCB     AM_IMMEDIATE8   ; 1A
1740 ca40 00                         FCB     AM_INVALID      ; 1B
1741 ca41 02                         FCB     AM_IMMEDIATE8   ; 1C
1742 ca42 01                         FCB     AM_INHERENT     ; 1D
1743 ca43 02                         FCB     AM_IMMEDIATE8   ; 1E
1744 ca44 02                         FCB     AM_IMMEDIATE8   ; 1F
1745                         
1746 ca45 06                         FCB     AM_RELATIVE8    ; 20
1747 ca46 06                         FCB     AM_RELATIVE8    ; 21
1748 ca47 06                         FCB     AM_RELATIVE8    ; 22
1749 ca48 06                         FCB     AM_RELATIVE8    ; 23
1750 ca49 06                         FCB     AM_RELATIVE8    ; 24
1751 ca4a 06                         FCB     AM_RELATIVE8    ; 25
1752 ca4b 06                         FCB     AM_RELATIVE8    ; 26
1753 ca4c 06                         FCB     AM_RELATIVE8    ; 27
1754 ca4d 06                         FCB     AM_RELATIVE8    ; 28
1755 ca4e 06                         FCB     AM_RELATIVE8    ; 29
1756 ca4f 06                         FCB     AM_RELATIVE8    ; 2A
1757 ca50 06                         FCB     AM_RELATIVE8    ; 2B
1758 ca51 06                         FCB     AM_RELATIVE8    ; 2C
1759 ca52 06                         FCB     AM_RELATIVE8    ; 2D
1760 ca53 06                         FCB     AM_RELATIVE8    ; 2E
1761 ca54 06                         FCB     AM_RELATIVE8    ; 2F
1762                         
1763 ca55 08                         FCB     AM_INDEXED      ; 30
1764 ca56 08                         FCB     AM_INDEXED      ; 31
1765 ca57 08                         FCB     AM_INDEXED      ; 32
1766 ca58 08                         FCB     AM_INDEXED      ; 33
1767 ca59 02                         FCB     AM_IMMEDIATE8   ; 34
1768 ca5a 02                         FCB     AM_IMMEDIATE8   ; 35
1769 ca5b 02                         FCB     AM_IMMEDIATE8   ; 36
1770 ca5c 02                         FCB     AM_IMMEDIATE8   ; 37
1771 ca5d 00                         FCB     AM_INVALID      ; 38
1772 ca5e 01                         FCB     AM_INHERENT     ; 39
1773 ca5f 01                         FCB     AM_INHERENT     ; 3A
1774 ca60 01                         FCB     AM_INHERENT     ; 3B
1775 ca61 02                         FCB     AM_IMMEDIATE8   ; 3C
1776 ca62 01                         FCB     AM_INHERENT     ; 3D
1777 ca63 00                         FCB     AM_INVALID      ; 3E
1778 ca64 01                         FCB     AM_INHERENT     ; 3F
1779                         
1780 ca65 01                         FCB     AM_INHERENT     ; 40
1781 ca66 00                         FCB     AM_INVALID      ; 41
1782 ca67 00                         FCB     AM_INVALID      ; 42
1783 ca68 01                         FCB     AM_INHERENT     ; 43
1784 ca69 01                         FCB     AM_INHERENT     ; 44
1785 ca6a 00                         FCB     AM_INVALID      ; 45
1786 ca6b 01                         FCB     AM_INHERENT     ; 46
1787 ca6c 01                         FCB     AM_INHERENT     ; 47
1788 ca6d 01                         FCB     AM_INHERENT     ; 48
1789 ca6e 01                         FCB     AM_INHERENT     ; 49
1790 ca6f 01                         FCB     AM_INHERENT     ; 4A
1791 ca70 00                         FCB     AM_INVALID      ; 4B
1792 ca71 01                         FCB     AM_INHERENT     ; 4C
1793 ca72 01                         FCB     AM_INHERENT     ; 4D
1794 ca73 00                         FCB     AM_INVALID      ; 4E
1795 ca74 01                         FCB     AM_INHERENT     ; 4F
1796                         
1797 ca75 01                         FCB     AM_INHERENT     ; 50
1798 ca76 00                         FCB     AM_INVALID      ; 51
1799 ca77 00                         FCB     AM_INVALID      ; 52
1800 ca78 01                         FCB     AM_INHERENT     ; 53
1801 ca79 01                         FCB     AM_INHERENT     ; 54
1802 ca7a 00                         FCB     AM_INVALID      ; 55
1803 ca7b 01                         FCB     AM_INHERENT     ; 56
1804 ca7c 01                         FCB     AM_INHERENT     ; 57
1805 ca7d 01                         FCB     AM_INHERENT     ; 58
1806 ca7e 01                         FCB     AM_INHERENT     ; 59
1807 ca7f 01                         FCB     AM_INHERENT     ; 5A
1808 ca80 00                         FCB     AM_INVALID      ; 5B
1809 ca81 01                         FCB     AM_INHERENT     ; 5C
1810 ca82 01                         FCB     AM_INHERENT     ; 5D
1811 ca83 00                         FCB     AM_INVALID      ; 5E
1812 ca84 01                         FCB     AM_INHERENT     ; 5F
1813                         
1814 ca85 08                         FCB     AM_INDEXED      ; 60
1815 ca86 00                         FCB     AM_INVALID      ; 61
1816 ca87 00                         FCB     AM_INVALID      ; 62
1817 ca88 08                         FCB     AM_INDEXED      ; 63
1818 ca89 08                         FCB     AM_INDEXED      ; 64
1819 ca8a 00                         FCB     AM_INVALID      ; 65
1820 ca8b 08                         FCB     AM_INDEXED      ; 66
1821 ca8c 08                         FCB     AM_INDEXED      ; 67
1822 ca8d 08                         FCB     AM_INDEXED      ; 68
1823 ca8e 08                         FCB     AM_INDEXED      ; 69
1824 ca8f 08                         FCB     AM_INDEXED      ; 6A
1825 ca90 00                         FCB     AM_INVALID      ; 6B
1826 ca91 08                         FCB     AM_INDEXED      ; 6C
1827 ca92 08                         FCB     AM_INDEXED      ; 6D
1828 ca93 08                         FCB     AM_INDEXED      ; 6E
1829 ca94 08                         FCB     AM_INDEXED      ; 6F
1830                         
1831 ca95 05                         FCB     AM_EXTENDED     ; 70
1832 ca96 00                         FCB     AM_INVALID      ; 71
1833 ca97 00                         FCB     AM_INVALID      ; 72
1834 ca98 05                         FCB     AM_EXTENDED     ; 73
1835 ca99 05                         FCB     AM_EXTENDED     ; 74
1836 ca9a 00                         FCB     AM_INVALID      ; 75
1837 ca9b 05                         FCB     AM_EXTENDED     ; 76
1838 ca9c 05                         FCB     AM_EXTENDED     ; 77
1839 ca9d 05                         FCB     AM_EXTENDED     ; 78
1840 ca9e 05                         FCB     AM_EXTENDED     ; 79
1841 ca9f 05                         FCB     AM_EXTENDED     ; 7A
1842 caa0 00                         FCB     AM_INVALID      ; 7B
1843 caa1 05                         FCB     AM_EXTENDED     ; 7C
1844 caa2 05                         FCB     AM_EXTENDED     ; 7D
1845 caa3 05                         FCB     AM_EXTENDED     ; 7E
1846 caa4 05                         FCB     AM_EXTENDED     ; 7F
1847                         
1848 caa5 02                         FCB     AM_IMMEDIATE8   ; 80
1849 caa6 02                         FCB     AM_IMMEDIATE8   ; 81
1850 caa7 02                         FCB     AM_IMMEDIATE8   ; 82
1851 caa8 03                         FCB     AM_IMMEDIATE16  ; 83
1852 caa9 02                         FCB     AM_IMMEDIATE8   ; 84
1853 caaa 02                         FCB     AM_IMMEDIATE8   ; 85
1854 caab 02                         FCB     AM_IMMEDIATE8   ; 86
1855 caac 00                         FCB     AM_INVALID      ; 87
1856 caad 02                         FCB     AM_IMMEDIATE8   ; 88
1857 caae 02                         FCB     AM_IMMEDIATE8   ; 89
1858 caaf 02                         FCB     AM_IMMEDIATE8   ; 8A
1859 cab0 02                         FCB     AM_IMMEDIATE8   ; 8B
1860 cab1 03                         FCB     AM_IMMEDIATE16  ; 8C
1861 cab2 06                         FCB     AM_RELATIVE8    ; 8D
1862 cab3 03                         FCB     AM_IMMEDIATE16  ; 8E
1863 cab4 00                         FCB     AM_INVALID      ; 8F
1864                         
1865 cab5 04                         FCB     AM_DIRECT       ; 90
1866 cab6 04                         FCB     AM_DIRECT       ; 91
1867 cab7 04                         FCB     AM_DIRECT       ; 92
1868 cab8 04                         FCB     AM_DIRECT       ; 93
1869 cab9 04                         FCB     AM_DIRECT       ; 94
1870 caba 04                         FCB     AM_DIRECT       ; 95
1871 cabb 04                         FCB     AM_DIRECT       ; 96
1872 cabc 04                         FCB     AM_DIRECT       ; 97
1873 cabd 04                         FCB     AM_DIRECT       ; 98
1874 cabe 04                         FCB     AM_DIRECT       ; 99
1875 cabf 04                         FCB     AM_DIRECT       ; 9A
1876 cac0 04                         FCB     AM_DIRECT       ; 9B
1877 cac1 04                         FCB     AM_DIRECT       ; 9C
1878 cac2 04                         FCB     AM_DIRECT       ; 9D
1879 cac3 04                         FCB     AM_DIRECT       ; 9E
1880 cac4 04                         FCB     AM_DIRECT       ; 9F
1881                         
1882 cac5 08                         FCB     AM_INDEXED      ; A0
1883 cac6 08                         FCB     AM_INDEXED      ; A1
1884 cac7 08                         FCB     AM_INDEXED      ; A2
1885 cac8 08                         FCB     AM_INDEXED      ; A3
1886 cac9 08                         FCB     AM_INDEXED      ; A4
1887 caca 08                         FCB     AM_INDEXED      ; A5
1888 cacb 08                         FCB     AM_INDEXED      ; A6
1889 cacc 08                         FCB     AM_INDEXED      ; A7
1890 cacd 08                         FCB     AM_INDEXED      ; A8
1891 cace 08                         FCB     AM_INDEXED      ; A9
1892 cacf 08                         FCB     AM_INDEXED      ; AA
1893 cad0 08                         FCB     AM_INDEXED      ; AB
1894 cad1 08                         FCB     AM_INDEXED      ; AC
1895 cad2 08                         FCB     AM_INDEXED      ; AD
1896 cad3 08                         FCB     AM_INDEXED      ; AE
1897 cad4 08                         FCB     AM_INDEXED      ; AF
1898                         
1899 cad5 05                         FCB     AM_EXTENDED     ; B0
1900 cad6 05                         FCB     AM_EXTENDED     ; B1
1901 cad7 05                         FCB     AM_EXTENDED     ; B2
1902 cad8 05                         FCB     AM_EXTENDED     ; B3
1903 cad9 05                         FCB     AM_EXTENDED     ; B4
1904 cada 05                         FCB     AM_EXTENDED     ; B5
1905 cadb 05                         FCB     AM_EXTENDED     ; B6
1906 cadc 05                         FCB     AM_EXTENDED     ; B7
1907 cadd 05                         FCB     AM_EXTENDED     ; B8
1908 cade 05                         FCB     AM_EXTENDED     ; B9
1909 cadf 05                         FCB     AM_EXTENDED     ; BA
1910 cae0 05                         FCB     AM_EXTENDED     ; BB
1911 cae1 05                         FCB     AM_EXTENDED     ; BC
1912 cae2 05                         FCB     AM_EXTENDED     ; BD
1913 cae3 05                         FCB     AM_EXTENDED     ; BE
1914 cae4 05                         FCB     AM_EXTENDED     ; BF
1915                         
1916 cae5 02                         FCB     AM_IMMEDIATE8   ; C0
1917 cae6 02                         FCB     AM_IMMEDIATE8   ; C1
1918 cae7 02                         FCB     AM_IMMEDIATE8   ; C2
1919 cae8 03                         FCB     AM_IMMEDIATE16  ; C3
1920 cae9 02                         FCB     AM_IMMEDIATE8   ; C4
1921 caea 02                         FCB     AM_IMMEDIATE8   ; C5
1922 caeb 02                         FCB     AM_IMMEDIATE8   ; C6
1923 caec 00                         FCB     AM_INVALID      ; C7
1924 caed 02                         FCB     AM_IMMEDIATE8   ; C8
1925 caee 02                         FCB     AM_IMMEDIATE8   ; C9
1926 caef 02                         FCB     AM_IMMEDIATE8   ; CA
1927 caf0 02                         FCB     AM_IMMEDIATE8   ; CB
1928 caf1 02                         FCB     AM_IMMEDIATE8   ; CC
1929 caf2 01                         FCB     AM_INHERENT     ; CD
1930 caf3 02                         FCB     AM_IMMEDIATE8   ; CE
1931 caf4 00                         FCB     AM_INVALID      ; CF
1932                         
1933 caf5 04                         FCB     AM_DIRECT       ; D0
1934 caf6 04                         FCB     AM_DIRECT       ; D1
1935 caf7 04                         FCB     AM_DIRECT       ; D2
1936 caf8 04                         FCB     AM_DIRECT       ; D3
1937 caf9 04                         FCB     AM_DIRECT       ; D4
1938 cafa 04                         FCB     AM_DIRECT       ; D5
1939 cafb 04                         FCB     AM_DIRECT       ; D6
1940 cafc 04                         FCB     AM_DIRECT       ; D7
1941 cafd 04                         FCB     AM_DIRECT       ; D8
1942 cafe 04                         FCB     AM_DIRECT       ; D9
1943 caff 04                         FCB     AM_DIRECT       ; DA
1944 cb00 04                         FCB     AM_DIRECT       ; DB
1945 cb01 04                         FCB     AM_DIRECT       ; DC
1946 cb02 04                         FCB     AM_DIRECT       ; DD
1947 cb03 04                         FCB     AM_DIRECT       ; DE
1948 cb04 04                         FCB     AM_DIRECT       ; DF
1949                         
1950 cb05 08                         FCB     AM_INDEXED      ; E0
1951 cb06 08                         FCB     AM_INDEXED      ; E1
1952 cb07 08                         FCB     AM_INDEXED      ; E2
1953 cb08 08                         FCB     AM_INDEXED      ; E3
1954 cb09 08                         FCB     AM_INDEXED      ; E4
1955 cb0a 08                         FCB     AM_INDEXED      ; E5
1956 cb0b 08                         FCB     AM_INDEXED      ; E6
1957 cb0c 08                         FCB     AM_INDEXED      ; E7
1958 cb0d 08                         FCB     AM_INDEXED      ; E8
1959 cb0e 08                         FCB     AM_INDEXED      ; E9
1960 cb0f 08                         FCB     AM_INDEXED      ; EA
1961 cb10 08                         FCB     AM_INDEXED      ; EB
1962 cb11 08                         FCB     AM_INDEXED      ; EC
1963 cb12 08                         FCB     AM_INDEXED      ; ED
1964 cb13 08                         FCB     AM_INDEXED      ; EE
1965 cb14 08                         FCB     AM_INDEXED      ; EF
1966                         
1967 cb15 05                         FCB     AM_EXTENDED     ; F0
1968 cb16 05                         FCB     AM_EXTENDED     ; F1
1969 cb17 05                         FCB     AM_EXTENDED     ; F2
1970 cb18 05                         FCB     AM_EXTENDED     ; F3
1971 cb19 05                         FCB     AM_EXTENDED     ; F4
1972 cb1a 05                         FCB     AM_EXTENDED     ; F5
1973 cb1b 05                         FCB     AM_EXTENDED     ; F6
1974 cb1c 05                         FCB     AM_EXTENDED     ; F7
1975 cb1d 05                         FCB     AM_EXTENDED     ; F8
1976 cb1e 05                         FCB     AM_EXTENDED     ; F9
1977 cb1f 05                         FCB     AM_EXTENDED     ; FA
1978 cb20 05                         FCB     AM_EXTENDED     ; FB
1979 cb21 05                         FCB     AM_EXTENDED     ; FC
1980 cb22 05                         FCB     AM_EXTENDED     ; FD
1981 cb23 05                         FCB     AM_EXTENDED     ; FE
1982 cb24 05                         FCB     AM_EXTENDED     ; FF
1983                         
1984                         ; Special table for page 2 instructions prefixed by $10.
1985                         ; Format: opcode (less 10), instruction, addressing mode
1986                         
1987                         PAGE2:
1988 cb25 21 4e 07                   FCB     $21, OP_LBRN,  AM_RELATIVE16
1989 cb28 22 44 07                   FCB     $22, OP_LBHI,  AM_RELATIVE16
1990 cb2b 23 48 07                   FCB     $23, OP_LBLS,  AM_RELATIVE16
1991 cb2e 24 45 07                   FCB     $24, OP_LBHS,  AM_RELATIVE16
1992 cb31 25 40 07                   FCB     $25, OP_LBCS,  AM_RELATIVE16
1993 cb34 26 4b 07                   FCB     $26, OP_LBNE,  AM_RELATIVE16
1994 cb37 27 41 07                   FCB     $27, OP_LBEQ,  AM_RELATIVE16
1995 cb3a 28 50 07                   FCB     $28, OP_LBVC,  AM_RELATIVE16
1996 cb3d 29 51 07                   FCB     $29, OP_LBVS,  AM_RELATIVE16
1997 cb40 2a 4c 07                   FCB     $2A, OP_LBPL,  AM_RELATIVE16
1998 cb43 2b 4a 07                   FCB     $2B, OP_LBMI,  AM_RELATIVE16
1999 cb46 2c 42 07                   FCB     $2C, OP_LBGE,  AM_RELATIVE16
2000 cb49 2d 49 07                   FCB     $2D, OP_LBLT,  AM_RELATIVE16
2001 cb4c 2e 43 07                   FCB     $2E, OP_LBGT,  AM_RELATIVE16
2002 cb4f 2f 46 07                   FCB     $2F, OP_LBLE,  AM_RELATIVE16
2003 cb52 3f 85 01                   FCB     $3F, OP_SWI2,  AM_INHERENT
2004 cb55 83 2a 03                   FCB     $83, OP_CMPD,  AM_IMMEDIATE16
2005 cb58 8c 2e 03                   FCB     $8C, OP_CMPY,  AM_IMMEDIATE16
2006 cb5b 8e 58 03                   FCB     $8E, OP_LDY,   AM_IMMEDIATE16
2007 cb5e 93 2a 04                   FCB     $93, OP_CMPD,  AM_DIRECT
2008 cb61 9c 2e 04                   FCB     $9C, OP_CMPY,  AM_DIRECT
2009 cb64 9e 58 04                   FCB     $9E, OP_LDY,   AM_DIRECT
2010 cb67 9d 80 04                   FCB     $9D, OP_STY,   AM_DIRECT
2011 cb6a a3 2a 08                   FCB     $A3, OP_CMPD,  AM_INDEXED
2012 cb6d ac 2e 08                   FCB     $AC, OP_CMPY,  AM_INDEXED
2013 cb70 ae 58 08                   FCB     $AE, OP_LDY,   AM_INDEXED
2014 cb73 af 80 08                   FCB     $AF, OP_STY,   AM_INDEXED
2015 cb76 b3 2a 05                   FCB     $B3, OP_CMPD,  AM_EXTENDED
2016 cb79 bc 2e 05                   FCB     $BC, OP_CMPY,  AM_EXTENDED
2017 cb7c be 58 05                   FCB     $BE, OP_LDY,   AM_EXTENDED
2018 cb7f bf 80 05                   FCB     $BF, OP_STY,   AM_EXTENDED
2019 cb82 ce 55 03                   FCB     $CE, OP_LDS,   AM_IMMEDIATE16
2020 cb85 de 55 04                   FCB     $DE, OP_LDS,   AM_DIRECT
2021 cb88 dd 7d 04                   FCB     $DD, OP_STS,   AM_DIRECT
2022 cb8b ee 55 08                   FCB     $EE, OP_LDS,   AM_INDEXED
2023 cb8e ef 7d 08                   FCB     $EF, OP_STS,   AM_INDEXED
2024 cb91 fe 55 05                   FCB     $FE, OP_LDS,   AM_EXTENDED
2025 cb94 ff 7d 05                   FCB     $FF, OP_STS,   AM_EXTENDED
2026 cb97 00                         FCB     0                             ; indicates end of table
2027                         
2028                         ; Special table for page 3 instructions prefixed by $11.
2029                         ; Same format as table above.
2030                         
2031                         PAGE3:
2032 cb98 3f 86 01                   FCB     $3F, OP_SWI3,  AM_INHERENT
2033 cb9b 83 2c 03                   FCB     $83, OP_CMPU,  AM_IMMEDIATE16
2034 cb9e 8c 2b 03                   FCB     $8C, OP_CMPS,  AM_IMMEDIATE16
2035 cba1 93 2c 04                   FCB     $93, OP_CMPU,  AM_DIRECT
2036 cba4 9c 2b 04                   FCB     $9C, OP_CMPS,  AM_DIRECT
2037 cba7 a3 2c 08                   FCB     $A3, OP_CMPU,  AM_INDEXED
2038 cbaa ac 2b 08                   FCB     $AC, OP_CMPS,  AM_INDEXED
2039 cbad b3 2c 05                   FCB     $B3, OP_CMPU,  AM_EXTENDED
2040 cbb0 bc 2b 05                   FCB     $BC, OP_CMPS,  AM_EXTENDED
2041 cbb3 00                         FCB     0                             ; indicates end of table
2042                         
2043                         ; Display strings. Should be terminated in EOT character.
2044                         
2045 cbb4 3b 20 49 4e 56 41  MSG1:   FCC     "; INVALID"
     4c 49 44
2046 cbbd 04                         FCB     EOT
2047                         
2048 cbbe 50 52 45 53 53 20  MSG2:   FCC     "PRESS <SPACE> TO CONTINUE, <Q> TO QUIT "
     3c 53 50 41 43 45
     3e 20 54 4f 20 43
     4f 4e 54 49 4e 55
     45 2c 20 3c 51 3e
     20 54 4f 20 51 55
     49 54 20
2049 cbe5 04                         FCB     EOT
2050                         
2051 cbe6 50 43 52           MSG3:   FCC     "PCR"
2052 cbe9 04                         FCB     EOT
2053                         
2054 cbea ff ff ff ff ff ff            FILL $FF, $D000-*   ; Fill ROM with FFs until $D000
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff
2055                         
2056                         ************************************************************************
2057                         
2058 a000                    UART      EQU  $A000
2059 a001                    RECEV     EQU  UART+1
2060 a001                    TRANS     EQU  UART+1
2061 a000                    USTAT     EQU  UART
2062 a000                    UCTRL     EQU  UART
2063                         
2064 0008                    BS        EQU  8              ; BACKSPACE
2065 000d                    CR        EQU  $D             ; ENTER KEY
2066 001b                    ESC       EQU  $1B            ; ESCAPE CODE
2067 0020                    SPACE     EQU  $20            ; SPACE (BLANK)
2068 003a                    STKBUF    EQU  58             ; STACK BUFFER ROOM
2069 00fa                    LBUFMX    EQU  250            ; MAX NUMBER OF CHARS IN A BASIC LINE
2070 00fa                    MAXLIN    EQU  $FA            ; MAXIMUM MS BYTE OF LINE NUMBER
2071                         * PSEUDO OPS
2072 0021                    SKP1      EQU  $21            ; OP CODE OF BRN - SKIP ONE BYTE
2073 008c                    SKP2      EQU  $8C            ; OP CODE OF CMPX # - SKIP TWO BYTES
2074 0086                    SKP1LD    EQU  $86            ; OP CODE OF LDA # - SKIP THE NEXT BYTE
2075                         *                             ; AND LOAD THE VALUE OF THAT BYTE INTO ACCA - THIS
2076                         *                             ; IS USUALLY USED TO LOAD ACCA WITH A NON ZERO VALUE
2077 0015                    RTS_LOW   EQU  $15            ; 6850 ACIA CONTROL REGISTER: RX INT DISABLED, RTS LOW, TX INT DISABLED, 8N1, CLK/16
2078 0000                              ORG  0
2079 0000                    ENDFLG    RMB  1              ; STOP/END FLAG: POSITIVE=STOP, NEG=END
2080 0001                    CHARAC    RMB  1              ; TERMINATOR FLAG 1
2081 0002                    ENDCHR    RMB  1              ; TERMINATOR FLAG 2
2082 0003                    TMPLOC    RMB  1              ; SCRATCH VARIABLE
2083 0004                    IFCTR     RMB  1              ; IF COUNTER - HOW MANY IF STATEMENTS IN A LINE
2084 0005                    DIMFLG    RMB  1              ; *DV* ARRAY FLAG 0=EVALUATE, 1=DIMENSIONING
2085 0006                    VALTYP    RMB  1              ; *DV* *PV TYPE FLAG: 0=NUMERIC, $FF=STRING
2086 0007                    GARBFL    RMB  1              ; *TV STRING SPACE HOUSEKEEPING FLAG
2087 0008                    ARYDIS    RMB  1              ; DISABLE ARRAY SEARCH: 00=ALLOW SEARCH
2088 0009                    INPFLG    RMB  1              ; *TV INPUT FLAG: READ=0, INPUT<>0
2089 000a                    RELFLG    RMB  1              ; *TV RELATIONAL OPERATOR FLAG
2090 000b                    TEMPPT    RMB  2              ; *PV TEMPORARY STRING STACK POINTER
2091 000d                    LASTPT    RMB  2              ; *PV ADDR OF LAST USED STRING STACK ADDRESS
2092 000f                    TEMPTR    RMB  2              ; TEMPORARY POINTER
2093 0011                    TMPTR1    RMB  2              ; TEMPORARY DESCRIPTOR STORAGE (STACK SEARCH)
2094 0013                    FPA2      RMB  4              ; FLOATING POINT ACCUMULATOR #2 MANTISSA
2095 0017                    BOTSTK    RMB  2              ; BOTTOM OF STACK AT LAST CHECK
2096 0019                    TXTTAB    RMB  2              ; *PV BEGINNING OF BASIC PROGRAM
2097 001b                    VARTAB    RMB  2              ; *PV START OF VARIABLES
2098 001d                    ARYTAB    RMB  2              ; *PV START OF ARRAYS
2099 001f                    ARYEND    RMB  2              ; *PV END OF ARRAYS (+1)
2100 0021                    FRETOP    RMB  2              ; *PV START OF STRING STORAGE (TOP OF FREE RAM)
2101 0023                    STRTAB    RMB  2              ; *PV START OF STRING VARIABLES
2102 0025                    FRESPC    RMB  2              ; UTILITY STRING POINTER
2103 0027                    MEMSIZ    RMB  2              ; *PV TOP OF STRING SPACE
2104 0029                    OLDTXT    RMB  2              ; SAVED LINE NUMBER DURING A "STOP"
2105 002b                    BINVAL    RMB  2              ; BINARY VALUE OF A CONVERTED LINE NUMBER
2106 002d                    OLDPTR    RMB  2              ; SAVED INPUT PTR DURING A "STOP"
2107 002f                    TINPTR    RMB  2              ; TEMPORARY INPUT POINTER STORAGE
2108 0031                    DATTXT    RMB  2              ; *PV 'DATA' STATEMENT LINE NUMBER POINTER
2109 0033                    DATPTR    RMB  2              ; *PV 'DATA' STATEMENT ADDRESS POINTER
2110 0035                    DATTMP    RMB  2              ; DATA POINTER FOR 'INPUT' & 'READ'
2111 0037                    VARNAM    RMB  2              ; *TV TEMP STORAGE FOR A VARIABLE NAME
2112 0039                    VARPTR    RMB  2              ; *TV POINTER TO A VARIABLE DESCRIPTOR
2113 003b                    VARDES    RMB  2              ; TEMP POINTER TO A VARIABLE DESCRIPTOR
2114 003d                    RELPTR    RMB  2              ; POINTER TO RELATIONAL OPERATOR PROCESSING ROUTINE
2115 003f                    TRELFL    RMB  1              ; TEMPORARY RELATIONAL OPERATOR FLAG BYTE
2116                         * FLOATING POINT ACCUMULATORS #3,4 & 5 ARE MOSTLY
2117                         * USED AS SCRATCH PAD VARIABLES.
2118                         ** FLOATING POINT ACCUMULATOR #3 :PACKED: ($40-$44)
2119 0040                    V40       RMB  1
2120 0041                    V41       RMB  1
2121 0042                    V42       RMB  1
2122 0043                    V43       RMB  1
2123 0044                    V44       RMB  1
2124                         ** FLOATING POINT ACCUMULATOR #4 :PACKED: ($45-$49)
2125 0045                    V45       RMB  1
2126 0046                    V46       RMB  1
2127 0047                    V47       RMB  1
2128 0048                    V48       RMB  2
2129                         ** FLOATING POINT ACCUMULATOR #5 :PACKED: ($4A-$4E)
2130 004a                    V4A       RMB  1
2131 004b                    V4B       RMB  2
2132 004d                    V4D       RMB  2
2133                         ** FLOATING POINT ACCUMULATOR #0
2134 004f                    FP0EXP    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #0 EXPONENT
2135 0050                    FPA0      RMB  4              ; *PV FLOATING POINT ACCUMULATOR #0 MANTISSA
2136 0054                    FP0SGN    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #0 SIGN
2137 0055                    COEFCT    RMB  1              ; POLYNOMIAL COEFFICIENT COUNTER
2138 0056                    STRDES    RMB  5              ; TEMPORARY STRING DESCRIPTOR
2139 005b                    FPCARY    RMB  1              ; FLOATING POINT CARRY BYTE
2140                         ** FLOATING POINT ACCUMULATOR #1
2141 005c                    FP1EXP    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #1 EXPONENT
2142 005d                    FPA1      RMB  4              ; *PV FLOATING POINT ACCUMULATOR #1 MANTISSA
2143 0061                    FP1SGN    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #1 SIGN
2144 0062                    RESSGN    RMB  1              ; SIGN OF RESULT OF FLOATING POINT OPERATION
2145 0063                    FPSBYT    RMB  1              ; FLOATING POINT SUB BYTE (FIFTH BYTE)
2146 0064                    COEFPT    RMB  2              ; POLYNOMIAL COEFFICIENT POINTER
2147 0066                    LSTTXT    RMB  2              ; CURRENT LINE POINTER DURING LIST
2148 0068                    CURLIN    RMB  2              ; *PV CURRENT LINE # OF BASIC PROGRAM, $FFFF = DIRECT
2149 006a                    DEVCFW    RMB  1              ; *TV TAB FIELD WIDTH
2150 006b                    DEVLCF    RMB  1              ; *TV TAB ZONE
2151 006c                    DEVPOS    RMB  1              ; *TV PRINT POSITION
2152 006d                    DEVWID    RMB  1              ; *TV PRINT WIDTH
2153 006e                    RSTFLG    RMB  1              ; *PV WARM START FLAG: $55=WARM, OTHER=COLD
2154 006f                    RSTVEC    RMB  2              ; *PV WARM START VECTOR - JUMP ADDRESS FOR WARM START
2155 0071                    TOPRAM    RMB  2              ; *PV TOP OF RAM
2156 0073                    IKEYIM    RMB  1              ; *TV INKEY$ RAM IMAGE
2157 0074                    ZERO      RMB  2              ; *PV DUMMY - THESE TWO BYTES ARE ALWAYS ZERO
2158                         * THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM
2159 0076                    LPTCFW    RMB  1              ; 16
2160 0077                    LPTLCF    RMB  1              ; 112
2161 0078                    LPTWID    RMB  1              ; 132
2162 0079                    LPTPOS    RMB  1              ; 0
2163 007a                    EXECJP    RMB  2              ; LB4AA
2164                         
2165                         * THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM
2166                         * BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE
2167                         * INTERPRETED IS STORED AT CHARAD.
2168 007c 0c 84              GETNCH    INC  <CHARAD+1      ; *PV INCREMENT LS BYTE OF INPUT POINTER
2169 007e 26 02                        BNE  GETCCH         ; *PV BRANCH IF NOT ZERO (NO CARRY)
2170 0080 0c 83                        INC  <CHARAD        ; *PV INCREMENT MS BYTE OF INPUT POINTER
2171 0082 b6                 GETCCH    FCB  $B6            ; *PV OP CODE OF LDA EXTENDED
2172 0083                    CHARAD    RMB  2              ; *PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT
2173                         *         *    CHARACTER WHICH THE BASIC INTERPRETER IS
2174                         *         *    PROCESSING
2175 0085 7e d1 c2                     JMP  BROMHK         ; JUMP BACK INTO THE BASIC RUM
2176                         
2177 0088                    VAB       RMB  1              ; = LOW ORDER FOUR BYTES OF THE PRODUCT
2178 0089                    VAC       RMB  1              ; = OF A FLOATING POINT MULTIPLICATION
2179 008a                    VAD       RMB  1              ; = THESE BYTES ARE USE AS RANDOM DATA
2180 008b                    VAE       RMB  1              ; = BY THE RND STATEMENT
2181                         
2182                         * EXTENDED BASIC VARIABLES
2183 008c                    TRCFLG    RMB  1              ; *PV TRACE FLAG 0=OFF ELSE=ON
2184 008d                    USRADR    RMB  2              ; *PV ADDRESS OF THE START OF USR VECTORS
2185                         
2186                         * EXTENDED BASIC SCRATCH PAD VARIABLES
2187 008f                    VCF       RMB  2
2188 0091                    VD1       RMB  2
2189 0093                    VD3       RMB  2
2190 0095                    VD5       RMB  2
2191 0097                    VD7       RMB  1
2192 0098                    VD8       RMB  1
2193 0099                    VD9       RMB  1
2194 009a                    VDA       RMB  1
2195 009b                    SW3VEC    RMB  3
2196 009e                    SW2VEC    RMB  3
2197 00a1                    SWIVEC    RMB  3
2198 00a4                    NMIVEC    RMB  3
2199 00a7                    IRQVEC    RMB  3
2200 00aa                    FRQVEC    RMB  3
2201 00ad                    USRJMP    RMB  3              ; JUMP ADDRESS FOR BASIC'S USR FUNCTION
2202 00b0                    RVSEED    RMB  1              ; * FLOATING POINT RANDOM NUMBER SEED EXPONENT
2203 00b1                              RMB  4              ; * MANTISSA: INITIALLY SET TO $804FC75259
2204                         
2205                         **** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)
2206 00b5                    USR0      RMB  2              ; USR 0 VECTOR
2207 00b7                              RMB  2              ; USR 1
2208 00b9                              RMB  2              ; USR 2
2209 00bb                              RMB  2              ; USR 3
2210 00bd                              RMB  2              ; USR 4
2211 00bf                              RMB  2              ; USR 5
2212 00c1                              RMB  2              ; USR 6
2213 00c3                              RMB  2              ; USR 7
2214 00c5                              RMB  2              ; USR 8
2215 00c7                              RMB  2              ; USR 9
2216                         
2217 00c9                    STRSTK    RMB  8*5            ; STRING DESCRIPTOR STACK
2218 00f1                    LINHDR    RMB  2              ; LINE INPUT BUFFER HEADER
2219 00f3                    LINBUF    RMB  LBUFMX+1       ; BASIC LINE INPUT BUFFER
2220 01ee                    STRBUF    RMB  41             ; STRING BUFFER
2221                         
2222 0217                    PROGST    RMB  1              ; START OF PROGRAM SPACE
2223                         *         INTERRUPT VECTORS
2224                         *          ORG  $FFF2
2225                         *SWI3      RMB  2
2226                         *SWI2      RMB  2
2227                         *FIRQ      RMB  2
2228                         *IRQ       RMB  2
2229                         *SWI       RMB  2
2230                         *NMI       RMB  2
2231                         *RESETV    RMB  2
2232                         
2233 d000                              ORG  $D000
2234                         
2235                         * JUMP TO BASIC COLD START AT START OF ROM FOR CONVENIENCE
2236 d000 7e d0 49                     JMP   RESVEC
2237                         
2238                         * CONSOLE IN
2239 d003 8d 03              LA171     BSR  KEYIN          ; GET A CHARACTER FROM CONSOLE IN
2240 d005 27 fc                        BEQ  LA171          ; LOOP IF NO KEY DOWN
2241 d007 39                           RTS
2242                         
2243                         *
2244                         * THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A KEY
2245                         * IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DOWN.
2246                         *
2247                         *
2248                         LA1C1
2249 d008 b6 a0 00           KEYIN     LDA  USTAT
2250 d00b 85 01                        BITA #1
2251 d00d 27 06                        BEQ  NOCHAR
2252 d00f b6 a0 01                     LDA  RECEV
2253 d012 84 7f                        ANDA #$7F
2254 d014 39                           RTS
2255 d015 4f                 NOCHAR    CLRA
2256 d016 39                           RTS
2257                         
2258                         
2259                         
2260                         * CONSOLE OUT
2261 d017 8d 24              PUTCHR    BSR  WAITACIA
2262 d019 34 02                        PSHS A              ;
2263 d01b 81 0d                        CMPA #CR            ; IS IT CARRIAGE RETURN?
2264 d01d 27 0b                        BEQ  NEWLINE        ; YES
2265 d01f b7 a0 01                     STA  TRANS
2266 d022 0c 79                        INC  LPTPOS         ; INCREMENT CHARACTER COUNTER
2267 d024 96 79                        LDA  LPTPOS         ; CHECK FOR END OF LINE PRINTER LINE
2268 d026 91 78                        CMPA LPTWID         ; AT END OF LINE PRINTER LINE?
2269 d028 25 10                        BLO  PUTEND         ; NO
2270 d02a 0f 79              NEWLINE   CLR  LPTPOS         ; RESET CHARACTER COUNTER
2271 d02c 8d 0f                        BSR  WAITACIA
2272 d02e 86 0d                        LDA  #13
2273 d030 b7 a0 01                     STA  TRANS
2274 d033 8d 08                        BSR  WAITACIA
2275 d035 86 0a                        LDA  #10            ; DO LINEFEED AFTER CR
2276 d037 b7 a0 01                     STA  TRANS
2277 d03a 35 02              PUTEND    PULS A              ;
2278 d03c 39                           RTS
2279                         
2280 d03d 34 02              WAITACIA  PSHS A
2281 d03f b6 a0 00           WRWAIT    LDA  USTAT
2282 d042 85 02                        BITA #2
2283 d044 27 f9                        BEQ  WRWAIT
2284 d046 35 02                        PULS A              ;
2285 d048 39                           RTS
2286                         
2287                         *
2288                         RESVEC
2289 d049 10 ce 01 ee        LA00E     LDS  #LINBUF+LBUFMX+1 ; SET STACK TO TOP OF LINE INPUT BUFFER
2290 d04d 96 6e                        LDA  RSTFLG         ; GET WARM START FLAG
2291 d04f 81 55                        CMPA #$55           ; IS IT A WARM START?
2292 d051 26 0a                        BNE  BACDST         ; NO - D0 A COLD START
2293 d053 9e 6f                        LDX  RSTVEC         ; WARM START VECTOR
2294 d055 a6 84                        LDA  ,X             ; GET FIRST BYTE OF WARM START ADDR
2295 d057 81 12                        CMPA #$12           ; IS IT NOP?
2296 d059 26 02                        BNE  BACDST         ; NO - DO A COLD START
2297 d05b 6e 84                        JMP  ,X             ; YES, G0 THERE
2298                         
2299                         * COLD START ENTRY
2300                         
2301 d05d 8e 02 18           BACDST    LDX  #PROGST+1      ; POINT X TO CLEAR 1ST 1K OF RAM
2302 d060 6f 83              LA077     CLR  ,--X           ; MOVE POINTER DOWN TWO-CLEAR BYTE
2303 d062 30 01                        LEAX 1,X            ; ADVANCE POINTER ONE
2304 d064 26 fa                        BNE  LA077          ; KEEP GOING IF NOT AT BOTTOM OF PAGE 0
2305 d066 8e 02 17                     LDX  #PROGST        ; SET TO START OF PROGRAM SPACE
2306 d069 6f 80                        CLR  ,X+            ; CLEAR 1ST BYTE OF BASIC PROGRAM
2307 d06b 9f 19                        STX  TXTTAB         ; BEGINNING OF BASIC PROGRAM
2308 d06d a6 02              LA084     LDA  2,X            ; LOOK FOR END OF MEMORY
2309 d06f 43                           COMA                ; * COMPLEMENT IT AND PUT IT BACK
2310 d070 a7 02                        STA  2,X            ; * INTO SYSTEM MEMORY
2311 d072 a1 02                        CMPA 2,X            ; IS IT RAM?
2312 d074 26 06                        BNE  LA093          ; BRANCH IF NOT (ROM, BAD RAM OR NO RAM)
2313 d076 30 01                        LEAX 1,X            ; MOVE POINTER UP ONE
2314 d078 63 01                        COM  1,X            ; RE-COMPLEMENT TO RESTORE BYTE
2315 d07a 20 f1                        BRA  LA084          ; KEEP LOOKING FOR END OF RAM
2316 d07c 9f 71              LA093     STX  TOPRAM         ; SAVE ABSOLUTE TOP OF RAM
2317 d07e 9f 27                        STX  MEMSIZ         ; SAVE TOP OF STRING SPACE
2318 d080 9f 23                        STX  STRTAB         ; SAVE START OF STRING VARIABLES
2319 d082 30 89 ff 38                  LEAX -200,X         ; CLEAR 200 - DEFAULT STRING SPACE TO 200 BYTES
2320 d086 9f 21                        STX  FRETOP         ; SAVE START OF STRING SPACE
2321 d088 1f 14                        TFR  X,S            ; PUT STACK THERE
2322 d08a 8e d0 d1                     LDX  #LA10D         ; POINT X TO ROM SOURCE DATA
2323 d08d ce 00 76                     LDU  #LPTCFW        ; POINT U TO RAM DESTINATION
2324 d090 c6 12                        LDB  #18            ; MOVE 18 BYTES
2325 d092 bd d1 b1                     JSR  LA59A          ; MOVE 18 BYTES FROM ROM TO RAM
2326 d095 ce 00 a7                     LDU  #IRQVEC        ; POINT U TO NEXT RAM DESTINATION
2327 d098 c6 04                        LDB  #4             ; MOVE 4 MORE BYTES
2328 d09a bd d1 b1                     JSR  LA59A          ; MOVE 4 BYTES FROM ROM TO RAM
2329 d09d 86 39                        LDA  #$39
2330 d09f 97 f0                        STA  LINHDR-1       ; PUT RTS IN LINHDR-1
2331 d0a1 bd d4 bd                     JSR  LAD19          ; G0 DO A 'NEW'
2332                         * EXTENDED BASIC INITIALISATION
2333 d0a4 8e 00 b5                     LDX  #USR0          ; INITIALIZE ADDRESS OF START OF
2334 d0a7 9f 8d                        STX  USRADR         ; USR JUMP TABLE
2335                         * INITIALIZE THE USR CALLS TO 'FC ERROR'
2336 d0a9 ce db d1                     LDU  #LB44A         ; ADDRESS OF 'FC ERROR' ROUTINE
2337 d0ac c6 0a                        LDB  #10            ; 10 USR CALLS IN EX BASIC
2338 d0ae ef 81              L8031     STU  ,X++           ; STORE 'FC' ERROR AT USR ADDRESSES
2339 d0b0 5a                           DECB                ; FINISHED ALL 10?
2340 d0b1 26 fb                        BNE  L8031          ; NO
2341                         
2342                         * INITIALISE ACIA
2343 d0b3 86 15                        LDA  #RTS_LOW       ; DIV16 CLOCK -> 7372800 / 4 / 16 = 115200
2344 d0b5 b7 a0 00                     STA  UCTRL
2345 d0b8 8e d1 06                     LDX  #LA147-1       ; POINT X TO COLOR BASIC COPYRIGHT MESSAGE
2346 d0bb bd e0 e8                     JSR  LB99C          ; PRINT 'COLOR BASIC'
2347 d0be 8e d0 c9                     LDX  #BAWMST        ; WARM START ADDRESS
2348 d0c1 9f 6f                        STX  RSTVEC         ; SAVE IT
2349 d0c3 86 55                        LDA  #$55           ; WARM START FLAG
2350 d0c5 97 6e                        STA  RSTFLG         ; SAVE IT
2351 d0c7 20 04                        BRA  LA0F3          ; GO TO BASIC'S MAIN LOOP
2352 d0c9 12                 BAWMST    NOP                 ; NOP REQ'D FOR WARM START
2353 d0ca bd d4 d7                     JSR  LAD33          ; DO PART OF A NEW
2354 d0cd 7e d4 25           LA0F3     JMP  LAC73          ; GO TO MAIN LOOP OF BASIC
2355                         *
2356                         * FIRQ SERVICE ROUTINE
2357                         BFRQSV
2358 d0d0 3b                           RTI
2359                         *
2360                         * THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIRECT PAGE
2361 d0d1 10                 LA10D     FCB  16             ; TAB FIELD WIDTH
2362 d0d2 40                           FCB  64             ; LAST TAB ZONE
2363 d0d3 50                           FCB  80             ; PRINTER WIDTH
2364 d0d4 00                           FCB  0              ; LINE PRINTER POSITION
2365 d0d5 db d1                        FDB  LB44A          ; ARGUMENT OF EXEC COMMAND - SET TO 'FC' ERROR
2366                         * LINE INPUT ROUTINE
2367 d0d7 0c 84                        INC  CHARAD+1
2368 d0d9 26 02                        BNE  LA123
2369 d0db 0c 83                        INC  CHARAD
2370 d0dd b6 00 00           LA123     LDA  >0000
2371 d0e0 7e d1 c2                     JMP  BROMHK
2372                         *
2373                         * THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1
2374 d0e3 7e d1 c1                     JMP  BIRQSV         ; IRQ SERVICE
2375 d0e6 7e d0 d0                     JMP  BFRQSV         ; FIRQ SERVICE
2376 d0e9 7e db d1                     JMP  LB44A          ; USR ADDRESS FOR 8K BASIC (INITIALIZED TO 'FC' ERROR)
2377 d0ec 80                           FCB  $80            ; *RANDOM SEED
2378 d0ed 4f c7                        FDB  $4FC7          ; *RANDON SEED OF MANTISSA
2379 d0ef 52 59                        FDB  $5259          ; *.811635157
2380                         * BASIC COMMAND INTERPRETATION TABLE ROM IMAGE
2381 d0f1 32                 COMVEC    FCB  50             ; 50 BASIC COMMANDS
2382 d0f2 d2 20                        FDB  LAA66          ; POINTS TO RESERVED WORDS
2383 d0f4 d3 2d                        FDB  LAB67          ; POINTS TO JUMP TABLE FOR COMMANDS
2384 d0f6 1d                           FCB  29             ; 29 BASIC SECONDARY COMMANDS
2385 d0f7 d2 c0                        FDB  LAB1A          ; POINTS TO SECONDARY FUNCTION RESERVED WORDS
2386 d0f9 d1 d1                        FDB  LAA29          ; POINTS TO SECONDARY FUNCTION JUMP TABLE
2387 d0fb 00 00                        FDB  0              ; NO MORE TABLES (RES WORDS=0)
2388 d0fd 00 00                        FDB  0              ; NO MORE TABLES
2389 d0ff 00 00                        FDB  0              ; NO MORE TABLES
2390 d101 00 00                        FDB  0              ; NO MORE TABLES
2391 d103 00 00                        FDB  0              ; NO MORE TABLES
2392 d105 00 00                        FDB  0              ; NO MORE TABLES (SECONDARY FNS =0)
2393                         
2394                         * COPYRIGHT MESSAGES
2395 d107 36 38 30 39 20 45  LA147     FCC  "6809 EXTENDED BASIC"
     58 54 45 4e 44 45
     44 20 42 41 53 49
     43
2396 d11a 0d                           FCB  CR
2397 d11b 28 43 29 20 31 39            FCC  "(C) 1982 BY MICROSOFT"
     38 32 20 42 59 20
     4d 49 43 52 4f 53
     4f 46 54
2398 d130 0d 0d              LA156     FCB  CR,CR
2399 d132 00                 LA165     FCB  $00
2400                         
2401                         
2402 d133 34 16              LA35F     PSHS X,B,A          ; SAVE REGISTERS
2403 d135 9e 76                        LDX  LPTCFW         ; TAB FIELD WIDTH AND TAB ZONE
2404 d137 dc 78                        LDD  LPTWID         ; PRINTER WIDTH AND POSITION
2405 d139 9f 6a              LA37C     STX  DEVCFW         ; SAVE TAB FIELD WIDTH AND ZONE
2406 d13b d7 6c                        STB  DEVPOS         ; SAVE PRINT POSITION
2407 d13d 97 6d                        STA  DEVWID         ; SAVE PRINT WIDTH
2408 d13f 35 96                        PULS A,B,X,PC       ; RESTORE REGISTERS
2409                         
2410                         * THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASIC
2411                         * EXIT WITH BREAK KEY: CARRY = 1
2412                         * EXIT WITH ENTER KEY: CARRY = 0
2413                         LA38D
2414 d141 0f 73              LA390     CLR  IKEYIM         ; RESET BREAK CHECK KEY TEMP KEY STORAGE
2415 d143 8e 00 f4                     LDX  #LINBUF+1      ; INPUT LINE BUFFER
2416 d146 c6 01                        LDB  #1             ; ACCB CHAR COUNTER: SET TO 1 TO ALLOW A
2417                         *         BACKSPACE AS FIRST CHARACTER
2418 d148 bd d0 03           LA39A     JSR  LA171          ; GO GET A CHARACTER FROM CONSOLE IN
2419 d14b 81 08                        CMPA #BS            ; BACKSPACE
2420 d14d 26 07                        BNE  LA3B4          ; NO
2421 d14f 5a                           DECB                ; YES - DECREMENT CHAR COUNTER
2422 d150 27 ef                        BEQ  LA390          ; BRANCH IF BACK AT START OF LINE AGAIN
2423 d152 30 1f                        LEAX -1,X           ; DECREMENT BUFFER POINTER
2424 d154 20 34                        BRA  LA3E8          ; ECHO CHAR TO SCREEN
2425 d156 81 15              LA3B4     CMPA #$15           ; SHIFT RIGHT ARROW?
2426 d158 26 0a                        BNE  LA3C2          ; NO
2427                         * YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LINE
2428 d15a 5a                 LA3B8     DECB                ; DEC CHAR CTR
2429 d15b 27 e4                        BEQ  LA390          ; GO BACK TO START IF CHAR CTR = 0
2430 d15d 86 08                        LDA  #BS            ; BACKSPACE?
2431 d15f bd d0 17                     JSR  PUTCHR         ; SEND TO CONSOLE OUT (SCREEN)
2432 d162 20 f6                        BRA  LA3B8          ; KEEP GOING
2433 d164 81 03              LA3C2     CMPA #3             ; BREAK KEY?
2434 d166 1a 01                        ORCC #1             ; SET CARRY FLAG
2435 d168 27 05                        BEQ  LA3CD          ; BRANCH IF BREAK KEY DOWN
2436 d16a 81 0d              LA3C8     CMPA #CR            ; ENTER KEY?
2437 d16c 26 0d                        BNE  LA3D9          ; NO
2438 d16e 4f                 LA3CC     CLRA                ; CLEAR CARRY FLAG IF ENTER KEY - END LINE ENTRY
2439 d16f 34 01              LA3CD     PSHS CC             ; SAVE CARRY FLAG
2440 d171 bd e0 a8                     JSR  LB958          ; SEND CR TO SCREEN
2441 d174 6f 84                        CLR  ,X             ; MAKE LAST BYTE IN INPUT BUFFER = 0
2442 d176 8e 00 f3                     LDX  #LINBUF        ; RESET INPUT BUFFER POINTER
2443 d179 35 81                        PULS CC,PC          ; RESTORE CARRY FLAG
2444                         
2445                         * INSERT A CHARACTER INTO THE BASIC LINE INPUT BUFFER
2446 d17b 81 20              LA3D9     CMPA #$20           ; IS IT CONTROL CHAR?
2447 d17d 25 c9                        BLO  LA39A          ; BRANCH IF CONTROL CHARACTER
2448 d17f 81 7b                        CMPA #'z+1          ; *
2449 d181 24 c5                        BCC  LA39A          ; * IGNORE IF > LOWER CASE Z
2450 d183 c1 fa                        CMPB #LBUFMX        ; HAVE 250 OR MORE CHARACTERS BEEN ENTERED?
2451 d185 24 c1                        BCC  LA39A          ; YES, IGNORE ANY MORE
2452 d187 a7 80                        STA  ,X+            ; PUT IT IN INPUT BUFFER
2453 d189 5c                           INCB                ; INCREMENT CHARACTER COUNTER
2454 d18a bd d0 17           LA3E8     JSR  PUTCHR         ; ECHO IT TO SCREEN
2455 d18d 20 b9                        BRA  LA39A          ; GO SET SOME MORE
2456                         
2457                         
2458                         * EXEC
2459 d18f 27 05              EXEC      BEQ  LA545          ; BRANCH IF NO ARGUMENT
2460 d191 bd de c4                     JSR  LB73D          ; EVALUATE ARGUMENT - ARGUMENT RETURNED IN X
2461 d194 9f 7a                        STX  EXECJP         ; STORE X TO EXEC JUMP ADDRESS
2462 d196 6e 9f 00 7a        LA545     JMP  [EXECJP]       ; GO DO IT
2463                         
2464                         * BREAK CHECK
2465 d19a 7e d5 a6           LA549     JMP  LADEB          ; GO DO BREAK KEY CHECK
2466                         
2467                         * INKEY$
2468 d19d 96 73              INKEY     LDA  IKEYIM         ; WAS A KEY DOWN IN THE BREAK CHECK?
2469 d19f 26 03                        BNE  LA56B          ; YES
2470 d1a1 bd d0 08                     JSR  KEYIN          ; GO GET A KEY
2471 d1a4 0f 73              LA56B     CLR  IKEYIM         ; CLEAR INKEY RAM IMAGE
2472 d1a6 97 53                        STA  FPA0+3         ; STORE THE KEY IN FPA0
2473 d1a8 10 26 0c 6a                  LBNE LB68F          ; CONVERT FPA0+3 TO A STRING
2474 d1ac 97 56                        STA  STRDES         ; SET LENGTH OF STRING = 0 IF NO KEY DOWN
2475 d1ae 7e de 22                     JMP  LB69B          ; PUT A NULL STRING ONTO THE STRING STACK
2476                         
2477                         * MOVE ACCB BYTES FROM (X) TO (U)
2478 d1b1 a6 80              LA59A     LDA  ,X+            ; GET BYTE FROM X
2479 d1b3 a7 c0                        STA  ,U+            ; STORE IT AT U
2480 d1b5 5a                           DECB                ; MOVED ALL BYTES?
2481 d1b6 26 f9                        BNE  LA59A          ; NO
2482 d1b8 39                 LA5A1     RTS
2483                         
2484 d1b9 39                 LA5C4     RTS
2485                         
2486                         ** THIS ROUTINE WILL SCAN OFF THE FILE NAME FROM A BASIC LINE
2487                         ** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTERS
2488                         ** FOLLOWING THE END OF THE NAME
2489 d1ba 9d 82              LA5C7     JSR  GETCCH         ; GET CURRENT INPUT CHAR FROM BASIC LINE
2490 d1bc 27 fb              LA5C9     BEQ  LA5C4          ; RETURN IF END OF LINE
2491 d1be 7e da 03                     JMP  LB277          ; SYNTAX ERROR IF ANY MORE CHARACTERS
2492                         * IRQ SERVICE
2493                         BIRQSV
2494 d1c1 3b                 LA9C5     RTI                 ; RETURN FROM INTERRUPT
2495                         
2496                         * SET CARRY IF NUMERIC - RETURN WITH
2497                         * ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END
2498                         * OF BASIC LINE OR SUB LINE
2499 d1c2 81 3a              BROMHK    CMPA #'9+1          ; IS THIS CHARACTER >=(ASCII 9)+1?
2500 d1c4 24 0a                        BHS  LAA28          ; BRANCH IF > 9; Z SET IF = COLON
2501 d1c6 81 20                        CMPA #SPACE         ; SPACE?
2502 d1c8 26 02                        BNE  LAA24          ; NO - SET CARRY IF NUMERIC
2503 d1ca 0e 7c                        JMP  GETNCH         ; IF SPACE, GET NECT CHAR (IGNORE SPACES)
2504 d1cc 80 30              LAA24     SUBA #'0            ; * SET CARRY IF
2505 d1ce 80 d0                        SUBA #-'0           ; * CHARACTER > ASCII 0
2506 d1d0 39                 LAA28     RTS
2507                         
2508                         * DISPATCH TABLE FOR SECONDARY FUNCTIONS
2509                         * TOKENS ARE PRECEEDED BY $FF
2510                         * FIRST SET ALWAYS HAS ONE PARAMETER
2511                         FUNC_TAB
2512 d1d1 e3 c6              LAA29     FDB  SGN            ; SGN
2513 d1d3 e4 3a                        FDB  INT            ; INT
2514 d1d5 e3 df                        FDB  ABS            ; ABS
2515 d1d7 00 ad                        FDB  USRJMP         ; USR
2516 0083                    TOK_USR   EQU  *-FUNC_TAB/2+$7F
2517 ff83                    TOK_FF_USR EQU  *-FUNC_TAB/2+$FF7F
2518 d1d9 e6 6b                        FDB  RND            ; RND
2519 d1db e6 c0                        FDB  SIN            ; SIN
2520 d1dd de d7                        FDB  PEEK           ; PEEK
2521 d1df de 08                        FDB  LEN            ; LEN
2522 d1e1 dc 84                        FDB  STR            ; STR$
2523 d1e3 de 9d                        FDB  VAL            ; VAL
2524 d1e5 de 27                        FDB  ASC            ; ASC
2525 d1e7 de 13                        FDB  CHR            ; CHR$
2526 d1e9 e7 70                        FDB  ATN            ; ATN
2527 d1eb e7 38                        FDB  COS            ; COS
2528 d1ed e7 41                        FDB  TAN            ; TAN
2529 d1ef e8 b2                        FDB  EXP            ; EXP
2530 d1f1 e8 e4                        FDB  FIX            ; FIX
2531 d1f3 e8 06                        FDB  LOG            ; LOG
2532 d1f5 ea 6c                        FDB  POS            ; POS
2533 d1f7 e8 40                        FDB  SQR            ; SQR
2534 d1f9 ef 3e                        FDB  HEXDOL         ; HEX$
2535                         * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
2536 d1fb de 32                        FDB  LEFT           ; LEFT$
2537 0095                    TOK_LEFT  EQU  *-FUNC_TAB/2+$7F
2538 d1fd de 4f                        FDB  RIGHT          ; RIGHT$
2539 d1ff de 56                        FDB  MID            ; MID$
2540 0097                    TOK_MID   EQU  *-FUNC_TAB/2+$7F
2541                         * REMAINING FUNCTIONS
2542 d201 d1 9d                        FDB  INKEY          ; INKEY$
2543 0098                    TOK_INKEY EQU  *-FUNC_TAB/2+$7F
2544 d203 dc 75                        FDB  MEM            ; MEM
2545 d205 ea 74                        FDB  VARPT          ; VARPTR
2546 d207 eb 34                        FDB  INSTR          ; INSTR
2547 d209 eb 04                        FDB  STRING         ; STRING$
2548 001d                    NUM_SEC_FNS EQU  *-FUNC_TAB/2
2549                         
2550                         * THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESSES FOR ARITHMETIC
2551                         * AND LOGICAL OPERATORS - THE NEGATION OPERATORS DO NOT ACT ON TWO OPERANDS
2552                         * S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREATED SEPARATELY IN THE
2553                         * EXPRESSION EVALUATION ROUTINE. THEY ARE:
2554                         * UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGATION (NOT), PRECEDENCE $5A
2555                         * THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, PRECEDENCE $64.
2556                         * A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSION OR PARENTHESES
2557                         *
2558 d20b 79                 LAA51     FCB  $79
2559 d20c e1 11                        FDB  LB9C5          ; +
2560 d20e 79                           FCB  $79
2561 d20f e1 08                        FDB  LB9BC          ; -
2562 d211 7b                           FCB  $7B
2563 d212 e2 18                        FDB  LBACC          ; *
2564 d214 7b                           FCB  $7B
2565 d215 e2 dd                        FDB  LBB91          ; /
2566 d217 7f                           FCB  $7F
2567 d218 e8 49                        FDB  L8489          ; EXPONENTIATION
2568 d21a 50                           FCB  $50
2569 d21b da 5c                        FDB  LB2D5          ; AND
2570 d21d 46                           FCB  $46
2571 d21e da 5b                        FDB  LB2D4          ; OR
2572                         
2573                         * THIS IS THE RESERVED WORD TABLE
2574                         * FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS
2575 d220 46 4f              LAA66     FCC  "FO"           ; 80
2576 d222 d2                           FCB  $80+'R
2577 d223 47                           FCC  "G"            ; 81
2578 d224 cf                           FCB  $80+'O
2579 0081                    TOK_GO    EQU  $81
2580 d225 52 45                        FCC  "RE"           ; 82
2581 d227 cd                           FCB  $80+'M
2582 d228 a7                           FCB  ''+$80         ; 83
2583 d229 45 4c 53                     FCC  "ELS"          ; 84
2584 d22c c5                           FCB  $80+'E
2585 d22d 49                           FCC  "I"            ; 85
2586 d22e c6                           FCB  $80+'F
2587 d22f 44 41 54                     FCC  "DAT"          ; 86
2588 d232 c1                           FCB  $80+'A
2589 d233 50 52 49 4e                  FCC  "PRIN"         ; 87
2590 d237 d4                           FCB  $80+'T
2591 d238 4f                           FCC  "O"            ; 88
2592 d239 ce                           FCB  $80+'N
2593 d23a 49 4e 50 55                  FCC  "INPU"         ; 89
2594 d23e d4                           FCB  $80+'T
2595 d23f 45 4e                        FCC  "EN"           ; 8A
2596 d241 c4                           FCB  $80+'D
2597 d242 4e 45 58                     FCC  "NEX"          ; 8B
2598 d245 d4                           FCB  $80+'T
2599 d246 44 49                        FCC  "DI"           ; 8C
2600 d248 cd                           FCB  $80+'M
2601 d249 52 45 41                     FCC  "REA"          ; 8D
2602 d24c c4                           FCB  $80+'D
2603 d24d 52 55                        FCC  "RU"           ; 8E
2604 d24f ce                           FCB  $80+'N
2605 d250 52 45 53 54 4f 52            FCC  "RESTOR"       ; 8F
2606 d256 c5                           FCB  $80+'E
2607 d257 52 45 54 55 52               FCC  "RETUR"        ; 90
2608 d25c ce                           FCB  $80+'N
2609 d25d 53 54 4f                     FCC  "STO"          ; 91
2610 d260 d0                           FCB  $80+'P
2611 d261 50 4f 4b                     FCC  "POK"          ; 92
2612 d264 c5                           FCB  $80+'E
2613 d265 43 4f 4e                     FCC  "CON"          ; 93
2614 d268 d4                           FCB  $80+'T
2615 d269 4c 49 53                     FCC  "LIS"          ; 94
2616 d26c d4                           FCB  $80+'T
2617 d26d 43 4c 45 41                  FCC  "CLEA"         ; 95
2618 d271 d2                           FCB  $80+'R
2619 d272 4e 45                        FCC  "NE"           ; 96
2620 d274 d7                           FCB  $80+'W
2621 d275 45 58 45                     FCC  "EXE"          ; 97
2622 d278 c3                           FCB  $80+'C
2623 d279 54 52 4f                     FCC  "TRO"          ; 98
2624 d27c ce                           FCB  $80+'N
2625 d27d 54 52 4f 46                  FCC  "TROF"         ; 99
2626 d281 c6                           FCB  $80+'F
2627 d282 44 45                        FCC  "DE"           ; 9A
2628 d284 cc                           FCB  $80+'L
2629 d285 44 45                        FCC  "DE"           ; 9B
2630 d287 c6                           FCB  $80+'F
2631 d288 4c 49 4e                     FCC  "LIN"          ; 9C
2632 d28b c5                           FCB  $80+'E
2633 d28c 52 45 4e 55                  FCC  "RENU"         ; 9D
2634 d290 cd                           FCB  $80+'M
2635 d291 45 44 49                     FCC  "EDI"          ; 9E
2636 d294 d4                           FCB  $80+'T
2637                         * END OF EXECUTABLE COMMANDS. THE REMAINDER OF THE TABLE ARE NON-EXECUTABLE TOKENS
2638 d295 54 41 42                     FCC  "TAB"          ; 9F
2639 d298 a8                           FCB  $80+'(
2640 009f                    TOK_TAB   EQU  $9F
2641 d299 54                           FCC  "T"            ; A0
2642 d29a cf                           FCB  $80+'O
2643 00a0                    TOK_TO    EQU  $A0
2644 d29b 53 55                        FCC  "SU"           ; A1
2645 d29d c2                           FCB  $80+'B
2646 00a1                    TOK_SUB   EQU  $A1
2647 d29e 54 48 45                     FCC  "THE"          ; A2
2648 d2a1 ce                           FCB  $80+'N
2649 00a2                    TOK_THEN  EQU  $A2
2650 d2a2 4e 4f                        FCC  "NO"           ; A3
2651 d2a4 d4                           FCB  $80+'T
2652 00a3                    TOK_NOT   EQU  $A3
2653 d2a5 53 54 45                     FCC  "STE"          ; A4
2654 d2a8 d0                           FCB  $80+'P
2655 00a4                    TOK_STEP  EQU  $A4
2656 d2a9 4f 46                        FCC  "OF"           ; A5
2657 d2ab c6                           FCB  $80+'F
2658 d2ac ab                           FCB  '++$80         ; A6
2659 00a6                    TOK_PLUS  EQU  $A6
2660 d2ad ad                           FCB  '-+$80         ; A7
2661 00a7                    TOK_MINUS EQU  $A7
2662 d2ae aa                           FCB  '*+$80         ; A8
2663 d2af af                           FCB  '/+$80         ; A9
2664 d2b0 de                           FCB  '^+$80         ; AA
2665 d2b1 41 4e                        FCC  "AN"           ; AB
2666 d2b3 c4                           FCB  $80+'D
2667 d2b4 4f                           FCC  "O"            ; AC
2668 d2b5 d2                           FCB  $80+'R
2669 d2b6 be                           FCB  '>+$80         ; AD
2670 00ad                    TOK_GREATER EQU  $AD
2671 d2b7 bd                           FCB  '=+$80         ; AE
2672 00ae                    TOK_EQUALS EQU  $AE
2673 d2b8 bc                           FCB  '<+$80         ; AF
2674 d2b9 46                           FCC  "F"            ; B0
2675 d2ba ce                           FCB  $80+'N
2676 00b0                    TOK_FN    EQU  $B0
2677 d2bb 55 53 49 4e                  FCC  "USIN"         ; B1
2678 d2bf c7                           FCB  $80+'G
2679 00b1                    TOK_USING EQU  $B1
2680                         *
2681                         
2682                         * FIRST SET ALWAYS HAS ONE PARAMETER
2683 d2c0 53 47              LAB1A     FCC  "SG"           ; 80
2684 d2c2 ce                           FCB  $80+'N
2685 d2c3 49 4e                        FCC  "IN"           ; 81
2686 d2c5 d4                           FCB  $80+'T
2687 d2c6 41 42                        FCC  "AB"           ; 82
2688 d2c8 d3                           FCB  $80+'S
2689 d2c9 55 53                        FCC  "US"           ; 83
2690 d2cb d2                           FCB  $80+'R
2691 d2cc 52 4e                        FCC  "RN"           ; 84
2692 d2ce c4                           FCB  $80+'D
2693 d2cf 53 49                        FCC  "SI"           ; 85
2694 d2d1 ce                           FCB  $80+'N
2695 d2d2 50 45 45                     FCC  "PEE"          ; 86
2696 d2d5 cb                           FCB  $80+'K
2697 d2d6 4c 45                        FCC  "LE"           ; 87
2698 d2d8 ce                           FCB  $80+'N
2699 d2d9 53 54 52                     FCC  "STR"          ; 88
2700 d2dc a4                           FCB  $80+'$
2701 d2dd 56 41                        FCC  "VA"           ; 89
2702 d2df cc                           FCB  $80+'L
2703 d2e0 41 53                        FCC  "AS"           ; 8A
2704 d2e2 c3                           FCB  $80+'C
2705 d2e3 43 48 52                     FCC  "CHR"          ; 8B
2706 d2e6 a4                           FCB  $80+'$
2707 d2e7 41 54                        FCC  "AT"           ; 8C
2708 d2e9 ce                           FCB  $80+'N
2709 d2ea 43 4f                        FCC  "CO"           ; 8D
2710 d2ec d3                           FCB  $80+'S
2711 d2ed 54 41                        FCC  "TA"           ; 8E
2712 d2ef ce                           FCB  $80+'N
2713 d2f0 45 58                        FCC  "EX"           ; 8F
2714 d2f2 d0                           FCB  $80+'P
2715 d2f3 46 49                        FCC  "FI"           ; 90
2716 d2f5 d8                           FCB  $80+'X
2717 d2f6 4c 4f                        FCC  "LO"           ; 91
2718 d2f8 c7                           FCB  $80+'G
2719 d2f9 50 4f                        FCC  "PO"           ; 92
2720 d2fb d3                           FCB  $80+'S
2721 d2fc 53 51                        FCC  "SQ"           ; 93
2722 d2fe d2                           FCB  $80+'R
2723 d2ff 48 45 58                     FCC  "HEX"          ; 94
2724 d302 a4                           FCB  $80+'$
2725                         * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
2726 d303 4c 45 46 54                  FCC  "LEFT"         ; 95
2727 d307 a4                           FCB  $80+'$
2728 d308 52 49 47 48 54               FCC  "RIGHT"        ; 96
2729 d30d a4                           FCB  $80+'$
2730 d30e 4d 49 44                     FCC  "MID"          ; 97
2731 d311 a4                           FCB  $80+'$
2732                         * REMAINING FUNCTIONS
2733 d312 49 4e 4b 45 59               FCC  "INKEY"        ; 98
2734 d317 a4                           FCB  $80+'$
2735 d318 4d 45                        FCC  "ME"           ; 99
2736 d31a cd                           FCB  $80+'M
2737 d31b 56 41 52 50 54               FCC  "VARPT"        ; 9A
2738 d320 d2                           FCB  $80+'R
2739 d321 49 4e 53 54                  FCC  "INST"         ; 9B
2740 d325 d2                           FCB  $80+'R
2741 d326 53 54 52 49 4e 47            FCC  "STRING"       ; 9C
2742 d32c a4                           FCB  $80+'$
2743                         
2744                         *
2745                         * DISPATCH TABLE FOR COMMANDS TOKEN #
2746                         CMD_TAB
2747 d32d d4 eb              LAB67     FDB  FOR            ; 80
2748 d32f d6 36                        FDB  GO             ; 81
2749 d331 d6 93                        FDB  REM            ; 82
2750 0082                    TOK_REM   EQU  *-CMD_TAB/2+$7F
2751 d333 d6 93                        FDB  REM            ; 83 (')
2752 0083                    TOK_SNGL_Q EQU  *-CMD_TAB/2+$7F
2753 d335 d6 93                        FDB  REM            ; 84 (ELSE)
2754 0084                    TOK_ELSE  EQU  *-CMD_TAB/2+$7F
2755 d337 d6 c4                        FDB  IF             ; 85
2756 0085                    TOK_IF    EQU  *-CMD_TAB/2+$7F
2757 d339 d6 90                        FDB  DATA           ; 86
2758 0086                    TOK_DATA  EQU  *-CMD_TAB/2+$7F
2759 d33b e0 6d                        FDB  PRINT          ; 87
2760 0087                    TOK_PRINT EQU  *-CMD_TAB/2+$7F
2761 d33d d6 f2                        FDB  ON             ; 88
2762 d33f d7 9f                        FDB  INPUT          ; 89
2763 0089                    TOK_INPUT EQU  *-CMD_TAB/2+$7F
2764 d341 d5 bd                        FDB  END            ; 8A
2765 d343 d8 84                        FDB  NEXT           ; 8B
2766 d345 da d5                        FDB  DIM            ; 8C
2767 d347 d7 d9                        FDB  READ           ; 8D
2768 d349 d6 2b                        FDB  RUN            ; 8E
2769 d34b d5 9f                        FDB  RESTOR         ; 8F
2770 d34d d6 70                        FDB  RETURN         ; 90
2771 d34f d5 c1                        FDB  STOP           ; 91
2772 d351 de de                        FDB  POKE           ; 92
2773 d353 d5 e6                        FDB  CONT           ; 93
2774 d355 de e5                        FDB  LIST           ; 94
2775 d357 d5 f7                        FDB  CLEAR          ; 95
2776 d359 d4 bb                        FDB  NEW            ; 96
2777 d35b d1 8f                        FDB  EXEC           ; 97
2778 d35d ea 67                        FDB  TRON           ; 98
2779 d35f ea 68                        FDB  TROFF          ; 99
2780 d361 ec e3                        FDB  DEL            ; 9A
2781 d363 ec 27                        FDB  DEF            ; 9B
2782 d365 f3 d1                        FDB  LINE           ; 9C
2783 d367 ed 6d                        FDB  RENUM          ; 9D
2784 d369 e8 f3                        FDB  EDIT           ; 9E
2785 009e                    TOK_HIGH_EXEC EQU  *-CMD_TAB/2+$7F
2786                         
2787                         * ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY
2788 d36b 4e 46              LABAF     FCC  "NF"           ; 0 NEXT WITHOUT FOR
2789 d36d 53 4e                        FCC  "SN"           ; 1 SYNTAX ERROR
2790 d36f 52 47                        FCC  "RG"           ; 2 RETURN WITHOUT GOSUB
2791 d371 4f 44                        FCC  "OD"           ; 3 OUT OF DATA
2792 d373 46 43                        FCC  "FC"           ; 4 ILLEGAL FUNCTION CALL
2793 d375 4f 56                        FCC  "OV"           ; 5 OVERFLOW
2794 d377 4f 4d                        FCC  "OM"           ; 6 OUT OF MEMORY
2795 d379 55 4c                        FCC  "UL"           ; 7 UNDEFINED LINE NUMBER
2796 d37b 42 53                        FCC  "BS"           ; 8 BAD SUBSCRIPT
2797 d37d 44 44                        FCC  "DD"           ; 9 REDIMENSIONED ARRAY
2798 d37f 2f 30                        FCC  "/0"           ; 10 DIVISION BY ZERO
2799 d381 49 44                        FCC  "ID"           ; 11 ILLEGAL DIRECT STATEMENT
2800 d383 54 4d                        FCC  "TM"           ; 12 TYPE MISMATCH
2801 d385 4f 53                        FCC  "OS"           ; 13 OUT OF STRING SPACE
2802 d387 4c 53                        FCC  "LS"           ; 14 STRING TOO LONG
2803 d389 53 54                        FCC  "ST"           ; 15 STRING FORMULA TOO COMPLEX
2804 d38b 43 4e                        FCC  "CN"           ; 16 CAN'T CONTINUE
2805 d38d 46 44                        FCC  "FD"           ; 17 BAD FILE DATA
2806 d38f 41 4f                        FCC  "AO"           ; 18 FILE ALREADY OPEN
2807 d391 44 4e                        FCC  "DN"           ; 19 DEVICE NUMBER ERROR
2808 d393 49 4f                        FCC  "IO"           ; 20 I/O ERROR
2809 d395 46 4d                        FCC  "FM"           ; 21 BAD FILE MODE
2810 d397 4e 4f                        FCC  "NO"           ; 22 FILE NOT OPEN
2811 d399 49 45                        FCC  "IE"           ; 23 INPUT PAST END OF FILE
2812 d39b 44 53                        FCC  "DS"           ; 24 DIRECT STATEMENT IN FILE
2813                         * ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC
2814 d39d 55 46              L890B     FCC  "UF"           ; 25 UNDEFINED FUNCTION (FN) CALL
2815 d39f 4e 45              L890D     FCC  "NE"           ; 26 FILE NOT FOUND
2816                         
2817 d3a1 20 45 52 52 4f 52  LABE1     FCC  " ERROR"
2818 d3a7 00                           FCB  $00
2819 d3a8 20 49 4e 20        LABE8     FCC  " IN "
2820 d3ac 00                           FCB  $00
2821 d3ad 0d                 LABED     FCB  CR
2822 d3ae 4f 4b              LABEE     FCC  "OK"
2823 d3b0 0d 00                        FCB  CR,$00
2824 d3b2 0d                 LABF2     FCB  CR
2825 d3b3 42 52 45 41 4b               FCC  "BREAK"
2826 d3b8 00                           FCB  $00
2827                         
2828                         * SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DATA.
2829                         * THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEING
2830                         * SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT DATA IS 18
2831                         * BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DATA IS 5 BYTES
2832                         * WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DATA
2833                         * IS CONSIDERED 'GOSUB/RETURN'
2834 d3b9 30 64              LABF9     LEAX 4,S            ; POINT X TO 3RD ADDRESS ON STACK - IGNORE THE
2835                         *         FIRST TWO RETURN ADDRESSES ON THE STACK
2836 d3bb c6 12              LABFB     LDB  #18            ; 18 BYTES SAVED ON STACK FOR EACH 'FOR' LOOP
2837 d3bd 9f 0f                        STX  TEMPTR         ; SAVE POINTER
2838 d3bf a6 84                        LDA  ,X             ; GET 1ST BYTE
2839 d3c1 80 80                        SUBA #$80           ; * CHECK FOR TYPE OF STACK JUMP FOUND
2840 d3c3 26 15                        BNE  LAC1A          ; * BRANCH IF NOT 'FOR/NEXT'
2841 d3c5 ae 01                        LDX  1,X            ; = GET INDEX VARIABLE DESCRIPTOR
2842 d3c7 9f 11                        STX  TMPTR1         ; = POINTER AND SAVE IT IN TMPTR1
2843 d3c9 9e 3b                        LDX  VARDES         ; GET INDEX VARIABLE BEING SEARCHED FOR
2844 d3cb 27 09                        BEQ  LAC16          ; BRANCH IF DEFAULT INDEX VARIABLE - USE THE
2845                         *                             ; FIRST 'FOR/NEXT' DATA FOUND ON STACK
2846                         *                             ; IF NO INDEX VARIABLE AFTER 'NEXT'
2847 d3cd 9c 11                        CMPX TMPTR1         ; DOES THE STACK INDEX MATCH THE ONE
2848                         *                             ; BEING SEARCHED FOR?
2849 d3cf 27 09                        BEQ  LAC1A          ; YES
2850 d3d1 9e 0f                        LDX  TEMPTR         ; * RESTORE INITIAL POINTER, ADD
2851 d3d3 3a                           ABX                 ; * 18 TO IT AND LOOK FOR
2852 d3d4 20 e5                        BRA  LABFB          ; * NEXT BLOCK OF DATA
2853 d3d6 9e 11              LAC16     LDX  TMPTR1         ; = GET 1ST INDEX VARIABLE FOUND AND
2854 d3d8 9f 3b                        STX  VARDES         ; = SAVE AS 'NEXT' INDEX
2855 d3da 9e 0f              LAC1A     LDX  TEMPTR         ; POINT X TO START OF 'FOR/NEXT' DATA
2856 d3dc 4d                           TSTA                ; SET ZERO FLAG IF 'FOR/NEXT' DATA
2857 d3dd 39                           RTS
2858                         * CHECK FOR MEMORY SPACE FOR NEW TOP OF
2859                         * ARRAYS AND MOVE ARRAYS TO NEW LOCATION
2860 d3de 8d 17              LAC1E     BSR  LAC37          ; ACCD = NEW BOTTOM OF FREE RAM - IS THERE
2861                         *                             ; ROOM FOR THE STACK?
2862                         * MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND
2863                         * SAVE FINAL VALUE OF U IN V45
2864 d3e0 de 41              LAC20     LDU  V41            ; POINT U TO DESTINATION ADDRESS (V41)
2865 d3e2 33 41                        LEAU 1,U            ; ADD ONE TO U - COMPENSATE FOR FIRST PSHU
2866 d3e4 9e 43                        LDX  V43            ; POINT X TO SOURCE ADDRESS (V43)
2867 d3e6 30 01                        LEAX 1,X            ; ADD ONE - COMPENSATE FOR FIRST LDA ,X
2868 d3e8 a6 82              LAC28     LDA  ,-X            ; GRAB A BYTE FROM SOURCE
2869 d3ea 36 02                        PSHU A              ; MOVE IT TO DESTINATION
2870 d3ec 9c 47                        CMPX V47            ; DONE?
2871 d3ee 26 f8                        BNE  LAC28          ; NO - KEEP MOVING BYTES
2872 d3f0 df 45                        STU  V45            ; SAVE FINAL DESTINATION ADDRESS
2873 d3f2 39                 LAC32     RTS
2874                         * CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB
2875                         * BYTES IN FREE RAM - OM ERROR IF NOT
2876 d3f3 4f                 LAC33     CLRA                ; * ACCD CONTAINS NUMBER OF EXTRA
2877 d3f4 58                           ASLB                ; * BYTES TO PUT ON STACK
2878 d3f5 d3 1f                        ADDD ARYEND         ; END OF PROGRAM AND VARIABLES
2879 d3f7 c3 00 3a           LAC37     ADDD #STKBUF        ; ADD STACK BUFFER - ROOM FOR STACK?
2880 d3fa 25 08                        BCS  LAC44          ; BRANCH IF GREATER THAN $FFFF
2881 d3fc 10 df 17                     STS  BOTSTK         ; CURRENT NEW BOTTOM OF STACK STACK POINTER
2882 d3ff 10 93 17                     CMPD BOTSTK         ; ARE WE GOING TO BE BELOW STACK?
2883 d402 25 ee                        BCS  LAC32          ; YES - NO ERROR
2884 d404 c6 0c              LAC44     LDB  #6*2           ; OUT OF MEMORY ERROR
2885                         
2886                         * ERROR SERVICING ROUTINE
2887 d406 bd d4 d7           LAC46     JSR  LAD33          ; RESET STACK, STRING STACK, CONTINUE POINTER
2888 d409 bd e0 ac                     JSR  LB95C          ; SEND A CR TO SCREEN
2889 d40c bd e0 fb                     JSR  LB9AF          ; SEND A '?' TO SCREEN
2890 d40f 8e d3 6b                     LDX  #LABAF         ; POINT TO ERROR TABLE
2891 d412 3a                 LAC60     ABX                 ; ADD MESSAGE NUMBER OFFSET
2892 d413 8d 31                        BSR  LACA0          ; * GET TWO CHARACTERS FROM X AND
2893 d415 8d 2f                        BSR  LACA0          ; * SEND TO CONSOLE OUT (SCREEN)
2894 d417 8e d3 a0                     LDX  #LABE1-1       ; POINT TO "ERROR" MESSAGE
2895 d41a bd e0 e8           LAC68     JSR  LB99C          ; PRINT MESSAGE POINTED TO BY X
2896 d41d 96 68                        LDA  CURLIN         ; GET CURRENT LINE NUMBER (CURL IN)
2897 d41f 4c                           INCA                ; TEST FOR DIRECT MODE
2898 d420 27 03                        BEQ  LAC73          ; BRANCH IF DIRECT MODE
2899 d422 bd e5 11                     JSR  LBDC5          ; PRINT 'IN ****'
2900                         
2901                         * THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE
2902 d425 bd e0 ac           LAC73     JSR  LB95C          ; MOVE CURSOR TO START OF LINE
2903 d428 8e d3 ad                     LDX  #LABED         ; POINT X TO 'OK', CR MESSAGE
2904 d42b bd e0 e8                     JSR  LB99C          ; PRINT 'OK', CR
2905 d42e bd d1 41           LAC7C     JSR  LA390          ; GO GET AN INPUT LINE
2906 d431 ce ff ff                     LDU  #$FFFF         ; THE LINE NUMBER FOR DIRECT MODE IS $FFFF
2907 d434 df 68                        STU  CURLIN         ; SAVE IT IN CURLIN
2908 d436 25 f6                        BCS  LAC7C          ; BRANCH IF LINE INPUT TERMINATED BY BREAK
2909 d438 9f 83                        STX  CHARAD         ; SAVE (X) AS CURRENT INPUT POINTER - THIS WILL
2910                         *         ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. THE
2911                         *         LINE JUST ENTERED WILL BE INTERPRETED
2912 d43a 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
2913 d43c 27 f0                        BEQ  LAC7C          ; NO LINE INPUT - GET ANOTHER LINE
2914 d43e 25 0b                        BCS  LACA5          ; BRANCH IF NUMER1C - THERE WAS A LINE NUMBER BEFORE
2915                         *         THE  STATEMENT ENTERED, SO THIS STATEMENT
2916                         *         WILL BE MERGED INTO THE BASIC PROGRAM
2917 d440 bd df 9a                     JSR  LB821          ; GO CRUNCH LINE
2918 d443 7e d5 74                     JMP  LADC0          ; GO EXECUTE THE STATEMENT (LIVE KEYBOARD)
2919                         *
2920 d446 a6 80              LACA0     LDA  ,X+            ; GET A CHARACTER
2921 d448 7e e0 fd                     JMP  LB9B1          ; SEND TO CONSOLE OUT
2922                         * TAKE A LINE FROM THE LINE INPUT BUFFER
2923                         * AND INSERT IT INTO THE BASIC PROGRAM
2924 d44b bd d7 17           LACA5     JSR  LAF67          ; CONVERT LINE NUMBER TO BINARY
2925 d44e 9e 2b              LACA8     LDX  BINVAL         ; GET CONVERTED LINE NUMBER
2926 d450 9f f1                        STX  LINHDR         ; STORE IT IN LINE INPUT HEADER
2927 d452 bd df 9a                     JSR  LB821          ; GO CRUNCH THE LINE
2928 d455 d7 03                        STB  TMPLOC         ; SAVE LINE LENGTH
2929 d457 8d 4c                        BSR  LAD01          ; FIND OUT WHERE TO INSERT LINE
2930 d459 25 12                        BCS  LACC8          ; RANCH IF LINE NUMBER DOES NOT ALREADY EXIST
2931 d45b dc 47                        LDD  V47            ; GET ABSOLUTE ADDRESS OF LINE NUMBER
2932 d45d a3 84                        SUBD ,X             ; SUBTRACT ADDRESS OF NEXT LINE NUMBER
2933 d45f d3 1b                        ADDD VARTAB         ; * ADD TO CURRENT END OF PROGRAM - THIS WILL REMOVE
2934 d461 dd 1b                        STD  VARTAB         ; * THE LENGTH OF THIS LINE NUMBER FROM THE PROGRAM
2935 d463 ee 84                        LDU  ,X             ; POINT U TO ADDRESS OF NEXT LINE NUMBER
2936                         * DELETE OLD LINE FROM BASIC PROGRAM
2937 d465 37 02              LACC0     PULU A              ; GET A BYTE FROM WHAT'S LEFT OF PROGRAM
2938 d467 a7 80                        STA  ,X+            ; MOVE IT DOWN
2939 d469 9c 1b                        CMPX VARTAB         ; COMPARE TO END OF BASIC PROGRAM
2940 d46b 26 f8                        BNE  LACC0          ; BRANCH IF NOT AT END
2941 d46d 96 f3              LACC8     LDA  LINBUF         ; * CHECK TO SEE IF THERE IS A LINE IN
2942 d46f 27 1c                        BEQ  LACE9          ; * THE BUFFER AND BRANCH IF NONE
2943 d471 dc 1b                        LDD  VARTAB         ; = SAVE CURRENT END OF
2944 d473 dd 43                        STD  V43            ; = PROGRAM IN V43
2945 d475 db 03                        ADDB TMPLOC         ; * ADD LENGTH OF CRUNCHED LINE,
2946 d477 89 00                        ADCA #0             ; * PROPOGATE CARRY AND SAVE NEW END
2947 d479 dd 41                        STD  V41            ; * OF PROGRAM IN V41
2948 d47b bd d3 de                     JSR  LAC1E          ; = MAKE SURE THERE'S ENOUGH RAM FOR THIS
2949                         *         =    LINE & MAKE A HOLE IN BASIC FOR NEW LINE
2950 d47e ce 00 ef                     LDU  #LINHDR-2      ; POINT U TO LINE TO BE INSERTED
2951 d481 37 02              LACDD     PULU A              ; GET A BYTE FROM NEW LINE
2952 d483 a7 80                        STA  ,X+            ; INSERT IT IN PROGRAM
2953 d485 9c 45                        CMPX V45            ; * COMPARE TO ADDRESS OF END OF INSERTED
2954 d487 26 f8                        BNE  LACDD          ; * LINE AND BRANCH IF NOT DONE
2955 d489 9e 41                        LDX  V41            ; = GET AND SAVE
2956 d48b 9f 1b                        STX  VARTAB         ; = END OF PROGRAM
2957 d48d 8d 36              LACE9     BSR  LAD21          ; RESET INPUT POINTER, CLEAR VARIABLES, INITIALIZE
2958 d48f 8d 02                        BSR  LACEF          ; ADJUST START OF NEXT LINE ADDRESSES
2959 d491 20 9b                        BRA  LAC7C          ; EENTER BASIC'S INPUT LOOP
2960                         * COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BASIC PROGRAM
2961 d493 9e 19              LACEF     LDX  TXTTAB         ; POINT X TO START OF PROGRAM
2962 d495 ec 84              LACF1     LDD  ,X             ; GET ADDRESS OF NEXT LINE
2963 d497 27 21                        BEQ  LAD16          ; RETURN IF END OF PROGRAM
2964 d499 33 04                        LEAU 4,X            ; POINT U TO START OF BASIC TEXT IN LINE
2965 d49b a6 c0              LACF7     LDA  ,U+            ; * SKIP THROUGH THE LINE UNTIL A
2966 d49d 26 fc                        BNE  LACF7          ; * ZERO (END OF LINE) IS FOUND
2967 d49f ef 84                        STU  ,X             ; SAVE THE NEW START OF NEXT LINE ADDRESS
2968 d4a1 ae 84                        LDX  ,X             ; POINT X TO START OF NEXT LINE
2969 d4a3 20 f0                        BRA  LACF1          ; KEEP GOING
2970                         *
2971                         * FIND A LINE NUMBER IN THE BASIC PROGRAM
2972                         * RETURN WITH CARRY SET IF NO MATCH FOUND
2973 d4a5 dc 2b              LAD01     LDD  BINVAL         ; GET THE LINE NUMBER TO FIND
2974 d4a7 9e 19                        LDX  TXTTAB         ; BEGINNING OF PROGRAM
2975 d4a9 ee 84              LAD05     LDU  ,X             ; GET ADDRESS OF NEXT LINE NUMBER
2976 d4ab 27 09                        BEQ  LAD12          ; BRANCH IF END OF PROG
2977 d4ad 10 a3 02                     CMPD 2,X            ; IS IT A MATCH?
2978 d4b0 23 06                        BLS  LAD14          ; CARRY SET IF LOWER; CARRY CLEAR IF MATCH
2979 d4b2 ae 84                        LDX  ,X             ; X = ADDRESS OF NEXT LINE
2980 d4b4 20 f3                        BRA  LAD05          ; KEEP LOOPING FOR LINE NUMBER
2981 d4b6 1a 01              LAD12     ORCC #1             ; SET CARRY FLAG
2982 d4b8 9f 47              LAD14     STX  V47            ; SAVE MATCH LINE NUMBER OR NUMBER OF LINE JUST AFTER
2983                         *                             ; WHERE IT SHOULD HAVE BEEN
2984 d4ba 39                 LAD16     RTS
2985                         
2986                         * NEW
2987 d4bb 26 fb              NEW       BNE  LAD14          ; BRANCH IF ARGUMENT GIVEN
2988 d4bd 9e 19              LAD19     LDX  TXTTAB         ; GET START OF BASIC
2989 d4bf 6f 80                        CLR  ,X+            ; * PUT 2 ZERO BYTES THERE - ERASE
2990 d4c1 6f 80                        CLR  ,X+            ; * THE BASIC PROGRAM
2991 d4c3 9f 1b                        STX  VARTAB         ; AND THE NEXT ADDRESS IS NOW THE END OF PROGRAM
2992 d4c5 9e 19              LAD21     LDX  TXTTAB         ; GET START OF BASIC
2993 d4c7 bd d6 6b                     JSR  LAEBB          ; PUT INPUT POINTER ONE BEFORE START OF BASIC
2994                         * ERASE ALL VARIABLES
2995 d4ca 9e 27              LAD26     LDX  MEMSIZ         ; * RESET START OF STRING VARIABLES
2996 d4cc 9f 23                        STX  STRTAB         ; * TO TOP OF STRING SPACE
2997 d4ce bd d5 9f                     JSR  RESTOR         ; RESET 'DATA' POINTER TO START OF BASIC
2998 d4d1 9e 1b                        LDX  VARTAB         ; * GET START OF VARIABLES AND USE IT
2999 d4d3 9f 1d                        STX  ARYTAB         ; * TO RESET START OF ARRAYS
3000 d4d5 9f 1f                        STX  ARYEND         ; RESET END OF ARRAYS
3001 d4d7 8e 00 c9           LAD33     LDX  #STRSTK        ; * RESET STRING STACK POINTER TO
3002 d4da 9f 0b                        STX  TEMPPT         ; * BOTTOM OF STRING STACK
3003 d4dc ae e4                        LDX  ,S             ; GET RETURN ADDRESS OFF STACK
3004 d4de 10 de 21                     LDS  FRETOP         ; RESTORE STACK POINTER
3005 d4e1 6f e2                        CLR  ,-S            ; PUT A ZERO BYTE ON STACK - TO CLEAR ANY RETURN OF
3006                         *                             ; FOR/NEXT DATA FROM THE STACK
3007 d4e3 0f 2d                        CLR  OLDPTR         ; RESET 'CONT' ADDRESS SO YOU
3008 d4e5 0f 2e                        CLR  OLDPTR+1       ; 'CAN'T CONTINUE'
3009 d4e7 0f 08                        CLR  ARYDIS         ; CLEAR THE ARRAY DISABLE FLAG
3010 d4e9 6e 84                        JMP  ,X             ; RETURN TO CALLING ROUTINE - THIS IS NECESSARY
3011                         *                             ; SINCE THE STACK WAS RESET
3012                         *
3013                         * FOR
3014                         *
3015                         * THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR
3016                         * EACH FOR-NEXT LOOP WHICH IS BEING PROCESSED. THESE
3017                         * BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);
3018                         *         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=FP VALUE OF STEP;
3019                         *         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO; 1 IF POSITIVE;
3020                         * 9-13=FP VALUE OF 'TO' PARAMETER;
3021                         * 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE END
3022                         *         OF   THE LINE CONTAINING THE 'FOR' STATEMENT
3023 d4eb 86 80              FOR       LDA  #$80           ; * SAVE THE DISABLE ARRAY FLAG IN VO8
3024 d4ed 97 08                        STA  ARYDIS         ; * DO NOT ALLOW THE INDEX VARIABLE TO BE AN ARRAY
3025 d4ef bd d7 39                     JSR  LET            ; SET INDEX VARIABLE TO INITIAL VALUE
3026 d4f2 bd d3 b9                     JSR  LABF9          ; SEARCH THE STACK FOR 'FOR/NEXT' DATA
3027 d4f5 32 62                        LEAS 2,S            ; PURGE RETURN ADDRESS OFF OF THE STACK
3028 d4f7 26 04                        BNE  LAD59          ; BRANCH IF INDEX VARIABLE NOT ALREADY BEING USED
3029 d4f9 9e 0f                        LDX  TEMPTR         ; GET (ADDRESS + 18) OF MATCHED 'FOR/NEXT' DATA
3030 d4fb 32 85                        LEAS B,X            ; MOVE THE STACK POINTER TO THE BEGINNING OF THE
3031                         * MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
3032                         * OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY
3033                         * ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
3034                         * THIS POINT ON THE STACK
3035 d4fd c6 09              LAD59     LDB  #$09           ; * CHECK FOR ROOM FOR 18 BYTES
3036 d4ff bd d3 f3                     JSR  LAC33          ; * IN FREE RAM
3037 d502 bd d6 98                     JSR  LAEE8          ; GET ADDR OF END OF SUBLINE IN X
3038 d505 dc 68                        LDD  CURLIN         ; GET CURRENT LINE NUMBER
3039 d507 34 16                        PSHS X,B,A          ; SAVE LINE ADDR AND LINE NUMBER ON STACK
3040 d509 c6 a0                        LDB  #TOK_TO        ; TOKEN FOR 'TO'
3041 d50b bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR 'TO'
3042 d50e bd d8 cf                     JSR  LB143          ; 'TM' ERROR IF INDEX VARIABLE SET TO STRING
3043 d511 bd d8 cd                     JSR  LB141          ; EVALUATE EXPRESSION
3044                         *
3045 d514 d6 54                        LDB  FP0SGN         ; GET FPA0 MANTISSA SIGN
3046 d516 ca 7f                        ORB  #$7F           ; FORM A MASK TO SAVE DATA BITS OF HIGH ORDER MANTISSA
3047 d518 d4 50                        ANDB FPA0           ; PUT THE MANTISSA SIGN IN BIT 7 OF HIGH ORDER MANTISSA
3048 d51a d7 50                        STB  FPA0           ; SAVE THE PACKED HIGH ORDER MANTISSA
3049 d51c 10 8e d5 23                  LDY  #LAD7F         ; LOAD FOLLOWING ADDRESS INTO Y AS A RETURN
3050 d520 7e d9 76                     JMP  LB1EA          ; ADDRESS - PUSH FPA0 ONTO THE STACK
3051 d523 8e e2 11           LAD7F     LDX  #LBAC5         ; POINT X TO FLOATING POINT NUMBER 1.0 (DEFAULT STEP VALUE)
3052 d526 bd e3 60                     JSR  LBC14          ; MOVE (X) TO FPA0
3053 d529 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3054 d52b 81 a4                        CMPA #TOK_STEP      ; STEP TOKEN
3055 d52d 26 05                        BNE  LAD90          ; BRANCH IF NO 'STEP' VALUE
3056 d52f 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3057 d531 bd d8 cd                     JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
3058 d534 bd e3 b9           LAD90     JSR  LBC6D          ; CHECK STATUS OF FPA0
3059 d537 bd d9 72                     JSR  LB1E6          ; SAVE STATUS AND FPA0 ON THE STACK
3060 d53a dc 3b                        LDD  VARDES         ; * GET DESCRIPTOR POINTER FOR THE 'STEP'
3061 d53c 34 06                        PSHS B,A            ; * VARIABLE AND SAVE IT ON THE STACK
3062 d53e 86 80                        LDA  #$80           ; = GET THE 'FOR' FLAG AND
3063 d540 34 02                        PSHS A              ; = SAVE IT ON THE STACK
3064                         *
3065                         * MAIN COMMAND INTERPRETATION LOOP
3066 d542 1c af              LAD9E     ANDCC #$AF          ; ENABLE IRQ,FIRQ
3067 d544 8d 60                        BSR  LADEB          ; CHECK FOR KEYBOARD BREAK
3068 d546 9e 83                        LDX  CHARAD         ; GET BASIC'S INPUT POINTER
3069 d548 9f 2f                        STX  TINPTR         ; SAVE IT
3070 d54a a6 80                        LDA  ,X+            ; GET CURRENT INPUT CHAR & MOVE POINTER
3071 d54c 27 07                        BEQ  LADB4          ; BRANCH IF END OF LINE
3072 d54e 81 3a                        CMPA #':            ; CHECK FOR LINE SEPARATOR
3073 d550 27 22                        BEQ  LADC0          ; BRANCH IF COLON
3074 d552 7e da 03           LADB1     JMP  LB277          ; 'SYNTAX ERROR'-IF NOT LINE SEPARATOR
3075 d555 a6 81              LADB4     LDA  ,X++           ; GET MS BYTE OF ADDRESS OF NEXT BASIC LINE
3076 d557 97 00                        STA  ENDFLG         ; SAVE IN STOP/END FLAG - CAUSE A STOP IF
3077                         *                             ; NEXT LINE ADDRESS IS < $8000; CAUSE
3078                         *                             ; AN END IF ADDRESS > $8000
3079 d559 27 72                        BEQ  LAE15          ; BRANCH TO 'STOP' - END OF PROGRAM
3080 d55b ec 80                        LDD  ,X+            ; GET CURRENT LINE NUMBER
3081 d55d dd 68                        STD  CURLIN         ; SAVE IN CURLIN
3082 d55f 9f 83                        STX  CHARAD         ; SAVE ADDRESS OF FIRST BYTE OF LINE
3083                         * EXTENDED BASIC TRACE
3084 d561 96 8c                        LDA  TRCFLG         ; TEST THE TRACE FLAG
3085 d563 27 0f                        BEQ  LADC0          ; BRANCH IF TRACE OFF
3086 d565 86 5b                        LDA  #$5B           ; <LEFT HAND MARKER FOR TRON LINE NUMBER
3087 d567 bd d0 17                     JSR  PUTCHR         ; OUTPUT A CHARACTER
3088 d56a 96 68                        LDA  CURLIN         ; GET MS BYTE OF LINE NUMBER
3089 d56c bd e5 18                     JSR  LBDCC          ; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN
3090 d56f 86 5d                        LDA  #$5D           ; > RIGHT HAND MARKER FOR TRON LINE NUMBER
3091 d571 bd d0 17                     JSR  PUTCHR         ; OUTPUT A CHARACTER
3092                         * END OF EXTENDED BASIC TRACE
3093 d574 9d 7c              LADC0     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3094 d576 8d 02                        BSR  LADC6          ; GO PROCESS COMMAND
3095 d578 20 c8                        BRA  LAD9E          ; GO BACK TO MAIN LOOP
3096 d57a 27 29              LADC6     BEQ  LADEA          ; RETURN IF END OF LINE (RTS - was BEQ LAE40)
3097 d57c 4d                           TSTA                ; CHECK FOR TOKEN - BIT 7 SET (NEGATIVE)
3098 d57d 10 2a 01 b8                  LBPL LET            ; BRANCH IF NOT A TOKEN - GO DO A 'LET' WHICH
3099                         *                             ; IS THE 'DEFAULT' TOKEN FOR MICROSOFT BASIC
3100 d581 81 ff                        CMPA #$FF           ; SECONDARY TOKEN
3101 d583 27 0f                        BEQ  SECTOK
3102 d585 81 9e                        CMPA #TOK_HIGH_EXEC ; SKIPF TOKEN - HIGHEST EXECUTABLE COMMAND IN BASIC
3103 d587 22 c9                        BHI  LADB1          ; 'SYNTAX ERROR' IF NON-EXECUTABLE TOKEN
3104 d589 be d0 f4                     LDX  COMVEC+3       ; GET ADDRESS OF BASIC'S COMMAND TABLE
3105 d58c 48                 LADD4     ASLA                ; X2 (2 BYTE/JUMP ADDRESS) & DISCARD BIT 7
3106 d58d 1f 89                        TFR  A,B            ; SAVE COMMAND OFFSET IN ACCB
3107 d58f 3a                           ABX                 ; NON X POINTS TO COMMAND JUMP ADDR
3108 d590 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
3109                         *
3110                         * HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
3111 d592 6e 94                        JMP  [,X]           ; GO DO A COMMAND
3112                         SECTOK
3113                         * THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTABLE IS
3114                         * THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHECK DONE HERE
3115 d594 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
3116 d596 81 97                        CMPA #TOK_MID       ; TOKEN FOR "MID$"
3117 d598 10 27 14 f0                  LBEQ L86D6          ; PROCESS MID$ REPLACEMENT
3118 d59c 7e da 03                     JMP  LB277          ; SYNTAX ERROR
3119                         
3120                         *
3121                         * RESTORE
3122 d59f 9e 19              RESTOR    LDX  TXTTAB         ; BEGINNING OF PROGRAM ADDRESS
3123 d5a1 30 1f                        LEAX -1,X           ; MOVE TO ONE BYTE BEFORE PROGRAM
3124 d5a3 9f 33              LADE8     STX  DATPTR         ; SAVE NEW DATA POINTER
3125 d5a5 39                 LADEA     RTS
3126                         *
3127                         * BREAK CHECK
3128 d5a6 bd d0 08           LADEB     JSR  LA1C1          ; GET A KEYSTROKE ENTRY
3129 d5a9 27 0a                        BEQ  LADFA          ; RETURN IF NO INPUT
3130 d5ab 81 03              LADF0     CMPA #3             ; CONTROL C? (BREAK)
3131 d5ad 27 12                        BEQ  STOP           ; YES
3132 d5af 81 13                        CMPA #$13           ; CONTROL S? (PAUSE)
3133 d5b1 27 03                        BEQ  LADFB          ; YES
3134 d5b3 97 73                        STA  IKEYIM         ; SAVE KEYSTROKE IN INKEY IMAGE
3135 d5b5 39                 LADFA     RTS
3136 d5b6 bd d0 08           LADFB     JSR  KEYIN          ; GET A KEY
3137 d5b9 27 fb                        BEQ  LADFB          ; BRANCH IF NO KEY DOWN
3138 d5bb 20 ee                        BRA  LADF0          ; CONTINUE - DO A BREAK CHECK
3139                         *
3140                         * END
3141 d5bd 9d 82              END       JSR  GETCCH         ; GET CURRENT INPUT CHAR
3142 d5bf 20 02                        BRA  LAE0B
3143                         *
3144                         * STOP
3145 d5c1 1a 01              STOP      ORCC #$01           ; SET CARRY FLAG
3146 d5c3 26 31              LAE0B     BNE  LAE40          ; BRANCH IF ARGUMENT EXISTS
3147 d5c5 9e 83                        LDX  CHARAD         ; * SAVE CURRENT POSITION OF
3148 d5c7 9f 2f                        STX  TINPTR         ; * BASIC'S INPUT POINTER
3149 d5c9 06 00              LAE11     ROR  ENDFLG         ; ROTATE CARRY INTO BIT 7 OF STOP/END FLAG
3150 d5cb 32 62                        LEAS 2,S            ; PURGE RETURN ADDRESS OFF STACK
3151 d5cd 9e 68              LAE15     LDX  CURLIN         ; GET CURRENT LINE NUMBER
3152 d5cf 8c ff ff                     CMPX #$FFFF         ; DIRECT MODE?
3153 d5d2 27 06                        BEQ  LAE22          ; YES
3154 d5d4 9f 29                        STX  OLDTXT         ; SAVE CURRENT LINE NUMBER
3155 d5d6 9e 2f                        LDX  TINPTR         ; * GET AND SAVE CURRENT POSITION
3156 d5d8 9f 2d                        STX  OLDPTR         ; * OF BASIC'S INPUT POINTER
3157                         LAE22
3158 d5da 8e d3 b1                     LDX  #LABF2-1       ; POINT TO CR, 'BREAK' MESSAGE
3159 d5dd 0d 00                        TST  ENDFLG         ; CHECK STOP/END FLAG
3160 d5df 10 2a fe 42                  LBPL LAC73          ; BRANCH TO MAIN LOOP OF BASIC IF END
3161 d5e3 7e d4 1a                     JMP  LAC68          ; PRINT 'BREAK AT ####' AND GO TO
3162                         *                             ; BASIC'S MAIN LOOP IF 'STOP'
3163                         
3164                         * CONT
3165 d5e6 26 0e              CONT      BNE  LAE40          ; RETURN IF ARGUMENT GIVEN
3166 d5e8 c6 20                        LDB  #2*16          ; 'CAN'T CONTINUE' ERROR
3167 d5ea 9e 2d                        LDX  OLDPTR         ; GET CONTINUE ADDRESS (INPUT POINTER)
3168 d5ec 10 27 fe 16                  LBEQ LAC46          ; 'CN' ERROR IF CONTINUE ADDRESS = 0
3169 d5f0 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3170 d5f2 9e 29                        LDX  OLDTXT         ; GET LINE NUMBER
3171 d5f4 9f 68                        STX  CURLIN         ; RESET CURRENT LINE NUMBER
3172 d5f6 39                 LAE40     RTS
3173                         *
3174                         * CLEAR
3175 d5f7 27 2c              CLEAR     BEQ  LAE6F          ; BRANCH IF NO ARGUMENT
3176 d5f9 bd db 6d                     JSR  LB3E6          ; EVALUATE ARGUMENT
3177 d5fc 34 06                        PSHS B,A            ; SAVE AMOUNT OF STRING SPACE ON STACK
3178 d5fe 9e 27                        LDX  MEMSIZ         ; GET CURRENT TOP OF CLEARED SPACE
3179 d600 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3180 d602 27 0c                        BEQ  LAE5A          ; BRANCH IF NO NEW TOP OF CLEARED SPACE
3181 d604 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
3182 d607 bd de c4                     JSR  LB73D          ; EVALUATE EXPRESSlON; RETURN VALUE IN X
3183 d60a 30 1f                        LEAX -1,X           ; X = TOP OF CLEARED SPACE
3184 d60c 9c 71                        CMPX TOPRAM         ; COMPARE TO TOP OF RAM
3185 d60e 22 18                        BHI  LAE72          ; 'OM' ERROR IF > TOP OF RAM
3186 d610 1f 10              LAE5A     TFR  X,D            ; ACCD = TOP OF CLEARED SPACE
3187 d612 a3 e1                        SUBD ,S++           ; SUBTRACT OUT AMOUNT OF CLEARED SPACE
3188 d614 25 12                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
3189 d616 1f 03                        TFR  D,U            ; U = BOTTOM OF CLEARED SPACE
3190 d618 83 00 3a                     SUBD #STKBUF        ; SUBTRACT OUT STACK BUFFER
3191 d61b 25 0b                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
3192 d61d 93 1b                        SUBD VARTAB         ; SUBTRACT OUT START OF VARIABLES
3193 d61f 25 07                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
3194 d621 df 21                        STU  FRETOP         ; SAVE NEW BOTTOM OF CLEARED SPACE
3195 d623 9f 27                        STX  MEMSIZ         ; SAVE NEW TOP OF CLEARED SPACE
3196 d625 7e d4 ca           LAE6F     JMP  LAD26          ; ERASE ALL VARIABLES, INITIALIZE POINTERS, ETC
3197 d628 7e d4 04           LAE72     JMP  LAC44          ; 'OM' ERROR
3198                         *
3199                         * RUN
3200 d62b 9d 82              RUN       JSR  GETCCH         ; * GET CURRENT INPUT CHARACTER
3201 d62d 10 27 fe 94                  LBEQ LAD21          ; * IF NO LINE NUMBER
3202 d631 bd d4 ca                     JSR  LAD26          ; ERASE ALL VARIABLES
3203 d634 20 19                        BRA  LAE9F          ; 'GOTO' THE RUN ADDRESS
3204                         *
3205                         * GO
3206 d636 1f 89              GO        TFR  A,B            ; SAVE INPUT CHARACTER IN ACCB
3207 d638 9d 7c              LAE88     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3208 d63a c1 a0                        CMPB #TOK_TO        ; 'TO' TOKEN
3209 d63c 27 16                        BEQ  LAEA4          ; BRANCH IF GOTO
3210 d63e c1 a1                        CMPB #TOK_SUB       ; 'SUB' TOKEN
3211 d640 26 45                        BNE  LAED7          ; 'SYNTAX ERROR' IF NEITHER
3212 d642 c6 03                        LDB  #3             ; =ROOM FOR 6
3213 d644 bd d3 f3                     JSR  LAC33          ; =BYTES ON STACK?
3214 d647 de 83                        LDU  CHARAD         ; * SAVE CURRENT BASIC INPUT POINTER, LINE
3215 d649 9e 68                        LDX  CURLIN         ; * NUMBER AND SUB TOKEN ON STACK
3216 d64b 86 a1                        LDA  #TOK_SUB       ; *
3217 d64d 34 52                        PSHS U,X,A          ; *
3218 d64f 8d 03              LAE9F     BSR  LAEA4          ; GO DO A 'GOTO'
3219 d651 7e d5 42                     JMP  LAD9E          ; JUMP BACK TO BASIC'S MAIN LOOP
3220                         * GOTO
3221 d654 9d 82              LAEA4     JSR  GETCCH         ; GET CURRENT INPUT CHAR
3222 d656 bd d7 17                     JSR  LAF67          ; GET LINE NUMBER TO BINARY IN BINVAL
3223 d659 8d 40                        BSR  LAEEB          ; ADVANCE BASIC'S POINTER TO END OF LINE
3224 d65b 30 01                        LEAX $01,X          ; POINT TO START OF NEXT LINE
3225 d65d dc 2b                        LDD  BINVAL         ; GET THE LINE NUMBER TO RUN
3226 d65f 10 93 68                     CMPD CURLIN         ; COMPARE TO CURRENT LINE NUMBER
3227 d662 22 02                        BHI  LAEB6          ; IF REO'D LINE NUMBER IS > CURRENT LINE NUMBER,
3228                         *              ; DON'T START LOOKING FROM
3229                         *              ; START OF PROGRAM
3230 d664 9e 19                        LDX  TXTTAB         ; BEGINNING OF PROGRAM
3231 d666 bd d4 a9           LAEB6     JSR  LAD05          ; GO FIND A LINE NUMBER
3232 d669 25 17                        BCS  LAED2          ; 'UNDEFINED LINE NUMBER'
3233 d66b 30 1f              LAEBB     LEAX -1,X           ; MOVE BACK TO JUST BEFORE START OF LINE
3234 d66d 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3235 d66f 39                 LAEBF     RTS
3236                         *
3237                         * RETURN
3238 d670 26 fd              RETURN    BNE  LAEBF          ; EXIT ROUTINE IF ARGUMENT GIVEN
3239 d672 86 ff                        LDA  #$FF           ; * PUT AN ILLEGAL VARIABLE NAME IN FIRST BYTE OF
3240 d674 97 3b                        STA  VARDES         ; * VARDES WHICH WILL CAUSE 'FOR/NEXT' DATA ON THE
3241                         *              ; STACK TO BE IGNORED
3242 d676 bd d3 b9                     JSR  LABF9          ; CHECK FOR RETURN DATA ON THE STACK
3243 d679 1f 14                        TFR  X,S            ; RESET STACK POINTER - PURGE TWO RETURN ADDRESSES
3244                         *              ; FROM THE STACK
3245 d67b 81 21                        CMPA #TOK_SUB-$80   ; SUB TOKEN - $80
3246 d67d 27 0b                        BEQ  LAEDA          ; BRANCH IF 'RETURN' FROM SUBROUTINE
3247 d67f c6 04                        LDB  #2*2           ; ERROR #2 'RETURN WITHOUT GOSUB'
3248 d681 8c                           FCB  SKP2           ; SKIP TWO BYTES
3249 d682 c6 0e              LAED2     LDB  #7*2           ; ERROR #7 'UNDEFINED LINE NUMBER'
3250 d684 7e d4 06                     JMP  LAC46          ; JUMP TO ERROR HANDLER
3251 d687 7e da 03           LAED7     JMP  LB277          ; 'SYNTAX ERROR'
3252 d68a 35 52              LAEDA     PULS A,X,U          ; * RESTORE VALUES OF CURRENT LINE NUMBER AND
3253 d68c 9f 68                        STX  CURLIN         ; * BASIC'S INPUT POINTER FOR THIS SUBROUTINE
3254 d68e df 83                        STU  CHARAD         ; * AND LOAD ACCA WITH SUB TOKEN ($A6)
3255                         *
3256                         * DATA
3257 d690 8d 06              DATA      BSR  LAEE8          ; MOVE INPUT POINTER TO END OF SUBLINE OR LINE
3258 d692 8c                           FCB  SKP2           ; SKIP 2 BYTES
3259                         
3260                         * REM, ELSE
3261                         ELSE
3262 d693 8d 06              REM       BSR  LAEEB          ; MOVE INPUT POINTER TO END OF LINE
3263 d695 9f 83                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3264 d697 39                 LAEE7     RTS
3265                         * ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE
3266 d698 c6 3a              LAEE8     LDB  #':            ; COLON = SUBLINE TERMINATOR CHARACTER
3267 d69a 86                 LAEEA     FCB  SKP1LD         ; SKPILD SKIP ONE BYTE; LDA #$5F
3268                         * ADVANCE BASIC'S INPUT POINTER TO END OF
3269                         * LINE - RETURN ADDRESS OF END OF LINE+1 IN X
3270 d69b 5f                 LAEEB     CLRB                ; 0 = LINE TERMINATOR CHARACTER
3271 d69c d7 01                        STB  CHARAC         ; TEMP STORE PRIMARY TERMINATOR CHARACTER
3272 d69e 5f                           CLRB                ; 0 (END OF LINE) = ALTERNATE TERM. CHAR.
3273 d69f 9e 83                        LDX  CHARAD         ; LOAD X W/BASIC'S INPUT POINTER
3274 d6a1 1f 98              LAEF1     TFR  B,A            ; * CHANGE TERMINATOR CHARACTER
3275 d6a3 d6 01                        LDB  CHARAC         ; * FROM ACCB TO CHARAC - SAVE OLD TERMINATOR
3276                         *         IN   CHARAC
3277 d6a5 97 01                        STA  CHARAC         ; SWAP PRIMARY AND SECONDARY TERMINATORS
3278 d6a7 a6 84              LAEF7     LDA  ,X             ; GET NEXT INPUT CHARACTER
3279 d6a9 27 ec                        BEQ  LAEE7          ; RETURN IF 0 (END OF LINE)
3280 d6ab 34 04                        PSHS B              ; SAVE TERMINATOR ON STACK
3281 d6ad a1 e0                        CMPA ,S+            ; COMPARE TO INPUT CHARACTER
3282 d6af 27 e6                        BEQ  LAEE7          ; RETURN IF EQUAL
3283 d6b1 30 01                        LEAX 1,X            ; MOVE POINTER UP ONE
3284 d6b3 81 22                        CMPA #'"            ; CHECK FOR DOUBLE QUOTES
3285 d6b5 27 ea                        BEQ  LAEF1          ; BRANCH IF " - TOGGLE TERMINATOR CHARACTERS
3286 d6b7 4c                           INCA                ; * CHECK FOR $FF AND BRANCH IF
3287 d6b8 26 02                        BNE  LAF0C          ; * NOT SECONDARY TOKEN
3288 d6ba 30 01                        LEAX 1,X            ; MOVE INPUT POINTER 1 MORE IF SECONDARY
3289 d6bc 81 86              LAF0C     CMPA #TOK_IF+1      ; TOKEN FOR IF?
3290 d6be 26 e7                        BNE  LAEF7          ; NO - GET ANOTHER INPUT CHARACTER
3291 d6c0 0c 04                        INC  IFCTR          ; INCREMENT IF COUNTER - KEEP TRACK OF HOW MANY
3292                         *                             ; 'IF' STATEMENTS ARE NESTED IN ONE LINE
3293 d6c2 20 e3                        BRA  LAEF7          ; GET ANOTHER INPUT CHARACTER
3294                         
3295                         * IF
3296 d6c4 bd d8 cd           IF        JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
3297 d6c7 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3298 d6c9 81 81                        CMPA #TOK_GO        ; TOKEN FOR GO
3299 d6cb 27 05                        BEQ  LAF22          ; TREAT 'GO' THE SAME AS 'THEN'
3300 d6cd c6 a2                        LDB  #TOK_THEN      ; TOKEN FOR THEN
3301 d6cf bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK ON ACCB
3302 d6d2 96 4f              LAF22     LDA  FP0EXP         ; CHECK FOR TRUE/FALSE - FALSE IF FPA0 EXPONENT = ZERO
3303 d6d4 26 13                        BNE  LAF39          ; BRANCH IF CONDITION TRUE
3304 d6d6 0f 04                        CLR  IFCTR          ; CLEAR FLAG - KEEP TRACK OF WHICH NESTED ELSE STATEMENT
3305                         *                             ; TO SEARCH FOR IN NESTED 'IF' LOOPS
3306 d6d8 8d b6              LAF28     BSR  DATA           ; MOVE BASIC'S POINTER TO END OF SUBLINE
3307 d6da 4d                           TSTA                ; * CHECK TO SEE IF END OF LINE OR SUBLINE
3308 d6db 27 ba                        BEQ  LAEE7          ; * AND RETURN IF END OF LINE
3309 d6dd 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
3310 d6df 81 84                        CMPA #TOK_ELSE      ; TOKEN FOR ELSE
3311 d6e1 26 f5                        BNE  LAF28          ; IGNORE ALL DATA EXCEPT 'ELSE' UNTIL
3312                         *                             ; END OF LINE (ZERO BYTE)
3313 d6e3 0a 04                        DEC  IFCTR          ; CHECK TO SEE IF YOU MUST SEARCH ANOTHER SUBLINE
3314 d6e5 2a f1                        BPL  LAF28          ; BRANCH TO SEARCH ANOTHER SUBLINE FOR 'ELSE'
3315 d6e7 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
3316 d6e9 9d 82              LAF39     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3317 d6eb 10 25 ff 65                  LBCS LAEA4          ; BRANCH TO 'GOTO' IF NUMERIC CHARACTER
3318 d6ef 7e d5 7a                     JMP  LADC6          ; RETURN TO MAIN INTERPRETATION LOOP
3319                         
3320                         * ON
3321 d6f2 bd de 92           ON        JSR  LB70B          ; EVALUATE EXPRESSION
3322 d6f5 c6 81                        LDB  #TOK_GO        ; TOKEN FOR GO
3323 d6f7 bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR GO
3324 d6fa 34 02                        PSHS A              ; SAVE NEW TOKEN (TO,SUB)
3325 d6fc 81 a1                        CMPA #TOK_SUB       ; TOKEN FOR SUB?
3326 d6fe 27 04                        BEQ  LAF54          ; YES
3327 d700 81 a0                        CMPA #TOK_TO        ; TOKEN FOR TO?
3328 d702 26 83              LAF52     BNE  LAED7          ; 'SYNTAX' ERROR IF NOT 'SUB' OR 'TO'
3329 d704 0a 53              LAF54     DEC  FPA0+3         ; DECREMENT IS BYTE OF MANTISSA OF FPA0 - THIS
3330                         *                             ; IS THE ARGUMENT OF THE 'ON' STATEMENT
3331 d706 26 05                        BNE  LAF5D          ; BRANCH IF NOT AT THE PROPER GOTO OR GOSUB LINE NUMBER
3332 d708 35 04                        PULS B              ; GET BACK THE TOKEN FOLLOWING 'GO'
3333 d70a 7e d6 38                     JMP  LAE88          ; GO DO A 'GOTO' OR 'GOSUB'
3334 d70d 9d 7c              LAF5D     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3335 d70f 8d 06                        BSR  LAF67          ; CONVERT BASIC LINE NUMBER TO BINARY
3336 d711 81 2c                        CMPA #',            ; IS CHARACTER FOLLOWING LINE NUMBER A COMMA?
3337 d713 27 ef                        BEQ  LAF54          ; YES
3338 d715 35 84                        PULS B,PC           ; IF NOT, FALL THROUGH TO NEXT COMMAND
3339 d717 9e 74              LAF67     LDX  ZERO           ; DEFAULT LINE NUMBER OF ZERO
3340 d719 9f 2b                        STX  BINVAL         ; SAVE IT IN BINVAL
3341                         *
3342                         * CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINVAL
3343                         *
3344 d71b 24 61              LAF6B     BCC  LAFCE          ; RETURN IF NOT NUMERIC CHARACTER
3345 d71d 80 30                        SUBA #'0            ; MASK OFF ASCII
3346 d71f 97 01                        STA  CHARAC         ; SAVE DIGIT IN VO1
3347 d721 dc 2b                        LDD  BINVAL         ; GET ACCUMULATED LINE NUMBER VALUE
3348 d723 81 18                        CMPA #24            ; LARGEST LINE NUMBER IS $F9FF (63999) -
3349                         *         (24*256+255)*10+9
3350 d725 22 db                        BHI  LAF52          ; 'SYNTAX' ERROR IF TOO BIG
3351                         * MULT ACCD X 10
3352 d727 58                           ASLB                ; *
3353 d728 49                           ROLA                ; * TIMES 2
3354 d729 58                           ASLB                ; =
3355 d72a 49                           ROLA                ; = TIMES 4
3356 d72b d3 2b                        ADDD BINVAL         ; ADD 1 = TIMES 5
3357 d72d 58                           ASLB                ; *
3358 d72e 49                           ROLA                ; * TIMES 10
3359 d72f db 01                        ADDB CHARAC         ; ADD NEXT DIGIT
3360 d731 89 00                        ADCA #0             ; PROPAGATE CARRY
3361 d733 dd 2b                        STD  BINVAL         ; SAVE NEW ACCUMULATED LINE NUMBER
3362 d735 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
3363 d737 20 e2                        BRA  LAF6B          ; LOOP- PROCESS NEXT DIGIT
3364                         *
3365                         * LET (EXBAS)
3366                         * EVALUATE A NON-TOKEN EXPRESSION
3367                         * TARGET = REPLACEMENT
3368 d739 bd da de           LET       JSR  LB357          ; FIND TARGET VARIABLE DESCRIPTOR
3369 d73c 9f 3b                        STX  VARDES         ; SAVE DESCRIPTOR ADDRESS OF 1ST EXPRESSION
3370 d73e c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR "="
3371 d740 bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR '='
3372 d743 96 06                        LDA  VALTYP         ; * GET VARIABLE TYPE AND
3373 d745 34 02                        PSHS A              ; * SAVE ON THE STACK
3374 d747 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
3375 d74a 35 02                        PULS A              ; * REGET VARIABLE TYPE OF 1ST EXPRESSION AND
3376 d74c 46                           RORA                ; * SET CARRY IF STRING
3377 d74d bd d8 d4                     JSR  LB148          ; TYPE CHECK-TM ERROR IF VARIABLE TYPES ON
3378                         *                             ; BOTH SIDES OF EQUALS SIGN NOT THE SAME
3379 d750 10 27 0c 2b                  LBEQ LBC33          ; GO PUT FPA0 INTO VARIABLE DESCRIPTOR IF NUMERIC
3380                         * MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT
3381                         * FPA0+2 INTO THE STRING SPACE. TRANSFER THE
3382                         * DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES
3383                         * DON'T MOVE THE STRING IF IT IS ALREADY IN THE
3384                         * STRING SPACE. REMOVE DESCRIPTOR FROM STRING
3385                         * STACK IF IT IS LAST ONE ON THE STACK
3386 d754 9e 52              LAFA4     LDX  FPA0+2         ; POINT X TO DESCRIPTOR OF REPLACEMENT STRING
3387 d756 dc 21                        LDD  FRETOP         ; LOAD ACCD WITH START OF STRING SPACE
3388 d758 10 a3 02                     CMPD 2,X            ; IS THE STRING IN STRING SPACE?
3389 d75b 24 11                        BCC  LAFBE          ; BRANCH IF IT'S NOT IN THE STRING SPACE
3390 d75d 9c 1b                        CMPX VARTAB         ; COMPARE DESCRIPTOR ADDRESS TO START OF VARIABLES
3391 d75f 25 0d                        BCS  LAFBE          ; BRANCH IF DESCRIPTOR ADDRESS NOT IN VARIABLES
3392 d761 e6 84              LAFB1     LDB  ,X             ; GET LENGTH OF REPLACEMENT STRING
3393 d763 bd dc 94                     JSR  LB50D          ; RESERVE ACCB BYTES OF STRING SPACE
3394 d766 9e 4d                        LDX  V4D            ; GET DESCRIPTOR ADDRESS BACK
3395 d768 bd dd ca                     JSR  LB643          ; MOVE STRING INTO STRING SPACE
3396 d76b 8e 00 56                     LDX  #STRDES        ; POINT X TO TEMP STRING DESCRIPTOR ADDRESS
3397 d76e 9f 4d              LAFBE     STX  V4D            ; SAVE STRING DESCRIPTOR ADDRESS IN V4D
3398 d770 bd dd fc                     JSR  LB675          ; REMOVE STRING DESCRIPTOR IF LAST ONE
3399                         *              ; ON STRING STACK
3400 d773 de 4d                        LDU  V4D            ; POINT U TO REPLACEMENT DESCRIPTOR ADDRESS
3401 d775 9e 3b                        LDX  VARDES         ; GET TARGET DESCRIPTOR ADDRESS
3402 d777 37 26                        PULU A,B,Y          ; GET LENGTH AND START OF REPLACEMENT STRING
3403 d779 a7 84                        STA  ,X             ; * SAVE STRING LENGTH AND START IN
3404 d77b 10 af 02                     STY  2,X            ; * TARGET DESCRIPTOR LOCATION
3405 d77e 39                 LAFCE     RTS
3406                         
3407 d77f 3f 52 45 44 4f     LAFCF     FCC  "?REDO"        ; ?REDO MESSAGE
3408 d784 0d 00                        FCB  CR,$00
3409                         
3410                         LAFD6
3411 d786 7e d4 06           LAFDC     JMP  LAC46          ; JMP TO ERROR HANDLER
3412 d789 96 09              LAFDF     LDA  INPFLG         ; = GET THE INPUT FLAG AND BRANCH
3413 d78b 27 07                        BEQ  LAFEA          ; = IF 'INPUT'
3414 d78d 9e 31                        LDX  DATTXT         ; * GET LINE NUMBER WHERE THE ERROR OCCURRED
3415 d78f 9f 68                        STX  CURLIN         ; * AND USE IT AS THE CURRENT LINE NUMBER
3416 d791 7e da 03                     JMP  LB277          ; 'SYNTAX ERROR'
3417 d794 8e d7 7e           LAFEA     LDX  #LAFCF-1       ; * POINT X TO '?REDO' AND PRINT
3418 d797 bd e0 e8                     JSR  LB99C          ; * IT ON THE SCREEN
3419 d79a 9e 2f                        LDX  TINPTR         ; = GET THE SAVED ABSOLUTE ADDRESS OF
3420 d79c 9f 83                        STX  CHARAD         ; = INPUT POINTER AND RESTORE IT
3421 d79e 39                           RTS
3422                         *
3423                         * INPUT
3424 d79f c6 16              INPUT     LDB  #11*2          ; 'ID' ERROR
3425 d7a1 9e 68                        LDX  CURLIN         ; GET CURRENT LINE NUMBER
3426 d7a3 30 01                        LEAX 1,X            ; ADD ONE
3427 d7a5 27 df                        BEQ  LAFDC          ; 'ID' ERROR BRANCH IF DIRECT MODE
3428 d7a7 8d 01                        BSR  LB00F          ; GET SOME INPUT DATA - WAS LB002
3429 d7a9 39                           RTS
3430 d7aa 81 22              LB00F     CMPA #'"            ; CHECK FOR PROMPT STRING DELIMITER
3431 d7ac 26 0b                        BNE  LB01E          ; BRANCH IF NO PROMPT STRING
3432 d7ae bd d9 d0                     JSR  LB244          ; PUT PROMPT STRING ON STRING STACK
3433 d7b1 c6 3b                        LDB  #';            ; *
3434 d7b3 bd d9 fb                     JSR  LB26F          ; * DO A SYNTAX CHECK FOR SEMICOLON
3435 d7b6 bd e0 eb                     JSR  LB99F          ; PRINT MESSAGE TO CONSOLE OUT
3436 d7b9 8e 00 f3           LB01E     LDX  #LINBUF        ; POINT TO BASIC'S LINE BUFFER
3437 d7bc 6f 84                        CLR  ,X             ; CLEAR 1ST BYTE - FLAG TO INDICATE NO DATA
3438                         *              ; IN LINE BUFFER
3439 d7be 8d 06                        BSR  LB02F          ; INPUT A STRING TO LINE BUFFER
3440 d7c0 c6 2c                        LDB  #',            ; * INSERT A COMMA AT THE END
3441 d7c2 e7 84                        STB  ,X             ; * OF THE LINE INPUT BUFFER
3442 d7c4 20 16                        BRA  LB049
3443                         * FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
3444 d7c6 bd e0 fb           LB02F     JSR  LB9AF          ; SEND A "?" TO CONSOLE OUT
3445 d7c9 bd e0 f8                     JSR  LB9AC          ; SEND A 'SPACE' TO CONSOLE OUT
3446 d7cc bd d1 41           LB035     JSR  LA390          ; GO READ IN A BASIC LINE
3447 d7cf 24 05                        BCC  LB03F          ; BRANCH IF ENTER KEY ENDED ENTRY
3448 d7d1 32 64                        LEAS 4,S            ; PURGE TWO RETURN ADDRESSES OFF THE STACK
3449 d7d3 7e d5 c9                     JMP  LAE11          ; GO DO A 'STOP' IF BREAK KEY ENDED LINE ENTRY
3450 d7d6 c6 2e              LB03F     LDB  #2*23          ; 'INPUT PAST END OF FILE' ERROR
3451 d7d8 39                           RTS
3452                         *
3453                         * READ
3454 d7d9 9e 33              READ      LDX  DATPTR         ; GET 'READ' START ADDRESS
3455 d7db 86                           FCB  SKP1LD         ; SKIP ONE BYTE - LDA #*$4F
3456 d7dc 4f                 LB049     CLRA                ; 'INPUT' ENTRY POINT: INPUT FLAG = 0
3457 d7dd 97 09                        STA  INPFLG         ; SET INPUT FLAG; 0 = INPUT: <> 0 = READ
3458 d7df 9f 35                        STX  DATTMP         ; SAVE 'READ' START ADDRESS/'INPUT' BUFFER START
3459 d7e1 bd da de           LB04E     JSR  LB357          ; EVALUATE A VARIABLE
3460 d7e4 9f 3b                        STX  VARDES         ; SAVE DESCRIPTOR ADDRESS
3461 d7e6 9e 83                        LDX  CHARAD         ; * GET BASIC'S INPUT POINTER
3462 d7e8 9f 2b                        STX  BINVAL         ; * AND SAVE IT
3463 d7ea 9e 35                        LDX  DATTMP         ; GET 'READ' ADDRESS START/'INPUT' BUFFER POINTER
3464 d7ec a6 84                        LDA  ,X             ; GET A CHARACTER FROM THE BASIC PROGRAM
3465 d7ee 26 09                        BNE  LB069          ; BRANCH IF NOT END OF LINE
3466 d7f0 96 09                        LDA  INPFLG         ; * CHECK INPUT FLAG AND BRANCH
3467 d7f2 26 51                        BNE  LB0B9          ; * IF LOOKING FOR DATA (READ)
3468                         * NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
3469                         * NOT COMING FROM SCREEN
3470 d7f4 bd e0 fb                     JSR  LB9AF          ; SEND A '?' TO CONSOLE OUT
3471 d7f7 8d cd                        BSR  LB02F          ; FILL INPUT BUFFER FROM CONSOLE IN
3472 d7f9 9f 83              LB069     STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3473 d7fb 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
3474 d7fd d6 06                        LDB  VALTYP         ; * CHECK VARIABLE TYPE AND
3475 d7ff 27 23                        BEQ  LB098          ; * BRANCH IF NUMERIC
3476                         * READ/INPUT A STRING VARIABLE
3477 d801 9e 83                        LDX  CHARAD         ; LOAD X WITH CURRENT BASIC INPUT POINTER
3478 d803 97 01                        STA  CHARAC         ; SAVE CURRENT INPUT CHARACTER
3479 d805 81 22                        CMPA #'"            ; CHECK FOR STRING DELIMITER
3480 d807 27 0e                        BEQ  LB08B          ; BRANCH IF STRING DELIMITER
3481 d809 30 1f                        LEAX -1,X           ; BACK UP POINTER
3482 d80b 4f                           CLRA                ; * ZERO = END OF LINE CHARACTER
3483 d80c 97 01                        STA  CHARAC         ; * SAVE AS TERMINATOR
3484 d80e bd d1 33                     JSR  LA35F          ; SET UP PRINT PARAMETERS
3485 d811 86 3a                        LDA  #':            ; END OF SUBLINE CHARACTER
3486 d813 97 01                        STA  CHARAC         ; SAVE AS TERMINATOR I
3487 d815 86 2c                        LDA  #',            ; COMMA
3488 d817 97 02              LB08B     STA  ENDCHR         ; SAVE AS TERMINATOR 2
3489 d819 bd dc a5                     JSR  LB51E          ; STRIP A STRING FROM THE INPUT BUFFER
3490 d81c bd d9 d5                     JSR  LB249          ; MOVE INPUT POINTER TO END OF STRING
3491 d81f bd d7 54                     JSR  LAFA4          ; PUT A STRING INTO THE STRING SPACE IF NECESSARY
3492 d822 20 06                        BRA  LB09E          ; CHECK FOR ANOTHER DATA ITEM
3493                         * SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM
3494 d824 bd e4 5e           LB098     JSR  LBD12          ; CONVERT AN ASCII STRING TO FP NUMBER
3495 d827 bd e3 7f                     JSR  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS IN VARDES -
3496                         *                             ; INPUT OR READ DATA ITEM
3497 d82a 9d 82              LB09E     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3498 d82c 27 06                        BEQ  LB0A8          ; BRANCH IF END OF LINE
3499 d82e 81 2c                        CMPA #',            ; CHECK FOR A COMMA
3500 d830 10 26 ff 52                  LBNE LAFD6          ; BAD FILE DATA' ERROR OR RETRY
3501 d834 9e 83              LB0A8     LDX  CHARAD         ; * GET CURRENT INPUT
3502 d836 9f 35                        STX  DATTMP         ; * POINTER (USED AS A DATA POINTER) AND SAVE IT
3503 d838 9e 2b                        LDX  BINVAL         ; * RESET INPUT POINTER TO INPUT OR
3504 d83a 9f 83                        STX  CHARAD         ; * READ STATEMENT
3505 d83c 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
3506 d83e 27 21                        BEQ  LB0D5          ; BRANCH IF END OF LINE - EXIT COMMAND
3507 d840 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
3508 d843 20 9c                        BRA  LB04E          ; GET ANOTHER INPUT OR READ ITEM
3509                         * SEARCH FROM ADDRESS IN X FOR
3510                         * 1ST OCCURENCE OF THE TOKEN FOR DATA
3511 d845 9f 83              LB0B9     STX  CHARAD         ; RESET BASIC'S INPUT POINTER
3512 d847 bd d6 98                     JSR  LAEE8          ; SEARCH FOR END OF CURRENT LINE OR SUBLINE
3513 d84a 30 01                        LEAX 1,X            ; MOVE X ONE PAST END OF LINE
3514 d84c 4d                           TSTA                ; CHECK FOR END OF LINE
3515 d84d 26 0a                        BNE  LB0CD          ; BRANCH IF END OF SUBLINE
3516 d84f c6 06                        LDB  #2*3           ; 'OUT OF DATA' ERROR
3517 d851 ee 81                        LDU  ,X++           ; GET NEXT 2 CHARACTERS
3518 d853 27 41                        BEQ  LB10A          ; 'OD' ERROR IF END OF PROGRAM
3519 d855 ec 81                        LDD  ,X++           ; GET BASIC LINE NUMBER AND
3520 d857 dd 31                        STD  DATTXT         ; SAVE IT IN DATTXT
3521 d859 a6 84              LB0CD     LDA  ,X             ; GET AN INPUT CHARACTER
3522 d85b 81 86                        CMPA #TOK_DATA      ; DATA TOKEN?
3523 d85d 26 e6                        BNE  LB0B9          ; NO - KEEP LOOKING
3524 d85f 20 98                        BRA  LB069          ; YES
3525                         * EXIT READ AND INPUT COMMANDS
3526 d861 9e 35              LB0D5     LDX  DATTMP         ; GET DATA POINTER
3527 d863 d6 09                        LDB  INPFLG         ; * CHECK INPUT FLAG
3528 d865 10 26 fd 3a                  LBNE LADE8          ; * SAVE NEW DATA POINTER IF READ
3529 d869 a6 84                        LDA  ,X             ; = CHECK NEXT CHARACTER IN 'INPUT' BUFFER
3530 d86b 27 06                        BEQ  LB0E7          ; =
3531 d86d 8e d8 73                     LDX  #LB0E8-1       ; POINT X TO '?EXTRA IGNORED'
3532 d870 7e e0 e8                     JMP  LB99C          ; PRINT THE MESSAGE
3533 d873 39                 LB0E7     RTS
3534                         
3535 d874 3f 45 58 54 52 41  LB0E8     FCC  "?EXTRA IGNORED" ; ?EXTRA IGNORED MESSAGE
     20 49 47 4e 4f 52
     45 44
3536                         
3537                         
3538 d882 0d 00                        FCB  CR,$00
3539                         
3540                         * NEXT
3541 d884 26 04              NEXT      BNE  LB0FE          ; BRANCH IF ARGUMENT GIVEN
3542 d886 9e 74                        LDX  ZERO           ; X = 0: DEFAULT FOR NO ARGUMENT
3543 d888 20 03                        BRA  LB101
3544 d88a bd da de           LB0FE     JSR  LB357          ; EVALUATE AN ALPHA EXPRESSION
3545 d88d 9f 3b              LB101     STX  VARDES         ; SAVE VARIABLE DESCRIPTOR POINTER
3546 d88f bd d3 b9                     JSR  LABF9          ; GO SCAN FOR 'FOR/NEXT' DATA ON STACK
3547 d892 27 04                        BEQ  LB10C          ; BRANCH IF DATA FOUND
3548 d894 c6 00                        LDB  #0             ; 'NEXT WITHOUT FOR' ERROR (SHOULD BE CLRB)
3549 d896 20 47              LB10A     BRA  LB153          ; PROCESS ERROR
3550 d898 1f 14              LB10C     TFR  X,S            ; POINT S TO START OF 'FOR/NEXT' DATA
3551 d89a 30 03                        LEAX 3,X            ; POINT X TO FP VALUE OF STEP
3552 d89c bd e3 60                     JSR  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
3553 d89f a6 68                        LDA  8,S            ; GET THE DIRECTION OF STEP
3554 d8a1 97 54                        STA  FP0SGN         ; SAVE IT AS THE SIGN OF FPA0
3555 d8a3 9e 3b                        LDX  VARDES         ; POINT (X) TO INDEX VARIABLE DESCRIPTOR
3556 d8a5 bd e1 0e                     JSR  LB9C2          ; ADD (X) TO FPA0 (STEP TO INDEX)
3557 d8a8 bd e3 7f                     JSR  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS
3558                         *                             ; CONTAINED IN VARDES
3559 d8ab 30 69                        LEAX 9,S            ; POINT (X) TO TERMINAL VALUE OF INDEX
3560 d8ad bd e3 e2                     JSR  LBC96          ; COMPARE CURRENT INDEX VALUE TO TERMINAL VALUE OF INDEX
3561 d8b0 e0 68                        SUBB 8,S            ; ACCB = 0 IF TERMINAL VALUE=CURRENT VALUE AND STEP=0 OR IF
3562                         *                             ; STEP IS POSITIVE AND CURRENT VALUE>TERMINAL VALUE OR
3563                         *                             ; STEP IS NEGATIVE AND CURRENT VALUE<TERMINAL VALUE
3564 d8b2 27 0c                        BEQ  LB134          ; BRANCH IF 'FOR/NEXT' LOOP DONE
3565 d8b4 ae 6e                        LDX  14,S           ; * GET LINE NUMBER AND
3566 d8b6 9f 68                        STX  CURLIN         ; * BASIC POINTER OF
3567 d8b8 ae e8 10                     LDX  16,S           ; * STATEMENT FOLLOWING THE
3568 d8bb 9f 83                        STX  CHARAD         ; * PROPER FOR STATEMENT
3569 d8bd 7e d5 42           LB131     JMP  LAD9E          ; JUMP BACK TO COMMAND INTEPR. LOOP
3570 d8c0 32 e8 12           LB134     LEAS 18,S           ; PULL THE 'FOR-NEXT' DATA OFF THE STACK
3571 d8c3 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3572 d8c5 81 2c                        CMPA #',            ; CHECK FOR ANOTHER ARGUMENT
3573 d8c7 26 f4                        BNE  LB131          ; RETURN IF NONE
3574 d8c9 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
3575 d8cb 8d bd                        BSR  LB0FE          ; BSR SIMULATES A CALL TO 'NEXT' FROM COMMAND LOOP
3576                         
3577                         
3578 d8cd 8d 13              LB141     BSR  LB156          ; EVALUATE EXPRESSION AND DO A TYPE CHECK FOR NUMERIC
3579 d8cf 1c fe              LB143     ANDCC #$FE          ; CLEAR CARRY FLAG
3580 d8d1 7d                 LB145     FCB  $7D            ; OP CODE OF TST $1A01 - SKIP TWO BYTES (DO
3581                         *              ; NOT CHANGE CARRY FLAG)
3582 d8d2 1a 01              LB146     ORCC #1             ; SET CARRY
3583                         
3584                         * STRING TYPE MODE CHECK - IF ENTERED AT LB146 THEN VALTYP PLUS IS 'TM' ERROR
3585                         * NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN VALTYP MINUS IS 'TM' ERROR
3586                         * IF ENTERED AT LB148, A TYPE CHECK IS DONE ON VALTYP
3587                         * IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERIC
3588                         * IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRING.
3589 d8d4 0d 06              LB148     TST  VALTYP         ; TEST TYPE FLAG; DO NOT CHANGE CARRY
3590 d8d6 25 03                        BCS  LB14F          ; BRANCH IF STRING
3591 d8d8 2a 99                        BPL  LB0E7          ; RETURN ON PLUS
3592 d8da 8c                           FCB  SKP2           ; SKIP 2 BYTES - 'TM' ERROR
3593 d8db 2b 96              LB14F     BMI  LB0E7          ; RETURN ON MINUS
3594 d8dd c6 18                        LDB  #12*2          ; 'TYPE M1SMATCH' ERROR
3595 d8df 7e d4 06           LB153     JMP  LAC46          ; PROCESS ERROR
3596                         * EVALUATE EXPRESSION
3597 d8e2 8d 6e              LB156     BSR  LB1C6          ; BACK UP INPUT POINTER
3598 d8e4 4f                 LB158     CLRA                ; END OF OPERATION PRECEDENCE FLAG
3599 d8e5 8c                           FCB  SKP2           ; SKIP TWO BYTES
3600 d8e6 34 04              LB15A     PSHS B              ; SAVE FLAG (RELATIONAL OPERATOR FLAG)
3601 d8e8 34 02                        PSHS A              ; SAVE FLAG (PRECEDENCE FLAG)
3602 d8ea c6 01                        LDB  #1             ; *
3603 d8ec bd d3 f3                     JSR  LAC33          ; * SEE IF ROOM IN FREE RAM FOR (B) WORDS
3604 d8ef bd d9 af                     JSR  LB223          ; GO EVALUATE AN EXPRESSION
3605 d8f2 0f 3f                        CLR  TRELFL         ; RESET RELATIONAL OPERATOR FLAG
3606 d8f4 9d 82              LB168     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3607                         * CHECK FOR RELATIONAL OPERATORS
3608 d8f6 80 ad              LB16A     SUBA #TOK_GREATER   ; TOKEN FOR >
3609 d8f8 25 13                        BCS  LB181          ; BRANCH IF LESS THAN RELATIONAL OPERATORS
3610 d8fa 81 03                        CMPA #3             ; *
3611 d8fc 24 0f                        BCC  LB181          ; * BRANCH IF GREATER THAN RELATIONAL OPERATORS
3612 d8fe 81 01                        CMPA #1             ; SET CARRY IF '>'
3613 d900 49                           ROLA                ; CARRY TO BIT 0
3614 d901 98 3f                        EORA TRELFL         ; * CARRY SET IF
3615 d903 91 3f                        CMPA TRELFL         ; * TRELFL = ACCA
3616 d905 25 64                        BCS  LB1DF          ; BRANCH IF SYNTAX ERROR : == << OR >>
3617 d907 97 3f                        STA  TRELFL         ; BIT 0: >, BIT 1 =, BIT 2: <
3618 d909 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER
3619 d90b 20 e9                        BRA  LB16A          ; CHECK FOR ANOTHER RELATIONAL OPERATOR
3620                         *
3621 d90d d6 3f              LB181     LDB  TRELFL         ; GET RELATIONAL OPERATOR FLAG
3622 d90f 26 33                        BNE  LB1B8          ; BRANCH IF RELATIONAL COMPARISON
3623 d911 10 24 00 6b                  LBCC LB1F4          ; BRANCH IF > RELATIONAL OPERATOR
3624 d915 8b 07                        ADDA #7             ; SEVEN ARITHMETIC/LOGICAL OPERATORS
3625 d917 24 67                        BCC  LB1F4          ; BRANCH IF NOT ARITHMETIC/LOGICAL OPERATOR
3626 d919 99 06                        ADCA VALTYP         ; ADD CARRY, NUMERIC FLAG AND MODIFIED TOKEN NUMBER
3627 d91b 10 27 04 77                  LBEQ LB60F          ; BRANCH IF VALTYP = FF, AND ACCA = '+' TOKEN -
3628                         *                             ; CONCATENATE TWO STRINGS
3629 d91f 89 ff                        ADCA #-1            ; RESTORE ARITHMETIC/LOGICAL OPERATOR NUMBER
3630 d921 34 02                        PSHS A              ; * STORE OPERATOR NUMBER ON STACK; MULTIPLY IT BY 2
3631 d923 48                           ASLA                ; * THEN ADD THE STORED STACK DATA = MULTIPLY
3632 d924 ab e0                        ADDA ,S+            ; * X 3; 3 BYTE/TABLE ENTRY
3633 d926 8e d2 0b                     LDX  #LAA51         ; JUMP TABLE FOR ARITHMETIC & LOGICAL OPERATORS
3634 d929 30 86                        LEAX A,X            ; POINT X TO PROPER TABLE
3635 d92b 35 02              LB19F     PULS A              ; GET PRECEDENCE FLAG FROM STACK
3636 d92d a1 84                        CMPA ,X             ; COMPARE TO CURRENT OPERATOR
3637 d92f 24 55                        BCC  LB1FA          ; BRANCH IF STACK OPERATOR > CURRENT OPERATOR
3638 d931 8d 9c                        BSR  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
3639                         
3640                         * OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE THAN THE PREVIOUS OPERATION.
3641 d933 34 02              LB1A7     PSHS A              ; SAVE PRECEDENCE FLAG
3642 d935 8d 29                        BSR  LB1D4          ; PUSH OPERATOR ROUTINE ADDRESS AND FPA0 ONTO STACK
3643 d937 9e 3d                        LDX  RELPTR         ; GET POINTER TO ARITHMETIC/LOGICAL TABLE ENTRY FOR
3644                         *                             ; LAST CALCULATED OPERATION
3645 d939 35 02                        PULS A              ; GET PRECEDENCE FLAG OF PREVIOUS OPERATION
3646 d93b 26 1d                        BNE  LB1CE          ; BRANCH IF NOT END OF OPERATION
3647 d93d 4d                           TSTA                ; CHECK TYPE OF PRECEDENCE FLAG
3648 d93e 10 27 00 6a                  LBEQ LB220          ; BRANCH IF END OF EXPRESSION OR SUB-EXPRESSION
3649 d942 20 4b                        BRA  LB203          ; EVALUATE AN OPERATION
3650                         
3651 d944 08 06              LB1B8     ASL  VALTYP         ; BIT 7 OF TYPE FLAG TO CARRY
3652 d946 59                           ROLB                ; SHIFT RELATIONAL FLAG LEFT - VALTYP TO BIT 0
3653 d947 8d 09                        BSR  LB1C6          ; MOVE THE INPUT POINTER BACK ONE
3654 d949 8e d9 57                     LDX  #LB1CB         ; POINT X TO RELATIONAL COMPARISON JUMP TABLE
3655 d94c d7 3f                        STB  TRELFL         ; SAVE RELATIONAL COMPARISON DATA
3656 d94e 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
3657 d950 20 d9                        BRA  LB19F          ; PERFORM OPERATION OR SAVE ON STACK
3658                         
3659 d952 9e 83              LB1C6     LDX  CHARAD         ; * GET BASIC'S INPUT POINTER AND
3660 d954 7e d6 6b                     JMP  LAEBB          ; * MOVE IT BACK ONE
3661                         * RELATIONAL COMPARISON JUMP TABLE
3662 d957 64                 LB1CB     FCB  $64            ; RELATIONAL COMPARISON FLAG
3663 d958 da 7b              LB1CC     FDB  LB2F4          ; JUMP ADDRESS
3664                         
3665 d95a a1 84              LB1CE     CMPA ,X             ; COMPARE PRECEDENCE OF LAST DONE OPERATION TO
3666                         *         NEXT TO BE DONE OPERATION
3667 d95c 24 31                        BCC  LB203          ; EVALUATE OPERATION IF LOWER PRECEDENCE
3668 d95e 20 d3                        BRA  LB1A7          ; PUSH OPERATION DATA ON STACK IF HIGHER PRECEDENCE
3669                         
3670                         * PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK AND EVALUATE ANOTHER EXPR
3671 d960 ec 01              LB1D4     LDD  1,X            ; GET ADDRESS OF OPERATOR ROUTINE
3672 d962 34 06                        PSHS B,A            ; SAVE IT ON THE STACK
3673 d964 8d 08                        BSR  LB1E2          ; PUSH FPA0 ONTO STACK
3674 d966 d6 3f                        LDB  TRELFL         ; GET BACK RELATIONAL OPERATOR FLAG
3675 d968 16 ff 7b                     LBRA LB15A          ; EVALUATE ANOTHER EXPRESSION
3676 d96b 7e da 03           LB1DF     JMP  LB277          ; 'SYNTAX ERROR'
3677                         * PUSH FPA0 ONTO THE STACK. ,S   = EXPONENT
3678                         * 1-2,S =HIGH ORDER MANTISSA 3-4,S = LOW ORDER MANTISSA
3679                         * 5,S = SIGN RETURN WITH PRECEDENCE CODE IN ACCA
3680 d96e d6 54              LB1E2     LDB  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
3681 d970 a6 84                        LDA  ,X             ; GET PRECEDENCE CODE TO ACCA
3682 d972 35 20              LB1E6     PULS Y              ; GET RETURN ADDRESS FROM STACK & PUT IT IN Y
3683 d974 34 04                        PSHS B              ; SAVE ACCB ON STACK
3684 d976 d6 4f              LB1EA     LDB  FP0EXP         ; * PUSH FPA0 ONTO THE STACK
3685 d978 9e 50                        LDX  FPA0           ; *
3686 d97a de 52                        LDU  FPA0+2         ; *
3687 d97c 34 54                        PSHS U,X,B          ; *
3688 d97e 6e a4                        JMP  ,Y             ; JUMP TO ADDRESS IN Y
3689                         
3690                         * BRANCH HERE IF NON-OPERATOR CHARACTER FOUND - USUALLY ')' OR END OF LINE
3691 d980 9e 74              LB1F4     LDX  ZERO           ; POINT X TO DUMMY VALUE (ZERO)
3692 d982 a6 e0                        LDA  ,S+            ; GET PRECEDENCE FLAG FROM STACK
3693 d984 27 26                        BEQ  LB220          ; BRANCH IF END OF EXPRESSION
3694 d986 81 64              LB1FA     CMPA #$64           ; * CHECK FOR RELATIONAL COMPARISON FLAG
3695 d988 27 03                        BEQ  LB201          ; * AND BRANCH IF RELATIONAL COMPARISON
3696 d98a bd d8 cf                     JSR  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
3697 d98d 9f 3d              LB201     STX  RELPTR         ; SAVE POINTER TO OPERATOR ROUTINE
3698 d98f 35 04              LB203     PULS B              ; GET RELATIONAL OPERATOR FLAG FROM STACK
3699 d991 81 5a                        CMPA #$5A           ; CHECK FOR 'NOT' OPERATOR
3700 d993 27 19                        BEQ  LB222          ; RETURN IF 'NOT' - NO RELATIONAL COMPARISON
3701 d995 81 7d                        CMPA #$7D           ; CHECK FOR NEGATION (UNARY) FLAG
3702 d997 27 15                        BEQ  LB222          ; RETURN IF NEGATION - NO RELATIONAL COMPARISON
3703                         
3704                         * EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON STACK, FIRST SIX BYTES
3705                         * ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRESS OF ROUTINE WHICH
3706                         * WILL EVALUATE THE OPERATION. THE RTS AT END OF ROUTINE WILL VECTOR
3707                         * TO EVALUATING ROUTINE.
3708 d999 54                           LSRB                ; = ROTATE VALTYP BIT INTO CARRY
3709 d99a d7 0a                        STB  RELFLG         ; = FLAG AND SAVE NEW RELFLG
3710 d99c 35 52                        PULS A,X,U          ; * PULL A FP VALUE OFF OF THE STACK
3711 d99e 97 5c                        STA  FP1EXP         ; * AND SAVE IT IN FPA1
3712 d9a0 9f 5d                        STX  FPA1           ; *
3713 d9a2 df 5f                        STU  FPA1+2         ; *
3714 d9a4 35 04                        PULS B              ; = GET MANTISSA SIGN AND
3715 d9a6 d7 61                        STB  FP1SGN         ; = SAVE IT IN FPA1
3716 d9a8 d8 54                        EORB FP0SGN         ; EOR IT WITH FPA1 MANTISSA SIGN
3717 d9aa d7 62                        STB  RESSGN         ; SAVE IT IN RESULT SIGN BYTE
3718 d9ac d6 4f              LB220     LDB  FP0EXP         ; GET EXPONENT OF FPA0
3719 d9ae 39                 LB222     RTS
3720                         
3721 d9af bd eb fc           LB223     JSR  XVEC15         ; CALL EXTENDED BASIC ADD-IN
3722 d9b2 0f 06                        CLR  VALTYP         ; INITIALIZE TYPE FLAG TO NUMERIC
3723 d9b4 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHAR
3724 d9b6 24 03                        BCC  LB22F          ; BRANCH IF NOT NUMERIC
3725 d9b8 7e e4 5e           LB22C     JMP  LBD12          ; CONVERT ASCII STRING TO FLOATING POINT -
3726                         *         RETURN RESULT IN FPA0
3727                         * PROCESS A NON NUMERIC FIRST CHARACTER
3728 d9bb bd db 29           LB22F     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
3729 d9be 24 50                        BCC  LB284          ; BRANCH IF ALPHA CHARACTER
3730 d9c0 81 2e                        CMPA #'.            ; IS IT '.' (DECIMAL POINT)?
3731 d9c2 27 f4                        BEQ  LB22C          ; CONVERT ASCII STRING TO FLOATING POINT
3732 d9c4 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN
3733 d9c6 27 40                        BEQ  LB27C          ; YES - GO PROCESS THE MINUS OPERATOR
3734 d9c8 81 a6                        CMPA #TOK_PLUS      ; PLUS TOKEN
3735 d9ca 27 e3                        BEQ  LB223          ; YES - GET ANOTHER CHARACTER
3736 d9cc 81 22                        CMPA #'"            ; STRING DELIMITER?
3737 d9ce 26 0a                        BNE  LB24E          ; NO
3738 d9d0 9e 83              LB244     LDX  CHARAD         ; CURRENT BASIC POINTER TO X
3739 d9d2 bd dc 9f                     JSR  LB518          ; SAVE STRING ON STRING STACK
3740 d9d5 9e 64              LB249     LDX  COEFPT         ; * GET ADDRESS OF END OF STRING AND
3741 d9d7 9f 83                        STX  CHARAD         ; * PUT BASIC'S INPUT POINTER THERE
3742 d9d9 39                           RTS
3743 d9da 81 a3              LB24E     CMPA #TOK_NOT       ; NOT TOKEN?
3744 d9dc 26 0d                        BNE  LB25F          ; NO
3745                         * PROCESS THE NOT OPERATOR
3746 d9de 86 5a                        LDA  #$5A           ; 'NOT' PRECEDENCE FLAG
3747 d9e0 bd d8 e6                     JSR  LB15A          ; PROCESS OPERATION FOLLOWING 'NOT'
3748 d9e3 bd db 74                     JSR  INTCNV         ; CONVERT FPA0 TO INTEGER IN ACCD
3749 d9e6 43                           COMA                ; * 'NOT' THE INTEGER
3750 d9e7 53                           COMB                ; *
3751 d9e8 7e dc 7b                     JMP  GIVABF         ; CONVERT ACCD TO FLOATING POINT (FPA0)
3752 d9eb 4c                 LB25F     INCA                ; CHECK FOR TOKENS PRECEEDED BY $FF
3753 d9ec 27 2e                        BEQ  LB290          ; IT WAS PRECEEDED BY $FF
3754 d9ee 8d 06              LB262     BSR  LB26A          ; SYNTAX CHECK FOR A '('
3755 d9f0 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSIONS WITHIN PARENTHESES AT
3756                         *         HIGHEST PRECEDENCE
3757 d9f3 c6 29              LB267     LDB  #')            ; SYNTAX CHECK FOR ')'
3758 d9f5 8c                           FCB  SKP2           ; SKIP 2 BYTES
3759 d9f6 c6 28              LB26A     LDB  #'(            ; SYNTAX CHECK FOR '('
3760 d9f8 8c                           FCB  SKP2           ; SKIP 2 BYTES
3761 d9f9 c6 2c              LB26D     LDB  #',            ; SYNTAX CHECK FOR COMMA
3762 d9fb e1 9f 00 83        LB26F     CMPB [CHARAD]       ; * COMPARE ACCB TO CURRENT INPUT
3763 d9ff 26 02                        BNE  LB277          ; * CHARACTER - SYNTAX ERROR IF NO MATCH
3764 da01 0e 7c                        JMP  GETNCH         ; GET A CHARACTER FROM BASIC
3765 da03 c6 02              LB277     LDB  #2*1           ; SYNTAX ERROR
3766 da05 7e d4 06                     JMP  LAC46          ; JUMP TO ERROR HANDLER
3767                         
3768                         * PROCESS THE MINUS (UNARY) OPERATOR
3769 da08 86 7d              LB27C     LDA  #$7D           ; MINUS (UNARY) PRECEDENCE FLAG
3770 da0a bd d8 e6                     JSR  LB15A          ; PROCESS OPERATION FOLLOWING 'UNARY' NEGATION
3771 da0d 7e e6 35                     JMP  LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
3772                         
3773                         * EVALUATE ALPHA EXPRESSION
3774 da10 bd da de           LB284     JSR  LB357          ; FIND THE DESCRIPTOR ADDRESS OF A VARIABLE
3775 da13 9f 52              LB287     STX  FPA0+2         ; SAVE DESCRIPTOR ADDRESS IN FPA0
3776 da15 96 06                        LDA  VALTYP         ; TEST VARIABLE TYPE
3777 da17 26 95                        BNE  LB222          ; RETURN IF STRING
3778 da19 7e e3 60                     JMP  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
3779                         
3780                         * EVALUATING A SECONDARY TOKEN
3781 da1c 9d 7c              LB290     JSR  GETNCH         ; GET AN INPUT CHARACTER (SECONDARY TOKEN)
3782 da1e 1f 89                        TFR  A,B            ; SAVE IT IN ACCB
3783 da20 58                           ASLB                ; X2 & BET RID OF BIT 7
3784 da21 9d 7c                        JSR  GETNCH         ; GET ANOTHER INPUT CHARACTER
3785 da23 c1 38                        CMPB #NUM_SEC_FNS-1*2 ; 29 SECONDARY FUNCTIONS - 1
3786 da25 23 03                        BLS  LB29F          ; BRANCH IF COLOR BASIC TOKEN
3787 da27 7e da 03                     JMP  LB277          ; SYNTAX ERROR
3788 da2a 34 04              LB29F     PSHS B              ; SAVE TOKEN OFFSET ON STACK
3789 da2c c1 2a                        CMPB #TOK_LEFT-$80*2 ; CHECK FOR TOKEN WITH AN ARGUMENT
3790 da2e 25 1e                        BCS  LB2C7          ; DO SECONDARIES STRING$ OR LESS
3791 da30 c1 30                        CMPB #TOK_INKEY-$80*2 ; *
3792 da32 24 1c                        BCC  LB2C9          ; * DO SECONDARIES $92 (INKEY$) OR >
3793 da34 8d c0                        BSR  LB26A          ; SYNTAX CHECK FOR A '('
3794 da36 a6 e4                        LDA  ,S             ; GET TOKEN NUMBER
3795                         * DO SECONDARIES (LEFT$, RIGHT$, MID$)
3796 da38 bd d8 e2                     JSR  LB156          ; EVALUATE FIRST STRING IN ARGUMENT
3797 da3b 8d bc                        BSR  LB26D          ; SYNTAX CHECK FOR A COMMA
3798 da3d bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARiABLE
3799 da40 35 02                        PULS A              ; GET TOKEN OFFSET FROM STACK
3800 da42 de 52                        LDU  FPA0+2         ; POINT U TO STRING DESCRIPTOR
3801 da44 34 42                        PSHS U,A            ; SAVE TOKEN OFFSET AND DESCRIPTOR ADDRESS
3802 da46 bd de 92                     JSR  LB70B          ; EVALUATE FIRST NUMERIC ARGUMENT
3803 da49 35 02                        PULS A              ; GET TOKEN OFFSET FROM STACK
3804 da4b 34 06                        PSHS B,A            ; SAVE TOKEN OFFSET AND NUMERIC ARGUMENT
3805 da4d 8e                           FCB  $8E            ; OP CODE OF LDX# - SKlP 2 BYTES
3806 da4e 8d 9e              LB2C7     BSR  LB262          ; SYNTAX CHECK FOR A '('
3807 da50 35 04              LB2C9     PULS B              ; GET TOKEN OFFSET
3808 da52 be d0 f9                     LDX  COMVEC+8       ; GET SECONDARY FUNCTION JUMP TABLE ADDRESS
3809 da55 3a                 LB2CE     ABX                 ; ADD IN COMMAND OFFSET
3810                         *
3811                         * HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION
3812 da56 ad 94                        JSR  [,X]           ; GO DO AN SECONDARY FUNCTION
3813 da58 7e d8 cf                     JMP  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
3814                         
3815                         * LOGICAL OPERATOR 'OR' JUMPS HERE
3816 da5b 86                 LB2D4     FCB  SKP1LD         ; SKIP ONE BYTE - 'OR' FLAG = $4F
3817                         
3818                         * LOGICAL OPERATOR 'AND' JUMPS HERE
3819 da5c 4f                 LB2D5     CLRA                ; AND FLAG = 0
3820 da5d 97 03                        STA  TMPLOC         ; AND/OR FLAG
3821 da5f bd db 74                     JSR  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
3822 da62 dd 01                        STD  CHARAC         ; TEMP SAVE ACCD
3823 da64 bd e3 96                     JSR  LBC4A          ; MOVE FPA1 TO FPA0
3824 da67 bd db 74                     JSR  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
3825 da6a 0d 03                        TST  TMPLOC         ; CHECK AND/OR FLAG
3826 da6c 26 06                        BNE  LB2ED          ; BRANCH IF OR
3827 da6e 94 01                        ANDA CHARAC         ; * 'AND' ACCD WITH FPA0 INTEGER
3828 da70 d4 02                        ANDB ENDCHR         ; * STORED IN ENDCHR
3829 da72 20 04                        BRA  LB2F1          ; CONVERT TO FP
3830 da74 9a 01              LB2ED     ORA  CHARAC         ; * 'OR' ACCD WITH FPA0 INTEGER
3831 da76 da 02                        ORB  ENDCHR         ; * STORED IN CHARAC
3832 da78 7e dc 7b           LB2F1     JMP  GIVABF         ; CONVERT THE VALUE IN ACCD INTO A FP NUMBER
3833                         
3834                         * RELATIONAL COMPARISON PROCESS HANDLER
3835 da7b bd d8 d4           LB2F4     JSR  LB148          ; 'TM' ERROR IF TYPE MISMATCH
3836 da7e 26 10                        BNE  LB309          ; BRANCH IF STRING VARIABLE
3837 da80 96 61                        LDA  FP1SGN         ; * 'PACK' THE MANTISSA
3838 da82 8a 7f                        ORA  #$7F           ; * SIGN OF FPA1 INTO
3839 da84 94 5d                        ANDA FPA1           ; * BIT 7 OF THE
3840 da86 97 5d                        STA  FPA1           ; * MANTISSA MS BYTE
3841 da88 8e 00 5c                     LDX  #FP1EXP        ; POINT X TO FPA1
3842 da8b bd e3 e2                     JSR  LBC96          ; COMPARE FPA0 TO FPA1
3843 da8e 20 36                        BRA  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
3844                         
3845                         * RELATIONAL COMPARISON OF STRINGS
3846 da90 0f 06              LB309     CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
3847 da92 0a 3f                        DEC  TRELFL         ; REMOVE STRING TYPE FLAG (BIT0=1 FOR STRINGS) FROM THE
3848                         *                             ; DESIRED RELATIONAL COMPARISON DATA
3849 da94 bd dd de                     JSR  LB657          ; GET LENGTH AND ADDRESS OF STRING WHOSE
3850                         *                             ; DESCRIPTOR ADDRESS IS IN THE BOTTOM OF FPA0
3851 da97 d7 56                        STB  STRDES         ; * SAVE LENGTH AND ADDRESS IN TEMPORARY
3852 da99 9f 58                        STX  STRDES+2       ; * DESCRIPTOR (STRING B)
3853 da9b 9e 5f                        LDX  FPA1+2         ; = RETURN LENGTH AND ADDRESS OF STRING
3854 da9d bd dd e0                     JSR  LB659          ; = WHOSE DESCRIPTOR ADDRESS IS STORED IN FPA1+2
3855 daa0 96 56                        LDA  STRDES         ; LOAD ACCA WITH LENGTH OF STRING B
3856 daa2 34 04                        PSHS B              ; SAVE LENGTH A ON STACK
3857 daa4 a0 e0                        SUBA ,S+            ; SUBTRACT LENGTH A FROM LENGTH B
3858 daa6 27 07                        BEQ  LB328          ; BRANCH IF STRINGS OF EQUAL LENGTH
3859 daa8 86 01                        LDA  #1             ; ; TRUE FLAG
3860 daaa 24 03                        BCC  LB328          ; TRUE IF LENGTH B > LENGTH A
3861 daac d6 56                        LDB  STRDES         ; LOAD ACCB WITH LENGTH B
3862 daae 40                           NEGA                ; SET FLAG = FALSE (1FF)
3863 daaf 97 54              LB328     STA  FP0SGN         ; SAVE TRUE/FALSE FLAG
3864 dab1 de 58                        LDU  STRDES+2       ; POINT U TO START OF STRING
3865 dab3 5c                           INCB                ; COMPENSATE FOR THE DECB BELOW
3866                         * ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING
3867 dab4 5a                 LB32D     DECB                ; DECREMENT SHORTER STRING LENGTH
3868 dab5 26 04                        BNE  LB334          ; BRANCH IF ALL OF STRING NOT COMPARED
3869 dab7 d6 54                        LDB  FP0SGN         ; GET TRUE/FALSE FLAB
3870 dab9 20 0b                        BRA  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
3871 dabb a6 80              LB334     LDA  ,X+            ; GET A BYTE FROM STRING A
3872 dabd a1 c0                        CMPA ,U+            ; COMPARE TO STRING B
3873 dabf 27 f3                        BEQ  LB32D          ; CHECK ANOTHER CHARACTER IF =
3874 dac1 c6 ff                        LDB  #$FF           ; FALSE FLAG IF STRING A > B
3875 dac3 24 01                        BCC  LB33F          ; BRANCH IF STRING A > STRING B
3876 dac5 50                           NEGB                ; SET FLAG = TRUE
3877                         
3878                         * DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA0
3879 dac6 cb 01              LB33F     ADDB #1             ; CONVERT $FF,0,1 TO 0,1,2
3880 dac8 59                           ROLB                ; NOW IT'S 1,2,4 FOR > = <
3881 dac9 d4 0a                        ANDB RELFLG         ; 'AND' THE ACTUAL COMPARISON WITH THE DESIRED -
3882                         COMPARISON
3883 dacb 27 02                        BEQ  LB348          ; BRANCH IF FALSE (NO MATCHING BITS)
3884 dacd c6 ff                        LDB  #$FF           ; TRUE FLAG
3885 dacf 7e e3 c8           LB348     JMP  LBC7C          ; CONVERT ACCB INTO FP NUMBER IN FPA0
3886                         
3887                         * DIM
3888 dad2 bd d9 f9           LB34B     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
3889 dad5 c6 01              DIM       LDB  #1             ; DIMENSION FLAG
3890 dad7 8d 08                        BSR  LB35A          ; SAVE ARRAY SPACE FOR THIS VARIABLE
3891 dad9 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3892 dadb 26 f5                        BNE  LB34B          ; KEEP DIMENSIONING IF NOT END OF LINE
3893 dadd 39                           RTS
3894                         * EVALUATE A VARIABLE - RETURN X AND
3895                         * VARPTR POINTING TO VARIABLE DESCRIPTOR
3896                         * EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO
3897                         * BYTES ARE THE VARIABLE NAME AND THE NEXT 5
3898                         * BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE
3899                         * FIRST BYTE OF VARlABLE NAME IS SET, THE
3900                         * VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF
3901                         * THE SECOND BYTE OF VARIABLE NAME IS SET, THE
3902                         * VARIABLE IS A STRING, OTHERWISE THE VARIABLE
3903                         * IS NUMERIC.
3904                         * IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS
3905                         * INSERTED INTO THE VARIABLE SPACE
3906 dade 5f                 LB357     CLRB                ; DIMENSION FLAG = 0; DO NOT SET UP AN ARRAY
3907 dadf 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3908 dae1 d7 05              LB35A     STB  DIMFLG         ; SAVE ARRAY FLAG
3909                         * ENTRY POINT FOR DEF FN VARIABLE SEARCH
3910 dae3 97 37              LB35C     STA  VARNAM         ; SAVE INPUT CHARACTER
3911 dae5 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
3912 dae7 8d 40                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
3913 dae9 10 25 ff 16                  LBCS LB277          ; SYNTAX ERROR IF NOT ALPHA
3914 daed 5f                           CLRB                ; DEFAULT 2ND VARIABLE CHARACTER TO ZERO
3915 daee d7 06                        STB  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
3916 daf0 9d 7c                        JSR  GETNCH         ; GET ANOTHER CHARACTER FROM BASIC
3917 daf2 25 04                        BCS  LB371          ; BRANCH IF NUMERIC (2ND CHARACTER IN
3918                         *                             ; VARIABLE MAY BE NUMERIC)
3919 daf4 8d 33                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
3920 daf6 25 0a                        BCS  LB37B          ; BRANCH IF NOT ALPHA
3921 daf8 1f 89              LB371     TFR  A,B            ; SAVE 2ND CHARACTER IN ACCB
3922                         * READ INPUT CHARACTERS UNTIL A NON ALPHA OR
3923                         * NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS
3924                         * IN VARIABLE NAME AFTER THE 1ST TWO
3925 dafa 9d 7c              LB373     JSR  GETNCH         ; GET AN INPUT CHARACTER
3926 dafc 25 fc                        BCS  LB373          ; BRANCH IF NUMERIC
3927 dafe 8d 29                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
3928 db00 24 f8                        BCC  LB373          ; BRANCH IF ALPHA
3929 db02 81 24              LB37B     CMPA #'$            ; CHECK FOR A STRING VARIABLE
3930 db04 26 06                        BNE  LB385          ; BRANCH IF IT IS NOT A STRING
3931 db06 03 06                        COM  VALTYP         ; SET VARIABLE TYPE TO STRING
3932 db08 cb 80                        ADDB #$80           ; SET BIT 7 OF 2ND CHARACTER (STRING)
3933 db0a 9d 7c                        JSR  GETNCH         ; GET AN INPUT CHARACTER
3934 db0c d7 38              LB385     STB  VARNAM+1       ; SAVE 2ND CHARACTER IN VARNAM+1
3935 db0e 9a 08                        ORA  ARYDIS         ; OR IN THE ARRAY DISABLE FLAG - IF = $80,
3936                         *              ; DON'T SEARCH FOR VARIABLES IN THE ARRAYS
3937 db10 80 28                        SUBA #'(            ; IS THIS AN ARRAY VARIABLE?
3938 db12 10 27 00 75                  LBEQ LB404          ; BRANCH IF IT IS
3939 db16 0f 08                        CLR  ARYDIS         ; RESET THE ARRAY DISABLE FLAG
3940 db18 9e 1b                        LDX  VARTAB         ; POINT X TO THE START OF VARIABLES
3941 db1a dc 37                        LDD  VARNAM         ; GET VARIABLE IN QUESTION
3942 db1c 9c 1d              LB395     CMPX ARYTAB         ; COMPARE X TO THE END OF VARIABLES
3943 db1e 27 12                        BEQ  LB3AB          ; BRANCH IF END OF VARIABLES
3944 db20 10 a3 81                     CMPD ,X++           ; * COMPARE VARIABLE IN QUESTION TO CURRENT
3945 db23 27 3e                        BEQ  LB3DC          ; * VARIABLE AND BRANCH IF MATCH
3946 db25 30 05                        LEAX 5,X            ; = MOVE POINTER TO NEXT VARIABLE AND
3947 db27 20 f3                        BRA  LB395          ; = KEEP LOOKING
3948                         
3949                         * SET CARRY IF NOT UPPER CASE ALPHA
3950 db29 81 41              LB3A2     CMPA #'A            ; * CARRY SET IF < 'A'
3951 db2b 25 04                        BCS  LB3AA          ; *
3952 db2d 80 5b                        SUBA #'Z+1          ; =
3953                         *         SUBA #-('Z+1)       ; = CARRY CLEAR IF <= 'Z'
3954 db2f 80 a5                        FCB  $80,$A5
3955 db31 39                 LB3AA     RTS
3956                         * PUT A NEW VARIABLE IN TABLE OF VARIABLES
3957 db32 8e 00 74           LB3AB     LDX  #ZERO          ; POINT X TO ZERO LOCATION
3958 db35 ee e4                        LDU  ,S             ; GET CURRENT RETURN ADDRESS
3959 db37 11 83 da 13                  CMPU #LB287         ; DID WE COME FROM 'EVALUATE ALPHA EXPR'?
3960 db3b 27 28                        BEQ  LB3DE          ; YES - RETURN A ZERO VALUE
3961 db3d dc 1f                        LDD  ARYEND         ; * GET END OF ARRAYS ADDRESS AND
3962 db3f dd 43                        STD  V43            ; * SAVE IT AT V43
3963 db41 c3 00 07                     ADDD #7             ; = ADD 7 TO END OF ARRAYS (EACH
3964 db44 dd 41                        STD  V41            ; = VARIABLE = 7 BYTES) AND SAVE AT V41
3965 db46 9e 1d                        LDX  ARYTAB         ; * GET END OF VARIABLES AND SAVE AT V47
3966 db48 9f 47                        STX  V47            ; *
3967 db4a bd d3 de                     JSR  LAC1E          ; MAKE A SEVEN BYTE SLOT FOR NEW VARIABLE AT
3968                         *         TOP  OF VARIABLES
3969 db4d 9e 41                        LDX  V41            ; = GET NEW END OF ARRAYS AND SAVE IT
3970 db4f 9f 1f                        STX  ARYEND         ; =
3971 db51 9e 45                        LDX  V45            ; * GET NEW END OF VARIABLES AND SAVE IT
3972 db53 9f 1d                        STX  ARYTAB         ; *
3973 db55 9e 47                        LDX  V47            ; GET OLD END OF VARIABLES
3974 db57 dc 37                        LDD  VARNAM         ; GET NEW VARIABLE NAME
3975 db59 ed 81                        STD  ,X++           ; SAVE VARIABLE NAME
3976 db5b 4f                           CLRA                ; * ZERO OUT THE FP VALUE OF THE NUMERIC
3977 db5c 5f                           CLRB                ; * VARIABLE OR THE LENGTH AND ADDRESS
3978 db5d ed 84                        STD  ,X             ; * OF A STRING VARIABLE
3979 db5f ed 02                        STD  2,X            ; *
3980 db61 a7 04                        STA  4,X            ; *
3981 db63 9f 39              LB3DC     STX  VARPTR         ; STORE ADDRESS OF VARIABLE VALUE
3982 db65 39                 LB3DE     RTS
3983                         *
3984 db66 90 80 00 00 00     LB3DF     FCB  $90,$80,$00,$00,$00 ; * FLOATING POINT -32768
3985                         *                             ; SMALLEST SIGNED TWO BYTE INTEGER
3986                         *
3987 db6b 9d 7c              LB3E4     JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
3988 db6d bd d8 cd           LB3E6     JSR  LB141          ; GO EVALUATE NUMERIC EXPRESSION
3989 db70 96 54              LB3E9     LDA  FP0SGN         ; GET FPA0 MANTISSA SIGN
3990 db72 2b 5d                        BMI  LB44A          ; 'FC' ERROR IF NEGATIVE NUMBER
3991                         
3992                         
3993 db74 bd d8 cf           INTCNV    JSR  LB143          ; 'TM' ERROR IF STRING VARIABLE
3994 db77 96 4f                        LDA  FP0EXP         ; GET FPA0 EXPONENT
3995 db79 81 90                        CMPA #$90           ; * COMPARE TO 32768 - LARGEST INTEGER EXPONENT AND
3996 db7b 25 08                        BCS  LB3FE          ; * BRANCH IF FPA0 < 32768
3997 db7d 8e db 66                     LDX  #LB3DF         ; POINT X TO FP VALUE OF -32768
3998 db80 bd e3 e2                     JSR  LBC96          ; COMPARE -32768 TO FPA0
3999 db83 26 4c                        BNE  LB44A          ; 'FC' ERROR IF NOT =
4000 db85 bd e4 14           LB3FE     JSR  LBCC8          ; CONVERT FPA0 TO A TWO BYTE INTEGER
4001 db88 dc 52                        LDD  FPA0+2         ; GET THE INTEGER
4002 db8a 39                           RTS
4003                         * EVALUATE AN ARRAY VARIABLE
4004 db8b dc 05              LB404     LDD  DIMFLG         ; GET ARRAY FLAG AND VARIABLE TYPE
4005 db8d 34 06                        PSHS B,A            ; SAVE THEM ON STACK
4006 db8f 12                           NOP                 ; DEAD SPACE CAUSED BY 1.2 REVISION
4007 db90 5f                           CLRB                ; RESET DIMENSION COUNTER
4008 db91 9e 37              LB40A     LDX  VARNAM         ; GET VARIABLE NAME
4009 db93 34 14                        PSHS X,B            ; SAVE VARIABLE NAME AND DIMENSION COUNTER
4010 db95 8d d4                        BSR  LB3E4          ; EVALUATE EXPRESSION (DIMENSlON LENGTH)
4011 db97 35 34                        PULS B,X,Y          ; PULL OFF VARIABLE NAME, DIMENSlON COUNTER,
4012                         *                             ; ARRAY FLAG
4013 db99 9f 37                        STX  VARNAM         ; SAVE VARIABLE NAME AND VARIABLE TYPE
4014 db9b de 52                        LDU  FPA0+2         ; GET DIMENSION LENGTH
4015 db9d 34 60                        PSHS U,Y            ; SAVE DIMENSION LENGTH, ARRAY FLAG, VARIABLE TYPE
4016 db9f 5c                           INCB                ; INCREASE DIMENSION COUNTER
4017 dba0 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4018 dba2 81 2c                        CMPA #',            ; CHECK FOR ANOTHER DIMENSION
4019 dba4 27 eb                        BEQ  LB40A          ; BRANCH IF MORE
4020 dba6 d7 03                        STB  TMPLOC         ; SAVE DIMENSION COUNTER
4021 dba8 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR A ')'
4022 dbab 35 06                        PULS A,B            ; * RESTORE VARIABLE TYPE AND ARRAY
4023 dbad dd 05                        STD  DIMFLG         ; * FLAG - LEAVE DIMENSION LENGTH ON STACK
4024 dbaf 9e 1d                        LDX  ARYTAB         ; GET START OF ARRAYS
4025 dbb1 9c 1f              LB42A     CMPX ARYEND         ; COMPARE TO END OF ARRAYS
4026 dbb3 27 21                        BEQ  LB44F          ; BRANCH IF NO MATCH FOUND
4027 dbb5 dc 37                        LDD  VARNAM         ; GET VARIABLE IN QUESTION
4028 dbb7 10 a3 84                     CMPD ,X             ; COMPARE TO CURRENT VARIABLE
4029 dbba 27 06                        BEQ  LB43B          ; BRANCH IF =
4030 dbbc ec 02                        LDD  2,X            ; GET OFFSET TO NEXT ARRAY VARIABLE
4031 dbbe 30 8b                        LEAX D,X            ; ADD TO CURRENT POINTER
4032 dbc0 20 ef                        BRA  LB42A          ; KEEP SEARCHING
4033 dbc2 c6 12              LB43B     LDB  #2*9           ; 'REDIMENSIONED ARRAY' ERROR
4034 dbc4 96 05                        LDA  DIMFLG         ; * TEST ARRAY FLAG - IF <>0 YOU ARE TRYING
4035 dbc6 26 0b                        BNE  LB44C          ; * TO REDIMENSION AN ARRAY
4036 dbc8 d6 03                        LDB  TMPLOC         ; GET NUMBER OF DIMENSIONS IN ARRAY
4037 dbca e1 04                        CMPB 4,X            ; COMPARE TO THIS ARRAYS DIMENSIONS
4038 dbcc 27 59                        BEQ  LB4A0          ; BRANCH IF =
4039 dbce c6 10              LB447     LDB  #8*2           ; 'BAD SUBSCRIPT'
4040 dbd0 8c                           FCB  SKP2           ; SKIP TWO BYTES
4041 dbd1 c6 08              LB44A     LDB  #4*2           ; 'ILLEGAL FUNCTION CALL'
4042 dbd3 7e d4 06           LB44C     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
4043                         
4044                         * INSERT A NEW ARRAY INTO ARRAY VARIABLES
4045                         * EACH SET OF ARRAY VARIABLES IS PRECEEDED BY A DE-
4046                         * SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS THE
4047                         * NUMBER OF DIMENSIONS IN THE ARRAY. THE BLOCK IS DEFINED
4048                         * AS FOLLOWS: BYTES 0,1:VARIABLE'S NAME; 2,3:TOTAL LENGTH
4049                         * OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIMEN-
4050                         * ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIMEN-
4051                         * SION 2;... 4+N,5+N:LENGTH OF DIMENSION N.
4052                         
4053 dbd6 cc 00 05           LB44F     LDD  #5             ; * 5 BYTES/ARRAY ENTRY SAVE AT COEFPT
4054 dbd9 dd 64                        STD  COEFPT         ; *
4055 dbdb dc 37                        LDD  VARNAM         ; = GET NAME OF ARRAY AND SAVE IN
4056 dbdd ed 84                        STD  ,X             ; = FIRST 2 BYTES OF DESCRIPTOR
4057 dbdf d6 03                        LDB  TMPLOC         ; GET NUMBER OF DIMENSIONS AND SAVE IN
4058 dbe1 e7 04                        STB  4,X            ; * 5TH BYTE OF DESCRIPTOR
4059 dbe3 bd d3 f3                     JSR  LAC33          ; CHECK FOR ROOM FOR DESCRIPTOR IN FREE RAM
4060 dbe6 9f 41                        STX  V41            ; TEMPORARILY SAVE DESCRIPTOR ADDRESS
4061 dbe8 c6 0b              LB461     LDB  #11            ; * DEFAULT DIMENSION VALUE:X(10)
4062 dbea 4f                           CLRA                ; *
4063 dbeb 0d 05                        TST  DIMFLG         ; = CHECK ARRAY FLAG AND BRANCH IF
4064 dbed 27 05                        BEQ  LB46D          ; = NOT DIMENSIONING AN ARRAY
4065 dbef 35 06                        PULS A,B            ; GET DIMENSION LENGTH
4066 dbf1 c3 00 01                     ADDD #1             ; ADD ONE (X(0) HAS A LENGTH OF ONE)
4067 dbf4 ed 05              LB46D     STD  5,X            ; SAVE LENGTH OF ARRAY DIMENSION
4068 dbf6 8d 5d                        BSR  LB4CE          ; MULTIPLY ACCUM ARRAY SIZE NUMBER LENGTH
4069                         *                             ; OF NEW DIMENSION
4070 dbf8 dd 64                        STD  COEFPT         ; TEMP STORE NEW CURRENT ACCUMULATED ARRAY SIZE
4071 dbfa 30 02                        LEAX 2,X            ; BUMP POINTER UP TWO
4072 dbfc 0a 03                        DEC  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND BRANCH IF
4073 dbfe 26 e8                        BNE  LB461          ; * NOT DONE WITH ALL DIMENSIONS
4074 dc00 9f 0f                        STX  TEMPTR         ; SAVE ADDRESS OF (END OF ARRAY DESCRIPTOR - 5)
4075 dc02 d3 0f                        ADDD TEMPTR         ; ADD TOTAL SIZE OF NEW ARRAY
4076 dc04 10 25 f7 fc                  LBCS LAC44          ; 'OM' ERROR IF > $FFFF
4077 dc08 1f 01                        TFR  D,X            ; SAVE END OF ARRAY IN X
4078 dc0a bd d3 f7                     JSR  LAC37          ; MAKE SURE THERE IS ENOUGH FREE RAM FOR ARRAY
4079 dc0d 83 00 35                     SUBD #STKBUF-5      ; SUBTRACT OUT THE (STACK BUFFER - 5)
4080 dc10 dd 1f                        STD  ARYEND         ; SAVE NEW END OF ARRAYS
4081 dc12 4f                           CLRA                ; ZERO = TERMINATOR BYTE
4082 dc13 30 1f              LB48C     LEAX -1,X           ; * STORE TWO TERMINATOR BYTES AT
4083 dc15 a7 05                        STA  5,X            ; * THE END OF THE ARRAY DESCRIPTOR
4084 dc17 9c 0f                        CMPX TEMPTR         ; *
4085 dc19 26 f8                        BNE  LB48C          ; *
4086 dc1b 9e 41                        LDX  V41            ; GET ADDRESS OF START OF DESCRIPTOR
4087 dc1d 96 1f                        LDA  ARYEND         ; GET MSB OF END OF ARRAYS; LSB ALREADY THERE
4088 dc1f 93 41                        SUBD V41            ; SUBTRACT OUT ADDRESS OF START OF DESCRIPTOR
4089 dc21 ed 02                        STD  2,X            ; SAVE LENGTH OF (ARRAY AND DESCRIPTOR)
4090 dc23 96 05                        LDA  DIMFLG         ; * GET ARRAY FLAG AND BRANCH
4091 dc25 26 2d                        BNE  LB4CD          ; * BACK IF DIMENSIONING
4092                         * CALCULATE POINTER TO CORRECT ELEMENT
4093 dc27 e6 04              LB4A0     LDB  4,X            ; GET THE NUMBER OF DIMENSIONS
4094 dc29 d7 03                        STB  TMPLOC         ; TEMPORARILY SAVE
4095 dc2b 4f                           CLRA                ; * INITIALIZE POINTER
4096 dc2c 5f                           CLRB                ; * TO ZERO
4097 dc2d dd 64              LB4A6     STD  COEFPT         ; SAVE ACCUMULATED POINTER
4098 dc2f 35 06                        PULS A,B            ; * PULL DIMENSION ARGUMENT OFF THE
4099 dc31 dd 52                        STD  FPA0+2         ; * STACK AND SAVE IT
4100 dc33 10 a3 05                     CMPD 5,X            ; COMPARE TO STORED 'DIM' ARGUMENT
4101 dc36 24 3a                        BCC  LB4EB          ; 'BS' ERROR IF > = "DIM" ARGUMENT
4102 dc38 de 64                        LDU  COEFPT         ; * GET ACCUMULATED POINTER AND
4103 dc3a 27 04                        BEQ  LB4B9          ; * BRANCH IF 1ST DIMENSION
4104 dc3c 8d 17                        BSR  LB4CE          ; = MULTIPLY ACCUMULATED POINTER AND DIMENSION
4105 dc3e d3 52                        ADDD FPA0+2         ; = LENGTH AND ADD TO CURRENT ARGUMENT
4106 dc40 30 02              LB4B9     LEAX 2,X            ; MOVE POINTER TO NEXT DIMENSION
4107 dc42 0a 03                        DEC  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND
4108 dc44 26 e7                        BNE  LB4A6          ; * BRANCH IF ANY DIMENSIONS LEFT
4109                         * MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE
4110 dc46 ed e3                        STD  ,--S
4111 dc48 58                           ASLB
4112 dc49 49                           ROLA                ; TIMES 2
4113 dc4a 58                           ASLB
4114 dc4b 49                           ROLA                ; TIMES 4
4115 dc4c e3 e1                        ADDD ,S++           ; TIMES 5
4116 dc4e 30 8b                        LEAX D,X            ; ADD OFFSET TO START OF ARRAY
4117 dc50 30 05                        LEAX 5,X            ; ADJUST POINTER FOR SIZE OF DESCRIPTOR
4118 dc52 9f 39                        STX  VARPTR         ; SAVE POINTER TO ARRAY VALUE
4119 dc54 39                 LB4CD     RTS
4120                         * MULTIPLY 2 BYTE NUMBER IN 5,X BY THE 2 BYTE NUMBER
4121                         * IN COEFPT. RETURN RESULT IN ACCD, BS ERROR IF > $FFFF
4122 dc55 86 10              LB4CE     LDA  #16            ; 16 SHIFTS TO DO A MULTIPLY
4123 dc57 97 45                        STA  V45            ; SHIFT COUNTER
4124 dc59 ec 05                        LDD  5,X            ; * GET SIZE OF DIMENSION
4125 dc5b dd 17                        STD  BOTSTK         ; * AND SAVE IT
4126 dc5d 4f                           CLRA                ; * ZERO
4127 dc5e 5f                           CLRB                ; * ACCD
4128 dc5f 58                 LB4D8     ASLB                ; = SHIFT ACCB LEFT
4129 dc60 49                           ROLA                ; = ONE BIT
4130 dc61 25 0f                        BCS  LB4EB          ; 'BS' ERROR IF CARRY
4131 dc63 08 65                        ASL  COEFPT+1       ; * SHIFT MULTIPLICAND LEFT ONE
4132 dc65 09 64                        ROL  COEFPT         ; * BIT - ADD MULTIPLIER TO ACCUMULATOR
4133 dc67 24 04                        BCC  LB4E6          ; * IF CARRY <> 0
4134 dc69 d3 17                        ADDD BOTSTK         ; ADD MULTIPLIER TO ACCD
4135 dc6b 25 05                        BCS  LB4EB          ; 'BS' ERROR IF CARRY (>$FFFF)
4136 dc6d 0a 45              LB4E6     DEC  V45            ; * DECREMENT SHIFT COUNTER
4137 dc6f 26 ee                        BNE  LB4D8          ; * IF NOT DONE
4138 dc71 39                           RTS
4139 dc72 7e db ce           LB4EB     JMP  LB447          ; 'BS' ERROR
4140                         *
4141                         * MEM
4142                         * THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE
4143                         * BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK
4144                         * FOR WHICH MEM DOES NOT ALLOW.
4145                         *
4146 dc75 1f 40              MEM       TFR  S,D            ; PUT STACK POINTER INTO ACCD
4147 dc77 93 1f                        SUBD ARYEND         ; SUBTRACT END OF ARRAYS
4148 dc79 21                           FCB  SKP1           ; SKIP ONE BYTE
4149                         *CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0
4150 dc7a 4f                 LB4F3     CLRA                ; CLEAR MS BYTE OF ACCD
4151                         * CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMBER IN FPA0
4152 dc7b 0f 06              GIVABF    CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
4153 dc7d dd 50                        STD  FPA0           ; SAVE ACCD IN TOP OF FACA
4154 dc7f c6 90                        LDB  #$90           ; EXPONENT REQUIRED IF THE TOP TWO BYTES
4155                         *         OF   FPA0 ARE TO BE TREATED AS AN INTEGER IN FPA0
4156 dc81 7e e3 ce                     JMP  LBC82          ; CONVERT THE REST OF FPA0 TO AN INTEGER
4157                         
4158                         * STR$
4159 dc84 bd d8 cf           STR       JSR  LB143          ; 'TM' ERROR IF STRING VARIABLE
4160 dc87 ce 01 f0                     LDU  #STRBUF+2      ; *CONVERT FP NUMBER TO ASCII STRING IN
4161 dc8a bd e5 28                     JSR  LBDDC          ; *THE STRING BUFFER
4162 dc8d 32 62                        LEAS 2,S            ; PURGE THE RETURN ADDRESS FROM THE STACK
4163 dc8f 8e 01 ef                     LDX  #STRBUF+1      ; *POINT X TO STRING BUFFER AND SAVE
4164 dc92 20 0b                        BRA  LB518          ; *THE STRING IN THE STRING SPACE
4165                         * RESERVE ACCB BYTES OF STRING SPACE. RETURN START
4166                         * ADDRESS IN (X) AND FRESPC
4167 dc94 9f 4d              LB50D     STX  V4D            ; SAVE X IN V4D
4168 dc96 8d 5c              LB50F     BSR  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
4169 dc98 9f 58              LB511     STX  STRDES+2       ; SAVE NEW STRING ADDRESS
4170 dc9a d7 56                        STB  STRDES         ; SAVE LENGTH OF RESERVED BLOCK
4171 dc9c 39                           RTS
4172 dc9d 30 1f              LB516     LEAX -1,X           ; MOVE POINTER BACK ONE
4173                         * SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO) OR
4174                         * EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR ENDCHR IS MATCHED.
4175                         * THE RESULTING STRING IS STORED IN THE STRING SPACE
4176                         * ONLY IF THE START OF THE STRING IS <= STRBUF+2
4177 dc9f 86 22              LB518     LDA  #'"            ; * INITIALIZE
4178 dca1 97 01                        STA  CHARAC         ; * TERMINATORS
4179 dca3 97 02              LB51A     STA  ENDCHR         ; * TO "
4180 dca5 30 01              LB51E     LEAX 1,X            ; MOVE POINTER UP ONE
4181 dca7 9f 62                        STX  RESSGN         ; TEMPORARILY SAVE START OF STRING
4182 dca9 9f 58                        STX  STRDES+2       ; SAVE START OF STRING IN TEMP DESCRIPTOR
4183 dcab c6 ff                        LDB  #-1            ; INITIALIZE CHARACTER COUNTER TO - 1
4184 dcad 5c                 LB526     INCB                ; INCREMENT CHARACTER COUNTER
4185 dcae a6 80                        LDA  ,X+            ; GET CHARACTER
4186 dcb0 27 0c                        BEQ  LB537          ; BRANCH IF END OF LINE
4187 dcb2 91 01                        CMPA CHARAC         ; * CHECK FOR TERMINATORS
4188 dcb4 27 04                        BEQ  LB533          ; * IN CHARAC AND ENDCHR
4189 dcb6 91 02                        CMPA ENDCHR         ; * DON'T MOVE POINTER BACK
4190 dcb8 26 f3                        BNE  LB526          ; * ONE IF TERMINATOR IS "MATCHED"
4191 dcba 81 22              LB533     CMPA #'"            ; = COMPARE CHARACTER TO STRING DELIMITER
4192 dcbc 27 02                        BEQ  LB539          ; = & DON'T MOVE POINTER BACK IF SO
4193 dcbe 30 1f              LB537     LEAX -1,X           ; MOVE POINTER BACK ONE
4194 dcc0 9f 64              LB539     STX  COEFPT         ; SAVE END OF STRING ADDRESS
4195 dcc2 d7 56                        STB  STRDES         ; SAVE STRING LENGTH IN TEMP DESCRIPTOR
4196 dcc4 de 62                        LDU  RESSGN         ; GET INITlAL STRING START
4197 dcc6 11 83 01 f0                  CMPU #STRBUF+2      ; COMPARE TO START OF STRING BUFFER
4198 dcca 22 07              LB543     BHI  LB54C          ; BRANCH IF > START OF STRING BUFFER
4199 dccc 8d c6                        BSR  LB50D          ; GO RESERVE SPACE FOR THE STRING
4200 dcce 9e 62                        LDX  RESSGN         ; POINT X TO THE BEGINNING OF THE STRING
4201 dcd0 bd dd cc                     JSR  LB645          ; MOVE (B) BYTES FROM (X) TO
4202                         *                             [FRESPC] - MOVE STRING DATA
4203                         * PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA
4204                         * ON THE STRING STACK. SET VARIABLE TYPE TO STRING
4205 dcd3 9e 0b              LB54C     LDX  TEMPPT         ; GET NEXT AVAILABLE STRING STACK DESCRIPTOR
4206 dcd5 8c 00 f1                     CMPX #LINHDR        ; COMPARE TO TOP OF STRING DESCRIPTOR STACK - WAS #CFNBUF
4207 dcd8 26 05                        BNE  LB558          ; FORMULA O.K.
4208 dcda c6 1e                        LDB  #15*2          ; STRING FORMULA TOO COMPLEX' ERROR
4209 dcdc 7e d4 06           LB555     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
4210 dcdf 96 56              LB558     LDA  STRDES         ; * GET LENGTH OF STRING AND SAVE IT
4211                         *         STA  ,X             ; * IN BYTE 0 OF DESCRIPTOR
4212 dce1 a7 00                        FCB  $A7,$00
4213 dce3 dc 58                        LDD  STRDES+2       ; = GET START ADDRESS OF ACTUAL STRING
4214 dce5 ed 02                        STD  2,X            ; = AND SAVE IN BYTES 2,3 OF DESCRIPTOR
4215 dce7 86 ff                        LDA  #$FF           ; * VARIABLE TYPE = STRING
4216 dce9 97 06                        STA  VALTYP         ; * SAVE IN VARIABLE TYPE FLAG
4217 dceb 9f 0d                        STX  LASTPT         ; = SAVE START OF DESCRIPTOR
4218 dced 9f 52                        STX  FPA0+2         ; = ADDRESS IN LASTPT AND FPA0
4219 dcef 30 05                        LEAX 5,X            ; 5 BYTES/STRING DESCRIPTOR
4220 dcf1 9f 0b                        STX  TEMPPT         ; NEXT AVAILABLE STRING VARIABLE DESCRIPTOR
4221 dcf3 39                           RTS
4222                         * RESERVE ACCB BYTES IN STRING STORAGE SPACE
4223                         * RETURN WITH THE STARTING ADDRESS OF THE
4224                         * RESERVED STRING SPACE IN (X) AND FRESPC
4225 dcf4 0f 07              LB56D     CLR  GARBFL         ; CLEAR STRING REORGANIZATION FLAG
4226 dcf6 4f                 LB56F     CLRA                ; * PUSH THE LENGTH OF THE
4227 dcf7 34 06                        PSHS B,A            ; * STRING ONTO THE STACK
4228 dcf9 dc 23                        LDD  STRTAB         ; GET START OF STRING VARIABLES
4229 dcfb a3 e0                        SUBD ,S+            ; SUBTRACT STRING LENGTH
4230 dcfd 10 93 21                     CMPD FRETOP         ; COMPARE TO START OF STRING STORAGE
4231 dd00 25 0a                        BCS  LB585          ; IF BELOW START, THEN REORGANIZE
4232 dd02 dd 23                        STD  STRTAB         ; SAVE NEW START OF STRING VARIABLES
4233 dd04 9e 23                        LDX  STRTAB         ; GET START OF STRING VARIABLES
4234 dd06 30 01                        LEAX 1,X            ; ADD ONE
4235 dd08 9f 25                        STX  FRESPC         ; SAVE START ADDRESS OF NEWLY RESERVED SPACE
4236 dd0a 35 84                        PULS B,PC           ; RESTORE NUMBER OF BYTES RESERVED AND RETURN
4237 dd0c c6 1a              LB585     LDB  #2*13          ; OUT OF STRING SPACE' ERROR
4238 dd0e 03 07                        COM  GARBFL         ; TOGGLE REORGANIZATiON FLAG
4239 dd10 27 ca                        BEQ  LB555          ; ERROR IF FRESHLY REORGANIZED
4240 dd12 8d 04                        BSR  LB591          ; GO REORGANIZE STRING SPACE
4241 dd14 35 04                        PULS B              ; GET BACK THE NUMBER OF BYTES TO RESERVE
4242 dd16 20 de                        BRA  LB56F          ; TRY TO RESERVE ACCB BYTES AGAIN
4243                         * REORGANIZE THE STRING SPACE
4244 dd18 9e 27              LB591     LDX  MEMSIZ         ; GET THE TOP OF STRING SPACE
4245 dd1a 9f 23              LB593     STX  STRTAB         ; SAVE TOP OF UNORGANIZED STRING SPACE
4246 dd1c 4f                           CLRA                ; * ZERO OUT ACCD
4247 dd1d 5f                           CLRB                ; * AND RESET VARIABLE
4248 dd1e dd 4b                        STD  V4B            ; * POINTER TO 0
4249 dd20 9e 21                        LDX  FRETOP         ; POINT X TO START OF STRING SPACE
4250 dd22 9f 47                        STX  V47            ; SAVE POINTER IN V47
4251 dd24 8e 00 c9                     LDX  #STRSTK        ; POINT X TO START OF STRING DESCRIPTOR STACK
4252 dd27 9c 0b              LB5A0     CMPX TEMPPT         ; COMPARE TO ADDRESS OF NEXT AVAILABLE DESCRIPTOR
4253 dd29 27 04                        BEQ  LB5A8          ; BRANCH IF TOP OF STRING STACK
4254 dd2b 8d 32                        BSR  LB5D8          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
4255 dd2d 20 f8                        BRA  LB5A0          ; KEEP CHECKING
4256 dd2f 9e 1b              LB5A8     LDX  VARTAB         ; GET THE END OF BASIC PROGRAM
4257 dd31 9c 1d              LB5AA     CMPX ARYTAB         ; COMPARE TO END OF VARIABLES
4258 dd33 27 04                        BEQ  LB5B2          ; BRANCH IF AT TOP OF VARIABLES
4259 dd35 8d 22                        BSR  LB5D2          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
4260 dd37 20 f8                        BRA  LB5AA          ; KEEP CHECKING VARIABLES
4261 dd39 9f 41              LB5B2     STX  V41            ; SAVE ADDRESS OF THE END OF VARIABLES
4262 dd3b 9e 41              LB5B4     LDX  V41            ; GET CURRENT ARRAY POINTER
4263 dd3d 9c 1f              LB5B6     CMPX ARYEND         ; COMPARE TO THE END OF ARRAYS
4264 dd3f 27 35                        BEQ  LB5EF          ; BRANCH IF AT END OF ARRAYS
4265 dd41 ec 02                        LDD  2,X            ; GET LENGTH OF ARRAY AND DESCRIPTOR
4266 dd43 d3 41                        ADDD V41            ; * ADD TO CURRENT ARRAY POINTER
4267 dd45 dd 41                        STD  V41            ; * AND SAVE IT
4268 dd47 a6 01                        LDA  1,X            ; GET 1ST CHARACTER OF VARIABLE NAME
4269 dd49 2a f0                        BPL  LB5B4          ; BRANCH IF NUMERIC ARRAY
4270 dd4b e6 04                        LDB  4,X            ; GET THE NUMBER OF DIMENSIONS IN THIS ARRAY
4271 dd4d 58                           ASLB                ; MULTIPLY BY 2
4272 dd4e cb 05                        ADDB #5             ; ADD FIVE BYTES (VARIABLE NAME, ARRAY
4273                         *                             ; LENGTH, NUMBER DIMENSIONS)
4274 dd50 3a                           ABX                 ; X NOW POINTS TO START OF ARRAY ELEMENTS
4275 dd51 9c 41              LB5CA     CMPX V41            ; AT END OF THIS ARRAY?
4276 dd53 27 e8                        BEQ  LB5B6          ; YES - CHECK FOR ANOTHER
4277 dd55 8d 08                        BSR  LB5D8          ; CHECK FOR STRING LOCATED IN
4278                         *                             ; UNORGANIZED STRING SPACE
4279 dd57 20 f8                        BRA  LB5CA          ; KEEP CHECKING ELEMENTS IN THIS ARRAY
4280 dd59 a6 01              LB5D2     LDA  1,X            ; GET F1RST BYTE OF VARIABLE NAME
4281 dd5b 30 02                        LEAX 2,X            ; MOVE POINTER TO DESCRIPTOR
4282 dd5d 2a 14                        BPL  LB5EC          ; BRANCH IF VARIABLE IS NUMERIC
4283                         * SEARCH FOR STRING - ENTER WITH X POINTING TO
4284                         * THE STRING DESCRIPTOR. IF STRING IS STORED
4285                         * BETWEEN V47 AND STRTAB, SAVE DESCRIPTOR POINTER
4286                         * IN V4B AND RESET V47 TO STRING ADDRESS
4287 dd5f e6 84              LB5D8     LDB  ,X             ; GET THE LENGTH OF THE STRING
4288 dd61 27 10                        BEQ  LB5EC          ; BRANCH IF NULL - NO STRING
4289 dd63 ec 02                        LDD  2,X            ; GET STARTING ADDRESS OF THE STRING
4290 dd65 10 93 23                     CMPD STRTAB         ; COMPARE TO THE START OF STRING VARIABLES
4291 dd68 22 09                        BHI  LB5EC          ; BRANCH IF THIS STRING IS STORED IN
4292                         *              ; THE STRING VARIABLES
4293 dd6a 10 93 47                     CMPD V47            ; COMPARE TO START OF STRING SPACE
4294 dd6d 23 04                        BLS  LB5EC          ; BRANCH IF NOT STORED IN THE STRING SPACE
4295 dd6f 9f 4b                        STX  V4B            ; SAVE VARIABLE POINTER IF STORED IN STRING SPACE
4296 dd71 dd 47                        STD  V47            ; SAVE STRING STARTING ADDRESS
4297 dd73 30 05              LB5EC     LEAX 5,X            ; MOVE TO NEXT VARIABLE DESCRIPTOR
4298 dd75 39                 LB5EE     RTS
4299 dd76 9e 4b              LB5EF     LDX  V4B            ; GET ADDRESS OF THE DESCRIPTOR FOR THE
4300                         *              ; STRING WHICH IS STORED IN THE HIGHEST RAM ADDRESS IN
4301                         *              ; THE UNORGANIZED STRING SPACE
4302 dd78 27 fb                        BEQ  LB5EE          ; BRANCH IF NONE FOUND AND REORGANIZATION DONE
4303 dd7a 4f                           CLRA                ; CLEAR MS BYTE OF LENGTH
4304 dd7b e6 84                        LDB  ,X             ; GET LENGTH OF STRING
4305 dd7d 5a                           DECB                ; SUBTRACT ONE
4306 dd7e d3 47                        ADDD V47            ; ADD LENGTH OF STRING TO ITS STARTING ADDRESS
4307 dd80 dd 43                        STD  V43            ; SAVE AS MOVE STARTING ADDRESS
4308 dd82 9e 23                        LDX  STRTAB         ; POINT X TO THE START OF ORGANIZED STRING VARIABLES
4309 dd84 9f 41                        STX  V41            ; SAVE AS MOVE ENDING ADDRESS
4310 dd86 bd d3 e0                     JSR  LAC20          ; MOVE STRING FROM CURRENT POSITION TO THE
4311                         *              ; TOP OF UNORGANIZED STRING SPACE
4312 dd89 9e 4b                        LDX  V4B            ; POINT X TO STRING DESCRIPTOR
4313 dd8b dc 45                        LDD  V45            ; * GET NEW STARTING ADDRESS OF STRING AND
4314 dd8d ed 02                        STD  2,X            ; * SAVE IT IN DESCRIPTOR
4315 dd8f 9e 45                        LDX  V45            ; GET NEW TOP OF UNORGANIZED STRING SPACE
4316 dd91 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
4317 dd93 7e dd 1a                     JMP  LB593          ; JUMP BACK AND REORGANIZE SOME MORE
4318                         
4319                         
4320 dd96 dc 52              LB60F     LDD  FPA0+2         ; * GET DESCRIPTOR ADDRESS OF STRING A
4321 dd98 34 06                        PSHS B,A            ; * AND SAVE IT ON THE STACK
4322 dd9a bd d9 af                     JSR  LB223          ; GET DESCRIPTOR ADDRESS OF STRING B
4323 dd9d bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
4324 dda0 35 10                        PULS X              ; * POINT X TO STRING A DESCRIPTOR
4325 dda2 9f 62                        STX  RESSGN         ; * ADDRESS AND SAVE IT IN RESSGN
4326 dda4 e6 84                        LDB  ,X             ; GET LENGTH OF STRING A
4327 dda6 9e 52                        LDX  FPA0+2         ; POINT X TO DESCRIPTOR OF STRING B
4328 dda8 eb 84                        ADDB ,X             ; ADD LENGTH OF STRING B TO STR1NG A
4329 ddaa 24 05                        BCC  LB62A          ; BRANCH IF LENGTH < 256
4330 ddac c6 1c                        LDB  #2*14          ; 'STRING TOO LONG' ERROR IF LENGTH > 255
4331 ddae 7e d4 06                     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
4332 ddb1 bd dc 94           LB62A     JSR  LB50D          ; RESERVE ROOM IN STRING SPACE FOR NEW STRING
4333 ddb4 9e 62                        LDX  RESSGN         ; GET DESCRIPTOR ADDRESS OF STRING A
4334 ddb6 e6 84                        LDB  ,X             ; GET LENGTH OF STRING A
4335 ddb8 8d 10                        BSR  LB643          ; MOVE STRING A INTO RESERVED BUFFER IN STRING SPACE
4336 ddba 9e 4d                        LDX  V4D            ; GET DESCRIPTOR ADDRESS OF STRING B
4337 ddbc 8d 22                        BSR  LB659          ; GET LENGTH AND ADDRESS OF STRING B
4338 ddbe 8d 0c                        BSR  LB645          ; MOVE STRING B INTO REST OF RESERVED BUFFER
4339 ddc0 9e 62                        LDX  RESSGN         ; POINT X TO DESCRIPTOR OF STRING A
4340 ddc2 8d 1c                        BSR  LB659          ; DELETE STRING A IF LAST STRING ON STRING STACK
4341 ddc4 bd dc d3                     JSR  LB54C          ; PUT STRING DESCRIPTOR ON THE STRING STACK
4342 ddc7 7e d8 f4                     JMP  LB168          ; BRANCH BACK TO EXPRESSION EVALUATION
4343                         
4344                         * MOVE (B) BYTES FROM 2,X TO FRESPC
4345 ddca ae 02              LB643     LDX  2,X            ; POINT X TO SOURCE ADDRESS
4346 ddcc de 25              LB645     LDU  FRESPC         ; POINT U TO DESTINATION ADDRESS
4347 ddce 5c                           INCB                ; COMPENSATION FOR THE DECB BELOW
4348 ddcf 20 04                        BRA  LB64E          ; GO MOVE THE BYTES
4349                         * MOVE B BYTES FROM (X) TO (U)
4350 ddd1 a6 80              LB64A     LDA  ,X+            ; * GET A SOURCE BYTE AND MOVE IT
4351 ddd3 a7 c0                        STA  ,U+            ; * TO THE DESTINATION
4352 ddd5 5a                 LB64E     DECB                ; DECREMENT BYTE COUNTER
4353 ddd6 26 f9                        BNE  LB64A          ; BRANCH IF ALL BYTES NOT MOVED
4354 ddd8 df 25                        STU  FRESPC         ; SAVE ENDING ADDRESS IN FRESPC
4355 ddda 39                           RTS
4356                         * RETURN LENGTH (ACCB) AND ADDRESS (X) OF
4357                         * STRING WHOSE DESCRIPTOR IS IN FPA0+2
4358                         * DELETE THE STRING IF IT IS THE LAST ONE
4359                         * PUT ON THE STRING STACK. REMOVE STRING FROM STRING
4360                         * SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.
4361 dddb bd d8 d2           LB654     JSR  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
4362 ddde 9e 52              LB657     LDX  FPA0+2         ; GET ADDRESS OF SELECTED STRING DESCRIPTOR
4363 dde0 e6 84              LB659     LDB  ,X             ; GET LENGTH OF STRING
4364 dde2 8d 18                        BSR  LB675          ; * CHECK TO SEE IF THIS STRING DESCRIPTOR WAS
4365 dde4 26 13                        BNE  LB672          ; * THE LAST ONE PUT ON THE STRING STACK AND
4366                         *                             ; * BRANCH IF NOT
4367 dde6 ae 07                        LDX  5+2,X          ; GET START ADDRESS OF STRING JUST REMOVED
4368 dde8 30 1f                        LEAX -1,X           ; MOVE POINTER DOWN ONE
4369 ddea 9c 23                        CMPX STRTAB         ; COMPARE TO START OF STRING VARIABLES
4370 ddec 26 08                        BNE  LB66F          ; BRANCH IF THIS STRING IS NOT AT THE BOTTOM
4371                         *                             ; OF STRING VARIABLES
4372 ddee 34 04                        PSHS B              ; SAVE LENGTH; ACCA WAS CLEARED
4373 ddf0 d3 23                        ADDD STRTAB         ; * ADD THE LENGTH OF THE JUST REMOVED STRING
4374 ddf2 dd 23                        STD  STRTAB         ; * TO THE START OF STRING VARIABLES - THIS WILL
4375                         *                             ; * REMOVE THE STRING FROM THE STRING SPACE
4376 ddf4 35 04                        PULS B              ; RESTORE LENGTH
4377 ddf6 30 01              LB66F     LEAX 1,X            ; ADD ONE TO POINTER
4378 ddf8 39                           RTS
4379 ddf9 ae 02              LB672     LDX  2,X            ; *POINT X TO ADDRESS OF STRING NOT
4380 ddfb 39                           RTS                 ; *ON THE STRING STACK
4381                         * REMOVE STRING FROM STRING STACK. ENTER WITH X
4382                         * POINTING TO A STRING DESCRIPTOR - DELETE THE
4383                         * STRING FROM STACK IF IT IS ON TOP OF THE
4384                         * STACK. IF THE STRING IS DELETED, SET THE ZERO FLAG
4385 ddfc 9c 0d              LB675     CMPX LASTPT         ; *COMPARE TO LAST USED DESCRIPTOR ADDRESS
4386 ddfe 26 07                        BNE  LB680          ; *ON THE STRING STACK, RETURN IF DESCRIPTOR
4387                         *                             ; *ADDRESS NOT ON THE STRING STACK
4388 de00 9f 0b                        STX  TEMPPT         ; SAVE LAST USED DESCRIPTOR AS NEXT AVAILABLE
4389 de02 30 1b                        LEAX -5,X           ; * MOVE LAST USED DESCRIPTOR BACK 5 BYTES
4390 de04 9f 0d                        STX  LASTPT         ; * AND SAVE AS THE LAST USED DESCRIPTOR ADDR
4391 de06 4f                           CLRA                ; SET ZERO FLAG
4392 de07 39                 LB680     RTS
4393                         
4394                         * LEN
4395 de08 8d 03              LEN       BSR  LB686          ; POINT X TO PROPER STRING AND GET LENGTH
4396 de0a 7e dc 7a           LB683     JMP  LB4F3          ; CONVERT ACCB TO FP NUMBER IN FPA0
4397                         * POINT X TO STRING ADDRESS LOAD LENGTH INTO
4398                         * ACCB. ENTER WITH THE STRING DESCRIPTOR IN
4399                         * BOTTOM TWO BYTES OF FPA0
4400 de0d 8d cc              LB686     BSR  LB654          ; GET LENGTH AND ADDRESS OF STRING
4401 de0f 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
4402 de11 5d                           TSTB                ; SET FLAGS ACCORDING TO LENGTH
4403 de12 39                           RTS
4404                         
4405                         * CHR$
4406 de13 bd de 95           CHR       JSR  LB70E          ; CONVERT FPA0 TO AN INTEGER IN ACCD
4407 de16 c6 01              LB68F     LDB  #1             ; * RESERVE ONE BYTE IN
4408 de18 bd dc f4                     JSR  LB56D          ; * THE STRING SPACE
4409 de1b 96 53                        LDA  FPA0+3         ; GET ASCII STRING VALUE
4410 de1d bd dc 98                     JSR  LB511          ; SAVE RESERVED STRING DESCRIPTOR IN TEMP DESCRIPTOR
4411 de20 a7 84                        STA  ,X             ; SAVE THE STRING (IT'S ONLY ONE BYTE)
4412 de22 32 62              LB69B     LEAS 2,S            ; PURGE THE RETURN ADDRESS OFF OF THE STACK
4413 de24 7e dc d3           LB69D     JMP  LB54C          ; PUT TEMP DESCRIPTOR DATA ONTO STRING STACK
4414                         
4415                         
4416 de27 8d 02              ASC       BSR  LB6A4          ; PUT 1ST CHARACTER OF STRING INTO ACCB
4417 de29 20 df                        BRA  LB683          ; CONVERT ACCB INTO FP NUMBER IN FPA0
4418 de2b 8d e0              LB6A4     BSR  LB686          ; POINT X TO STRING DESCRIPTOR
4419 de2d 27 5e                        BEQ  LB706          ; 'FC' ERROR IF NULL STRING
4420 de2f e6 84                        LDB  ,X             ; GET FIRST BYTE OF STRING
4421 de31 39                           RTS
4422                         
4423                         
4424 de32 8d 48              LEFT      BSR  LB6F5          ; GET ARGUMENTS FROM STACK
4425 de34 4f                 LB6AD     CLRA                ; CLEAR STRING POINTER OFFSET - OFFSET = 0 FOR LEFT$
4426 de35 e1 84              LB6AE     CMPB ,X             ; * COMPARE LENGTH PARAMETER TO LENGTH OF
4427 de37 23 03                        BLS  LB6B5          ; * STRING AND BRANCH IF LENGTH OF STRING
4428                         *                             ; >= LENGTH PARAMETER
4429 de39 e6 84                        LDB  ,X             ; USE LENGTH OF STRING OTHERWISE
4430 de3b 4f                           CLRA                ; CLEAR STRING POINTER OFFSET (0 FOR LEFT$)
4431 de3c 34 06              LB6B5     PSHS B,A            ; PUSH PARAMETERS ONTO STACK
4432 de3e bd dc 96                     JSR  LB50F          ; RESERVE ACCB BYTES IN THE STRING SPACE
4433 de41 9e 4d                        LDX  V4D            ; POINT X TO STRING DESCRIPTOR
4434 de43 8d 9b                        BSR  LB659          ; GET ADDRESS OF OLD STRING (X=ADDRESS)
4435 de45 35 04                        PULS B              ; * PULL STRING POINTER OFFSET OFF OF THE STACK
4436 de47 3a                           ABX                 ; * AND ADD IT TO STRING ADDRESS
4437 de48 35 04                        PULS B              ; PULL LENGTH PARAMETER OFF OF THE STACK
4438 de4a bd dd cc                     JSR  LB645          ; MOVE ACCB BYTES FROM (X) TO [FRESPC]
4439 de4d 20 d5                        BRA  LB69D          ; PUT TEMP STRING DESCRIPTOR ONTO THE STRING STACK
4440                         
4441                         * RIGHT$
4442 de4f 8d 2b              RIGHT     BSR  LB6F5          ; GET ARGUMENTS FROM STACK
4443 de51 a0 84                        SUBA ,X             ; ACCA=LENGTH PARAMETER - LENGTH OF OLD STRING
4444 de53 40                           NEGA                ; NOW ACCA = LENGTH OF OLD STRING
4445 de54 20 df                        BRA  LB6AE          ; PUT NEW STRING IN THE STRING SPACE
4446                         
4447                         * MID$
4448 de56 c6 ff              MID       LDB  #$FF           ; * GET DEFAULT VALUE OF LENGTH AND
4449 de58 d7 53                        STB  FPA0+3         ; * SAVE IT IN FPA0
4450 de5a 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
4451 de5c 81 29                        CMPA #')            ; ARGUMENT DELIMITER?
4452 de5e 27 05                        BEQ  LB6DE          ; YES - NO LENGTH PARAMETER GIVEN
4453 de60 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4454 de63 8d 2d                        BSR  LB70B          ; EVALUATE NUMERIC EXPRESSION (LENGTH)
4455 de65 8d 15              LB6DE     BSR  LB6F5          ; GET ARGUMENTS FROM STACK
4456 de67 27 24                        BEQ  LB706          ; 'FC' ERROR IF NULL STRING
4457 de69 5f                           CLRB                ; CLEAR LENGTH COUNTER (DEFAULT VALUE)
4458 de6a 4a                           DECA                ; *SUOTRACT ONE FROM POSITION PARAMETER (THESE
4459 de6b a1 84                        CMPA ,X             ; *ROUTINES EXPECT 1ST POSITION TO BE ZERO, NOT ONE)
4460                         *                             ; *AND COMPARE IT TO LENGTH OF OLD STRING
4461 de6d 24 cd                        BCC  LB6B5          ; IF POSITION > LENGTH OF OLD STRING, THEN NEW
4462                         *                             ; STRING WILL BE A NULL STRING
4463 de6f 1f 89                        TFR  A,B            ; SAVE ABSOLUTE POSITION PARAMETER IN ACCB
4464 de71 e0 84                        SUBB ,X             ; ACCB=POSITION-LENGTH OF OLD STRING
4465 de73 50                           NEGB                ; NOW ACCB=LENGTH OF OLDSTRING-POSITION
4466 de74 d1 53                        CMPB FPA0+3         ; *IF THE AMOUNT OF OLD STRING TO THE RIGHT OF
4467 de76 23 c4                        BLS  LB6B5          ; *POSITION IS <= THE LENGTH PARAMETER, BRANCH AND
4468                         * USE ALL OF THE STRING TO THE RIGHT OF THE POSITION
4469                         * INSTEAD OF THE LENGTH PARAMETER
4470 de78 d6 53                        LDB  FPA0+3         ; GET LENGTH OF NEW STRING
4471 de7a 20 c0                        BRA  LB6B5          ; PUT NEW STRING IN STRING SPACE
4472                         * DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY CALCULATED NUMERIC
4473                         * ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR OFF OF THE STACK
4474 de7c bd d9 f3           LB6F5     JSR  LB267          ; SYNTAX CHECK FOR A ")"
4475 de7f ee e4                        LDU  ,S             ; LOAD THE RETURN ADDRESS INTO U REGISTER
4476 de81 ae 65                        LDX  5,S            ; * GET ADDRESS OF STRING AND
4477 de83 9f 4d                        STX  V4D            ; * SAVE IT IN V4D
4478 de85 a6 64                        LDA  4,S            ; = PUT LENGTH OF STRING IN
4479 de87 e6 64                        LDB  4,S            ; = BOTH ACCA AND ACCB
4480 de89 32 67                        LEAS 7,S            ; REMOVE DESCRIPTOR AND RETURN ADDRESS FROM STACK
4481 de8b 1f 35                        TFR  U,PC           ; JUMP TO ADDRESS IN U REGISTER
4482 de8d 7e db d1           LB706     JMP  LB44A          ; 'ILLEGAL FUNCTION CALL'
4483                         * EVALUATE AN EXPRESSION - RETURN AN INTEGER IN
4484                         * ACCB - 'FC' ERROR IF EXPRESSION > 255
4485 de90 9d 7c              LB709     JSR  GETNCH         ; GET NEXT BASIC INPUT CHARACTER
4486 de92 bd d8 cd           LB70B     JSR  LB141          ; EVALUATE A NUMERIC EXPRESSION
4487 de95 bd db 70           LB70E     JSR  LB3E9          ; CONVERT FPA0 TO INTEGER IN ACCD
4488 de98 4d                           TSTA                ; TEST MS BYTE OF INTEGER
4489 de99 26 f2                        BNE  LB706          ; 'FC' ERROR IF EXPRESSION > 255
4490 de9b 0e 82                        JMP  GETCCH         ; GET CURRENT INPUT CHARACTER FROM BASIC
4491                         
4492                         * VAL
4493 de9d bd de 0d           VAL       JSR  LB686          ; POINT X TO STRING ADDRESS
4494 dea0 10 27 02 e1                  LBEQ LBA39          ; IF NULL STRING SET FPA0
4495 dea4 de 83                        LDU  CHARAD         ; SAVE INPUT POINTER IN REGISTER U
4496 dea6 9f 83                        STX  CHARAD         ; POINT INPUT POINTER TO ADDRESS OF STRING
4497 dea8 3a                           ABX                 ; MOVE POINTER TO END OF STRING TERMINATOR
4498 dea9 a6 84                        LDA  ,X             ; GET LAST BYTE OF STRING
4499 deab 34 52                        PSHS U,X,A          ; SAVE INPUT POINTER, STRING TERMINATOR
4500                         *         ADDRESS AND CHARACTER
4501 dead 6f 84                        CLR  ,X             ; CLEAR STRING TERMINATOR : FOR ASCII - FP CONVERSION
4502 deaf 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
4503 deb1 bd e4 5e                     JSR  LBD12          ; CONVERT AN ASCII STRING TO FLOATING POINT
4504 deb4 35 52                        PULS A,X,U          ; RESTORE CHARACTERS AND POINTERS
4505 deb6 a7 84                        STA  ,X             ; REPLACE STRING TERMINATOR
4506 deb8 df 83                        STU  CHARAD         ; RESTORE INPUT CHARACTER
4507 deba 39                           RTS
4508                         
4509 debb 8d 07              LB734     BSR  LB73D          ; * EVALUATE AN EXPRESSION, RETURN
4510 debd 9f 2b                        STX  BINVAL         ; * THE VALUE IN X; STORE IT IN BINVAL
4511 debf bd d9 f9           LB738     JSR  LB26D          ; SYNTAX CHECK FOR A COMMA
4512 dec2 20 ce                        BRA  LB70B          ; EVALUATE EXPRESSION IN RANGE 0 <= X < 256
4513                         * EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 'FC' ERROR IF
4514                         
4515 dec4 bd d8 cd           LB73D     JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
4516 dec7 96 54              LB740     LDA  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
4517 dec9 2b c2                        BMI  LB706          ; ILLEGAL FUNCTION CALL' IF NEGATIVE
4518 decb 96 4f                        LDA  FP0EXP         ; GET EXPONENT OF FPA0
4519 decd 81 90                        CMPA #$90           ; COMPARE TO LARGEST POSITIVE INTEGER
4520 decf 22 bc                        BHI  LB706          ; ILLEGAL FUNCTION CALL' IF TOO LARGE
4521 ded1 bd e4 14                     JSR  LBCC8          ; SHIFT BINARY POINT TO EXTREME RIGHT OF FPA0
4522 ded4 9e 52                        LDX  FPA0+2         ; LOAD X WITH LOWER TWO BYTES OF FPA0
4523 ded6 39                           RTS
4524                         
4525                         * PEEK
4526 ded7 8d ee              PEEK      BSR  LB740          ; CONVERT FPA0 TO INTEGER IN REGISTER X
4527 ded9 e6 84                        LDB  ,X             ; GET THE VALUE BEING 'PEEK'ED
4528 dedb 7e dc 7a                     JMP  LB4F3          ; CONVERT ACCB INTO A FP NUMBER
4529                         
4530                         * POKE
4531 dede 8d db              POKE      BSR  LB734          ; EVALUATE 2 EXPRESSIONS
4532 dee0 9e 2b                        LDX  BINVAL         ; GET THE ADDRESS TO BE 'POKE'ED
4533 dee2 e7 84                        STB  ,X             ; STORE THE DATA IN THAT ADDRESS
4534 dee4 39                           RTS
4535                         
4536                         
4537                         * LIST
4538 dee5 34 01              LIST      PSHS CC             ; SAVE ZERO FLAG ON STACK
4539 dee7 bd d7 17                     JSR  LAF67          ; CONVERT DECIMAL LINE NUMBER TO BINARY
4540 deea bd d4 a5                     JSR  LAD01          ; * FIND RAM ADDRESS OF THAT LINE NUMBER AND
4541 deed 9f 66                        STX  LSTTXT         ; * SAVE IT IN LSTTXT
4542 deef 35 01                        PULS CC             ; GET ZERO FLAG FROM STACK
4543 def1 27 12                        BEQ  LB784          ; BRANCH IF END OF LINE
4544 def3 9d 82                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
4545 def5 27 13                        BEQ  LB789          ; BRANCH IF END OF LINE
4546 def7 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN (IS IT A RANGE OF LINE NUMBERS?)
4547 def9 26 09                        BNE  LB783          ; NO - RETURN
4548 defb 9d 7c                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
4549 defd 27 06                        BEQ  LB784          ; BRANCH IF END OF LINE
4550 deff bd d7 17                     JSR  LAF67          ; GET ENDING LINE NUMBER
4551 df02 27 06                        BEQ  LB789          ; BRANCH IF LEGAL LINE NUMBER
4552 df04 39                 LB783 RTS
4553                         * LIST THE ENTIRE PROGRAM
4554 df05 ce ff ff           LB784     LDU  #$FFFF         ; * SET THE DEFAULT ENDING LINE NUMBER
4555 df08 df 2b                        STU  BINVAL         ; * TO $FFFF
4556 df0a 32 62              LB789     LEAS 2,S            ; PURGE RETURN ADDRESS FROM THE STACK
4557 df0c 9e 66                        LDX  LSTTXT         ; POINT X TO STARTING LINE ADDRESS
4558 df0e bd e0 ac           LB78D     JSR  LB95C          ; MOVE CURSOR TO START OF A NEW LINE
4559 df11 bd d1 9a                     JSR  LA549          ; CHECK FOR A BREAK OR PAUSE
4560 df14 ec 84                        LDD  ,X             ; GET ADDRESS OF NEXT BASIC LINE
4561 df16 26 03                        BNE  LB79F          ; BRANCH IF NOT END OF PROGRAM
4562                         LB797
4563 df18 7e d4 25                     JMP  LAC73          ; RETURN TO BASIC'S MAIN INPUT LOOP
4564 df1b 9f 66              LB79F     STX  LSTTXT         ; SAVE NEW STARTING LINE ADDRESS
4565 df1d ec 02                        LDD  2,X            ; * GET THE LINE NUMBER OF THIS LINE AND
4566 df1f 10 93 2b                     CMPD BINVAL         ; * COMPARE IT TO ENDING LINE NUMBER
4567 df22 22 f4                        BHI  LB797          ; EXIT IF LINE NUMBER > ENDING LINE NUMBER
4568 df24 bd e5 18                     JSR  LBDCC          ; PRINT THE NUMBER IN ACCD ON SCREEN IN DECIMAL
4569 df27 bd e0 f8                     JSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
4570 df2a 9e 66                        LDX  LSTTXT         ; GET RAM ADDRESS OF THIS LINE
4571 df2c 8d 10                        BSR  LB7C2          ; UNCRUNCH A LINE
4572 df2e ae 9f 00 66                  LDX  [LSTTXT]       ; POINT X TO START OF NEXT LINE
4573 df32 ce 00 f4                     LDU  #LINBUF+1      ; POINT U TO BUFFER FULL OF UNCRUNCHED LINE
4574 df35 a6 c0              LB7B9     LDA  ,U+            ; GET A BYTE FROM THE BUFFER
4575 df37 27 d5                        BEQ  LB78D          ; BRANCH IF END OF BUFFER
4576 df39 bd e0 fd                     JSR  LB9B1          ; SEND CHARACTER TO CONSOLE OUT
4577 df3c 20 f7                        BRA  LB7B9          ; GET ANOTHER CHARACTER
4578                         
4579                         * UNCRUNCH A LINE INTO BASIC'S LINE INPUT BUFFER
4580 df3e 30 04              LB7C2     LEAX 4,X            ; MOVE POINTER PAST ADDRESS OF NEXT LINE AND LINE NUMBER
4581 df40 10 8e 00 f4                  LDY  #LINBUF+1      ; UNCRUNCH LINE INTO LINE INPUT BUFFER
4582 df44 a6 80              LB7CB     LDA  ,X+            ; GET A CHARACTER
4583 df46 27 51                        BEQ  LB820          ; BRANCH IF END OF LINE
4584 df48 2b 15                        BMI  LB7E6          ; BRANCH IF IT'S A TOKEN
4585 df4a 81 3a                        CMPA #':            ; CHECK FOR END OF SUB LINE
4586 df4c 26 0d                        BNE  LB7E2          ; BRNCH IF NOT END OF SUB LINE
4587 df4e e6 84                        LDB  ,X             ; GET CHARACTER FOLLOWING COLON
4588 df50 c1 84                        CMPB #TOK_ELSE      ; TOKEN FOR ELSE?
4589 df52 27 f0                        BEQ  LB7CB          ; YES - DON'T PUT IT IN BUFFER
4590 df54 c1 83                        CMPB #TOK_SNGL_Q    ; TOKEN FOR REMARK?
4591 df56 27 ec                        BEQ  LB7CB          ; YES - DON'T PUT IT IN BUFFER
4592 df58 8c                           FCB  SKP2           ; SKIP TWO BYTES
4593 df59 86 21              LB7E0     LDA  #'!            ; EXCLAMATION POINT
4594 df5b 8d 30              LB7E2     BSR  LB814          ; PUT CHARACTER IN BUFFER
4595 df5d 20 e5                        BRA  LB7CB          ; GET ANOTHER CHARACTER
4596                         
4597 df5f ce d0 e7           LB7E6     LDU  #COMVEC-10     ; FIRST DO COMMANDS
4598 df62 81 ff                        CMPA #$FF           ; CHECK FOR SECONDARY TOKEN
4599 df64 26 04                        BNE  LB7F1          ; BRANCH IF NON SECONDARY TOKEN
4600 df66 a6 80                        LDA  ,X+            ; GET SECONDARY TOKEN
4601 df68 33 45                        LEAU 5,U            ; BUMP IT UP TO SECONDARY FUNCTIONS
4602 df6a 84 7f              LB7F1     ANDA #$7F           ; MASK OFF BIT 7 OF TOKEN
4603 df6c 33 4a              LB7F3     LEAU 10,U           ; MOVE TO NEXT COMMAND TABLE
4604 df6e 6d c4                        TST  ,U             ; IS THIS TABLE ENABLED?
4605 df70 27 e7                        BEQ  LB7E0          ; NO - ILLEGAL TOKEN
4606 df72 a0 c4                        SUBA ,U             ; SUBTRACT THE NUMBER OF TOKENS FROM THE CURRENT TOKEN NUMBER
4607 df74 2a f6                        BPL  LB7F3          ; BRANCH IF TOKEN NOT IN THIS TABLE
4608 df76 ab c4                        ADDA ,U             ; RESTORE TOKEN NUMBER RELATIVE TO THIS TABLE
4609 df78 ee 41                        LDU  1,U            ; POINT U TO COMMAND DICTIONARY TABLE
4610 df7a 4a                 LB801     DECA                ; DECREMENT TOKEN NUMBER
4611 df7b 2b 06                        BMI  LB80A          ; BRANCH IF THIS IS THE CORRECT TOKEN
4612                         * SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN
4613 df7d 6d c0              LB804     TST  ,U+            ; GRAB A BYTE
4614 df7f 2a fc                        BPL  LB804          ; BRANCH IF BIT 7 NOT SET
4615 df81 20 f7                        BRA  LB801          ; GO SEE IF THIS IS THE CORRECT TOKEN
4616 df83 a6 c4              LB80A     LDA  ,U             ; GET A CHARACTER FROM DICTIONARY TABLE
4617 df85 8d 06                        BSR  LB814          ; PUT CHARACTER IN BUFFER
4618 df87 6d c0                        TST  ,U+            ; CHECK FOR START OF NEXT TOKEN
4619 df89 2a f8                        BPL  LB80A          ; BRANCH IF NOT DONE WITH THIS TOKEN
4620 df8b 20 b7                        BRA  LB7CB          ; GO GET ANOTHER CHARACTER
4621 df8d 10 8c 01 ed        LB814     CMPY #LINBUF+LBUFMX ; TEST FOR END OF LINE INPUT BUFFER
4622 df91 24 06                        BCC  LB820          ; BRANCH IF AT END OF BUFFER
4623 df93 84 7f                        ANDA #$7F           ; MASK OFF BIT 7
4624 df95 a7 a0                        STA  ,Y+            ; * SAVE CHARACTER IN BUFFER AND
4625 df97 6f a4                        CLR  ,Y             ; * CLEAR NEXT CHARACTER SLOT IN BUFFER
4626 df99 39                 LB820     RTS
4627                         *
4628                         * CRUNCH THE LINE THAT THE INPUT POINTER IS
4629                         * POINTING TO INTO THE LINE INPUT BUFFER
4630                         * RETURN LENGTH OF CRUNCHED LINE IN ACCD
4631                         *
4632 df9a 9e 83              LB821     LDX  CHARAD         ; GET BASIC'S INPUT POINTER ADDRESS
4633 df9c ce 00 f3                     LDU  #LINBUF        ; POINT X TO LINE INPUT BUFFER
4634 df9f 0f 43              LB829     CLR  V43            ; CLEAR ILLEGAL TOKEN FLAG
4635 dfa1 0f 44                        CLR  V44            ; CLEAR DATA FLAG
4636 dfa3 a6 80              LB82D     LDA  ,X+            ; GET INPUT CHAR
4637 dfa5 27 21                        BEQ  LB852          ; BRANCH IF END OF LINE
4638 dfa7 0d 43                        TST  V43            ; * CHECK ILLEGAL TOKEN FLAG & BRANCH IF NOT
4639 dfa9 27 0f                        BEQ  LB844          ; * PROCESSING AN ILLEGAL TOKEN
4640 dfab bd db 29                     JSR  LB3A2          ; SET CARRY IF NOT UPPER CASE ALPHA
4641 dfae 24 18                        BCC  LB852          ; BRANCH IF UPPER CASE ALPHA
4642 dfb0 81 30                        CMPA #'0            ; * DON'T CRUNCH ASCII NUMERIC CHARACTERS
4643 dfb2 25 04                        BLO  LB842          ; * BRANCH IF NOT NUMERIC
4644 dfb4 81 39                        CMPA #'9            ; *
4645 dfb6 23 10                        BLS  LB852          ; * BRANCH IF NUMERIC
4646                         * END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC
4647 dfb8 0f 43              LB842     CLR  V43            ; CLEAR ILLEGAL TOKEN FLAG
4648 dfba 81 20              LB844     CMPA #SPACE         ; SPACE?
4649 dfbc 27 0a                        BEQ  LB852          ; DO NOT REMOVE SPACES
4650 dfbe 97 42                        STA  V42            ; SAVE INPUT CHARACTER AS SCAN DELIMITER
4651 dfc0 81 22                        CMPA #'"            ; CHECK FOR STRING DELIMITER
4652 dfc2 27 38                        BEQ  LB886          ; BRANCH IF STRING
4653 dfc4 0d 44                        TST  V44            ; * CHECK DATA FLAG AND BRANCH IF CLEAR
4654 dfc6 27 19                        BEQ  LB86B          ; * DO NOT CRUNCH DATA
4655 dfc8 a7 c0              LB852     STA  ,U+            ; SAVE CHARACTER IN BUFFER
4656 dfca 27 06                        BEQ  LB85C          ; BRANCH IF END OF LINE
4657 dfcc 81 3a                        CMPA #':            ; * CHECK FOR END OF SUBLINE
4658 dfce 27 cf                        BEQ  LB829          ; * AND RESET FLAGS IF END OF SUBLINE
4659 dfd0 20 d1              LB85A     BRA  LB82D          ; GO GET ANOTHER CHARACTER
4660 dfd2 6f c0              LB85C     CLR  ,U+            ; * DOUBLE ZERO AT END OF LINE
4661 dfd4 6f c0                        CLR  ,U+            ; *
4662 dfd6 1f 30                        TFR  U,D            ; SAVE ADDRESS OF END OF LINE IN ACCD
4663 dfd8 83 00 f1                     SUBD #LINHDR        ; LENGTH OF LINE IN ACCD
4664 dfdb 8e 00 f2                     LDX  #LINBUF-1      ; * SET THE INPUT POINTER TO ONE BEFORE
4665 dfde 9f 83                        STX  CHARAD         ; * THE START OF THE CRUNCHED LINE
4666 dfe0 39                           RTS                 ; EXIT 'CRUNCH'
4667 dfe1 81 3f              LB86B     CMPA #'?            ; CHECK FOR "?" - PRINT ABBREVIATION
4668 dfe3 26 04                        BNE  LB873          ; BRANCH IF NOT PRINT ABBREVIATION
4669 dfe5 86 87                        LDA  #TOK_PRINT     ; * GET THE PRINT TOKEN AND SAVE IT
4670 dfe7 20 df                        BRA  LB852          ; * IN BUFFER
4671 dfe9 81 27              LB873     CMPA #''            ; APOSTROPHE IS SAME AS REM
4672 dfeb 26 13                        BNE  LB88A          ; BRANCH IF NOT REMARK
4673 dfed cc 3a 83                     LDD  #$3A00+TOK_SNGL_Q ; COLON, REM TOKEN
4674 dff0 ed c1                        STD  ,U++           ; SAVE IN BUFFER
4675 dff2 0f 42              LB87C     CLR  V42            ; SET DELIMITER = 0 (END OF LINE)
4676 dff4 a6 80              LB87E     LDA  ,X+            ; SCAN TILL WE MATCH [V42]
4677 dff6 27 d0                        BEQ  LB852          ; BRANCH IF END OF LINE
4678 dff8 91 42                        CMPA V42            ; DELIMITER?
4679 dffa 27 cc                        BEQ  LB852          ; BRANCH OUT IF SO
4680 dffc a7 c0              LB886     STA  ,U+            ; DON'T CRUNCH REMARKS OR STRINGS
4681 dffe 20 f4                        BRA  LB87E          ; GO GET MORE STRING OR REMARK
4682 e000 81 30              LB88A     CMPA #'0            ; * LESS THAN ASCII ZERO?
4683 e002 25 04                        BCS  LB892          ; * BRANCH IF SO
4684 e004 81 3c                        CMPA #';+1          ; = CHECK FOR NUMERIC VALUE, COLON OR SEMICOLON
4685 e006 25 c0                        BCS  LB852          ; = AND INSERT IN BUFFER IF SO
4686 e008 30 1f              LB892     LEAX -1,X           ; MOVE INPUT POINTER BACK ONE
4687 e00a 34 50                        PSHS U,X            ; SAVE POINTERS TO INPUT STRING, OUTPUT STRING
4688 e00c 0f 41                        CLR  V41            ; TOKEN FLAG 0 = COMMAND, FF = SECONDARY
4689 e00e ce d0 e7                     LDU  #COMVEC-10     ; POINT U TO COMMAND INTERPRETATION
4690                         *                             ; TABLE FOR BASIC - 10
4691 e011 0f 42              LB89B     CLR  V42            ; INITIALIZE V42 AS TOKEN COUNTER
4692 e013 33 4a              LB89D     LEAU 10,U           ; MOVE TO NEXT COMMAND INTERPRETATION TABLE
4693 e015 a6 c4                        LDA  ,U             ; GET NUMBER OF COMMANDS
4694 e017 27 31                        BEQ  LB8D4          ; GO DO SECONDARY FUNCTIONS IF NO COMMAND TABLE
4695 e019 10 ae 41                     LDY  1,U            ; POINT Y TO COMMAND DICTIONARY TABLE
4696 e01c ae e4              LB8A6     LDX  ,S             ; GET POINTER TO INPUT STRING
4697 e01e e6 a0              LB8A8     LDB  ,Y+            ; GET A BYTE FROM DICTIONARY TABLE
4698 e020 e0 80                        SUBB ,X+            ; SUBTRACT INPUT CHARACTER
4699 e022 27 fa                        BEQ  LB8A8          ; LOOP IF SAME
4700 e024 c1 80                        CMPB #$80           ; LAST CHAR IN RESERVED WORD TABLE HAD
4701                         *                             ; BIT 7 SET, SO IF WE HAVE $80 HERE
4702                         *                             ; THEN IT IS A GOOD COMPARE
4703 e026 26 38                        BNE  LB8EA          ; BRANCH IF NO MATCH - CHECK ANOTHER COMMAND
4704 e028 32 62                        LEAS 2,S            ; DELETE OLD INPUT POINTER FROM STACK
4705 e02a 35 40                        PULS U              ; GET POINTER TO OUTPUT STRING
4706 e02c da 42                        ORB  V42            ; OR IN THE TABLE POSITION TO MAKE THE TOKEN
4707                         *                             ; - NOTE THAT B ALREADY HAD $80 IN IT -
4708 e02e 96 41                        LDA  V41            ; * CHECK TOKEN FLAG AND BRANCH
4709 e030 26 06                        BNE  LB8C2          ; * IF SECONDARY
4710 e032 c1 84                        CMPB #TOK_ELSE      ; IS IT ELSE TOKEN?
4711 e034 26 06                        BNE  LB8C6          ; NO
4712 e036 86 3a                        LDA  #':            ; PUT A COLON (SUBLINE) BEFORE ELSE TOKEN
4713 e038 ed c1              LB8C2     STD  ,U++           ; SECONDARY TOKENS PRECEEDED BY $FF
4714 e03a 20 94                        BRA  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
4715 e03c e7 c0              LB8C6     STB  ,U+            ; SAVE THIS TOKEN
4716 e03e c1 86                        CMPB #TOK_DATA      ; DATA TOKEN?
4717 e040 26 02                        BNE  LB8CE          ; NO
4718 e042 0c 44                        INC  V44            ; SET DATA FLAG
4719 e044 c1 82              LB8CE     CMPB #TOK_REM       ; REM TOKEN?
4720 e046 27 aa                        BEQ  LB87C          ; YES
4721 e048 20 86              LB8D2     BRA  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
4722                         * CHECK FOR A SECONDARY TOKEN
4723 e04a ce d0 ec           LB8D4     LDU  #COMVEC-5      ; NOW DO SECONDARY FUNCTIONS
4724 e04d 03 41                        COM  V41            ; TOGGLE THE TOKEN FLAG
4725 e04f 26 c0                        BNE  LB89B          ; BRANCH IF NOW CHECKING SECONDARY COMMANDS
4726                         
4727                         * THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CRUNCHED AND SO
4728                         * IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN
4729 e051 35 50                        PULS X,U            ; RESTORE INPUT AND OUTPUT POINTERS
4730 e053 a6 80                        LDA  ,X+            ; * MOVE THE FIRST CHARACTER OF AN
4731 e055 a7 c0                        STA  ,U+            ; * ILLEGAL TOKEN
4732 e057 bd db 29                     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
4733 e05a 25 ec                        BCS  LB8D2          ; BRANCH IF NOT ALPHA
4734 e05c 03 43                        COM  V43            ; SET ILLEGAL TOKEN FLAG IF UPPER CASE ALPHA
4735 e05e 20 e8                        BRA  LB8D2          ; PROCESS MORE INPUT CHARACTERS
4736 e060 0c 42              LB8EA     INC  V42            ; INCREMENT TOKEN COUNTER
4737 e062 4a                           DECA                ; DECR COMMAND COUNTER
4738 e063 27 ae                        BEQ  LB89D          ; GET ANOTHER COMMAND TABLE IF DONE W/THIS ONE
4739 e065 31 3f                        LEAY -1,Y           ; MOVE POINTER BACK ONE
4740 e067 e6 a0              LB8F1     LDB  ,Y+            ; * GET TO NEXT
4741 e069 2a fc                        BPL  LB8F1          ; * RESERVED WORD
4742 e06b 20 af                        BRA  LB8A6          ; GO SEE IF THIS WORD IS A MATCH
4743                         
4744                         * PRINT
4745 e06d 27 39              PRINT     BEQ  LB958          ; BRANCH IF NO ARGUMENT
4746 e06f 8d 01                        BSR  LB8FE          ; CHECK FOR ALL PRINT OPTIONS
4747 e071 39                           RTS
4748                         LB8FE
4749 e072 bd ef d2           LB918     JSR  XVEC9          ; CALL EXTENDED BASIC ADD-IN
4750 e075 27 3e              LB91B     BEQ  LB965          ; RETURN IF END OF LINE
4751 e077 81 9f              LB91D     CMPA #TOK_TAB       ; TOKEN FOR TAB( ?
4752 e079 27 53                        BEQ  LB97E          ; YES
4753 e07b 81 2c                        CMPA #',            ; COMMA?
4754 e07d 27 37                        BEQ  LB966          ; YES - ADVANCE TO NEXT TAB FIELD
4755 e07f 81 3b                        CMPA #';            ; SEMICOLON?
4756 e081 27 60                        BEQ  LB997          ; YES - DO NOT ADVANCE CURSOR
4757 e083 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
4758 e086 96 06                        LDA  VALTYP         ; * GET VARIABLE TYPE AND
4759 e088 34 02                        PSHS A              ; * SAVE IT ON THE STACK
4760 e08a 26 06                        BNE  LB938          ; BRANCH IF STRING VARIABLE
4761 e08c bd e5 25                     JSR  LBDD9          ; CONVERT FP NUMBER TO AN ASCII STRING
4762 e08f bd dc 9d                     JSR  LB516          ; PARSE A STRING FROM (X-1) AND PUT
4763                         *                             ; DESCRIPTOR ON STRING STACK
4764 e092 8d 57              LB938     BSR  LB99F          ; PRINT STRING POINTED TO BY X
4765 e094 35 04                        PULS B              ; GET VARIABLE TYPE BACK
4766 e096 bd d1 33                     JSR  LA35F          ; SET UP TAB WIDTH ZONE, ETC
4767 e099 5d                 LB949     TSTB                ; CHECK CURRENT PRINT POSITION
4768 e09a 26 08                        BNE  LB954          ; BRANCH IF NOT AT START OF LINE
4769 e09c 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4770 e09e 81 2c                        CMPA #',            ; COMMA?
4771 e0a0 27 14                        BEQ  LB966          ; SKIP TO NEXT TAB FIELD
4772 e0a2 8d 54                        BSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
4773 e0a4 9d 82              LB954     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4774 e0a6 26 cf                        BNE  LB91D          ; BRANCH IF NOT END OF LINE
4775 e0a8 86 0d              LB958     LDA  #CR            ; * SEND A CR TO
4776 e0aa 20 51                        BRA  LB9B1          ; * CONSOLE OUT
4777 e0ac bd d1 33           LB95C     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
4778 e0af 27 f7                        BEQ  LB958          ; BRANCH IF WIDTH = ZERO
4779 e0b1 96 6c                        LDA  DEVPOS         ; GET PRINT POSITION
4780 e0b3 26 f3                        BNE  LB958          ; BRANCH IF NOT AT START OF LINE
4781 e0b5 39                 LB965     RTS
4782                         * SKIP TO NEXT TAB FIELD
4783 e0b6 bd d1 33           LB966     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
4784 e0b9 27 0a                        BEQ  LB975          ; BRANCH IF LINE WIDTH = 0 (CASSETTE)
4785 e0bb d6 6c                        LDB  DEVPOS         ; GET CURRENT POSITION
4786 e0bd d1 6b                        CMPB DEVLCF         ; COMPARE TO LAST TAB ZONE
4787 e0bf 25 06                        BCS  LB977          ; BRANCH IF < LAST TAB ZONE
4788 e0c1 8d e5                        BSR  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
4789 e0c3 20 1e                        BRA  LB997          ; GET MORE DATA
4790 e0c5 d6 6c              LB975     LDB  DEVPOS         ; *
4791 e0c7 d0 6a              LB977     SUBB DEVCFW         ; * SUBTRACT TAB FIELD WIDTH FROM CURRENT
4792 e0c9 24 fc                        BCC  LB977          ; * POSITION UNTIL CARRY SET - NEGATING THE
4793 e0cb 50                           NEGB                ; * REMAINDER LEAVES THE NUMBER OF SPACES TO NEXT
4794                         *              ; * TAB ZONE IN ACCB
4795 e0cc 20 10                        BRA  LB98E          ; GO ADVANCE TO NEXT TAB ZONE
4796                         
4797                         * PRINT TAB(
4798 e0ce bd de 90           LB97E     JSR  LB709          ; EVALUATE EXPRESSION - RETURN VALUE IN B
4799 e0d1 81 29                        CMPA #')            ; * 'SYNTAX' ERROR IF NOT ')'
4800 e0d3 10 26 f9 2c                  LBNE LB277          ; *
4801 e0d7 bd d1 33                     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
4802 e0da d0 6c                        SUBB DEVPOS         ; GET DIFFERENCE OF PRINT POSITION & TAB POSITION
4803 e0dc 23 05                        BLS  LB997          ; BRANCH IF TAB POSITION < CURRENT POSITION
4804                         LB98E
4805 e0de 8d 18              LB992     BSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
4806 e0e0 5a                           DECB                ; DECREMENT DIFFERENCE COUNT
4807 e0e1 26 fb                        BNE  LB992          ; BRANCH UNTIL CURRENT POSITION = TAB POSITION
4808 e0e3 9d 7c              LB997     JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
4809 e0e5 7e e0 75                     JMP  LB91B          ; LOOK FOR MORE PRINT DATA
4810                         * COPY A STRING FROM (X) TO CONSOLE OUT
4811 e0e8 bd dc 9f           LB99C     JSR  LB518          ; PARSE A STRING FROM X AND PUT
4812                         *         DESCRIPTOR ON STRING STACK
4813 e0eb bd dd de           LB99F     JSR  LB657          ; GET LENGTH OF STRING AND REMOVE
4814                         *         DESCRIPTOR FROM STRING STACK
4815 e0ee 5c                           INCB                ; COMPENSATE FOR DECB BELOW
4816 e0ef 5a                 LB9A3     DECB                ; DECREMENT COUNTER
4817 e0f0 27 c3                        BEQ  LB965          ; EXIT ROUTINE
4818 e0f2 a6 80                        LDA  ,X+            ; GET A CHARACTER FROM X
4819 e0f4 8d 07                        BSR  LB9B1          ; SEND TO CONSOLE OUT
4820 e0f6 20 f7                        BRA  LB9A3          ; KEEP LOOPING
4821 e0f8 86 20              LB9AC     LDA  #SPACE         ; SPACE TO CONSOLE OUT
4822 e0fa 8c                           FCB  SKP2           ; SKIP NEXT TWO BYTES
4823 e0fb 86 3f              LB9AF     LDA  #'?            ; QUESTION MARK TO CONSOLE OUT
4824 e0fd 7e d0 17           LB9B1     JMP  PUTCHR         ; JUMP TO CONSOLE OUT
4825                         
4826                         * FLOATING POINT MATH PACKAGE
4827                         
4828                         * ADD .5 TO FPA0
4829 e100 8e e6 0c           LB9B4     LDX  #LBEC0         ; FLOATING POINT CONSTANT (.5)
4830 e103 20 09                        BRA  LB9C2          ; ADD .5 TO FPA0
4831                         * SUBTRACT FPA0 FROM FP NUMBER POINTED
4832                         * TO BY (X), LEAVE RESULT IN FPA0
4833 e105 bd e2 7b           LB9B9     JSR  LBB2F          ; COPY PACKED FP DATA FROM (X) TO FPA1
4834                         
4835                         * ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 FROM FPA1 (ENTER
4836                         * WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 IN ACCA)
4837 e108 03 54              LB9BC     COM  FP0SGN         ; CHANGE MANTISSA SIGN OF FPA0
4838 e10a 03 62                        COM  RESSGN         ; REVERSE RESULT SIGN FLAG
4839 e10c 20 03                        BRA  LB9C5          ; GO ADD FPA1 AND FPA0
4840                         * ADD FP NUMBER POINTED TO BY
4841                         * (X) TO FPA0 - LEAVE RESULT IN FPA0
4842 e10e bd e2 7b           LB9C2     JSR  LBB2F          ; UNPACK PACKED FP DATA FROM (X) TO
4843                         *         FPA1; RETURN EXPONENT OF FPA1 IN ACCA
4844                         
4845                         * ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO
4846                         
4847 e111 5d                 LB9C5     TSTB                ; CHECK EXPONENT OF FPA0
4848 e112 10 27 02 80                  LBEQ LBC4A          ; COPY FPA1 TO FPA0 IF FPA0 =
4849 e116 8e 00 5c                     LDX  #FP1EXP        ; POINT X TO FPA1
4850 e119 1f 89              LB9CD     TFR  A,B            ; PUT EXPONENT OF FPA1 INTO ACCB
4851 e11b 5d                           TSTB                ; CHECK EXPONENT
4852 e11c 27 6c                        BEQ  LBA3E          ; RETURN IF EXPONENT = 0 (ADDING 0 TO FPA0)
4853 e11e d0 4f                        SUBB FP0EXP         ; SUBTRACT EXPONENT OF FPA0 FROM EXPONENT OF FPA1
4854 e120 27 69                        BEQ  LBA3F          ; BRANCH IF EXPONENTS ARE EQUAL
4855 e122 25 0a                        BCS  LB9E2          ; BRANCH IF EXPONENT FPA0 > FPA1
4856 e124 97 4f                        STA  FP0EXP         ; REPLACE FPA0 EXPONENT WITH FPA1 EXPONENT
4857 e126 96 61                        LDA  FP1SGN         ; * REPLACE FPA0 MANTISSA SIGN
4858 e128 97 54                        STA  FP0SGN         ; * WITH FPA1 MANTISSA SIGN
4859 e12a 8e 00 4f                     LDX  #FP0EXP        ; POINT X TO FPA0
4860 e12d 50                           NEGB                ; NEGATE DIFFERENCE OF EXPONENTS
4861 e12e c1 f8              LB9E2     CMPB #-8            ; TEST DIFFERENCE OF EXPONENTS
4862 e130 2f 59                        BLE  LBA3F          ; BRANCH IF DIFFERENCE OF EXPONENTS <= 8
4863 e132 4f                           CLRA                ; CLEAR OVERFLOW BYTE
4864 e133 64 01                        LSR  1,X            ; SHIFT MS BYTE OF MANTISSA; BIT 7 = 0
4865 e135 bd e2 06                     JSR  LBABA          ; GO SHIFT MANTISSA OF (X) TO THE RIGHT (B) TIMES
4866 e138 d6 62              LB9EC     LDB  RESSGN         ; GET SIGN FLAG
4867 e13a 2a 0b                        BPL  LB9FB          ; BRANCH IF FPA0 AND FPA1 SIGNS ARE THE SAME
4868 e13c 63 01                        COM  1,X            ; * COMPLEMENT MANTISSA POINTED
4869 e13e 63 02                        COM  2,X            ; * TO BY (X) THE
4870 e140 63 03                        COM  3,X            ; * ADCA BELOW WILL
4871 e142 63 04                        COM  4,X            ; * CONVERT THIS OPERATION
4872 e144 43                           COMA                ; * INTO A NEG (MANTISSA)
4873 e145 89 00                        ADCA #0             ; ADD ONE TO ACCA - COMA ALWAYS SETS THE CARRY FLAG
4874                         * THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA
4875                         *
4876                         * ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0
4877 e147 97 63              LB9FB     STA  FPSBYT         ; SAVE FPA SUB BYTE
4878 e149 96 53                        LDA  FPA0+3         ; * ADD LS BYTE
4879 e14b 99 60                        ADCA FPA1+3         ; * OF MANTISSA
4880 e14d 97 53                        STA  FPA0+3         ; SAVE IN FPA0 LSB
4881 e14f 96 52                        LDA  FPA0+2         ; * ADD NEXT BYTE
4882 e151 99 5f                        ADCA FPA1+2         ; * OF MANTISSA
4883 e153 97 52                        STA  FPA0+2         ; SAVE IN FPA0
4884 e155 96 51                        LDA  FPA0+1         ; * ADD NEXT BYTE
4885 e157 99 5e                        ADCA FPA1+1         ; * OF MANTISSA
4886 e159 97 51                        STA  FPA0+1         ; SAVE IN FPA0
4887 e15b 96 50                        LDA  FPA0           ; * ADD MS BYTE
4888 e15d 99 5d                        ADCA FPA1           ; * OF MANTISSA
4889 e15f 97 50                        STA  FPA0           ; SAVE IN FPA0
4890 e161 5d                           TSTB                ; TEST SIGN FLAG
4891 e162 2a 44                        BPL  LBA5C          ; BRANCH IF FPA0 & FPA1 SIGNS WERE ALIKE
4892 e164 25 02              LBA18     BCS  LBA1C          ; BRANCH IF POSITIVE MANTISSA
4893 e166 8d 5d                        BSR  LBA79          ; NEGATE FPA0 MANTISSA
4894                         
4895                         * NORMALIZE FPA0
4896 e168 5f                 LBA1C     CLRB                ; CLEAR TEMPORARY EXPONENT ACCUMULATOR
4897 e169 96 50              LBA1D     LDA  FPA0           ; TEST MSB OF MANTISSA
4898 e16b 26 2e                        BNE  LBA4F          ; BRANCH IF <> 0
4899 e16d 96 51                        LDA  FPA0+1         ; * IF THE MSB IS
4900 e16f 97 50                        STA  FPA0           ; * 0, THEN SHIFT THE
4901 e171 96 52                        LDA  FPA0+2         ; * MANTISSA A WHOLE BYTE
4902 e173 97 51                        STA  FPA0+1         ; * AT A TIME. THIS
4903 e175 96 53                        LDA  FPA0+3         ; * IS FASTER THAN ONE
4904 e177 97 52                        STA  FPA0+2         ; * BIT AT A TIME
4905 e179 96 63                        LDA  FPSBYT         ; * BUT USES MORE MEMORY.
4906 e17b 97 53                        STA  FPA0+3         ; * FPSBYT, THE CARRY IN
4907 e17d 0f 63                        CLR  FPSBYT         ; * BYTE, REPLACES THE MATISSA LSB.
4908 e17f cb 08                        ADDB #8             ; SHIFTING ONE BYTE = 8 BIT SHIFTS; ADD 8 TO EXPONENT
4909 e181 c1 28                        CMPB #5*8           ; CHECK FOR 5 SHIFTS
4910 e183 2d e4                        BLT  LBA1D          ; BRANCH IF < 5 SHIFTS, IF > 5, THEN MANTISSA = 0
4911 e185 4f                 LBA39     CLRA                ; A ZERO EXPONENT = 0 FLOATING POINT
4912 e186 97 4f              LBA3A     STA  FP0EXP         ; ZERO OUT THE EXPONENT
4913 e188 97 54                        STA  FP0SGN         ; ZERO OUT THE MANTISSA SIGN
4914 e18a 39                 LBA3E     RTS
4915 e18b 8d 6d              LBA3F     BSR  LBAAE          ; SHIFT FPA0 MANTISSA TO RIGHT
4916 e18d 5f                           CLRB                ; CLEAR CARRY FLAG
4917 e18e 20 a8                        BRA  LB9EC
4918                         * SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7
4919                         * OF MATISSA MS BYTE = 1
4920 e190 5c                 LBA44     INCB                ; ADD ONE TO EXPONENT ACCUMULATOR
4921 e191 08 63                        ASL  FPSBYT         ; SHIFT SUB BYTE ONE LEFT
4922 e193 09 53                        ROL  FPA0+3         ; SHIFT LS BYTE
4923 e195 09 52                        ROL  FPA0+2         ; SHIFT NS BYTE
4924 e197 09 51                        ROL  FPA0+1         ; SHIFT NS BYTE
4925 e199 09 50                        ROL  FPA0           ; SHIFT MS BYTE
4926 e19b 2a f3              LBA4F     BPL  LBA44          ; BRANCH IF NOT YET NORMALIZED
4927 e19d 96 4f                        LDA  FP0EXP         ; GET CURRENT EXPONENT
4928 e19f 34 04                        PSHS B              ; SAVE EXPONENT MODIFIER CAUSED BY NORMALIZATION
4929 e1a1 a0 e0                        SUBA ,S+            ; SUBTRACT ACCUMULATED EXPONENT MODIFIER
4930 e1a3 97 4f                        STA  FP0EXP         ; SAVE AS NEW EXPONENT
4931 e1a5 23 de                        BLS  LBA39          ; SET FPA0 = 0 IF THE NORMALIZATION CAUSED
4932                         *         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE
4933                         *         SIZE OF THE EXPONENT
4934 e1a7 8c                           FCB  SKP2           ; SKIP 2 BYTES
4935 e1a8 25 08              LBA5C     BCS  LBA66          ; BRANCH IF MANTISSA OVERFLOW
4936 e1aa 08 63                        ASL  FPSBYT         ; SUB BYTE BIT 7 TO CARRY - USE AS ROUND-OFF
4937                         *                             ; FLAG (TRUNCATE THE REST OF SUB BYTE)
4938 e1ac 86 00                        LDA  #0             ; CLRA, BUT DO NOT CHANGE CARRY FLAG
4939 e1ae 97 63                        STA  FPSBYT         ; CLEAR THE SUB BYTE
4940 e1b0 20 0c                        BRA  LBA72          ; GO ROUND-OFF RESULT
4941 e1b2 0c 4f              LBA66     INC  FP0EXP         ; INCREMENT EXPONENT - MULTIPLY BY 2
4942 e1b4 27 28                        BEQ  LBA92          ; OVERFLOW ERROR IF CARRY PAST $FF
4943 e1b6 06 50                        ROR  FPA0           ; * SHIFT MANTISSA
4944 e1b8 06 51                        ROR  FPA0+1         ; * ONE TO
4945 e1ba 06 52                        ROR  FPA0+2         ; * THE RIGHT -
4946 e1bc 06 53                        ROR  FPA0+3         ; * DIVIDE BY TWO
4947 e1be 24 04              LBA72     BCC  LBA78          ; BRANCH IF NO ROUND-OFF NEEDED
4948 e1c0 8d 0d                        BSR  LBA83          ; ADD ONE TO MANTISSA - ROUND OFF
4949 e1c2 27 ee                        BEQ  LBA66          ; BRANCH iF OVERFLOW - MANTISSA = 0
4950 e1c4 39                 LBA78     RTS
4951                         * NEGATE FPA0 MANTISSA
4952 e1c5 03 54              LBA79     COM  FP0SGN         ; TOGGLE SIGN OF MANTISSA
4953 e1c7 03 50              LBA7B     COM  FPA0           ; * COMPLEMENT ALL 4 MANTISSA BYTES
4954 e1c9 03 51                        COM  FPA0+1         ; *
4955 e1cb 03 52                        COM  FPA0+2         ; *
4956 e1cd 03 53                        COM  FPA0+3         ; *
4957                         * ADD ONE TO FPA0 MANTISSA
4958 e1cf 9e 52              LBA83     LDX  FPA0+2         ; * GET BOTTOM 2 MANTISSA
4959 e1d1 30 01                        LEAX 1,X            ; * BYTES, ADD ONE TO
4960 e1d3 9f 52                        STX  FPA0+2         ; * THEM AND SAVE THEM
4961 e1d5 26 06                        BNE  LBA91          ; BRANCH IF NO OVERFLOW
4962 e1d7 9e 50                        LDX  FPA0           ; * IF OVERFLOW ADD ONE
4963 e1d9 30 01                        LEAX 1,X            ; * TO TOP 2 MANTISSA
4964 e1db 9f 50                        STX  FPA0           ; * BYTES AND SAVE THEM
4965 e1dd 39                 LBA91     RTS
4966 e1de c6 0a              LBA92     LDB  #2*5           ; OV' OVERFLOW ERROR
4967 e1e0 7e d4 06                     JMP  LAC46          ; PROCESS AN ERROR
4968 e1e3 8e 00 12           LBA97     LDX  #FPA2-1        ; POINT X TO FPA2
4969                         * SHIFT FPA POINTED TO BY (X) TO
4970                         * THE RIGHT -(B) TIMES. EXIT WITH
4971                         * ACCA CONTAINING DATA SHIFTED OUT
4972                         * TO THE RIGHT (SUB BYTE) AND THE DATA
4973                         * SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY
4974 e1e6 a6 04              LBA9A     LDA  4,X            ; GET LS BYTE OF MANTISSA (X)
4975 e1e8 97 63                        STA  FPSBYT         ; SAVE IN FPA SUB BYTE
4976 e1ea a6 03                        LDA  3,X            ; * SHIFT THE NEXT THREE BYTES OF THE
4977 e1ec a7 04                        STA  4,X            ; * MANTISSA RIGHT ONE COMPLETE BYTE.
4978 e1ee a6 02                        LDA  2,X            ; *
4979 e1f0 a7 03                        STA  3,X            ; *
4980 e1f2 a6 01                        LDA  1,X            ; *
4981 e1f4 a7 02                        STA  2,X            ; *
4982 e1f6 96 5b                        LDA  FPCARY         ; GET THE CARRY IN BYTE
4983 e1f8 a7 01                        STA  1,X            ; STORE AS THE MS MANTISSA BYTE OF (X)
4984 e1fa cb 08              LBAAE     ADDB #8             ; ADD 8 TO DIFFERENCE OF EXPONENTS
4985 e1fc 2f e8                        BLE  LBA9A          ; BRANCH IF EXPONENT DIFFERENCE < -8
4986 e1fe 96 63                        LDA  FPSBYT         ; GET FPA SUB BYTE
4987 e200 c0 08                        SUBB #8             ; CAST OUT THE 8 ADDED IN ABOVE
4988 e202 27 0c                        BEQ  LBAC4          ; BRANCH IF EXPONENT DIFFERENCE = 0
4989                         
4990                         
4991 e204 67 01              LBAB8     ASR  1,X            ; * SHIFT MANTISSA AND SUB BYTE ONE BIT TO THE RIGHT
4992 e206 66 02              LBABA     ROR  2,X            ; *
4993 e208 66 03                        ROR  3,X            ; *
4994 e20a 66 04                        ROR  4,X            ; *
4995 e20c 46                           RORA                ; *
4996 e20d 5c                           INCB                ; ADD ONE TO EXPONENT DIFFERENCE
4997 e20e 26 f4                        BNE  LBAB8          ; BRANCH IF EXPONENTS NOT =
4998 e210 39                 LBAC4     RTS
4999 e211 81 00 00 00 00     LBAC5     FCB  $81,$00,$00,$00,$00 ; FLOATING POINT CONSTANT 1.0
5000                         
5001                         * ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY
5002                         * FPA0 BY (X) - RETURN PRODUCT IN FPA0
5003 e216 8d 63              LBACA     BSR  LBB2F          ; MOVE PACKED FPA FROM (X) TO FPA1
5004 e218 27 60              LBACC     BEQ  LBB2E          ; BRANCH IF EXPONENT OF FPA0 = 0
5005 e21a 8d 78                        BSR  LBB48          ; CALCULATE EXPONENT OF PRODUCT
5006                         * MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE
5007                         * HIGH ORDER BYTES OF PRODUCT IN FPA0. THE
5008                         * LOW ORDER FOUR BYTES OF THE PRODUCT WILL
5009                         * BE STORED IN VAB-VAE.
5010 e21c 86 00              LBAD0     LDA  #0             ; * ZERO OUT MANTISSA OF FPA2
5011 e21e 97 13                        STA  FPA2           ; *
5012 e220 97 14                        STA  FPA2+1         ; *
5013 e222 97 15                        STA  FPA2+2         ; *
5014 e224 97 16                        STA  FPA2+3         ; *
5015 e226 d6 53                        LDB  FPA0+3         ; GET LS BYTE OF FPA0
5016 e228 8d 22                        BSR  LBB00          ; MULTIPLY BY FPA1
5017 e22a d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 4
5018 e22c d7 8b                        STB  VAE            ; *
5019 e22e d6 52                        LDB  FPA0+2         ; GET NUMBER 3 MANTISSA BYTE OF FPA0
5020 e230 8d 1a                        BSR  LBB00          ; MULTIPLY BY FPA1
5021 e232 d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 3
5022 e234 d7 8a                        STB  VAD            ; *
5023 e236 d6 51                        LDB  FPA0+1         ; GET NUMBER 2 MANTISSA BYTE OF FPA0
5024 e238 8d 12                        BSR  LBB00          ; MULTIPLY BY FPA1
5025 e23a d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 2
5026 e23c d7 89                        STB  VAC            ; *
5027 e23e d6 50                        LDB  FPA0           ; GET MS BYTE OF FPA0 MANTISSA
5028 e240 8d 0c                        BSR  LBB02          ; MULTIPLY BY FPA1
5029 e242 d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 1
5030 e244 d7 88                        STB  VAB            ; *
5031 e246 bd e3 57                     JSR  LBC0B          ; COPY MANTISSA FROM FPA2 TO FPA0
5032 e249 7e e1 68                     JMP  LBA1C          ; NORMALIZE FPA0
5033 e24c 27 95              LBB00     BEQ  LBA97          ; SHIFT FPA2 ONE BYTE TO RIGHT
5034 e24e 43                 LBB02     COMA                ; SET CARRY FLAG
5035                         * MULTIPLY FPA1 MANTISSA BY ACCB AND
5036                         * ADD PRODUCT TO FPA2 MANTISSA
5037 e24f 96 13              LBB03     LDA  FPA2           ; GET FPA2 MS BYTE
5038 e251 56                           RORB                ; ROTATE CARRY FLAG INTO SHIFT COUNTER;
5039                         *         DATA BIT INTO CARRY
5040 e252 27 26                        BEQ  LBB2E          ; BRANCH WHEN 8 SHIFTS DONE
5041 e254 24 16                        BCC  LBB20          ; DO NOT ADD FPA1 IF DATA BIT = 0
5042 e256 96 16                        LDA  FPA2+3         ; * ADD MANTISSA LS BYTE
5043 e258 9b 60                        ADDA FPA1+3         ; *
5044 e25a 97 16                        STA  FPA2+3         ; *
5045 e25c 96 15                        LDA  FPA2+2         ; = ADD MANTISSA NUMBER 3 BYTE
5046 e25e 99 5f                        ADCA FPA1+2         ; =
5047 e260 97 15                        STA  FPA2+2         ; =
5048 e262 96 14                        LDA  FPA2+1         ; * ADD MANTISSA NUMBER 2 BYTE
5049 e264 99 5e                        ADCA FPA1+1         ; *
5050 e266 97 14                        STA  FPA2+1         ; *
5051 e268 96 13                        LDA  FPA2           ; = ADD MANTISSA MS BYTE
5052 e26a 99 5d                        ADCA FPA1           ; =
5053 e26c 46                 LBB20     RORA                ; * ROTATE CARRY INTO MS BYTE
5054 e26d 97 13                        STA  FPA2           ; *
5055 e26f 06 14                        ROR  FPA2+1         ; = ROTATE FPA2 ONE BIT TO THE RIGHT
5056 e271 06 15                        ROR  FPA2+2         ; =
5057 e273 06 16                        ROR  FPA2+3         ; =
5058 e275 06 63                        ROR  FPSBYT         ; =
5059 e277 4f                           CLRA                ; CLEAR CARRY FLAG
5060 e278 20 d5                        BRA  LBB03          ; KEEP LOOPING
5061 e27a 39                 LBB2E     RTS
5062                         * UNPACK A FP NUMBER FROM (X) TO FPA1
5063 e27b ec 01              LBB2F     LDD  1,X            ; GET TWO MSB BYTES OF MANTISSA FROM
5064                         *         FPA  POINTED TO BY X
5065 e27d 97 61                        STA  FP1SGN         ; SAVE PACKED MANTISSA SIGN BYTE
5066 e27f 8a 80                        ORA  #$80           ; FORCE BIT 7 OF MSB MANTISSA = 1
5067 e281 dd 5d                        STD  FPA1           ; SAVE 2 MSB BYTES IN FPA1
5068 e283 d6 61                        LDB  FP1SGN         ; * GET PACKED MANTISSA SIGN BYTE. EOR W/FPA0
5069 e285 d8 54                        EORB FP0SGN         ; * SIGN - NEW SIGN POSITION IF BOTH OLD SIGNS ALIKE,
5070 e287 d7 62                        STB  RESSGN         ; * NEG IF BOTH OLD SIGNS DIFF. SAVE ADJUSTED
5071                         *                             ; * MANTISSA SIGN BYTE
5072 e289 ec 03                        LDD  3,X            ; = GET 2 LSB BYTES OF MANTISSA
5073 e28b dd 5f                        STD  FPA1+2         ; = AND PUT IN FPA1
5074 e28d a6 84                        LDA  ,X             ; * GET EXPONENT FROM (X) AND
5075 e28f 97 5c                        STA  FP1EXP         ; * PUT IN EXPONENT OF FPA1
5076 e291 d6 4f                        LDB  FP0EXP         ; GET EXPONENT OF FPA0
5077 e293 39                           RTS
5078                         * CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1
5079                         * ENTER WITH EXPONENT OF FPA1 IN ACCA
5080 e294 4d                 LBB48     TSTA                ; TEST EXPONENT OF FPA1
5081 e295 27 16                        BEQ  LBB61          ; PURGE RETURN ADDRESS & SET FPA0 = 0
5082 e297 9b 4f                        ADDA FP0EXP         ; ADD FPA1 EXPONENT TO FPA0 EXPONENT
5083 e299 46                           RORA                ; ROTATE CARRY INTO BIT 7; BIT 0 INTO CARRY
5084 e29a 49                           ROLA                ; SET OVERFLOW FLAG
5085 e29b 28 10                        BVC  LBB61          ; BRANCH IF EXPONENT TOO LARGE OR SMALL
5086 e29d 8b 80                        ADDA #$80           ; ADD $80 BIAS TO EXPONENT
5087 e29f 97 4f                        STA  FP0EXP         ; SAVE NEW EXPONENT
5088 e2a1 27 0c                        BEQ  LBB63          ; SET FPA0
5089 e2a3 96 62                        LDA  RESSGN         ; GET MANTISSA SIGN
5090 e2a5 97 54                        STA  FP0SGN         ; SAVE AS MANTISSA SIGN OF FPA0
5091 e2a7 39                           RTS
5092                         * IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0
5093                         * = IS NEGATIVE THEN FPA0 = 0
5094 e2a8 96 54              LBB5C     LDA  FP0SGN         ; GET MANTISSA SIGN OF FPA0
5095 e2aa 43                           COMA                ; CHANGE SIGN OF FPA0 MANTISSA
5096 e2ab 20 02                        BRA  LBB63
5097 e2ad 32 62              LBB61     LEAS 2,S            ; PURGE RETURN ADDRESS FROM STACK
5098 e2af 10 2a fe d2        LBB63     LBPL LBA39          ; ZERO FPA0 MANTISSA SIGN & EXPONENT
5099 e2b3 7e e1 de           LBB67     JMP  LBA92          ; 'OV' OVERFLOW ERROR
5100                         * FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0
5101 e2b6 bd e3 ab           LBB6A     JSR  LBC5F          ; TRANSFER FPA0 TO FPA1
5102 e2b9 27 0d                        BEQ  LBB7C          ; BRANCH IF EXPONENT = 0
5103 e2bb 8b 02                        ADDA #2             ; ADD 2 TO EXPONENT (TIMES 4)
5104 e2bd 25 f4                        BCS  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
5105 e2bf 0f 62                        CLR  RESSGN         ; CLEAR RESULT SIGN BYTE
5106 e2c1 bd e1 19                     JSR  LB9CD          ; ADD FPA1 TO FPA0 (TIMES 5)
5107 e2c4 0c 4f                        INC  FP0EXP         ; ADD ONE TO EXPONENT (TIMES 10)
5108 e2c6 27 eb                        BEQ  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
5109 e2c8 39                 LBB7C     RTS
5110 e2c9 84 20 00 00 00     LBB7D     FCB  $84,$20,$00,$00,$00 ; FLOATING POINT CONSTANT 10
5111                         * DIVIDE FPA0 BY 10
5112 e2ce bd e3 ab           LBB82     JSR  LBC5F          ; MOVE FPA0 TO FPA1
5113 e2d1 8e e2 c9                     LDX  #LBB7D         ; POINT TO FLOATING POINT CONSTANT 10
5114 e2d4 5f                           CLRB                ; ZERO MANTISSA SIGN BYTE
5115 e2d5 d7 62              LBB89     STB  RESSGN         ; STORE THE QUOTIENT MANTISSA SIGN BYTE
5116 e2d7 bd e3 60                     JSR  LBC14          ; UNPACK AN FP NUMBER FROM (X) INTO FPA0
5117 e2da 8c                           FCB  SKP2           ; SKIP TWO BYTES
5118                         * DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0
5119 e2db 8d 9e              LBB8F     BSR  LBB2F          ; GET FP NUMBER FROM (X) TO FPA1
5120                         
5121                         * ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY FPA0 (ENTER WITH
5122                         * EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY TSTA)
5123                         
5124                         * DIVIDE FPA1 BY FPA0
5125 e2dd 27 73              LBB91     BEQ  LBC06          ; '/0' DIVIDE BY ZERO ERROR
5126 e2df 00 4f                        NEG  FP0EXP         ; GET EXPONENT OF RECIPROCAL OF DIVISOR
5127 e2e1 8d b1                        BSR  LBB48          ; CALCULATE EXPONENT OF QUOTIENT
5128 e2e3 0c 4f                        INC  FP0EXP         ; INCREMENT EXPONENT
5129 e2e5 27 cc                        BEQ  LBB67          ; 'OV' OVERFLOW ERROR
5130 e2e7 8e 00 13                     LDX  #FPA2          ; POINT X TO MANTISSA OF FPA2 - HOLD
5131                         *                             ; TEMPORARY QUOTIENT IN FPA2
5132 e2ea c6 04                        LDB  #4             ; 5 BYTE DIVIDE
5133 e2ec d7 03                        STB  TMPLOC         ; SAVE BYTE COUNTER
5134 e2ee c6 01                        LDB  #1             ; SHIFT COUNTER-AND TEMPORARY QUOTIENT BYTE
5135                         * COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -
5136                         * SET CARRY FLAG IF FPA1 >= FPA0
5137 e2f0 96 50              LBBA4     LDA  FPA0           ; * COMPARE THE TWO MS BYTES
5138 e2f2 91 5d                        CMPA FPA1           ; * OF FPA0 AND FPA1 AND
5139 e2f4 26 13                        BNE  LBBBD          ; * BRANCH IF <>
5140 e2f6 96 51                        LDA  FPA0+1         ; = COMPARE THE NUMBER 2
5141 e2f8 91 5e                        CMPA FPA1+1         ; = BYTES AND
5142 e2fa 26 0d                        BNE  LBBBD          ; = BRANCH IF <>
5143 e2fc 96 52                        LDA  FPA0+2         ; * COMPARE THE NUMBER 3
5144 e2fe 91 5f                        CMPA FPA1+2         ; * BYTES AND
5145 e300 26 07                        BNE  LBBBD          ; * BRANCH IF <>
5146 e302 96 53                        LDA  FPA0+3         ; = COMPARE THE LS BYTES
5147 e304 91 60                        CMPA FPA1+3         ; = AND BRANCH
5148 e306 26 01                        BNE  LBBBD          ; = IF <>
5149 e308 43                           COMA                ; SET CARRY FLAG IF FPA0 = FPA1
5150 e309 1f a8              LBBBD     TFR  CC,A           ; SAVE CARRY FLAG STATUS IN ACCA; CARRY
5151                         *         CLEAR IF FPA0 > FPA1
5152 e30b 59                           ROLB                ; ROTATE CARRY INTO TEMPORARY QUOTIENT BYTE
5153 e30c 24 0a                        BCC  LBBCC          ; CARRY WILL BE SET AFTER 8 SHIFTS
5154 e30e e7 80                        STB  ,X+            ; SAVE TEMPORARY QUOTIENT
5155 e310 0a 03                        DEC  TMPLOC         ; DECREMENT BYTE COUNTER
5156 e312 2b 34                        BMI  LBBFC          ; BRANCH IF DONE
5157 e314 27 2e                        BEQ  LBBF8          ; BRANCH IF LAST BYTE
5158 e316 c6 01                        LDB  #1             ; RESET SHIFT COUNTER AND TEMPORARY QUOTIENT BYTE
5159 e318 1f 8a              LBBCC     TFR  A,CC           ; RESTORE CARRY FLAG AND
5160 e31a 25 0e                        BCS  LBBDE          ; BRANCH IF FPA0 =< FPA1
5161 e31c 08 60              LBBD0     ASL  FPA1+3         ; * SHIFT FPA1 MANTISSA 1 BIT TO LEFT
5162 e31e 09 5f                        ROL  FPA1+2         ; *
5163 e320 09 5e                        ROL  FPA1+1         ; *
5164 e322 09 5d                        ROL  FPA1           ; *
5165 e324 25 e3                        BCS  LBBBD          ; BRANCH IF CARRY - ADD ONE TO PARTIAL QUOTIENT
5166 e326 2b c8                        BMI  LBBA4          ; IF MSB OF HIGH ORDER MANTISSA BYTE IS
5167                         *         SET, CHECK THE MAGNITUDES OF FPA0, FPA1
5168 e328 20 df                        BRA  LBBBD          ; CARRY IS CLEAR, CHECK ANOTHER BIT
5169                         * SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1
5170 e32a 96 60              LBBDE     LDA  FPA1+3         ; * SUBTRACT THE LS BYTES OF MANTISSA
5171 e32c 90 53                        SUBA FPA0+3         ; *
5172 e32e 97 60                        STA  FPA1+3         ; *
5173 e330 96 5f                        LDA  FPA1+2         ; = THEN THE NEXT BYTE
5174 e332 92 52                        SBCA FPA0+2         ; =
5175 e334 97 5f                        STA  FPA1+2         ; =
5176 e336 96 5e                        LDA  FPA1+1         ; * AND THE NEXT
5177 e338 92 51                        SBCA FPA0+1         ; *
5178 e33a 97 5e                        STA  FPA1+1         ; *
5179 e33c 96 5d                        LDA  FPA1           ; = AND FINALLY, THE MS BYTE OF MANTISSA
5180 e33e 92 50                        SBCA FPA0           ; =
5181 e340 97 5d                        STA  FPA1           ; =
5182 e342 20 d8                        BRA  LBBD0          ; GO SHIFT FPA1
5183 e344 c6 40              LBBF8     LDB  #$40           ; USE ONLY TWO BITS OF THE LAST BYTE (FIFTH)
5184 e346 20 d0                        BRA  LBBCC          ; GO SHIFT THE LAST BYTE
5185 e348 56                 LBBFC     RORB                ; * SHIFT CARRY (ALWAYS SET HERE) INTO
5186 e349 56                           RORB                ; * BIT 5 AND MOVE
5187 e34a 56                           RORB                ; * BITS 1,0 TO BITS 7,6
5188 e34b d7 63                        STB  FPSBYT         ; SAVE SUB BYTE
5189 e34d 8d 08                        BSR  LBC0B          ; MOVE MANTISSA OF FPA2 TO FPA0
5190 e34f 7e e1 68                     JMP  LBA1C          ; NORMALIZE FPA0
5191 e352 c6 14              LBC06     LDB  #2*10          ; /0' ERROR
5192 e354 7e d4 06                     JMP  LAC46          ; PROCESS THE ERROR
5193                         * COPY MANTISSA FROM FPA2 TO FPA0
5194 e357 9e 13              LBC0B     LDX  FPA2           ; * MOVE TOP 2 BYTES
5195 e359 9f 50                        STX  FPA0           ; *
5196 e35b 9e 15                        LDX  FPA2+2         ; = MOVE BOTTOM 2 BYTES
5197 e35d 9f 52                        STX  FPA0+2         ; =
5198 e35f 39                           RTS
5199                         * COPY A PACKED FP NUMBER FROM (X) TO FPA0
5200 e360 34 02              LBC14     PSHS A              ; SAVE ACCA
5201 e362 ec 01                        LDD  1,X            ; GET TOP TWO MANTISSA BYTES
5202 e364 97 54                        STA  FP0SGN         ; SAVE MS BYTE OF MANTISSA AS MANTISSA SIGN
5203 e366 8a 80                        ORA  #$80           ; UNPACK MS BYTE
5204 e368 dd 50                        STD  FPA0           ; SAVE UNPACKED TOP 2 MANTISSA BYTES
5205 e36a 0f 63                        CLR  FPSBYT         ; CLEAR MANTISSA SUB BYTE
5206 e36c e6 84                        LDB  ,X             ; GET EXPONENT TO ACCB
5207 e36e ae 03                        LDX  3,X            ; * MOVE LAST 2
5208 e370 9f 52                        STX  FPA0+2         ; * MANTISSA BYTES
5209 e372 d7 4f                        STB  FP0EXP         ; SAVE EXPONENT
5210 e374 35 82                        PULS A,PC           ; RESTORE ACCA AND RETURN
5211                         
5212 e376 8e 00 45           LBC2A     LDX  #V45           ; POINT X TO MANTISSA OF FPA4
5213 e379 20 06                        BRA  LBC35          ; MOVE FPA0 TO FPA4
5214 e37b 8e 00 40           LBC2F     LDX  #V40           ; POINT X TO MANTISSA OF FPA3
5215 e37e 8c                           FCB  SKP2           ; SKIP TWO BYTES
5216 e37f 9e 3b              LBC33     LDX  VARDES         ; POINT X TO VARIABLE DESCRIPTOR IN VARDES
5217                         * PACK FPA0 AND MOVE IT TO ADDRESS IN X
5218 e381 96 4f              LBC35     LDA  FP0EXP         ; * COPY EXPONENT
5219 e383 a7 84                        STA  ,X             ; *
5220 e385 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN BIT
5221 e387 8a 7f                        ORA  #$7F           ; MASK THE BOTTOM 7 BITS
5222 e389 94 50                        ANDA FPA0           ; AND BIT 7 OF MANTISSA SIGN INTO BIT 7 OF MS BYTE
5223 e38b a7 01                        STA  1,X            ; SAVE MS BYTE
5224 e38d 96 51                        LDA  FPA0+1         ; * MOVE 2ND MANTISSA BYTE
5225 e38f a7 02                        STA  2,X            ; *
5226 e391 de 52                        LDU  FPA0+2         ; = MOVE BOTTOM 2 MANTISSA BYTES
5227 e393 ef 03                        STU  3,X            ; =
5228 e395 39                           RTS
5229                         * MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA
5230 e396 96 61              LBC4A     LDA  FP1SGN         ; * COPY MANTISSA SIGN FROM
5231 e398 97 54              LBC4C     STA  FP0SGN         ; * FPA1 TO FPA0
5232 e39a 9e 5c                        LDX  FP1EXP         ; = COPY EXPONENT + MS BYTE FROM
5233 e39c 9f 4f                        STX  FP0EXP         ; = FPA1 TO FPA0
5234 e39e 0f 63                        CLR  FPSBYT         ; CLEAR MANTISSA SUB BYTE
5235 e3a0 96 5e                        LDA  FPA1+1         ; * COPY 2ND MANTISSA BYTE
5236 e3a2 97 51                        STA  FPA0+1         ; * FROM FPA1 TO FPA0
5237 e3a4 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN
5238 e3a6 9e 5f                        LDX  FPA1+2         ; * COPY 3RD AND 4TH MANTISSA BYTE
5239 e3a8 9f 52                        STX  FPA0+2         ; * FROM FPA1 TO FPA0
5240 e3aa 39                           RTS
5241                         * TRANSFER FPA0 TO FPA1
5242 e3ab dc 4f              LBC5F     LDD  FP0EXP         ; * TRANSFER EXPONENT & MS BYTE
5243 e3ad dd 5c                        STD  FP1EXP         ; *
5244 e3af 9e 51                        LDX  FPA0+1         ; = TRANSFER MIDDLE TWO BYTES
5245 e3b1 9f 5e                        STX  FPA1+1         ; =
5246 e3b3 9e 53                        LDX  FPA0+3         ; * TRANSFER BOTTOM TWO BYTES
5247 e3b5 9f 60                        STX  FPA1+3         ; *
5248 e3b7 4d                           TSTA                ; SET FLAGS ACCORDING TO EXPONENT
5249 e3b8 39                           RTS
5250                         * CHECK FPA0; RETURN ACCB = 0 IF FPA0 = 0,
5251                         * ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = POSITIVE
5252 e3b9 d6 4f              LBC6D     LDB  FP0EXP         ; GET EXPONENT
5253 e3bb 27 08                        BEQ  LBC79          ; BRANCH IF FPA0 = 0
5254 e3bd d6 54              LBC71     LDB  FP0SGN         ; GET SIGN OF MANTISSA
5255 e3bf 59                 LBC73     ROLB                ; BIT 7 TO CARRY
5256 e3c0 c6 ff                        LDB  #$FF           ; NEGATIVE FLAG
5257 e3c2 25 01                        BCS  LBC79          ; BRANCH IF NEGATIVE MANTISSA
5258 e3c4 50                           NEGB                ; ACCB = 1 IF POSITIVE MANTISSA
5259 e3c5 39                 LBC79     RTS
5260                         
5261                         * SGN
5262 e3c6 8d f1              SGN       BSR  LBC6D          ; SET ACCB ACCORDING TO SIGN OF FPA0
5263                         * CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POINT NUMBER
5264 e3c8 d7 50              LBC7C     STB  FPA0           ; SAVE ACCB IN FPA0
5265 e3ca 0f 51                        CLR  FPA0+1         ; CLEAR NUMBER 2 MANTISSA BYTE OF FPA0
5266 e3cc c6 88                        LDB  #$88           ; EXPONENT REQUIRED IF FPA0 IS TO BE AN INTEGER
5267 e3ce 96 50              LBC82     LDA  FPA0           ; GET MS BYTE OF MANTISSA
5268 e3d0 80 80                        SUBA #$80           ; SET CARRY IF POSITIVE MANTISSA
5269 e3d2 d7 4f              LBC86     STB  FP0EXP         ; SAVE EXPONENT
5270 e3d4 dc 74                        LDD  ZERO           ; * ZERO OUT ACCD AND
5271 e3d6 dd 52                        STD  FPA0+2         ; * BOTTOM HALF OF FPA0
5272 e3d8 97 63                        STA  FPSBYT         ; CLEAR SUB BYTE
5273 e3da 97 54                        STA  FP0SGN         ; CLEAR SIGN OF FPA0 MANTISSA
5274 e3dc 7e e1 64                     JMP  LBA18          ; GO NORMALIZE FPA0
5275                         
5276                         * ABS
5277 e3df 0f 54              ABS       CLR  FP0SGN         ; FORCE MANTISSA SIGN OF FPA0 POSITIVE
5278 e3e1 39                           RTS
5279                         * COMPARE A PACKED FLOATING POINT NUMBER POINTED TO
5280                         * BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN
5281                         * ZERO FLAG SET AND ACCB = 0, IF EQUAL; ACCB = 1 IF
5282                         * FPA0 > (X); ACCB = $FF IF FPA0 < (X)
5283 e3e2 e6 84              LBC96     LDB  ,X             ; CHECK EXPONENT OF (X)
5284 e3e4 27 d3                        BEQ  LBC6D          ; BRANCH IF FPA = 0
5285 e3e6 e6 01                        LDB  1,X            ; GET MS BYTE OF MANTISSA OF (X)
5286 e3e8 d8 54                        EORB FP0SGN         ; EOR WITH SIGN OF FPA0
5287 e3ea 2b d1                        BMI  LBC71          ; BRANCH IF SIGNS NOT =
5288                         * COMPARE FPA0 WITH FP NUMBER POINTED TO BY (X).
5289                         * FPA0 IS NORMALIZED, (X) IS PACKED.
5290 e3ec d6 4f              LBCA0     LDB  FP0EXP         ; * GET EXPONENT OF
5291 e3ee e1 84                        CMPB ,X             ; * FPA0, COMPARE TO EXPONENT OF
5292 e3f0 26 1d                        BNE  LBCC3          ; * (X) AND BRANCH IF <>.
5293 e3f2 e6 01                        LDB  1,X            ; * GET MS BYTE OF (X), KEEP ONLY
5294 e3f4 ca 7f                        ORB  #$7F           ; * THE SIGN BIT - 'AND' THE BOTTOM 7
5295 e3f6 d4 50                        ANDB FPA0           ; * BITS OF FPA0 INTO ACCB
5296 e3f8 e1 01                        CMPB 1,X            ; = COMPARE THE BOTTOM 7 BITS OF THE MANTISSA
5297 e3fa 26 13                        BNE  LBCC3          ; = MS BYTE AND BRANCH IF <>
5298 e3fc d6 51                        LDB  FPA0+1         ; * COMPARE 2ND BYTE
5299 e3fe e1 02                        CMPB 2,X            ; * OF MANTISSA,
5300 e400 26 0d                        BNE  LBCC3          ; * BRANCH IF <>
5301 e402 d6 52                        LDB  FPA0+2         ; = COMPARE 3RD BYTE
5302 e404 e1 03                        CMPB 3,X            ; = OF MANTISSA,
5303 e406 26 07                        BNE  LBCC3          ; = BRANCH IF <>
5304 e408 d6 53                        LDB  FPA0+3         ; * SUBTRACT LS BYTE
5305 e40a e0 04                        SUBB 4,X            ; * OF (X) FROM LS BYTE OF
5306 e40c 26 01                        BNE  LBCC3          ; * FPA0, BRANCH IF <>
5307 e40e 39                           RTS                 ; RETURN IF FP (X) = FPA0
5308 e40f 56                 LBCC3     RORB                ; SHIFT CARRY TO BIT 7; CARRY SET IF FPA0 < (X)
5309 e410 d8 54                        EORB FP0SGN         ; TOGGLE SIZE COMPARISON BIT IF FPA0 IS NEGATIVE
5310 e412 20 ab                        BRA  LBC73          ; GO SET ACCB ACCORDING TO COMPARISON
5311                         * DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BINARY POINT IS TO THE RIGHT
5312                         * OF THE LEAST SIGNIFICANT BYTE OF THE MANTISSA
5313 e414 d6 4f              LBCC8     LDB  FP0EXP         ; GET EXPONENT OF FPA0
5314 e416 27 3d                        BEQ  LBD09          ; ZERO MANTISSA IF FPA0 = 0
5315 e418 c0 a0                        SUBB #$A0           ; SUBTRACT $A0 FROM FPA0 EXPONENT T THIS WILL YIELD
5316                         *                             ; THE NUMBER OF SHIFTS REQUIRED TO DENORMALIZE FPA0. WHEN
5317                         *                             ; THE EXPONENT OF FPA0 IS = ZERO, THEN THE BINARY POINT
5318                         *                             ; WILL BE TO THE RIGHT OF THE MANTISSA
5319 e41a 96 54                        LDA  FP0SGN         ; TEST SIGN OF FPA0 MANTISSA
5320 e41c 2a 05                        BPL  LBCD7          ; BRANCH IF POSITIVE
5321 e41e 03 5b                        COM  FPCARY         ; COMPLEMENT CARRY IN BYTE
5322 e420 bd e1 c7                     JSR  LBA7B          ; NEGATE MANTISSA OF FPA0
5323 e423 8e 00 4f           LBCD7     LDX  #FP0EXP        ; POINT X TO FPA0
5324 e426 c1 f8                        CMPB #-8            ; EXPONENT DIFFERENCE < -8?
5325 e428 2e 06                        BGT  LBCE4          ; YES
5326 e42a bd e1 fa                     JSR  LBAAE          ; SHIFT FPA0 RIGHT UNTIL FPA0 EXPONENT = $A0
5327 e42d 0f 5b                        CLR  FPCARY         ; CLEAR CARRY IN BYTE
5328 e42f 39                           RTS
5329 e430 0f 5b              LBCE4     CLR  FPCARY         ; CLEAR CARRY IN BYTE
5330 e432 96 54                        LDA  FP0SGN         ; * GET SIGN OF FPA0 MANTISSA
5331 e434 49                           ROLA                ; * ROTATE IT INTO THE CARRY FLAG
5332 e435 06 50                        ROR  FPA0           ; ROTATE CARRY (MANTISSA SIGN) INTO BIT 7
5333                         *                             ; OF LS BYTE OF MANTISSA
5334 e437 7e e2 06                     JMP  LBABA          ; DE-NORMALIZE FPA0
5335                         
5336                         * INT
5337                         * THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS IT WILL SHIFT THE BINARY POINT
5338                         * TO THE EXTREME RIGHT OF THE MANTISSA TO FORCE ITS EXPONENT TO BE $AO. ONCE
5339                         * THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE FOUR LEAST SIGNIFICANT
5340                         * BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUSION OF THE DE-NORMALIZATION
5341                         * ONLY THE INTEGER PORTION OF FPA0 WILL REMAIN.
5342                         *
5343 e43a d6 4f              INT       LDB  FP0EXP         ; GET EXPONENT OF FPA0
5344 e43c c1 a0                        CMPB #$A0           ; LARGEST POSSIBLE INTEGER EXPONENT
5345 e43e 24 1d                        BCC  LBD11          ; RETURN IF FPA0 >= 32768
5346 e440 8d d2                        BSR  LBCC8          ; SHIFT THE BINARY POINT ONE TO THE RIGHT OF THE
5347                         *                             ; LS BYTE OF THE FPA0 MANTISSA
5348 e442 d7 63                        STB  FPSBYT         ; ACCB = 0: ZERO OUT THE SUB BYTE
5349 e444 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN
5350 e446 d7 54                        STB  FP0SGN         ; FORCE MANTISSA SIGN TO BE POSITIVE
5351 e448 80 80                        SUBA #$80           ; SET CARRY IF MANTISSA
5352 e44a 86 a0                        LDA  #$A0           ; * GET DENORMALIZED EXPONENT AND
5353 e44c 97 4f                        STA  FP0EXP         ; * SAVE IT IN FPA0 EXPONENT
5354 e44e 96 53                        LDA  FPA0+3         ; = GET LS BYTE OF FPA0 AND
5355 e450 97 01                        STA  CHARAC         ; = SAVE IT IN CHARAC
5356 e452 7e e1 64                     JMP  LBA18          ; NORMALIZE FPA0
5357                         
5358 e455 d7 50              LBD09     STB  FPA0           ; * LOAD MANTISSA OF FPA0 WITH CONTENTS OF ACCB
5359 e457 d7 51                        STB  FPA0+1         ; *
5360 e459 d7 52                        STB  FPA0+2         ; *
5361 e45b d7 53                        STB  FPA0+3         ; *
5362 e45d 39                 LBD11     RTS                 ; *
5363                         
5364                         * CONVERT ASCII STRING TO FLOATING POINT
5365 e45e 9e 74              LBD12     LDX  ZERO           ; (X) = 0
5366 e460 9f 54                        STX  FP0SGN         ; * ZERO OUT FPA0 & THE SIGN FLAG (COEFCT)
5367 e462 9f 4f                        STX  FP0EXP         ; *
5368 e464 9f 51                        STX  FPA0+1         ; *
5369 e466 9f 52                        STX  FPA0+2         ; *
5370 e468 9f 47                        STX  V47            ; INITIALIZE EXPONENT & EXPONENT SIGN FLAG TO ZERO
5371 e46a 9f 45                        STX  V45            ; INITIALIZE RIGHT DECIMAL CTR & DECIMAL PT FLAG TO 0
5372 e46c 25 64                        BCS  LBD86          ; IF CARRY SET (NUMERIC CHARACTER), ASSUME ACCA CONTAINS FIRST
5373                         *         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE RAM HOOK
5374 e46e bd eb 9b                     JSR  XVEC19         ; CALL EXTENDED BASIC ADD-IN
5375 e471 81 2d              LBD25     CMPA #'-            ; * CHECK FOR A LEADING MINUS SIGN AND BRANCH
5376 e473 26 04                        BNE  LBD2D          ; * IF NO MINUS SIGN
5377 e475 03 55                        COM  COEFCT         ; TOGGLE SIGN; 0 = +; FF = -
5378 e477 20 04                        BRA  LBD31          ; INTERPRET THE REST OF THE STRING
5379 e479 81 2b              LBD2D     CMPA #'+            ; * CHECK FOR LEADING PLUS SlGN AND BRANCH
5380 e47b 26 04                        BNE  LBD35          ; * IF NOT A PLUS SIGN
5381 e47d 9d 7c              LBD31     JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
5382 e47f 25 51                        BCS  LBD86          ; BRANCH IF NUMERIC CHARACTER
5383 e481 81 2e              LBD35     CMPA #'.            ; DECIMAL POlNT?
5384 e483 27 28                        BEQ  LBD61          ; YES
5385 e485 81 45                        CMPA #'E            ; "E" SHORTHAND FORM (SCIENTIFIC NOTATION)?
5386 e487 26 28                        BNE  LBD65          ; NO
5387                         * EVALUATE EXPONENT OF EXPONENTIAL FORMAT
5388 e489 9d 7c                        JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
5389 e48b 25 64                        BCS  LBDA5          ; BRANCH IF NUMERIC
5390 e48d 81 a7                        CMPA #TOK_MINUS     ; MINUS TOKEN?
5391 e48f 27 0e                        BEQ  LBD53          ; YES
5392 e491 81 2d                        CMPA #'-            ; ASCII MINUS?
5393 e493 27 0a                        BEQ  LBD53          ; YES
5394 e495 81 a6                        CMPA #TOK_PLUS      ; PLUS TOKEN?
5395 e497 27 08                        BEQ  LBD55          ; YES
5396 e499 81 2b                        CMPA #'+            ; ASCII PLUS?
5397 e49b 27 04                        BEQ  LBD55          ; YES
5398 e49d 20 06                        BRA  LBD59          ; BRANCH IF NO SIGN FOUND
5399 e49f 03 48              LBD53     COM  V48            ; SET EXPONENT SIGN FLAG TO NEGATIVE
5400                         * STRIP A DECIMAL NUMBER FROM BASIC LINE, CONVERT IT TO BINARY IN V47
5401 e4a1 9d 7c              LBD55     JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
5402 e4a3 25 4c                        BCS  LBDA5          ; IF NUMERIC CHARACTER, CONVERT TO BINARY
5403 e4a5 0d 48              LBD59     TST  V48            ; * CHECK EXPONENT SIGN FLAG
5404 e4a7 27 08                        BEQ  LBD65          ; * AND BRANCH IF POSITIVE
5405 e4a9 00 47                        NEG  V47            ; NEGATE VALUE OF EXPONENT
5406 e4ab 20 04                        BRA  LBD65
5407 e4ad 03 46              LBD61     COM  V46            ; *TOGGLE DECIMAL PT FLAG AND INTERPRET ANOTHER
5408 e4af 26 cc                        BNE  LBD31          ; *CHARACTER IF <> 0 - TERMINATE INTERPRETATION
5409                         *         IF   SECOND DECIMAL POINT
5410                         * ADJUST FPA0 FOR THE DECIMAL EXPONENT IN V47
5411 e4b1 96 47              LBD65     LDA  V47            ; * GET EXPONENT, SUBTRACT THE NUMBER OF
5412 e4b3 90 45                        SUBA V45            ; * PLACES TO THE RIGHT OF DECIMAL POINT
5413 e4b5 97 47                        STA  V47            ; * AND RESAVE IT.
5414 e4b7 27 12                        BEQ  LBD7F          ; EXIT ROUTINE IF ADJUSTED EXPONENT = ZERO
5415 e4b9 2a 09                        BPL  LBD78          ; BRANCH IF POSITIVE EXPONENT
5416 e4bb bd e2 ce           LBD6F     JSR  LBB82          ; DIVIDE FPA0 BY 10
5417 e4be 0c 47                        INC  V47            ; INCREMENT EXPONENT COUNTER (MULTIPLY BY 10)
5418 e4c0 26 f9                        BNE  LBD6F          ; KEEP MULTIPLYING
5419 e4c2 20 07                        BRA  LBD7F          ; EXIT ROUTINE
5420 e4c4 bd e2 b6           LBD78     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
5421 e4c7 0a 47                        DEC  V47            ; DECREMENT EXPONENT COUNTER (DIVIDE BY 10)
5422 e4c9 26 f9                        BNE  LBD78          ; KEEP MULTIPLYING
5423 e4cb 96 55              LBD7F     LDA  COEFCT         ; GET THE SIGN FLAG
5424 e4cd 2a 8e                        BPL  LBD11          ; RETURN IF POSITIVE
5425 e4cf 7e e6 35                     JMP  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0, IF NEGATIVE
5426                         *MULTIPLY FPA0 BY TEN AND ADD ACCA TO THE RESULT
5427 e4d2 d6 45              LBD86     LDB  V45            ; *GET THE RIGHT DECIMAL COUNTER AND SUBTRACT
5428 e4d4 d0 46                        SUBB V46            ; *THE DECIMAL POINT FLAG FROM IT. IF DECIMAL POINT
5429 e4d6 d7 45                        STB  V45            ; *FLAG=0, NOTHING HAPPENS. IF DECIMAL POINT FLAG IS
5430                         *                             -1, THEN RIGHT DECIMAL COUNTER IS INCREMENTED BY ONE
5431 e4d8 34 02                        PSHS A              ; SAVE NEW DIGIT ON STACK
5432 e4da bd e2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
5433 e4dd 35 04                        PULS B              ; GET NEW DIGIT BACK
5434 e4df c0 30                        SUBB #'0            ; MASK OFF ASCII
5435 e4e1 8d 02                        BSR  LBD99          ; ADD ACCB TO FPA0
5436 e4e3 20 98                        BRA  LBD31          ; GET ANOTHER CHARACTER FROM BASIC
5437 e4e5 bd e3 7b           LBD99     JSR  LBC2F          ; PACK FPA0 AND SAVE IT IN FPA3
5438 e4e8 bd e3 c8                     JSR  LBC7C          ; CONVERT ACCB TO FP NUMBER IN FPA0
5439 e4eb 8e 00 40                     LDX  #V40           ; * ADD FPA0 TO
5440 e4ee 7e e1 0e                     JMP  LB9C2          ; * FPA3
5441                         
5442                         
5443 e4f1 d6 47              LBDA5     LDB  V47
5444 e4f3 58                           ASLB                ; TIMES 2
5445 e4f4 58                           ASLB                ; TIMES 4
5446 e4f5 db 47                        ADDB V47            ; ADD 1 = TIMES 5
5447 e4f7 58                           ASLB                ; TIMES 10
5448 e4f8 80 30                        SUBA #'0            ; *MASK OFF ASCII FROM ACCA, PUSH
5449 e4fa 34 04                        PSHS B              ; *RESULT ONTO THE STACK AND
5450 e4fc ab e0                        ADDA ,S+            ; ADD lT TO ACCB
5451 e4fe 97 47                        STA  V47            ; SAVE IN V47
5452 e500 20 9f                        BRA  LBD55          ; INTERPRET ANOTHER CHARACTER
5453                         *
5454 e502 9b 3e bc 1f fd     LBDB6     FCB  $9B,$3E,$BC,$1F,$FD ; * 99999999.9
5455 e507 9e 6e 6b 27 fd     LBDBB     FCB  $9E,$6E,$6B,$27,$FD ; * 999999999
5456 e50c 9e 6e 6b 28 00     LBDC0     FCB  $9E,$6E,$6B,$28,$00 ; * 1E + 09
5457                         *
5458 e511 8e d3 a7           LBDC5     LDX  #LABE8-1       ; POINT X TO " IN " MESSAGE
5459 e514 8d 0c                        BSR  LBDD6          ; COPY A STRING FROM (X) TO CONSOLE OUT
5460 e516 dc 68                        LDD  CURLIN         ; GET CURRENT BASIC LINE NUMBER TO ACCD
5461                         * CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER
5462                         * AND PRINT IT TO CONSOLE OUT
5463 e518 dd 50              LBDCC     STD  FPA0           ; SAVE ACCD IN TOP HALF OF FPA0
5464 e51a c6 90                        LDB  #$90           ; REQ'D EXPONENT IF TOP HALF OF ACCD = INTEGER
5465 e51c 43                           COMA                ; SET CARRY FLAG - FORCE POSITIVE MANTISSA
5466 e51d bd e3 d2                     JSR  LBC86          ; ZERO BOTTOM HALF AND SIGN OF FPA0, THEN
5467                         *         SAVE EXPONENT AND NORMALIZE IT
5468 e520 8d 03                        BSR  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
5469 e522 7e e0 e8           LBDD6     JMP  LB99C          ; COPY A STRING FROM (X) TO CONSOLE OUT
5470                         
5471                         * CONVERT FP NUMBER TO ASCII STRING
5472 e525 ce 01 f1           LBDD9     LDU  #STRBUF+3      ; POINT U TO BUFFER WHICH WILL NOT CAUSE
5473                         *                             ; THE STRING TO BE STORED IN STRING SPACE
5474 e528 86 20              LBDDC     LDA  #SPACE         ; SPACE = DEFAULT SIGN FOR POSITIVE #
5475 e52a d6 54                        LDB  FP0SGN         ; GET SIGN OF FPA0
5476 e52c 2a 02                        BPL  LBDE4          ; BRANCH IF POSITIVE
5477 e52e 86 2d                        LDA  #'-            ; ASCII MINUS SIGN
5478 e530 a7 c0              LBDE4     STA  ,U+            ; STORE SIGN OF NUMBER
5479 e532 df 64                        STU  COEFPT         ; SAVE BUFFER POINTER
5480 e534 97 54                        STA  FP0SGN         ; SAVE SIGN (IN ASCII)
5481 e536 86 30                        LDA  #'0            ; ASCII ZERO IF EXPONENT = 0
5482 e538 d6 4f                        LDB  FP0EXP         ; GET FPA0 EXPONENT
5483 e53a 10 27 00 c6                  LBEQ LBEB8          ; BRANCH IF FPA0 = 0
5484 e53e 4f                           CLRA                ; BASE 10 EXPONENT=0 FOR FP NUMBER > 1
5485 e53f c1 80                        CMPB #$80           ; CHECK EXPONENT
5486 e541 22 08                        BHI  LBDFF          ; BRANCH IF FP NUMBER > 1
5487                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE CONVERSION PROCESS
5488 e543 8e e5 0c                     LDX  #LBDC0         ; POINT X TO FP 1E+09
5489 e546 bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY (X)
5490 e549 86 f7                        LDA  #-9            ; BASE 10 EXPONENT = -9
5491 e54b 97 45              LBDFF     STA  V45            ; BASE 10 EXPONENT
5492                         * PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE RANGE
5493                         * OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST
5494                         * NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE
5495                         * SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING
5496                         * SCIENTIFIC NOTATION
5497 e54d 8e e5 07           LBE01     LDX  #LBDBB         ; POINT X TO FP 999,999,999
5498 e550 bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO 999,999,999
5499 e553 2e 0f                        BGT  LBE18          ; BRANCH IF > 999,999,999
5500 e555 8e e5 02           LBE09     LDX  #LBDB6         ; POINT X TO FP 99,999,999.9
5501 e558 bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO 99,999,999.9
5502 e55b 2e 0e                        BGT  LBE1F          ; BRANCH IF > 99,999,999.9 (IN RANGE)
5503 e55d bd e2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
5504 e560 0a 45                        DEC  V45            ; SUBTRACT ONE FROM DECIMAL OFFSET
5505 e562 20 f1                        BRA  LBE09          ; PSEUDO - NORMALIZE SOME MORE
5506 e564 bd e2 ce           LBE18     JSR  LBB82          ; DIVIDE FPA0 BY 10
5507 e567 0c 45                        INC  V45            ; ADD ONE TO BASE 10 EXPONENT
5508 e569 20 e2                        BRA  LBE01          ; PSEUDO - NORMALIZE SOME MORE
5509 e56b bd e1 00           LBE1F     JSR  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
5510 e56e bd e4 14                     JSR  LBCC8          ; CONVERT FPA0 TO AN INTEGER
5511 e571 c6 01                        LDB  #1             ; DEFAULT DECIMAL POINT FLAG (FORCE IMMED DECIMAL PT)
5512 e573 96 45                        LDA  V45            ; * GET BASE 10 EXPONENT AND ADD TEN TO IT
5513 e575 8b 0a                        ADDA #9+1           ; * (NUMBER 'NORMALIZED' TO 9 PLACES & DECIMAL PT)
5514 e577 2b 09                        BMI  LBE36          ; BRANCH IF NUMBER < 1.0
5515 e579 81 0b                        CMPA #9+2           ; NINE PLACES MAY BE DISPLAYED WITHOUT
5516                         *         USING SCIENTIFIC NOTATION
5517 e57b 24 05                        BCC  LBE36          ; BRANCH IF SCIENTIFIC NOTATION REQUIRED
5518 e57d 4a                           DECA                ; * SUBTRACT 1 FROM MODIFIED BASE 10 EXPONENT CTR
5519 e57e 1f 89                        TFR  A,B            ; * AND SAVE IT IN ACCB (DECiMAL POINT FLAG)
5520 e580 86 02                        LDA  #2             ; FORCE EXPONENT = 0 - DON'T USE SCIENTIFIC NOTATION
5521 e582 4a                 LBE36     DECA                ; * SUBTRACT TWO (WITHOUT AFFECTING CARRY)
5522 e583 4a                           DECA                ; * FROM BASE 10 EXPONENT
5523 e584 97 47                        STA  V47            ; SAVE EXPONENT - ZERO EXPONENT = DO NOT DISPLAY
5524                         *         IN   SCIENTIFIC NOTATION
5525 e586 d7 45                        STB  V45            ; DECIMAL POINT FLAG - NUMBER OF PLACES TO
5526                         *         LEFT OF DECIMAL POINT
5527 e588 2e 0d                        BGT  LBE4B          ; BRANCH IF >= 1
5528 e58a de 64                        LDU  COEFPT         ; POINT U TO THE STRING BUFFER
5529 e58c 86 2e                        LDA  #'.            ; * STORE A PERIOD
5530 e58e a7 c0                        STA  ,U+            ; * IN THE BUFFER
5531 e590 5d                           TSTB                ; CHECK DECIMAL POINT FLAG
5532 e591 27 04                        BEQ  LBE4B          ; BRANCH IF NOTHING TO LEFT OF DECIMAL POINT
5533 e593 86 30                        LDA  #'0            ; * STORE A ZERO
5534 e595 a7 c0                        STA  ,U+            ; * IN THE BUFFER
5535                         
5536                         * CONVERT FPA0 INTO A STRING OF ASCII DIGITS
5537 e597 8e e6 11           LBE4B     LDX  #LBEC5         ; POINT X TO FP POWER OF 10 MANTISSA
5538 e59a c6 80                        LDB  #0+$80         ; INITIALIZE DIGIT COUNTER TO 0+$80
5539                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
5540                         * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
5541                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB IS HOW
5542                         * THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.
5543 e59c 96 53              LBE50     LDA  FPA0+3         ; * ADD MANTISSA LS
5544 e59e ab 03                        ADDA 3,X            ; * BYTE OF FPA0
5545 e5a0 97 53                        STA  FPA0+3         ; * AND (X)
5546 e5a2 96 52                        LDA  FPA0+2         ; = ADD MANTISSA
5547 e5a4 a9 02                        ADCA 2,X            ; = NUMBER 3 BYTE OF
5548 e5a6 97 52                        STA  FPA0+2         ; = FPA0 AND (X)
5549 e5a8 96 51                        LDA  FPA0+1         ; * ADD MANTISSA
5550 e5aa a9 01                        ADCA 1,X            ; * NUMBER 2 BYTE OF
5551 e5ac 97 51                        STA  FPA0+1         ; * FPA0 AND (X)
5552 e5ae 96 50                        LDA  FPA0           ; = ADD MANTISSA
5553 e5b0 a9 84                        ADCA ,X             ; = MS BYTE OF
5554 e5b2 97 50                        STA  FPA0           ; = FPA0 AND (X)
5555 e5b4 5c                           INCB                ; ADD ONE TO DIGIT COUNTER
5556 e5b5 56                           RORB                ; ROTATE CARRY INTO BIT 7
5557 e5b6 59                           ROLB                ; *SET OVERFLOW FLAG AND BRANCH IF CARRY = 1 AND
5558 e5b7 28 e3                        BVC  LBE50          ; *POSITIVE MANTISSA OR CARRY = 0 AND NEG MANTISSA
5559 e5b9 24 03                        BCC  LBE72          ; BRANCH IF NEGATIVE MANTISSA
5560 e5bb c0 0b                        SUBB #10+1          ; * TAKE THE 9'S COMPLEMENT IF
5561 e5bd 50                           NEGB                ; * ADDING MANTISSA
5562 e5be cb 2f              LBE72     ADDB #'0-1          ; ADD ASCII OFFSET TO DIGIT
5563 e5c0 30 04                        LEAX 4,X            ; MOVE TO NEXT POWER OF 10 MANTISSA
5564 e5c2 1f 98                        TFR  B,A            ; SAVE DIGIT IN ACCA
5565 e5c4 84 7f                        ANDA #$7F           ; MASK OFF BIT 7 (ADD/SUBTRACT FLAG)
5566 e5c6 a7 c0                        STA  ,U+            ; STORE DIGIT IN STRING BUFFER
5567 e5c8 0a 45                        DEC  V45            ; DECREMENT DECIMAL POINT FLAG
5568 e5ca 26 04                        BNE  LBE84          ; BRANCH IF NOT TIME FOR DECIMAL POINT
5569 e5cc 86 2e                        LDA  #'.            ; * STORE DECIMAL POINT IN
5570 e5ce a7 c0                        STA  ,U+            ; * STRING BUFFER
5571 e5d0 53                 LBE84     COMB                ; TOGGLE BIT 7 (ADD/SUBTRACT FLAG)
5572 e5d1 c4 80                        ANDB #$80           ; MASK OFF ALL BUT ADD/SUBTRACT FLAG
5573 e5d3 8c e6 35                     CMPX #LBEC5+36      ; COMPARE X TO END OF MANTISSA TABLE
5574 e5d6 26 c4                        BNE  LBE50          ; BRANCH IF NOT AT END OF TABLE
5575                         * BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY
5576 e5d8 a6 c2              LBE8C     LDA  ,-U            ; GET THE LAST CHARACTER; MOVE POINTER BACK
5577 e5da 81 30                        CMPA #'0            ; WAS IT A ZERO?
5578 e5dc 27 fa                        BEQ  LBE8C          ; IGNORE TRAILING ZEROS IF SO
5579 e5de 81 2e                        CMPA #'.            ; CHECK FOR DECIMAL POINT
5580 e5e0 26 02                        BNE  LBE98          ; BRANCH IF NOT DECIMAL POINT
5581 e5e2 33 5f                        LEAU -1,U           ; STEP OVER THE DECIMAL POINT
5582 e5e4 86 2b              LBE98     LDA  #'+            ; ASCII PLUS SIGN
5583 e5e6 d6 47                        LDB  V47            ; GET SCIENTIFIC NOTATION EXPONENT
5584 e5e8 27 1c                        BEQ  LBEBA          ; BRANCH IF NOT SCIENTIFIC NOTATION
5585 e5ea 2a 03                        BPL  LBEA3          ; BRANCH IF POSITIVE EXPONENT
5586 e5ec 86 2d                        LDA  #'-            ; ASCII MINUS SIGN
5587 e5ee 50                           NEGB                ; NEGATE EXPONENT IF NEGATIVE
5588 e5ef a7 42              LBEA3     STA  2,U            ; STORE EXPONENT SIGN IN STRING
5589 e5f1 86 45                        LDA  #'E            ; * GET ASCII 'E' (SCIENTIFIC NOTATION
5590 e5f3 a7 41                        STA  1,U            ; * FLAG) AND SAVE IT IN THE STRING
5591 e5f5 86 2f                        LDA  #'0-1          ; INITIALIZE ACCA TO ASCII ZERO
5592                         
5593                         
5594 e5f7 4c                 LBEAB     INCA                ; ADD ONE TO 10'S DIGIT OF EXPONENT
5595 e5f8 c0 0a                        SUBB #10            ; SUBTRACT 10 FROM ACCB
5596 e5fa 24 fb                        BCC  LBEAB          ; ADD 1 TO 10'S DIGIT IF NO CARRY
5597 e5fc cb 3a                        ADDB #'9+1          ; CONVERT UNITS DIGIT TO ASCII
5598 e5fe ed 43                        STD  3,U            ; SAVE EXPONENT IN STRING
5599 e600 6f 45                        CLR  5,U            ; CLEAR LAST BYTE (TERMINATOR)
5600 e602 20 04                        BRA  LBEBC          ; GO RESET POINTER
5601 e604 a7 c4              LBEB8     STA  ,U             ; STORE LAST CHARACTER
5602 e606 6f 41              LBEBA     CLR  1,U            ; CLEAR LAST BYTE (TERMINATOR - REQUIRED BY
5603                         *         PRINT SUBROUTINES)
5604 e608 8e 01 f1           LBEBC     LDX  #STRBUF+3      ; RESET POINTER TO START OF BUFFER
5605 e60b 39                           RTS
5606                         *
5607 e60c 80 00 00 00 00     LBEC0     FCB  $80,$00,$00,$00,$00 ; FLOATING POINT .5
5608                         *
5609                         *** TABLE OF UNNORMALIZED POWERS OF 10
5610 e611 fa 0a 1f 00        LBEC5     FCB  $FA,$0A,$1F,$00 ; -100000000
5611 e615 00 98 96 80        LBEC9     FCB  $00,$98,$96,$80 ; 10000000
5612 e619 ff f0 bd c0        LBECD     FCB  $FF,$F0,$BD,$C0 ; -1000000
5613 e61d 00 01 86 a0        LBED1     FCB  $00,$01,$86,$A0 ; 100000
5614 e621 ff ff d8 f0        LBED5     FCB  $FF,$FF,$D8,$F0 ; -10000
5615 e625 00 00 03 e8        LBED9     FCB  $00,$00,$03,$E8 ; 1000
5616 e629 ff ff ff 9c        LBEDD     FCB  $FF,$FF,$FF,$9C ; -100
5617 e62d 00 00 00 0a        LBEE1     FCB  $00,$00,$00,$0A ; 10
5618 e631 ff ff ff ff        LBEE5     FCB  $FF,$FF,$FF,$FF ; -1
5619                         *
5620                         *
5621 e635 96 4f              LBEE9     LDA  FP0EXP         ; GET EXPONENT OF FPA0
5622 e637 27 02                        BEQ  LBEEF          ; BRANCH IF FPA0 = 0
5623 e639 03 54                        COM  FP0SGN         ; TOGGLE MANTISSA SIGN OF FPA0
5624 e63b 39                 LBEEF     RTS
5625                         * EXPAND A POLYNOMIAL OF THE FORM
5626                         * AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0
5627                         * AND THE X REGISTER POINTS TO A TABLE OF
5628                         * COEFFICIENTS A,B,C,D....
5629 e63c 9f 64              LBEF0     STX  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
5630 e63e bd e3 7b                     JSR  LBC2F          ; MOVE FPA0 TO FPA3
5631 e641 8d 05                        BSR  LBEFC          ; MULTIPLY FPA3 BY FPA0
5632 e643 8d 08                        BSR  LBF01          ; EXPAND POLYNOMIAL
5633 e645 8e 00 40                     LDX  #V40           ; POINT X TO FPA3
5634 e648 7e e2 16           LBEFC     JMP  LBACA          ; MULTIPLY (X) BY FPA0
5635                         
5636                         * CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL
5637                         * EXPRESSION. ENTER WITH (X) POINTING TO A TABLE
5638                         * OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE
5639                         * NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER
5640                         * OF PACKED FLOATING POINT NUMBERS. THE
5641                         * POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =
5642                         * (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0...YN)
5643 e64b 9f 64              LBEFF     STX  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
5644 e64d bd e3 76           LBF01     JSR  LBC2A          ; MOVE FPA0 TO FPA4
5645 e650 9e 64                        LDX  COEFPT         ; GET THE COEFFICIENT POINTER
5646 e652 e6 80                        LDB  ,X+            ; GET THE TOP OF COEFFICIENT TABLE TO
5647 e654 d7 55                        STB  COEFCT         ; * USE AND STORE IT IN TEMPORARY COUNTER
5648 e656 9f 64                        STX  COEFPT         ; SAVE NEW COEFFICIENT POINTER
5649 e658 8d ee              LBF0C     BSR  LBEFC          ; MULTIPLY (X) BY FPA0
5650 e65a 9e 64                        LDX  COEFPT         ; *GET COEFFICIENT POINTER
5651 e65c 30 05                        LEAX 5,X            ; *MOVE TO NEXT FP NUMBER
5652 e65e 9f 64                        STX  COEFPT         ; *SAVE NEW COEFFICIENT POINTER
5653 e660 bd e1 0e                     JSR  LB9C2          ; ADD (X) AND FPA0
5654 e663 8e 00 45                     LDX  #V45           ; POINT (X) TO FPA4
5655 e666 0a 55                        DEC  COEFCT         ; DECREMENT TEMP COUNTER
5656 e668 26 ee                        BNE  LBF0C          ; BRANCH IF MORE COEFFICIENTS LEFT
5657 e66a 39                           RTS
5658                         
5659                         * RND
5660 e66b bd e3 b9           RND       JSR  LBC6D          ; TEST FPA0
5661 e66e 2b 1f                        BMI  LBF45          ; BRANCH IF FPA0 = NEGATIVE
5662 e670 27 15                        BEQ  LBF3B          ; BRANCH IF FPA0 = 0
5663 e672 8d 10                        BSR  LBF38          ; CONVERT FPA0 TO AN INTEGER
5664 e674 bd e3 7b                     JSR  LBC2F          ; PACK FPA0 TO FPA3
5665 e677 8d 0e                        BSR  LBF3B          ; GET A RANDOM NUMBER: FPA0 < 1.0
5666 e679 8e 00 40                     LDX  #V40           ; POINT (X) TO FPA3
5667 e67c 8d ca                        BSR  LBEFC          ; MULTIPLY (X) BY FPA0
5668 e67e 8e e2 11                     LDX  #LBAC5         ; POINT (X) TO FP VALUE OF 1.0
5669 e681 bd e1 0e                     JSR  LB9C2          ; ADD 1.0 TO FPA0
5670 e684 7e e4 3a           LBF38     JMP  INT            ; CONVERT FPA0 TO AN INTEGER
5671                         * CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.0
5672 e687 9e b1              LBF3B     LDX  RVSEED+1       ; * MOVE VARIABLE
5673 e689 9f 50                        STX  FPA0           ; * RANDOM NUMBER
5674 e68b 9e b3                        LDX  RVSEED+3       ; * SEED TO
5675 e68d 9f 52                        STX  FPA0+2         ; * FPA0
5676 e68f be e6 bc           LBF45     LDX  RSEED          ; = MOVE FIXED
5677 e692 9f 5d                        STX  FPA1           ; = RANDOM NUMBER
5678 e694 be e6 be                     LDX  RSEED+2        ; = SEED TO
5679 e697 9f 5f                        STX  FPA1+2         ; = MANTISSA OF FPA0
5680 e699 bd e2 1c                     JSR  LBAD0          ; MULTIPLY FPA0 X FPA1
5681 e69c dc 8a                        LDD  VAD            ; GET THE TWO LOWEST ORDER PRODUCT BYTES
5682 e69e c3 65 8b                     ADDD #$658B         ; ADD A CONSTANT
5683 e6a1 dd b3                        STD  RVSEED+3       ; SAVE NEW LOW ORDER VARIABLE RANDOM # SEED
5684 e6a3 dd 52                        STD  FPA0+2         ; SAVE NEW LOW ORDER BYTES OF FPA0 MANTISSA
5685 e6a5 dc 88                        LDD  VAB            ; GET 2 MORE LOW ORDER PRODUCT BYTES
5686 e6a7 c9 b0                        ADCB #$B0           ; ADD A CONSTANT
5687 e6a9 89 05                        ADCA #5             ; ADD A CONSTANT
5688 e6ab dd b1                        STD  RVSEED+1       ; SAVE NEW HIGH ORDER VARIABLE RANDOM # SEED
5689 e6ad dd 50                        STD  FPA0           ; SAVE NEW HIGH ORDER FPA0 MANTISSA
5690 e6af 0f 54                        CLR  FP0SGN         ; FORCE FPA0 MANTISSA = POSITIVE
5691 e6b1 86 80                        LDA  #$80           ; * SET FPA0 BIASED EXPONENT
5692 e6b3 97 4f                        STA  FP0EXP         ; * TO 0 1 < FPA0 < 0
5693 e6b5 96 15                        LDA  FPA2+2         ; GET A BYTE FROM FPA2 (MORE RANDOMNESS)
5694 e6b7 97 63                        STA  FPSBYT         ; SAVE AS SUB BYTE
5695 e6b9 7e e1 68                     JMP  LBA1C          ; NORMALIZE FPA0
5696                         *
5697 e6bc 40 e6              RSEED     FDB  $40E6          ; *CONSTANT RANDOM NUMBER GENERATOR SEED
5698 e6be 4d ab                        FDB  $4DAB          ; *
5699                         
5700                         * SIN
5701                         * THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND WILL REPEAT ITSELF EVERY
5702                         * 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ONLY THE FRACTIONAL PART IS
5703                         * RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, THE COEFFICIENTS MUST BE
5704                         * MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.
5705                         
5706                         * SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES BELOW:
5707                         * SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)
5708 e6c0 bd e3 ab           SIN       JSR  LBC5F          ; COPY FPA0 TO FPA1
5709 e6c3 8e e7 05                     LDX  #LBFBD         ; POINT (X) TO 2*PI
5710 e6c6 d6 61                        LDB  FP1SGN         ; *GET MANTISSA SIGN OF FPA1
5711 e6c8 bd e2 d5                     JSR  LBB89          ; *AND DIVIDE FPA0 BY 2*PI
5712 e6cb bd e3 ab                     JSR  LBC5F          ; COPY FPA0 TO FPA1
5713 e6ce 8d b4                        BSR  LBF38          ; CONVERT FPA0 TO AN INTEGER
5714 e6d0 0f 62                        CLR  RESSGN         ; SET RESULT SIGN = POSITIVE
5715 e6d2 96 5c                        LDA  FP1EXP         ; *GET EXPONENT OF FPA1
5716 e6d4 d6 4f                        LDB  FP0EXP         ; *GET EXPONENT OF FPA0
5717 e6d6 bd e1 08                     JSR  LB9BC          ; *SUBTRACT FPA0 FROM FPA1
5718                         * NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUMENT/2*PI
5719 e6d9 8e e7 0a                     LDX  #LBFC2         ; POINT X TO FP (.25)
5720 e6dc bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM .25 (PI/2)
5721 e6df 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN OF FPA0
5722 e6e1 34 02                        PSHS A              ; SAVE IT ON STACK
5723 e6e3 2a 09                        BPL  LBFA6          ; BRANCH IF MANTISSA POSITIVE
5724 e6e5 bd e1 00                     JSR  LB9B4          ; ADD .5 (PI) TO FPA0
5725 e6e8 96 54                        LDA  FP0SGN         ; GET SIGN OF FPA0
5726 e6ea 2b 05                        BMI  LBFA9          ; BRANCH IF NEGATIVE
5727 e6ec 03 0a                        COM  RELFLG         ; COM IF +(3*PI)/2 >= ARGUMENT >+ PI/2 (QUADRANT FLAG)
5728 e6ee bd e6 35           LBFA6     JSR  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0
5729 e6f1 8e e7 0a           LBFA9     LDX  #LBFC2         ; POINT X TO FP (.25)
5730 e6f4 bd e1 0e                     JSR  LB9C2          ; ADD .25 (PI/2) TO FPA0
5731 e6f7 35 02                        PULS A              ; GET OLD MANTISSA SIGN
5732 e6f9 4d                           TSTA                ; * BRANCH IF OLD
5733 e6fa 2a 03                        BPL  LBFB7          ; * SIGN WAS POSITIVE
5734 e6fc bd e6 35                     JSR  LBEE9          ; TOGGLE MANTISSA SIGN
5735 e6ff 8e e7 0f           LBFB7     LDX  #LBFC7         ; POINT X TO TABLE OF COEFFICIENTS
5736 e702 7e e6 3c                     JMP  LBEF0          ; GO CALCULATE POLYNOMIAL VALUE
5737                         
5738 e705 83 49 0f da a2     LBFBD     FCB  $83,$49,$0F,$DA,$A2 ; 6.28318531 (2*PI)
5739 e70a 7f 00 00 00 00     LBFC2     FCB  $7F,$00,$00,$00,$00 ; .25
5740                         
5741                         
5742 e70f 05                 LBFC7     FCB  6-1            ; SIX COEFFICIENTS
5743 e710 84 e6 1a 2d 1b     LBFC8     FCB  $84,$E6,$1A,$2D,$1B ; * -((2*PI)**11)/11!
5744 e715 86 28 07 fb f8     LBFCD     FCB  $86,$28,$07,$FB,$F8 ; * ((2*PI)**9)/9!
5745 e71a 87 99 68 89 01     LBFD2     FCB  $87,$99,$68,$89,$01 ; * -((2*PI)**7)/7!
5746 e71f 87 23 35 df e1     LBFD7     FCB  $87,$23,$35,$DF,$E1 ; * ((2*PI)**5)/5!
5747 e724 86 a5 5d e7 28     LBFDC     FCB  $86,$A5,$5D,$E7,$28 ; * -((2*PI)**3)/3!
5748 e729 83 49 0f da a2     LBFE1     FCB  $83,$49,$0F,$DA,$A2 ; *
5749                         
5750 e72e a1 54 46 8f 13               FCB  $A1,$54,$46,$8F,$13 ; UNUSED GARBAGE BYTES
5751 e733 8f 52 43 89 cd               FCB  $8F,$52,$43,$89,$CD ; UNUSED GARBAGE BYTES
5752                         * EXTENDED BASIC
5753                         
5754                         * COS
5755                         * THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTITY COS(X)=SIN((PI/2)+X)
5756 e738 8e e7 6b           COS       LDX  #L83AB         ; POINT X TO FP CONSTANT (P1/2)
5757 e73b bd e1 0e                     JSR  LB9C2          ; ADD FPA0 TO (X)
5758 e73e 7e e6 c0           L837E     JMP  SIN            ; JUMP TO SIN ROUTINE
5759                         
5760                         * TAN
5761                         * THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTITY TAN(X)=SIN(X)/COS(X)
5762 e741 bd e3 7b           TAN       JSR  LBC2F          ; PACK FPA0 AND MOVE IT TO FPA3
5763 e744 0f 0a                        CLR  RELFLG         ; RESET QUADRANT FLAG
5764 e746 8d f6                        BSR  L837E          ; CALCULATE SIN OF ARGUMENT
5765 e748 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5
5766 e74b bd e3 81                     JSR  LBC35          ; PACK FPA0 AND MOVE IT TO FPA5
5767 e74e 8e 00 40                     LDX  #V40           ; POINT X TO FPA3
5768 e751 bd e3 60                     JSR  LBC14          ; MOVE FPA3 TO FPA0
5769 e754 0f 54                        CLR  FP0SGN         ; FORCE FPA0 MANTISSA TO BE POSITIVE
5770 e756 96 0a                        LDA  RELFLG         ; GET THE QUADRANT FLAG - COS NEGATIVE IN QUADS 2,3
5771 e758 8d 0c                        BSR  L83A6          ; CALCULATE VALUE OF COS(FPA0)
5772 e75a 0d 4f                        TST  FP0EXP         ; CHECK EXPONENT OF FPA0
5773 e75c 10 27 fa 7e                  LBEQ LBA92          ; ''OV' ERROR IF COS(X)=0
5774 e760 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5
5775 e763 7e e2 db           L83A3     JMP  LBB8F          ; DIVIDE (X) BY FPA0 - SIN(X)/COS(X)
5776 e766 34 02              L83A6     PSHS A              ; SAVE SIGN FLAG ON STACK
5777 e768 7e e6 ee                     JMP  LBFA6          ; EXPAND POLYNOMIAL
5778                         
5779 e76b 81 49 0f da a2     L83AB     FCB  $81,$49,$0F,$DA,$A2 ; 1.57079633 (PI/2)
5780                         
5781                         * ATN
5782                         * A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE
5783                         * ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED
5784                         * TO EVALUATE THE EXPRESSION DEPENDING UPON
5785                         * WHETHER OR NOT THE ARGUMENT SQUARED IS > OR < 1.0
5786                         
5787                         * IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .
5788                         * IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5)*5)-. . .)
5789                         
5790 e770 96 54              ATN       LDA  FP0SGN         ; * GET THE SIGN OF THE MANTISSA AND
5791 e772 34 02                        PSHS A              ; * SAVE IT ON THE STACK
5792 e774 2a 02                        BPL  L83B8          ; BRANCH IF POSITIVE MANTISSA
5793 e776 8d 24                        BSR  L83DC          ; CHANGE SIGN OF FPA0
5794 e778 96 4f              L83B8     LDA  FP0EXP         ; * GET EXPONENT OF FPA0 AND
5795 e77a 34 02                        PSHS A              ; * SAVE IT ON THE STACK
5796 e77c 81 81                        CMPA #$81           ; IS FPAO < 1.0?
5797 e77e 25 05                        BLO  L83C5          ; YES
5798 e780 8e e2 11                     LDX  #LBAC5         ; POINT X TO FP CONSTANT 1.0
5799 e783 8d de                        BSR  L83A3          ; GET RECIPROCAL OF FPA0
5800 e785 8e e7 a0           L83C5     LDX  #L83E0         ; POINT (X) TO TAYLOR SERIES COEFFICIENTS
5801 e788 bd e6 3c                     JSR  LBEF0          ; EXPAND POLYNOMIAL
5802 e78b 35 02                        PULS A              ; GET EXPONENT OF ARGUMENT
5803 e78d 81 81                        CMPA #$81           ; WAS ARGUMENT < 1.0?
5804 e78f 25 06                        BLO  L83D7          ; YES
5805 e791 8e e7 6b                     LDX  #L83AB         ; POINT (X) TO FP NUMBER (PI/2)
5806 e794 bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (PI/2)
5807 e797 35 02              L83D7     PULS A              ; * GET SIGN OF INITIAL ARGUMENT MANTISSA
5808 e799 4d                           TSTA                ; * AND SET FLAGS ACCORDING TO IT
5809 e79a 2a 03                        BPL  L83DF          ; RETURN IF ARGUMENT WAS POSITIVE
5810 e79c 7e e6 35           L83DC     JMP  LBEE9          ; CHANGE MANTISSA SIGN OF FPA0
5811 e79f 39                 L83DF     RTS
5812                         *
5813                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR ARCTANGENT
5814 e7a0 0b                 L83E0     FCB  $0B            ; TWELVE COEFFICIENTS
5815 e7a1 76 b3 83 bd d3     L83E1     FCB  $76,$B3,$83,$BD,$D3 ; -6.84793912E-04 1/23
5816 e7a6 79 1e f4 a6 f5     L83E6     FCB  $79,$1E,$F4,$A6,$F5 ; +4.85094216E-03 1/21
5817 e7ab 7b 83 fc b0 10     L83EB     FCB  $7B,$83,$FC,$B0,$10 ; -0.0161117018
5818 e7b0 7c 0c 1f 67 ca     L83F0     FCB  $7C,$0C,$1F,$67,$CA ; 0.0342096381
5819 e7b5 7c de 53 cb c1     L83F5     FCB  $7C,$DE,$53,$CB,$C1 ; -0.0542791328
5820 e7ba 7d 14 64 70 4c     L83FA     FCB  $7D,$14,$64,$70,$4C ; 0.0724571965
5821 e7bf 7d b7 ea 51 7a     L83FF     FCB  $7D,$B7,$EA,$51,$7A ; -0.0898023954
5822 e7c4 7d 63 30 88 7e     L8404     FCB  $7D,$63,$30,$88,$7E ; 0.110932413
5823 e7c9 7e 92 44 99 3a     L8409     FCB  $7E,$92,$44,$99,$3A ; -0.142839808
5824 e7ce 7e 4c cc 91 c7     L840E     FCB  $7E,$4C,$CC,$91,$C7 ; 0.199999121
5825 e7d3 7f aa aa aa 13     L8413     FCB  $7F,$AA,$AA,$AA,$13 ; -0.333333316
5826 e7d8 81 00 00 00 00     L8418     FCB  $81,$00,$00,$00,$00 ; 1
5827                         *
5828                         *** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR LN(X)
5829                         *
5830 e7dd 03                 L841D     FCB  3              ; FOUR COEFFICIENTS
5831 e7de 7f 5e 56 cb 79     L841E     FCB  $7F,$5E,$56,$CB,$79 ; 0.434255942
5832 e7e3 80 13 9b 0b 64     L8423     FCB  $80,$13,$9B,$0B,$64 ; 0.576584541
5833 e7e8 80 76 38 93 16     L8428     FCB  $80,$76,$38,$93,$16 ; 0.961800759
5834 e7ed 82 38 aa 3b 20     L842D     FCB  $82,$38,$AA,$3B,$20 ; 2.88539007
5835                         
5836 e7f2 80 35 04 f3 34     L8432     FCB  $80,$35,$04,$F3,$34 ; 1/SQR(2)
5837                         
5838 e7f7 81 35 04 f3 34     L8437     FCB  $81,$35,$04,$F3,$34 ; SQR(2)
5839                         
5840 e7fc 80 80 00 00 00     L843C     FCB  $80,$80,$00,$00,$00 ; -0.5
5841                         
5842 e801 80 31 72 17 f8     L8441     FCB  $80,$31,$72,$17,$F8 ; LN(2)
5843                         *
5844                         * LOG - NATURAL LOGARITHM (LN)
5845                         
5846                         * THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USING
5847                         * MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*(2**B) (SCIENTIFIC
5848                         * NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE VALUE OF
5849                         * LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WILL EXPAND THIS
5850                         * TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)*LN(2). ALL OF
5851                         * THE TERMS OF THE LATTER EXPRESSION ARE CONSTANTS EXCEPT FOR THE
5852                         * LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLOR SERIES EXPANSION
5853 e806 bd e3 b9           LOG       JSR  LBC6D          ; CHECK STATUS OF FPA0
5854 e809 10 2f f3 c4                  LBLE LB44A          ; 'FC' ERROR IF NEGATIVE OR ZERO
5855 e80d 8e e7 f2                     LDX  #L8432         ; POINT (X) TO FP NUMBER (1/SQR(2))
5856 e810 96 4f                        LDA  FP0EXP         ; *GET EXPONENT OF ARGUMENT
5857 e812 80 80                        SUBA #$80           ; *SUBTRACT OFF THE BIAS AND
5858 e814 34 02                        PSHS A              ; *SAVE IT ON THE STACK
5859 e816 86 80                        LDA  #$80
5860 e818 97 4f                        STA  FP0EXP
5861 e81a bd e1 0e                     JSR  LB9C2          ; ADD FPA0 TO (X)
5862 e81d 8e e7 f7                     LDX  #L8437         ; POINT X TO SQR(2)
5863 e820 bd e2 db                     JSR  LBB8F          ; DIVIDE SQR(2) BY FPA0
5864 e823 8e e2 11                     LDX  #LBAC5         ; POINT X TO FP VALUE OF 1.00
5865 e826 bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (X)
5866                         *         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE X IS ARGUMENT
5867 e829 8e e7 dd                     LDX  #L841D         ; POINT X TO TABLE OF COEFFICIENTS
5868 e82c bd e6 3c                     JSR  LBEF0          ; EXPAND POLYNOMIAL
5869 e82f 8e e7 fc                     LDX  #L843C         ; POINT X TO FP VALUE OF (-.5)
5870 e832 bd e1 0e                     JSR  LB9C2          ; ADD FPA0 TO X
5871 e835 35 04                        PULS B              ; GET EXPONENT OF ARGUMENT BACK (WITHOUT BIAS)
5872 e837 bd e4 e5                     JSR  LBD99          ; ADD ACCB TO FPA0
5873 e83a 8e e8 01                     LDX  #L8441         ; POINT X TO LN(2)
5874 e83d 7e e2 16                     JMP  LBACA          ; MULTIPLY FPA0 * LN(2)
5875                         
5876                         * SQR
5877 e840 bd e3 ab           SQR       JSR  LBC5F          ; MOVE FPA0 TO FPA1
5878 e843 8e e6 0c                     LDX  #LBEC0         ; POINT (X) TO FP NUMBER (.5)
5879 e846 bd e3 60                     JSR  LBC14          ; COPY A PACKED NUMBER FROM (X) TO FPA0
5880                         
5881                         * ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS
5882                         * HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION
5883                         * IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.7182818
5884 e849 27 67              L8489     BEQ  EXP            ; DO A NATURAL EXPONENTIATION IF EXPONENT = 0
5885 e84b 4d                           TSTA                ; *CHECK VALUE BEING EXPONENTIATED
5886 e84c 26 03                        BNE  L8491          ; *AND BRANCH IF IT IS <> 0
5887 e84e 7e e1 86                     JMP  LBA3A          ; FPA0=0 IF RAISING ZERO TO A POWER
5888 e851 8e 00 4a           L8491     LDX  #V4A           ; * PACK FPA0 AND SAVE
5889 e854 bd e3 81                     JSR  LBC35          ; * IT IN FPA5 (ARGUMENT'S EXPONENT)
5890 e857 5f                           CLRB                ; ACCB=DEFAULT RESULT SIGN FLAG; 0=POSITIVE
5891 e858 96 61                        LDA  FP1SGN         ; *CHECK THE SIGN OF ARGUMENT
5892 e85a 2a 10                        BPL  L84AC          ; *BRANCH IF POSITIVE
5893 e85c bd e4 3a                     JSR  INT            ; CONVERT EXPONENT INTO AN INTEGER
5894 e85f 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5 (ORIGINAL EXPONENT)
5895 e862 96 61                        LDA  FP1SGN         ; GET MANTISSA SIGN OF FPA1 (ARGUMENT)
5896 e864 bd e3 ec                     JSR  LBCA0          ; *COMPARE FPA0 TO (X) AND
5897 e867 26 03                        BNE  L84AC          ; *BRANCH IF NOT EQUAL
5898 e869 43                           COMA                ; TOGGLE FPA1 MANTISSA SIGN - FORCE POSITIVE
5899 e86a d6 01                        LDB  CHARAC         ; GET LS BYTE OF INTEGER VALUE OF EXPONENT (RESULT SIGN FLAG)
5900 e86c bd e3 98           L84AC     JSR  LBC4C          ; COPY FPA1 TO FPA0; ACCA = MANTISSA SIGN
5901 e86f 34 04                        PSHS B              ; PUT RESULT SIGN FLAG ON THE STACK
5902 e871 bd e8 06                     JSR  LOG
5903 e874 8e 00 4a                     LDX  #V4A           ; POINT (X) TO FPA5
5904 e877 bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY FPA5
5905 e87a 8d 36                        BSR  EXP            ; CALCULATE E**(FPA0)
5906 e87c 35 02                        PULS A              ; * GET RESULT SIGN FLAG FROM THE STACK
5907 e87e 46                           RORA                ; * AND BRANCH IF NEGATIVE
5908 e87f 10 25 fd b2                  LBCS LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
5909 e883 39                           RTS
5910                         
5911                         * CORRECTION FACTOR FOR EXPONENTIAL FUNCTION
5912 e884 81 38 aa 3b 29     L84C4     FCB  $81,$38,$AA,$3B,$29 ; 1.44269504 ( CF )
5913                         *
5914                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E**X
5915                         *
5916 e889 07                 L84C9     FCB  7              ; EIGHT COEFFICIENTS
5917 e88a 71 34 58 3e 56     L84CA     FCB  $71,$34,$58,$3E,$56 ; 2.14987637E-05: 1/(7!*(CF**7))
5918 e88f 74 16 7e b3 1b     L84CF     FCB  $74,$16,$7E,$B3,$1B ; 1.4352314E-04 : 1/(6!*(CF**6))
5919 e894 77 2f ee e3 85     L84D4     FCB  $77,$2F,$EE,$E3,$85 ; 1.34226348E-03: 1/(5!*(CF**5))
5920 e899 7a 1d 84 1c 2a     L84D9     FCB  $7A,$1D,$84,$1C,$2A ; 9.61401701E-03: 1/(4!*(CF**4))
5921 e89e 7c 63 59 58 0a     L84DE     FCB  $7C,$63,$59,$58,$0A ; 0.0555051269
5922 e8a3 7e 75 fd e7 c6     L84E3     FCB  $7E,$75,$FD,$E7,$C6 ; 0.240226385
5923 e8a8 80 31 72 18 10     L84E8     FCB  $80,$31,$72,$18,$10 ; 0.693147186
5924 e8ad 81 00 00 00 00     L84ED     FCB  $81,$00,$00,$00,$00 ; 1
5925                         *
5926                         * EXP ( E**X)
5927                         * THE EXPONENTIAL FUNCTION IS EVALUATED BY FIRST MULTIPLYING THE
5928                         * ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS DONE, AN
5929                         * ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFLOW) FOR A
5930                         * NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A POSITIVE
5931                         * ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED TO REFLECT
5932                         * THE CF MULTIPLICATION AT THE START OF THE EVALUATION PROCESS.
5933                         
5934 e8b2 8e e8 84           EXP       LDX  #L84C4         ; POINT X TO THE CORRECTION FACTOR
5935 e8b5 bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY (X)
5936 e8b8 bd e3 7b                     JSR  LBC2F          ; PACK FPA0 AND STORE IT IN FPA3
5937 e8bb 96 4f                        LDA  FP0EXP         ; *GET EXPONENT OF FPA0 AND
5938 e8bd 81 88                        CMPA #$88           ; *COMPARE TO THE MAXIMUM VALUE
5939 e8bf 25 03                        BLO  L8504          ; BRANCH IF FPA0 < 128
5940 e8c1 7e e2 a8           L8501     JMP  LBB5C          ; SET FPA0 = 0 OR 'OV' ERROR
5941 e8c4 bd e4 3a           L8504     JSR  INT            ; CONVERT FPA0 TO INTEGER
5942 e8c7 96 01                        LDA  CHARAC         ; GET LS BYTE OF INTEGER
5943 e8c9 8b 81                        ADDA #$81           ; * WAS THE ARGUMENT =127, IF SO
5944 e8cb 27 f4                        BEQ  L8501          ; * THEN 'OV' ERROR; THIS WILL ALSO ADD THE $80 BIAS
5945                         *              ; * REQUIRED WHEN THE NEW EXPONENT IS CALCULATED BELOW
5946 e8cd 4a                           DECA                ; DECREMENT ONE FROM THE EXPONENT, BECAUSE $81, NOT $80 WAS USED ABOVE
5947 e8ce 34 02                        PSHS A              ; SAVE EXPONENT OF INTEGER PORTION ON STACK
5948 e8d0 8e 00 40                     LDX  #V40           ; POINT (X) TO FPA3
5949 e8d3 bd e1 05                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (X) - GET FRACTIONAL PART OF ARGUMENT
5950 e8d6 8e e8 89                     LDX  #L84C9         ; POINT X TO COEFFICIENTS
5951 e8d9 bd e6 4b                     JSR  LBEFF          ; EVALUATE POLYNOMIAL FOR FRACTIONAL PART
5952 e8dc 0f 62                        CLR  RESSGN         ; FORCE THE MANTISSA TO BE POSITIVE
5953 e8de 35 02                        PULS A              ; GET INTEGER EXPONENT FROM STACK
5954 e8e0 bd e2 94                     JSR  LBB48          ; * CALCULATE EXPONENT OF NEW FPA0 BY ADDING THE EXPONENTS OF THE
5955                         *              ; * INTEGER AND FRACTIONAL PARTS
5956 e8e3 39                           RTS
5957                         
5958                         * FIX
5959 e8e4 bd e3 b9           FIX       JSR  LBC6D          ; CHECK STATUS OF FPA0
5960 e8e7 2b 03                        BMI  L852C          ; BRANCH IF FPA0 = NEGATIVE
5961 e8e9 7e e4 3a           L8529     JMP  INT            ; CONVERT FPA0 TO INTEGER
5962 e8ec 03 54              L852C     COM  FP0SGN         ; TOGGLE SIGN OF FPA0 MANTISSA
5963 e8ee 8d f9                        BSR  L8529          ; CONVERT FPA0 TO INTEGER
5964 e8f0 7e e6 35                     JMP  LBEE9          ; TOGGLE SIGN OF FPA0
5965                         
5966                         * EDIT
5967 e8f3 bd ed 21           EDIT      JSR  L89AE          ; GET LINE NUMBER FROM BASIC
5968 e8f6 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF THE STACK
5969 e8f8 86 01              L8538     LDA  #$01           ; 'LIST' FLAG
5970 e8fa 97 98                        STA  VD8            ; SET FLAG TO LIST LINE
5971 e8fc bd d4 a5                     JSR  LAD01          ; GO FIND THE LINE NUMBER IN PROGRAM
5972 e8ff 10 25 ed 7f                  LBCS LAED2          ; ERROR #7 'UNDEFINED LINE #'
5973 e903 bd df 3e                     JSR  LB7C2          ; GO UNCRUNCH LINE INTO BUFFER AT LINBUF+1
5974 e906 1f 20                        TFR  Y,D            ; PUT ABSOLUTE ADDRESS OF END OF LINE TO ACCD
5975 e908 83 00 f5                     SUBD #LINBUF+2      ; SUBTRACT OUT THE START OF LINE
5976 e90b d7 97                        STB  VD7            ; SAVE LENGTH OF LINE
5977 e90d dc 2b              L854D     LDD  BINVAL         ; GET THE HEX VALUE OF LINE NUMBER
5978 e90f bd e5 18                     JSR  LBDCC          ; LIST THE LINE NUMBER ON THE SCREEN
5979 e912 bd e0 f8                     JSR  LB9AC          ; PRINT A SPACE
5980 e915 8e 00 f4                     LDX  #LINBUF+1      ; POINT X TO BUFFER
5981 e918 d6 98                        LDB  VD8            ; * CHECK TO SEE IF LINE IS TO BE
5982 e91a 26 25                        BNE  L8581          ; * LISTED TO SCREEN - BRANCH IF IT IS
5983 e91c 5f                 L855C     CLRB                ; RESET DIGIT ACCUMULATOR - DEFAULT VALUE
5984 e91d bd ea 47           L855D     JSR  L8687          ; GET KEY STROKE
5985 e920 bd f1 ec                     JSR  L90AA          ; SET CARRY IF NOT NUMERIC
5986 e923 25 0b                        BLO  L8570          ; BRANCH IF NOT NUMERIC
5987 e925 80 30                        SUBA #'0            ; MASK OFF ASCII
5988 e927 34 02                        PSHS A              ; SAVE IT ON STACK
5989 e929 86 0a                        LDA  #10            ; NUMBER BEING CONVERTED IS BASE 10
5990 e92b 3d                           MUL                 ; MULTIPLY ACCUMULATED VALUE BY BASE (10)
5991 e92c eb e0                        ADDB ,S+            ; ADD DIGIT TO ACCUMULATED VALUE
5992 e92e 20 ed                        BRA  L855D          ; CHECK FOR ANOTHER DIGIT
5993 e930 c0 01              L8570     SUBB #$01           ; * REPEAT PARAMETER IN ACCB; IF IT
5994 e932 c9 01                        ADCB #$01           ; *IS 0, THEN MAKE IT '1'
5995 e934 81 41                        CMPA #'A            ; ABORT?
5996 e936 26 05                        BNE  L857D          ; NO
5997 e938 bd e0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
5998 e93b 20 bb                        BRA  L8538          ; RESTART EDIT PROCESS - CANCEL ALL CHANGES
5999 e93d 81 4c              L857D     CMPA #'L            ; LIST?
6000 e93f 26 0b                        BNE  L858C          ; NO
6001 e941 8d 31              L8581     BSR  L85B4          ; LIST THE LINE
6002 e943 0f 98                        CLR  VD8            ; RESET THE LIST FLAG TO 'NO LIST'
6003 e945 bd e0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN
6004 e948 20 c3                        BRA  L854D          ; GO INTERPRET ANOTHER EDIT COMMAND
6005 e94a 32 62              L858A     LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF THE STACK
6006 e94c 81 0d              L858C     CMPA #CR            ; ENTER KEY?
6007 e94e 26 0d                        BNE  L859D          ; NO
6008 e950 8d 22                        BSR  L85B4          ; ECHO THE LINE TO THE SCREEN
6009 e952 bd e0 a8           L8592     JSR  LB958          ; PRINT CARRIAGE RETURN
6010 e955 8e 00 f4                     LDX  #LINBUF+1      ; * RESET BASIC'S INPUT POINTER
6011 e958 9f 83                        STX  CHARAD         ; * TO THE LINE INPUT BUFFER
6012 e95a 7e d4 4e                     JMP  LACA8          ; GO PUT LINE BACK IN PROGRAM
6013 e95d 81 45              L859D     CMPA #'E            ; EXIT?
6014 e95f 27 f1                        BEQ  L8592          ; YES - SAME AS ENTER EXCEPT NO ECHO
6015 e961 81 51                        CMPA #'Q            ; QUIT?
6016 e963 26 06                        BNE  L85AB          ; NO
6017 e965 bd e0 a8                     JSR  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
6018 e968 7e d4 25                     JMP  LAC73          ; GO TO COMMAND LEVEL - MAKE NO CHANGES
6019 e96b 8d 02              L85AB     BSR  L85AF          ; INTERPRET THE REMAINING COMMANDS AS SUBROUTINES
6020 e96d 20 ad                        BRA  L855C          ; GO INTERPRET ANOTHER EDIT COMMAND
6021 e96f 81 20              L85AF     CMPA #SPACE         ; SPACE BAR?
6022 e971 26 10                        BNE  L85C3          ; NO
6023 e973 8c                 L85B3     FCB  SKP2           ; SKIP TWO BYTES
6024                         * DISPLAY THE NEXT ACCB BYTES OF THE LINE IN THE BUFFER TO THE SCREEN
6025                         *
6026 e974 c6 f9              L85B4     LDB  #LBUFMX-1      ; 250 BYTES MAX IN BUFFER
6027 e976 a6 84              L85B6     LDA  ,X             ; GET A CHARACTER FROM BUFFER
6028 e978 27 08                        BEQ  L85C2          ; EXIT IF IT'S A 0
6029 e97a bd d0 17                     JSR  PUTCHR         ; SEND CHAR TO CONSOLE OUT
6030 e97d 30 01                        LEAX $01,X          ; MOVE POINTER UP ONE
6031 e97f 5a                           DECB                ; DECREMENT CHARACTER COUNTER
6032 e980 26 f4                        BNE  L85B6          ; LOOP IF NOT DONE
6033 e982 39                 L85C2     RTS
6034 e983 81 44              L85C3     CMPA #'D            ; DELETE?
6035 e985 26 48                        BNE  L860F          ; NO
6036 e987 6d 84              L85C7     TST  ,X             ; * CHECK FOR END OF LINE
6037 e989 27 f7                        BEQ  L85C2          ; * AND BRANCH IF SO
6038 e98b 8d 04                        BSR  L85D1          ; REMOVE A CHARACTER
6039 e98d 5a                           DECB                ; DECREMENT REPEAT PARAMETER
6040 e98e 26 f7                        BNE  L85C7          ; BRANCH IF NOT DONE
6041 e990 39                           RTS
6042                         * REMOVE ONE CHARACTER FROM BUFFER
6043 e991 0a 97              L85D1     DEC  VD7            ; DECREMENT LENGTH OF BUFFER
6044 e993 31 1f                        LEAY -1,X           ; POINT Y TO ONE BEFORE CURRENT BUFFER POINTER
6045 e995 31 21              L85D5     LEAY $01,Y          ; INCREMENT TEMPORARY BUFFER POINTER
6046 e997 a6 21                        LDA  $01,Y          ; GET NEXT CHARACTER
6047 e999 a7 a4                        STA  ,Y             ; PUT IT IN CURRENT POSITION
6048 e99b 26 f8                        BNE  L85D5          ; BRANCH IF NOT END OF LINE
6049 e99d 39                           RTS
6050 e99e 81 49              L85DE     CMPA #'I            ;  INSERT?
6051 e9a0 27 13                        BEQ  L85F5          ; YES
6052 e9a2 81 58                        CMPA #'X            ; EXTEND?
6053 e9a4 27 0d                        BEQ  L85F3          ; YES
6054 e9a6 81 48                        CMPA #'H            ; HACK?
6055 e9a8 26 5c                        BNE  L8646          ; NO
6056 e9aa 6f 84                        CLR  ,X             ; TURN CURRENT BUFFER POINTER INTO END OF LINE FLAG
6057 e9ac 1f 10                        TFR  X,D            ; PUT CURRENT BUFFER POINTER IN ACCD
6058 e9ae 83 00 f5                     SUBD #LINBUF+2      ; SUBTRACT INITIAL POINTER POSITION
6059 e9b1 d7 97                        STB  VD7            ; SAVE NEW BUFFER LENGTH
6060 e9b3 8d bf              L85F3     BSR  L85B4          ; DISPLAY THE LINE ON THE SCREEN
6061 e9b5 bd ea 47           L85F5     JSR  L8687          ; GET A KEYSTROKE
6062 e9b8 81 0d                        CMPA #CR            ; ENTER KEY?
6063 e9ba 27 8e                        BEQ  L858A          ; YES - INTERPRET ANOTHER COMMAND - PRINT LINE
6064 e9bc 81 1b                        CMPA #ESC           ; ESCAPE?
6065 e9be 27 25                        BEQ  L8625          ; YES - RETURN TO COMMAND LEVEL - DON'T PRINT LINE
6066 e9c0 81 08                        CMPA #BS            ; BACK SPACE?
6067 e9c2 26 22                        BNE  L8626          ; NO
6068 e9c4 8c 00 f4                     CMPX #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
6069 e9c7 27 ec                        BEQ  L85F5          ; DO NOT ALLOW BS IF AT START
6070 e9c9 8d 45                        BSR  L8650          ; MOVE POINTER BACK ONE, BS TO SCREEN
6071 e9cb 8d c4                        BSR  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
6072 e9cd 20 e6                        BRA  L85F5          ; GET INSERT SUB COMMAND
6073 e9cf 81 43              L860F     CMPA #'C            ; CHANGE?
6074 e9d1 26 cb                        BNE  L85DE          ; NO
6075 e9d3 6d 84              L8613     TST  ,X             ; CHECK CURRENT BUFFER CHARACTER
6076 e9d5 27 0e                        BEQ  L8625          ; BRANCH IF END OF LINE
6077 e9d7 bd ea 47                     JSR  L8687          ; GET A KEYSTROKE
6078 e9da 25 02                        BLO  L861E          ; BRANCH IF LEGITIMATE KEY
6079 e9dc 20 f5                        BRA  L8613          ; TRY AGAIN IF ILLEGAL KEY
6080 e9de a7 80              L861E     STA  ,X+            ; INSERT NEW CHARACTER INTO BUFFER
6081 e9e0 8d 37                        BSR  L8659          ; SEND NEW CHARACTER TO SCREEN
6082 e9e2 5a                           DECB                ; DECREMENT REPEAT PARAMETER
6083 e9e3 26 ee                        BNE  L8613          ; BRANCH IF NOT DONE
6084 e9e5 39                 L8625     RTS
6085 e9e6 d6 97              L8626     LDB  VD7            ; GET LENGTH OF LINE
6086 e9e8 c1 f9                        CMPB #LBUFMX-1      ; COMPARE TO MAXIMUM LENGTH
6087 e9ea 26 02                        BNE  L862E          ; BRANCH IF NOT AT MAXIMUM
6088 e9ec 20 c7                        BRA  L85F5          ; IGNORE INPUT IF LINE AT MAXIMUM LENGTH
6089 e9ee 34 10              L862E     PSHS X              ; SAVE CURRENT BUFFER POINTER
6090 e9f0 6d 80              L8630     TST  ,X+            ; * SCAN THE LINE UNTIL END OF
6091 e9f2 26 fc                        BNE  L8630          ; * LINE (0) IS FOUND
6092 e9f4 e6 82              L8634     LDB  ,-X            ; DECR TEMP LINE POINTER AND GET A CHARACTER
6093 e9f6 e7 01                        STB  $01,X          ; PUT CHARACTER BACK DOWN ONE SPOT
6094 e9f8 ac e4                        CMPX ,S             ; HAVE WE REACHED STARTING POINT?
6095 e9fa 26 f8                        BNE  L8634          ; NO - KEEP GOING
6096 e9fc 32 62                        LEAS $02,S          ; PURGE BUFFER POINTER FROM STACK
6097 e9fe a7 80                        STA  ,X+            ; INSERT NEW CHARACTER INTO THE LINE
6098 ea00 8d 17                        BSR  L8659          ; SEND A CHARACTER TO CONSOLE OUT
6099 ea02 0c 97                        INC  VD7            ; ADD ONE TO BUFFER LENGTH
6100 ea04 20 af                        BRA  L85F5          ; GET INSERT SUB COMMAND
6101 ea06 81 08              L8646     CMPA #BS            ; BACKSPACE?
6102 ea08 26 12                        BNE  L865C          ; NO
6103 ea0a 8d 04              L864A     BSR  L8650          ; MOVE POINTER BACK 1, SEND BS TO SCREEN
6104 ea0c 5a                           DECB                ; DECREMENT REPEAT PARAMETER
6105 ea0d 26 fb                        BNE  L864A          ; LOOP UNTIL DONE
6106 ea0f 39                           RTS
6107 ea10 8c 00 f4           L8650     CMPX #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
6108 ea13 27 d0                        BEQ  L8625          ; DO NOT ALLOW BS IF AT START
6109 ea15 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
6110 ea17 86 08                        LDA  #BS            ; BACK SPACE
6111 ea19 7e d0 17           L8659     JMP  PUTCHR         ; SEND TO CONSOLE OUT
6112 ea1c 81 4b              L865C     CMPA #'K            ; KILL?
6113 ea1e 27 05                        BEQ  L8665          ; YES
6114 ea20 80 53                        SUBA #'S            ; SEARCH?
6115 ea22 27 01                        BEQ  L8665          ; YES
6116 ea24 39                           RTS
6117 ea25 34 02              L8665     PSHS A              ; SAVE KILL/SEARCH FLAG ON STACK
6118 ea27 8d 1e                        BSR  L8687          ; * GET A KEYSTROKE (TARGET CHARACTER)
6119 ea29 34 02                        PSHS A              ; * AND SAVE IT ON STACK
6120 ea2b a6 84              L866B     LDA  ,X             ; GET CURRENT BUFFER CHARACTER
6121 ea2d 27 16                        BEQ  L8685          ; AND RETURN IF END OF LINE
6122 ea2f 6d 61                        TST  $01,S          ; CHECK KILL/SEARCH FLAG
6123 ea31 26 06                        BNE  L8679          ; BRANCH IF KILL
6124 ea33 8d e4                        BSR  L8659          ; SEND A CHARACTER TO CONSOLE OUT
6125 ea35 30 01                        LEAX $01,X          ; INCREMENT BUFFER POINTER
6126 ea37 20 03                        BRA  L867C          ; CHECK NEXT INPUT CHARACTER
6127 ea39 bd e9 91           L8679     JSR  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
6128 ea3c a6 84              L867C     LDA  ,X             ; GET CURRENT INPUT CHARACTER
6129 ea3e a1 e4                        CMPA ,S             ; COMPARE TO TARGET CHARACTER
6130 ea40 26 e9                        BNE  L866B          ; BRANCH IF NO MATCH
6131 ea42 5a                           DECB                ; DECREMENT REPEAT PARAMETER
6132 ea43 26 e6                        BNE  L866B          ; BRANCH IF NOT DONE
6133 ea45 35 a0              L8685     PULS Y,PC           ; THE Y PULL WILL CLEAN UP THE STACK FOR THE 2 PSHS A
6134                         *
6135                         * GET A KEYSTRKE
6136 ea47 bd d0 03           L8687     JSR  LA171          ; CALL CONSOLE IN : DEV NBR=SCREEN
6137 ea4a 81 7f                        CMPA #$7F           ; GRAPHIC CHARACTER?
6138 ea4c 24 f9                        BCC  L8687          ; YES - GET ANOTHER CHAR
6139 ea4e 81 5f                        CMPA #$5F           ; SHIFT UP ARROW (QUIT INSERT)
6140 ea50 26 02                        BNE  L8694          ; NO
6141 ea52 86 1b                        LDA  #ESC           ; REPLACE W/ESCAPE CODE
6142 ea54 81 0d              L8694     CMPA #CR            ; ENTER KEY
6143 ea56 27 0e                        BEQ  L86A6          ; YES
6144 ea58 81 1b                        CMPA #ESC           ; ESCAPE?
6145 ea5a 27 0a                        BEQ  L86A6          ; YES
6146 ea5c 81 08                        CMPA #BS            ; BACKSPACE?
6147 ea5e 27 06                        BEQ  L86A6          ; YES
6148 ea60 81 20                        CMPA #SPACE         ; SPACE
6149 ea62 25 e3                        BLO  L8687          ; GET ANOTHER CHAR IF CONTROL CHAR
6150 ea64 1a 01                        ORCC #$01           ; SET CARRY
6151 ea66 39                 L86A6     RTS
6152                         
6153                         * TRON
6154 ea67 86                 TRON      FCB  SKP1LD         ; SKIP ONE BYTE AND LDA #$4F
6155                         
6156                         * TROFF
6157 ea68 4f                 TROFF     CLRA                ; TROFF FLAG
6158 ea69 97 8c                        STA  TRCFLG         ; TRON/TROFF FLAG:0=TROFF, <> 0=TRON
6159 ea6b 39                           RTS
6160                         
6161                         * POS
6162                         
6163 ea6c 86 00              POS       LDA  #0             ; GET DEVICE NUMBER
6164 ea6e d6 79                        LDB  LPTPOS         ; GET PRINT POSITION
6165 ea70 1d                 LA5E8     SEX                 ; CONVERT ACCB TO 2 DIGIT SIGNED INTEGER
6166 ea71 7e dc 7b                     JMP  GIVABF         ; CONVERT ACCD TO FLOATING POINT
6167                         
6168                         
6169                         * VARPTR
6170 ea74 bd d9 f6           VARPT     JSR  LB26A          ; SYNTAX CHECK FOR '('
6171 ea77 dc 1f                        LDD  ARYEND         ; GET ADDR OF END OF ARRAYS
6172 ea79 34 06                        PSHS B,A            ; SAVE IT ON STACK
6173 ea7b bd da de                     JSR  LB357          ; GET VARIABLE DESCRIPTOR
6174 ea7e bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6175 ea81 35 06                        PULS A,B            ; GET END OF ARRAYS ADDR BACK
6176 ea83 1e 10                        EXG  X,D            ; SWAP END OF ARRAYS AND VARIABLE DESCRIPTOR
6177 ea85 9c 1f                        CMPX ARYEND         ; COMPARE TO NEW END OF ARRAYS
6178 ea87 26 51                        BNE  L8724          ; 'FC' ERROR IF VARIABLE WAS NOT DEFINED PRIOR TO CALLING VARPTR
6179 ea89 7e dc 7b                     JMP  GIVABF         ; CONVERT VARIABLE DESCRIPTOR INTO A FP NUMBER
6180                         
6181                         * MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT
6182 ea8c 9d 7c              L86D6     JSR  GETNCH         ; GET INPUT CHAR FROM BASIC
6183 ea8e bd d9 f6                     JSR  LB26A          ; SYNTAX CHECK FOR '('
6184 ea91 bd da de                     JSR  LB357          ; * GET VARIABLE DESCRIPTOR ADDRESS AND
6185 ea94 34 10                        PSHS X              ; * SAVE IT ON THE STACK
6186 ea96 ec 02                        LDD  $02,X          ; POINT ACCD TO START OF OLDSTRING
6187 ea98 10 93 21                     CMPD FRETOP         ; COMPARE TO START OF CLEARED SPACE
6188 ea9b 23 04                        BLS  L86EB          ; BRANCH IF <=
6189 ea9d 93 27                        SUBD MEMSIZ         ; SUBTRACT OUT TOP OF CLEARED SPACE
6190 ea9f 23 12                        BLS  L86FD          ; BRANCH IF STRING IN STRING SPACE
6191 eaa1 e6 84              L86EB     LDB  ,X             ; GET LENGTH OF OLDSTRING
6192 eaa3 bd dc f4                     JSR  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
6193 eaa6 34 10                        PSHS X              ; SAVE RESERVED SPACE STRING ADDRESS ON STACK
6194 eaa8 ae 62                        LDX  $02,S          ; POINT X TO OLDSTRING DESCRIPTOR
6195 eaaa bd dd ca                     JSR  LB643          ; MOVE OLDSTRING INTO STRING SPACE
6196 eaad 35 50                        PULS X,U            ; * GET OLDSTRING DESCRIPTOR ADDRESS AND RESERVED STRING
6197 eaaf af 42                        STX  $02,U          ; * ADDRESS AND SAVE RESERVED ADDRESS AS OLDSTRING ADDRESS
6198 eab1 34 40                        PSHS U              ; SAVE OLDSTRING DESCRIPTOR ADDRESS
6199 eab3 bd de bf           L86FD     JSR  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
6200 eab6 34 04                        PSHS B              ; SAVE POSITION PARAMETER ON STACK
6201 eab8 5d                           TSTB                ; * CHECK POSITION PARAMETER AND BRANCH
6202 eab9 27 1f                        BEQ  L8724          ; * IF START OF STRING
6203 eabb c6 ff                        LDB  #$FF           ; DEFAULT REPLACEMENT LENGTH = $FF
6204 eabd 81 29                        CMPA #')            ; * CHECK FOR END OF MID$ STATEMENT AND
6205 eabf 27 03                        BEQ  L870E          ; * BRANCH IF AT END OF STATEMENT
6206 eac1 bd de bf                     JSR  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
6207 eac4 34 04              L870E     PSHS B              ; SAVE LENGTH PARAMETER ON STACK
6208 eac6 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6209 eac9 c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR =
6210 eacb bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR '='
6211 eace 8d 2e                        BSR  L8748          ; EVALUATE REPLACEMENT STRING
6212 ead0 1f 13                        TFR  X,U            ; SAVE REPLACEMENT STRING ADDRESS IN U
6213 ead2 ae 62                        LDX  $02,S          ; POINT X TO OLOSTRING DESCRIPTOR ADDRESS
6214 ead4 a6 84                        LDA  ,X             ; GET LENGTH OF OLDSTRING
6215 ead6 a0 61                        SUBA $01,S          ; SUBTRACT POSITION PARAMETER
6216 ead8 24 03                        BCC  L8727          ; INSERT REPLACEMENT STRING INTO OLDSTRING
6217 eada 7e db d1           L8724     JMP  LB44A          ; 'FC' ERROR IF POSITION > LENGTH OF OLDSTRING
6218 eadd 4c                 L8727     INCA                ; * NOW ACCA = NUMBER OF CHARACTERS TO THE RIGHT
6219                         *                             ; * (INCLUSIVE) OF THE POSITION PARAMETER
6220 eade a1 e4                        CMPA ,S
6221 eae0 24 02                        BCC  L872E          ; BRANCH IF NEW STRING WILL FIT IN OLDSTRING
6222 eae2 a7 e4                        STA  ,S             ; IF NOT, USE AS MUCH OF LENGTH PARAMETER AS WILL FIT
6223 eae4 a6 61              L872E     LDA  $01,S          ; GET POSITION PARAMETER
6224 eae6 1e 89                        EXG  A,B            ; ACCA=LENGTH OF REPL STRING, ACCB=POSITION PARAMETER
6225 eae8 ae 02                        LDX  $02,X          ; POINT X TO OLDSTRING ADDRESS
6226 eaea 5a                           DECB                ; * BASIC'S POSITION PARAMETER STARTS AT 1; THIS ROUTINE
6227                         *                             ; * WANTS IT TO START AT ZERO
6228 eaeb 3a                           ABX                 ; POINT X TO POSITION IN OLDSTRING WHERE THE REPLACEMENT WILL GO
6229 eaec 4d                           TSTA                ; * IF THE LENGTH OF THE REPLACEMENT STRING IS ZERO
6230 eaed 27 0d                        BEQ  L8746          ; * THEN RETURN
6231 eaef a1 e4                        CMPA ,S
6232 eaf1 23 02                        BLS  L873F          ; ADJUSTED LENGTH PARAMETER, THEN BRANCH
6233 eaf3 a6 e4                        LDA  ,S             ; OTHERWISE USE AS MUCH ROOM AS IS AVAILABLE
6234 eaf5 1f 89              L873F     TFR  A,B            ; SAVE NUMBER OF BYTES TO MOVE IN ACCB
6235 eaf7 1e 31                        EXG  U,X            ; SWAP SOURCE AND DESTINATION POINTERS
6236 eaf9 bd d1 b1                     JSR  LA59A          ; MOVE (B) BYTES FROM (X) TO (U)
6237 eafc 35 96              L8746     PULS A,B,X,PC
6238 eafe bd d8 e2           L8748     JSR  LB156          ; EVALUATE EXPRESSION
6239 eb01 7e dd db                     JMP  LB654          ; *'TM' ERROR IF NUMERIC; RETURN WITH X POINTING
6240                         *                             ; *TO STRING, ACCB = LENGTH
6241                         
6242                         * STRING
6243 eb04 bd d9 f6           STRING    JSR  LB26A          ; SYNTAX CHECK FOR '('
6244 eb07 bd de 92                     JSR  LB70B          ; EVALUATE EXPRESSION; ERROR IF > 255
6245 eb0a 34 04                        PSHS B              ; SAVE LENGTH OF STRING
6246 eb0c bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6247 eb0f bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
6248 eb12 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6249 eb15 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
6250 eb17 26 05                        BNE  L8768          ; BRANCH IF STRING
6251 eb19 bd de 95                     JSR  LB70E          ; CONVERT FPA0 INTO AN INTEGER IN ACCB
6252 eb1c 20 03                        BRA  L876B          ; SAVE THE STRING IN STRING SPACE
6253 eb1e bd de 2b           L8768     JSR  LB6A4          ; GET FIRST BYTE OF STRING
6254 eb21 34 04              L876B     PSHS B              ; SAVE FIRST BYTE OF EXPRESSION
6255 eb23 e6 61                        LDB  $01,S          ; GET LENGTH OF STRING
6256 eb25 bd dc 96                     JSR  LB50F          ; RESERVE ACCB BYTES IN STRING SPACE
6257 eb28 35 06                        PULS A,B            ; GET LENGTH OF STRING AND CHARACTER
6258 eb2a 27 05                        BEQ  L877B          ; BRANCH IF NULL STRING
6259 eb2c a7 80              L8776     STA  ,X+            ; SAVE A CHARACTER IN STRING SPACE
6260 eb2e 5a                           DECB                ; DECREMENT LENGTH
6261 eb2f 26 fb                        BNE  L8776          ; BRANCH IF NOT DONE
6262 eb31 7e de 22           L877B     JMP  LB69B          ; PUT STRING DESCRIPTOR ONTO STRING STACK
6263                         
6264                         * INSTR
6265 eb34 bd d9 f6           INSTR     JSR  LB26A          ; SYNTAX CHECK FOR '('
6266 eb37 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
6267 eb3a c6 01                        LDB  #$01           ; DEFAULT POSITION = 1 (SEARCH START)
6268 eb3c 34 04                        PSHS B              ; SAVE START
6269 eb3e 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
6270 eb40 26 10                        BNE  L879C          ; BRANCH IF STRING
6271 eb42 bd de 95                     JSR  LB70E          ; CONVERT FPA0 TO INTEGER IN ACCB
6272 eb45 e7 e4                        STB  ,S             ; SAVE START SEARCH VALUE
6273 eb47 27 91                        BEQ  L8724          ; BRANCH IF START SEARCH AT ZERO
6274 eb49 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6275 eb4c bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION - SEARCH STRING
6276 eb4f bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC
6277 eb52 9e 52              L879C     LDX  FPA0+2         ; SEARCH STRING DESCRIPTOR ADDRESS
6278 eb54 34 10                        PSHS X              ; SAVE ON THE STACK
6279 eb56 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6280 eb59 bd ea fe                     JSR  L8748          ; EVALUATE TARGET STRING EXPRESSION
6281 eb5c 34 14                        PSHS X,B            ; SAVE ADDRESS AND LENGTH ON STACK
6282 eb5e bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6283 eb61 ae 63                        LDX  $03,S          ; * LOAD X WITH SEARCH STRING DESCRIPTOR ADDRESS
6284 eb63 bd dd e0                     JSR  LB659          ; * AND GET THE LENGTH ANDADDRESS OF SEARCH STRING
6285 eb66 34 04                        PSHS B              ; SAVE LENGTH ON STACK
6286                         *
6287                         * AT THIS POINT THE STACK HAS THE FOLLOWING INFORMATION
6288                         * ON IT: 0,S-SEARCH LENGTH; 1,S-TARGET LENGTH; 2 3,S-TARGET
6289                         * ADDRESS; 4 5,S-SEARCH DESCRIPTOR ADDRESS; 6,S-SEARCH POSITION
6290 eb68 e1 66                        CMPB $06,S          ; COMPARE LENGTH OF SEARCH STRING TO START
6291 eb6a 25 23                        BLO  L87D9          ; POSITION; RETURN 0 IF LENGTH < START
6292 eb6c a6 61                        LDA  $01,S          ; GET LENGTH OF TARGET STRING
6293 eb6e 27 1c                        BEQ  L87D6          ; BRANCH IF TARGET STRING = NULL
6294 eb70 e6 66                        LDB  $06,S          ; GET START POSITION
6295 eb72 5a                           DECB                ; MOVE BACK ONE
6296 eb73 3a                           ABX                 ; POINT X TO POSITION IN SEARCH STRING WHERE SEARCHING WILL START
6297 eb74 31 84              L87BE     LEAY ,X             ; POINT Y TO SEARCH POSITION
6298 eb76 ee 62                        LDU  $02,S          ; POINT U TO START OF TARGET
6299 eb78 e6 61                        LDB  $01,S          ; LOAD ACCB WITH LENGTH OF TARGET
6300 eb7a a6 e4                        LDA  ,S             ; LOAD ACCA WITH LENGTH OF SEARCH
6301 eb7c a0 66                        SUBA $06,S          ; SUBTRACT SEARCH POSITION FROM SEARCH LENGTH
6302 eb7e 4c                           INCA                ; ADD ONE
6303 eb7f a1 61                        CMPA $01,S          ; COMPARE TO TARGET LENGTH
6304 eb81 25 0c                        BLO  L87D9          ; RETURN 0 IF TARGET LENGTH > WHAT'S LEFT OF SEARCH STRING
6305 eb83 a6 80              L87CD     LDA  ,X+            ; GET A CHARACTER FROM SEARCH STRING
6306 eb85 a1 c0                        CMPA ,U+            ; COMPARE IT TO TARGET STRING
6307 eb87 26 0c                        BNE  L87DF          ; BRANCH IF NO MATCH
6308 eb89 5a                           DECB                ; DECREMENT TARGET LENGTH
6309 eb8a 26 f7                        BNE  L87CD          ; CHECK ANOTHER CHARACTER
6310 eb8c e6 66              L87D6     LDB  $06,S          ; GET MATCH POSITION
6311 eb8e 21                 L87D8     FCB  SKP1           ; SKIP NEXT BYTE
6312 eb8f 5f                 L87D9     CLRB                ; MATCH ADDRESS = 0
6313 eb90 32 67                        LEAS $07,S          ; CLEAN UP THE STACK
6314 eb92 7e dc 7a                     JMP  LB4F3          ; CONVERT ACCB TO FP NUMBER
6315 eb95 6c 66              L87DF     INC  $06,S          ; INCREMENT SEARCH POSITION
6316 eb97 30 21                        LEAX $01,Y          ; MOVE X TO NEXT SEARCH POSITION
6317 eb99 20 d9                        BRA  L87BE          ; KEEP LOOKING FOR A MATCH
6318                         
6319                         * EXTENDED BASIC RVEC19 HOOK CODE
6320 eb9b 81 26              XVEC19    CMPA #'&            ; *
6321 eb9d 26 5c                        BNE  L8845          ; * RETURN IF NOT HEX OR OCTAL VARIABLE
6322 eb9f 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS FROM STACK
6323                         * PROCESS A VARIABLE PRECEEDED BY A '&' (&H,&O)
6324 eba1 0f 52              L87EB     CLR  FPA0+2         ; * CLEAR BOTTOM TWO
6325 eba3 0f 53                        CLR  FPA0+3         ; * BYTES OF FPA0
6326 eba5 8e 00 52                     LDX  #FPA0+2        ; BYTES 2,3 OF FPA0 = (TEMPORARY ACCUMULATOR)
6327 eba8 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6328 ebaa 81 4f                        CMPA #'O
6329 ebac 27 12                        BEQ  L880A          ; YES
6330 ebae 81 48                        CMPA #'H
6331 ebb0 27 23                        BEQ  L881F          ; YES
6332 ebb2 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6333 ebb4 20 0c                        BRA  L880C          ; DEFAULT TO OCTAL (&O)
6334 ebb6 81 38              L8800     CMPA #'8
6335 ebb8 10 22 ee 47                  LBHI LB277
6336 ebbc c6 03                        LDB  #$03           ; BASE 8 MULTIPLIER
6337 ebbe 8d 2a                        BSR  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
6338                         * EVALUATE AN &O VARIABLE
6339 ebc0 9d 7c              L880A     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6340 ebc2 25 f2              L880C     BLO  L8800          ; BRANCH IF NUMERIC
6341 ebc4 0f 50              L880E     CLR  FPA0           ; * CLEAR 2 HIGH ORDER
6342 ebc6 0f 51                        CLR  FPA0+1         ; * BYTES OF FPA0
6343 ebc8 0f 06                        CLR  VALTYP         ; SET VARXABLE TYPE TO NUMERIC
6344 ebca 0f 63                        CLR  FPSBYT         ; ZERO OUT SUB BYTE OF FPA0
6345 ebcc 0f 54                        CLR  FP0SGN         ; ZERO OUT MANTISSA SIGN OF FPA0
6346 ebce c6 a0                        LDB  #$A0           ; * SET EXPONENT OF FPA0
6347 ebd0 d7 4f                        STB  FP0EXP         ; *
6348 ebd2 7e e1 68                     JMP  LBA1C          ; GO NORMALIZE FPA0
6349                         * EVALUATE AN &H VARIABLE
6350 ebd5 9d 7c              L881F     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6351 ebd7 25 0b                        BLO  L882E          ; BRANCH IF NUMERIC
6352 ebd9 bd db 29                     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
6353 ebdc 25 e6                        BLO  L880E          ; BRANCH IF NOT ALPHA OR NUMERIC
6354 ebde 81 47                        CMPA #'G            ; CHECK FOR LETTERS A-F
6355 ebe0 24 e2                        BCC  L880E          ; BRANCH IF >= G (ILLEGAL HEX LETTER)
6356 ebe2 80 07                        SUBA #7             ; SUBTRACT ASCII DIFFERENCE BETWEEN A AND 9
6357 ebe4 c6 04              L882E     LDB  #$04           ; BASE 16 DIGIT MULTIPLIER = 2**4
6358 ebe6 8d 02                        BSR  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
6359 ebe8 20 eb                        BRA  L881F          ; KEEP EVALUATING VARIABLE
6360 ebea 68 01              L8834     ASL  $01,X          ; * MULTIPLY TEMPORARY
6361 ebec 69 84                        ROL  ,X             ; * ACCUMULATOR BY TWO
6362 ebee 10 25 f5 ec                  LBCS LBA92          ; 'OV' OVERFLOW ERROR
6363 ebf2 5a                           DECB                ; DECREMENT SHIFT COUNTER
6364 ebf3 26 f5                        BNE  L8834          ; MULTIPLY TEMPORARY ACCUMULATOR AGAIN
6365 ebf5 80 30                        SUBA #'0            ; MASK OFF ASCII
6366 ebf7 ab 01                        ADDA $01,X          ; * ADD DIGIT TO TEMPORARY
6367 ebf9 a7 01                        STA  $01,X          ; * ACCUMULATOR AND SAVE IT
6368 ebfb 39                 L8845     RTS
6369                         
6370 ebfc 35 40              XVEC15    PULS U              ; PULL RETURN ADDRESS AND SAVE IN U REGISTER
6371 ebfe 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
6372 ec00 9e 83                        LDX  CHARAD         ; CURRENT INPUT POINTER TO X
6373 ec02 9d 7c                        JSR  GETNCH         ; GET CHARACTER FROM BASIC
6374 ec04 81 26                        CMPA #'&            ; HEX AND OCTAL VARIABLES ARE PRECEEDED BY &
6375 ec06 27 99                        BEQ  L87EB          ; PROCESS A '&' VARIABLE
6376 ec08 81 b0                        CMPA #TOK_FN        ; TOKEN FOR FN
6377 ec0a 27 5e                        BEQ  L88B4          ; PROCESS FN CALL
6378 ec0c 81 ff                        CMPA #$FF           ; CHECK FOR SECONDARY TOKEN
6379 ec0e 26 08                        BNE  L8862          ; NOT SECONDARY
6380 ec10 9d 7c                        JSR  GETNCH         ; GET CHARACTER FROM BASIC
6381 ec12 81 83                        CMPA #TOK_USR       ; TOKEN FOR USR
6382 ec14 10 27 00 ab                  LBEQ L892C          ; PROCESS USR CALL
6383 ec18 9f 83              L8862     STX  CHARAD         ; RESTORE BASIC'S INPUT POINTER
6384 ec1a 6e c4                        JMP  ,U             ; RETURN TO CALLING ROUTINE
6385 ec1c 9e 68              L8866     LDX  CURLIN         ; GET CURRENT LINE NUMBER
6386 ec1e 30 01                        LEAX $01,X          ; IN DIRECT MODE?
6387 ec20 26 d9                        BNE  L8845          ; RETURN IF NOT IN DIRECT MODE
6388 ec22 c6 16                        LDB  #2*11          ; 'ILLEGAL DIRECT STATEMENT' ERROR
6389 ec24 7e d4 06           L886E     JMP  LAC46          ; PROCESS ERROR
6390                         
6391 ec27 ae 9f 00 83        DEF       LDX  [CHARAD]       ; GET TWO INPUT CHARS
6392 ec2b 8c ff 83                     CMPX #TOK_FF_USR    ; TOKEN FOR USR
6393 ec2e 10 27 00 74                  LBEQ L890F          ; BRANCH IF DEF USR
6394 ec32 8d 23                        BSR  L88A1          ; GET DESCRIPTOR ADDRESS FOR FN VARIABLE NAME
6395 ec34 8d e6                        BSR  L8866          ; DON'T ALLOW DEF FN IF IN DIRECT MODE
6396 ec36 bd d9 f6                     JSR  LB26A          ; SYNTAX CHECK FOR '('
6397 ec39 c6 80                        LDB  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE
6398 ec3b d7 08                        STB  ARYDIS         ; * AND SAVE IT IN THE ARRAY DISABLE FLAG
6399 ec3d bd da de                     JSR  LB357          ; GET VARIABLE DESCRIPTOR
6400 ec40 8d 25                        BSR  L88B1          ; 'TM' ERROR IF STRING
6401 ec42 bd d9 f3                     JSR  LB267          ; SYNTAX CHECK FOR ')'
6402 ec45 c6 ae                        LDB  #TOK_EQUALS    ; TOKEN FOR '='
6403 ec47 bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR =
6404 ec4a 9e 4b                        LDX  V4B            ; GET THE ADDRESS OF THE FN NAME DESCRIPTOR
6405 ec4c dc 83                        LDD  CHARAD         ; * GET THE CURRENT INPUT POINTER ADDRESS AND
6406 ec4e ed 84                        STD  ,X             ; * SAVE IT IN FIRST 2 BYTES OF THE DESCRIPTOR
6407 ec50 dc 39                        LDD  VARPTR         ; = GET THE DESCRIPTOR ADDRESS OF THE ARGUMENT
6408 ec52 ed 02                        STD  $02,X          ; = VARIABLE AND SAVE IT IN THE DESCRIPTOR OF THE FN NAME
6409 ec54 7e d6 90                     JMP  DATA           ; MOVE INPUT POINTER TO END OF LINE OR SUBLINE
6410 ec57 c6 b0              L88A1     LDB  #TOK_FN        ; TOKEN FOR FN
6411 ec59 bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR FN
6412 ec5c c6 80                        LDB  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE FLAG
6413 ec5e d7 08                        STB  ARYDIS         ; * AND SAVE IT IN ARRAY VARIABLE FLAG
6414 ec60 8a 80                        ORA  #$80           ; SET BIT 7 OF CURRENT INPUT CHARACTER TO INDICATE AN FN VARIABLE
6415 ec62 bd da e3                     JSR  LB35C          ; * GET THE DESCRIPTOR ADDRESS OF THIS
6416 ec65 9f 4b                        STX  V4B            ; * VARIABLE AND SAVE IT IN V4B
6417 ec67 7e d8 cf           L88B1     JMP  LB143          ; 'TM' ERROR IF STRING VARIABLE
6418                         * EVALUATE AN FN CALL
6419 ec6a 8d eb              L88B4     BSR  L88A1          ; * GET THE DESCRIPTOR OF THE FN NAME
6420 ec6c 34 10                        PSHS X              ; * VARIABLE AND SAVE IT ON THE STACK
6421 ec6e bd d9 ee                     JSR  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
6422 ec71 8d f4                        BSR  L88B1          ; 'TM' ERROR IF STRING VARIABLE
6423 ec73 35 40                        PULS U              ; POINT U TO FN NAME DESCRIPTOR
6424 ec75 c6 32                        LDB  #2*25          ; 'UNDEFINED FUNCTION CALL' ERROR
6425 ec77 ae 42                        LDX  $02,U          ; POINT X TO ARGUMENT VARIABLE DESCRIPTOR
6426 ec79 27 a9                        BEQ  L886E          ; BRANCH TO ERROR HANDLER
6427 ec7b 10 9e 83                     LDY  CHARAD         ; SAVE CURRENT INPUT POINTER IN Y
6428 ec7e ee c4                        LDU  ,U             ; * POINT U TO START OF FN FORMULA AND
6429 ec80 df 83                        STU  CHARAD         ; * SAVE IT IN INPUT POINTER
6430 ec82 a6 04                        LDA  $04,X          ; = GET FP VALUE OF
6431 ec84 34 02                        PSHS A              ; = ARGUMENT VARIABLE, CURRENT INPUT
6432 ec86 ec 84                        LDD  ,X             ; = POINTER, AND ADDRESS OF START
6433 ec88 ee 02                        LDU  $02,X          ; = OF FN FORMULA AND SAVE
6434 ec8a 34 76                        PSHS U,Y,X,B,A      ; = THEM ON THE STACK
6435 ec8c bd e3 81                     JSR  LBC35          ; PACK FPA0 AND SAVE IT IN (X)
6436 ec8f bd d8 cd           L88D9     JSR  LB141          ; EVALUATE FN EXPRESSION
6437 ec92 35 76                        PULS A,B,X,Y,U      ; RESTORE REGISTERS
6438 ec94 ed 84                        STD  ,X             ; * GET THE FP
6439 ec96 ef 02                        STU  $02,X          ; * VALUE OF THE ARGUMENT
6440 ec98 35 02                        PULS A              ; * VARIABLE OFF OF THE
6441 ec9a a7 04                        STA  $04,X          ; * STACK AND RE-SAVE IT
6442 ec9c 9d 82                        JSR  GETCCH         ; GET FINAL CHARACTER OF THE FN FORMULA
6443 ec9e 10 26 ed 61                  LBNE LB277          ; 'SYNTAX' ERROR IF NOT END OF LINE
6444 eca2 10 9f 83                     STY  CHARAD         ; RESTORE INPUT POINTER
6445 eca5 39                 L88EF     RTS
6446                         
6447                         
6448                         
6449                         * DEF USR
6450 eca6 9d 7c              L890F     JSR  GETNCH         ; SKIP PAST SECOND BYTE OF DEF USR TOKEN
6451 eca8 8d 09                        BSR  L891C          ; GET FN NUMBER
6452 ecaa 34 10                        PSHS X              ; SAVE FN EXEC ADDRESS STORAGE LOC
6453 ecac 8d 2d                        BSR  L8944          ; CALCULATE EXEC ADDRESS
6454 ecae 35 40                        PULS U              ; GET FN EXEC ADDRESS STORAGE LOC
6455 ecb0 af c4                        STX  ,U             ; SAVE EXEC ADDRESS
6456 ecb2 39                           RTS
6457 ecb3 5f                 L891C     CLRB                ; DEFAULT TO USR0 IF NO ARGUMENT
6458 ecb4 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6459 ecb6 24 06                        BCC  L8927          ; BRANCH IF NOT NUMERIC
6460 ecb8 80 30                        SUBA #'0            ; MASK OFF ASCII
6461 ecba 1f 89                        TFR  A,B            ; SAVE USR NUMBER IN ACCB
6462 ecbc 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6463 ecbe 9e 8d              L8927     LDX  USRADR         ; GET ADDRESS OF STORAGE LOCs FOR USR ADDRESS
6464 ecc0 58                           ASLB                ; X2 - 2 BYTES/USR ADDRESS
6465 ecc1 3a                           ABX                 ; ADD OFFSET TO START ADDRESS OF STORAGE LOCs
6466 ecc2 39                           RTS
6467                         * PROCESS A USR CALL
6468 ecc3 8d ee              L892C     BSR  L891C          ; GET STORAGE LOC OF EXEC ADDRESS FOR USR N
6469 ecc5 ae 84                        LDX  ,X             ; * GET EXEC ADDRESS AND
6470 ecc7 34 10                        PSHS X              ; * PUSH IT ONTO STACK
6471 ecc9 bd d9 ee                     JSR  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
6472 eccc 8e 00 4f                     LDX  #FP0EXP        ; POINT X TO FPA0
6473 eccf 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
6474 ecd1 27 07                        BEQ  L8943          ; BRANCH IF NUMERIC, STRING IF <> 0
6475 ecd3 bd dd de                     JSR  LB657          ; GET LENGTH & ADDRESS OF STRING VARIABLE
6476 ecd6 9e 52                        LDX  FPA0+2         ; GET POINTER TO STRING DESCRIPTOR
6477 ecd8 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
6478 ecda 39                 L8943     RTS                 ; JUMP TO USR ROUTINE (PSHS X ABOVE)
6479 ecdb c6 ae              L8944     LDB  #TOK_EQUALS    ; TOKEN FOR '='
6480 ecdd bd d9 fb                     JSR  LB26F          ; DO A SYNTAX CHECK FOR =
6481 ece0 7e de c4                     JMP  LB73D          ; EVALUATE EXPRESSION, RETURN VALUE IN X
6482                         
6483                         
6484                         
6485                         * DEL
6486 ece3 10 27 ee ea        DEL       LBEQ LB44A          ; 'FC' ERROR IF NO ARGUMENT
6487 ece7 bd d7 17                     JSR  LAF67          ; CONVERT A DECIMAL BASiC NUMBER TO BINARY
6488 ecea bd d4 a5                     JSR  LAD01          ; FIND RAM ADDRESS OF START OF A BASIC LINE
6489 eced 9f 93                        STX  VD3            ; SAVE RAM ADDRESS OF STARTING LINE NUMBER
6490 ecef 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6491 ecf1 27 10                        BEQ  L8990          ; BRANCH IF END OF LINE
6492 ecf3 81 a7                        CMPA #TOK_MINUS     ; TOKEN FOR '-'
6493 ecf5 26 3b                        BNE  L89BF          ; TERMINATE COMMAND IF LINE NUMBER NOT FOLLOWED BY '-'
6494 ecf7 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6495 ecf9 27 04                        BEQ  L898C          ; IF END OF LINE, USE DEFAULT ENDING LINE NUMBER
6496 ecfb 8d 24                        BSR  L89AE          ; * CONVERT ENDING LINE NUMBER TO BINARY
6497 ecfd 20 04                        BRA  L8990          ; * AND SAVE IT IN BINVAL
6498 ecff 86 ff              L898C     LDA  #$FF           ; = USE $FFXX AS DEFAULT ENDING
6499 ed01 97 2b                        STA  BINVAL         ; = LINE NUMBER - SAVE IT IN BINVAL
6500 ed03 de 93              L8990     LDU  VD3            ; POINT U TO STARTING LINE NUMBER ADDRESS
6501 ed05 8c                 L8992     FCB  SKP2           ; SKIP TWO BYTES
6502 ed06 ee c4              L8993     LDU  ,U             ; POINT U TO START OF NEXT LINE
6503 ed08 ec c4                        LDD  ,U             ; CHECK FOR END OF PROGRAM
6504 ed0a 27 06                        BEQ  L899F          ; BRANCH IF END OF PROGRAM
6505 ed0c ec 42                        LDD  $02,U          ; LOAD ACCD WITH THIS LINE'S NUMBER
6506 ed0e 93 2b                        SUBD BINVAL         ; SUBTRACT ENDING LINE NUMBER ADDRESS
6507 ed10 23 f4                        BLS  L8993          ; BRANCH IF = < ENDING LINE NUMBER
6508 ed12 9e 93              L899F     LDX  VD3            ; GET STARTING LINE NUMBER
6509 ed14 8d 15                        BSR  L89B8          ; MOVE (U) TO (X) UNTIL END OF PROGRAM
6510 ed16 bd d4 c5                     JSR  LAD21          ; RESET BASIC'S INPUT POINTER AND ERASE VARIABLES
6511 ed19 9e 93                        LDX  VD3            ; GET STARTING LINE NUMBER ADDRESS
6512 ed1b bd d4 95                     JSR  LACF1          ; RECOMPUTE START OF NEXT LINE ADDRESSES
6513 ed1e 7e d4 25                     JMP  LAC73          ; JUMP TO BASIC'S MAIN COMMAND LOOP
6514 ed21 bd d7 17           L89AE     JSR  LAF67          ; GO GET LINE NUMBER CONVERTED TO BINARY
6515 ed24 7e d1 ba                     JMP  LA5C7          ; MAKE SURE THERE'S NO MORE ON THIS LINE
6516 ed27 a6 c0              L89B4     LDA  ,U+            ; GET A BYTE FROM (U)
6517 ed29 a7 80                        STA  ,X+            ; MOVE THE BYTE TO (X)
6518 ed2b 11 93 1b           L89B8     CMPU VARTAB         ; COMPARE TO END OF BASIC
6519 ed2e 26 f7                        BNE  L89B4          ; BRANCH IF NOT AT END
6520 ed30 9f 1b                        STX  VARTAB         ; SAVE (X) AS NEW END OF BASIC
6521 ed32 39                 L89BF     RTS
6522                         
6523                         
6524 ed33 bd ec 1c           L89C0     JSR  L8866          ; 'BS' ERROR IF IN DIRECT MODE
6525 ed36 9d 7c                        JSR  GETNCH         ; GET A CHAR FROM BASIC
6526 ed38 81 22              L89D2     CMPA #'"            ; CHECK FOR PROMPT STRING
6527 ed3a 26 0b                        BNE  L89E1          ; BRANCH IF NO PROMPT STRING
6528 ed3c bd d9 d0                     JSR  LB244          ; STRIP OFF PROMPT STRING & PUT IT ON STRING STACK
6529 ed3f c6 3b                        LDB  #';            ; *
6530 ed41 bd d9 fb                     JSR  LB26F          ; * DO A SYNTAX CHECK FOR;
6531 ed44 bd e0 eb                     JSR  LB99F          ; REMOVE PROMPT STRING FROM STRING STACK & SEND TO CONSOLE OUT
6532 ed47 32 7e              L89E1     LEAS -2,S           ; RESERVE TWO STORAGE SLOTS ON STACK
6533 ed49 bd d7 cc                     JSR  LB035          ; INPUT A LINE FROM CURRENT INPUT DEVICE
6534 ed4c 32 62                        LEAS $02,S          ; CLEAN UP THE STACK
6535 ed4e bd da de                     JSR  LB357          ; SEARCH FOR A VARIABLE
6536 ed51 9f 3b                        STX  VARDES         ; SAVE POINTER TO VARIABLE DESCRIPTOR
6537 ed53 bd d8 d2                     JSR  LB146          ; ''TM' ERROR IF VARIABLE TYPE = NUMERIC
6538 ed56 8e 00 f3                     LDX  #LINBUF        ; POINT X TO THE STRING BUFFER WHERE THE INPUT STRING WAS STORED
6539 ed59 4f                           CLRA                ; TERMINATOR CHARACTER 0 (END OF LINE)
6540 ed5a bd dc a3                     JSR  LB51A          ; PARSE THE INPUT STRING AND STORE IT IN THE STRING SPACE
6541 ed5d 7e d7 54                     JMP  LAFA4          ; REMOVE DESCRIPTOR FROM STRING STACK
6542 ed60 bd d7 17           L89FC     JSR  LAF67          ; STRIP A DECIMAL NUMBER FROM BASIC INPUT LINE
6543 ed63 9e 2b                        LDX  BINVAL         ; GET BINARY VALUE
6544 ed65 39                           RTS
6545 ed66 9e 91              L8A02     LDX  VD1            ; GET CURRENT OLD NUMBER BEING RENUMBERED
6546 ed68 9f 2b              L8A04     STX  BINVAL         ; SAVE THE LINE NUMBER BEING SEARCHED FOR
6547 ed6a 7e d4 a5                     JMP  LAD01          ; GO FIND THE LINE NUMBER IN BASIC PROGRAM
6548                         
6549                         * RENUM
6550 ed6d bd d4 ca           RENUM     JSR  LAD26          ; ERASE VARIABLES
6551 ed70 cc 00 0a                     LDD  #10            ; DEFAULT LINE NUMBER INTERVAL
6552 ed73 dd 95                        STD  VD5            ; SAVE DEFAULT RENUMBER START LINE NUMBER
6553 ed75 dd 8f                        STD  VCF            ; SAVE DEFAULT INTERVAL
6554 ed77 5f                           CLRB                ; NOW ACCD = 0
6555 ed78 dd 91                        STD  VD1            ; DEFAULT LINE NUMBER OF WHERE TO START RENUMBERING
6556 ed7a 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6557 ed7c 24 06                        BCC  L8A20          ; BRANCH IF NOT NUMERIC
6558 ed7e 8d e0                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
6559 ed80 9f 95                        STX  VD5            ; SAVE LINE NUMBER WHERE RENUMBERING STARTS
6560 ed82 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6561 ed84 27 1b              L8A20     BEQ  L8A3D          ; BRANCH IF END OF LINE
6562 ed86 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6563 ed89 24 06                        BCC  L8A2D          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
6564 ed8b 8d d3                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
6565 ed8d 9f 91                        STX  VD1            ; SAVE NEW RENUMBER LINE
6566 ed8f 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6567 ed91 27 0e              L8A2D     BEQ  L8A3D          ; BRANCH IF END OF LINE
6568 ed93 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
6569 ed96 24 06                        BCC  L8A3A          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
6570 ed98 8d c6                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
6571 ed9a 9f 8f                        STX  VCF            ; SAVE NEW INTERVAL
6572 ed9c 27 49                        BEQ  L8A83          ; 'FC' ERROR
6573 ed9e bd d1 ba           L8A3A     JSR  LA5C7          ; CHECK FOR MORE CHARACTERS ON LINE - 'SYNTAX' ERROR IF ANY
6574 eda1 8d c3              L8A3D     BSR  L8A02          ; GO GET ADDRESS OF OLD NUMBER BEING RENUMBERED
6575 eda3 9f 93                        STX  VD3            ; SAVE ADDRESS
6576 eda5 9e 95                        LDX  VD5            ; GET NEXT RENUMBERED LINE NUMBER TO USE
6577 eda7 8d bf                        BSR  L8A04          ; FIND THE LINE NUMBER IN THE BASIC PROGRAM
6578 eda9 9c 93                        CMPX VD3            ; COMPARE TO ADDRESS OF OLD LINE NUMBER
6579 edab 25 3a                        BLO  L8A83          ; 'FC' ERROR IF NEW ADDRESS < OLD ADDRESS
6580 edad 8d 1c                        BSR  L8A67          ; MAKE SURE RENUMBERED LINE NUMBERS WILL BE IN RANGE
6581 edaf bd ee 41                     JSR  L8ADD          ; CONVERT ASCII LINE NUMBERS TO 'EXPANDED' BINARY
6582 edb2 bd d4 93                     JSR  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESSES
6583 edb5 8d af                        BSR  L8A02          ; GET RAM ADDRESS OF FIRST LINE TO BE RENUMBERED
6584 edb7 9f 93                        STX  VD3            ; SAVE IT
6585 edb9 8d 3a                        BSR  L8A91          ; MAKE SURE LINE NUMBERS EXIST
6586 edbb 8d 0f                        BSR  L8A68          ; INSERT NEW LINE NUMBERS IN LINE HEADERS
6587 edbd 8d 36                        BSR  L8A91          ; INSERT NEW LINE NUMBERS IN PROGRAM STATEMENTS
6588 edbf bd ee dc                     JSR  L8B7B          ; CONVERT PACKED BINARY LINE NUMBERS TO ASCII
6589 edc2 bd d4 ca                     JSR  LAD26          ; ERASE VARIABLES
6590 edc5 bd d4 93                     JSR  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESS
6591 edc8 7e d4 25                     JMP  LAC73          ; GO BACK TO BASIC'S MAIN LOOP
6592 edcb 86                 L8A67     FCB  SKP1LD         ; SKIP ONE BYTE - LDA #$4F
6593 edcc 4f                 L8A68     CLRA                ; NEW LINE NUMBER FLAG - 0; INSERT NEW LINE NUMBERS
6594 edcd 97 98                        STA  VD8            ; SAVE NEW LINE NUMBER FLAG; 0 = INSERT NEW NUMBERS
6595 edcf 9e 93                        LDX  VD3            ; GET ADDRESS OF OLD LINE NUMBER BEING RENUMBERED
6596 edd1 dc 95                        LDD  VD5            ; GET THE CURRENT RENUMBERED LINE NUMBER
6597 edd3 8d 15                        BSR  L8A86          ; RETURN IF END OF PROGRAM
6598 edd5 0d 98              L8A71     TST  VD8            ; CHECK NEW LINE NUMBER FLAG
6599 edd7 26 02                        BNE  L8A77          ; BRANCH IF NOT INSERTING NEW LINE NUMBERS
6600 edd9 ed 02                        STD  $02,X          ; STORE THE NEW LINE NUMBER IN THE BASIC PROGRAM
6601 eddb ae 84              L8A77     LDX  ,X             ; POINT X TO THE NEXT LINE IN BASIC
6602 eddd 8d 0b                        BSR  L8A86          ; RETURN IF END OF PROGRAM
6603 eddf d3 8f                        ADDD VCF            ; ADD INTERVAL TO CURRENT RENUMBERED LINE NUMBER
6604 ede1 25 04                        BLO  L8A83          ; 'FC' ERROR IF LINE NUMBER > $FFFF
6605 ede3 81 fa                        CMPA #MAXLIN        ; LARGEST LINE NUMBER = $F9FF
6606 ede5 25 ee                        BLO  L8A71          ; BRANCH IF LEGAL LINE NUMBER
6607 ede7 7e db d1           L8A83     JMP  LB44A          ; 'FC' ERROR IF LINE NUMBER MS BYTE > $F9
6608                         * TEST THE TWO BYTES POINTED TO BY (X).
6609                         * NORMAL RETURN IF <> 0. IF = 0 (END OF
6610                         * PROGRAM) RETURN IS PULLED OFF STACK AND
6611                         * YOU RETURN TO PREVIOUS SUBROUTINE CALL.
6612 edea 34 06              L8A86     PSHS B,A            ; SAVE ACCD
6613 edec ec 84                        LDD  ,X             ; TEST THE 2 BYTES POINTED TO BY X
6614 edee 35 06                        PULS A,B            ; RESTORE ACCD
6615 edf0 26 02                        BNE  L8A90          ; BRANCH IF NOT END OF PROGRAM
6616 edf2 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS FROM STACK
6617 edf4 39                 L8A90     RTS
6618 edf5 9e 19              L8A91     LDX  TXTTAB         ; GET START OF BASIC PROGRAM
6619 edf7 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
6620 edf9 30 01              L8A95     LEAX $01,X          ; MOVE POINTER UP ONE
6621 edfb 8d ed                        BSR  L8A86          ; RETURN IF END OF PROGRAM
6622 edfd 30 03              L8A99     LEAX $03,X          ; SKIP OVER NEXT LINE ADDRESS AND LINE NUMBER
6623 edff 30 01              L8A9B     LEAX $01,X          ; MOVE POINTER TO NEXT CHARACTER
6624 ee01 a6 84                        LDA  ,X             ; CHECK CURRENT CHARACTER
6625 ee03 27 f4                        BEQ  L8A95          ; BRANCH IF END OF LINE
6626 ee05 9f 0f                        STX  TEMPTR         ; SAVE CURRENT POINTER
6627 ee07 4a                           DECA                ; =
6628 ee08 27 0c                        BEQ  L8AB2          ; =BRANCH IF START OF PACKED NUMERIC LINE
6629 ee0a 4a                           DECA                ; *
6630 ee0b 27 2a                        BEQ  L8AD3          ; *BRANCH IF LINE NUMBER EXISTS
6631 ee0d 4a                           DECA                ; =
6632 ee0e 26 ef                        BNE  L8A9B          ; =MOVE TO NEXT CHARACTER IF > 3
6633 ee10 86 03              L8AAC     LDA  #$03           ; * SET 1ST BYTE = 3 TO INDICATE LINE
6634 ee12 a7 80                        STA  ,X+            ; * NUMBER DOESN'T CURRENTLY EXIST
6635 ee14 20 e7                        BRA  L8A99          ; GO GET ANOTHER CHARACTER
6636 ee16 ec 01              L8AB2     LDD  $01,X          ; GET MS BYTE OF LINE NUMBER
6637 ee18 6a 02                        DEC  $02,X          ; DECREMENT ZERO CHECK BYTE
6638 ee1a 27 01                        BEQ  L8AB9          ; BRANCH IF MS BYTE <> 0
6639 ee1c 4f                           CLRA                ; CLEAR MS BYTE
6640 ee1d e6 03              L8AB9     LDB  $03,X          ; GET LS BYTE OF LINE NUMBER
6641 ee1f 6a 04                        DEC  $04,X          ; DECREMENT ZERO CHECK FLAG
6642 ee21 27 01                        BEQ  L8AC0          ; BRANCH IF IS BYTE <> 0
6643 ee23 5f                           CLRB                ; CLEAR LS BYTE
6644 ee24 ed 01              L8AC0     STD  $01,X          ; SAVE BINARY LINE NUMBER
6645 ee26 dd 2b                        STD  BINVAL         ; SAVE TRIAL LINE NUMBER
6646 ee28 bd d4 a5                     JSR  LAD01          ; FIND RAM ADDRESS OF A BASIC LINE NUMBER
6647 ee2b 9e 0f              L8AC7     LDX  TEMPTR         ; GET BACK POINTER TO START OF PACKED LINE NUMBER
6648 ee2d 25 e1                        BLO  L8AAC          ; BRANCH IF NO LINE NUMBER MATCH FOUND
6649 ee2f dc 47                        LDD  V47            ; GET START ADDRESS OF LINE NUMBER
6650 ee31 6c 80                        INC  ,X+            ; * SET 1ST BYTE = 2, TO INDICATE LINE NUMBER EXISTS IF CHECKING FOR
6651                         *              ; * EXISTENCE OF LINE NUMBER, SET IT = 1 IF INSERTING LINE NUMBERS
6652                         
6653 ee33 ed 84                        STD  ,X             ; SAVE RAM ADDRESS OF CORRECT LINE NUMBER
6654 ee35 20 c6                        BRA  L8A99          ; GO GET ANOTHER CHARACTER
6655 ee37 6f 84              L8AD3     CLR  ,X             ; CLEAR CARRY FLAG AND 1ST BYTE
6656 ee39 ae 01                        LDX  $01,X          ; POINT X TO RAM ADDRESS OF CORRECT LINE NUMBER
6657 ee3b ae 02                        LDX  $02,X          ; PUT CORRECT LINE NUMBER INTO (X)
6658 ee3d 9f 47                        STX  V47            ; SAVE IT TEMPORARILY
6659 ee3f 20 ea                        BRA  L8AC7          ; GO INSERT IT INTO BASIC LINE
6660 ee41 9e 19              L8ADD     LDX  TXTTAB         ; GET BEGINNING OF BASIC PROGRAM
6661 ee43 20 04                        BRA  L8AE5
6662 ee45 9e 83              L8AE1     LDX  CHARAD         ; *GET CURRENT INPUT POINTER
6663 ee47 30 01                        LEAX $01,X          ; *AND BUMP IT ONE
6664 ee49 8d 9f              L8AE5     BSR  L8A86          ; RETURN IF END OF PROGRAM
6665 ee4b 30 02                        LEAX $02,X          ; SKIP PAST NEXT LINE ADDRESS
6666 ee4d 30 01              L8AE9     LEAX $01,X          ; ADVANCE POINTER BY ONE
6667 ee4f 9f 83              L8AEB     STX  CHARAD         ; SAVE NEW BASIC INPUT POINTER
6668 ee51 9d 7c              L8AED     JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
6669 ee53 4d                 L8AEF     TSTA                ; CHECK THE CHARACTER
6670 ee54 27 ef                        BEQ  L8AE1          ; BRANCH IF END OF LINE
6671 ee56 2a f9                        BPL  L8AED          ; BRANCH IF NOT A TOKEN
6672 ee58 9e 83                        LDX  CHARAD         ; GET CURRENT INPUT POINTER
6673 ee5a 81 ff                        CMPA #$FF           ; IS THIS A SECONDARY TOKEN?
6674 ee5c 27 ef                        BEQ  L8AE9          ; YES - IGNORE IT
6675 ee5e 81 a2                        CMPA #TOK_THEN      ; TOKEN FOR THEN?
6676 ee60 27 12                        BEQ  L8B13          ; YES
6677 ee62 81 84                        CMPA #TOK_ELSE      ; TOKEN FOR ELSE?
6678 ee64 27 0e                        BEQ  L8B13          ; YES
6679 ee66 81 81                        CMPA #TOK_GO        ; TOKEN FOR GO?
6680 ee68 26 e7                        BNE  L8AED          ; NO
6681 ee6a 9d 7c                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6682 ee6c 81 a0                        CMPA #TOK_TO        ; TOKEN FOR TO?
6683 ee6e 27 04                        BEQ  L8B13          ; YES
6684 ee70 81 a1                        CMPA #TOK_SUB       ; TOKEN FOR SUB?
6685 ee72 26 db                        BNE  L8AEB          ; NO
6686 ee74 9d 7c              L8B13     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
6687 ee76 25 04                        BLO  L8B1B          ; BRANCH IF NUMERIC
6688 ee78 9d 82              L8B17     JSR  GETCCH         ; GET CURRENT BASIC INPUT CHARRACTER
6689 ee7a 20 d7                        BRA  L8AEF          ; KEEP CHECKING THE LINE
6690 ee7c 9e 83              L8B1B     LDX  CHARAD         ; GET CURRENT INPUT ADDRESS
6691 ee7e 34 10                        PSHS X              ; SAVE IT ON THE STACK
6692 ee80 bd d7 17                     JSR  LAF67          ; CONVERT DECIMAL BASIC NUMBER TO BINARY
6693 ee83 9e 83                        LDX  CHARAD         ; GET CURRENT INPUT POINTER
6694 ee85 a6 82              L8B24     LDA  ,-X            ; GET PREVIOUS INPUT CHARACTER
6695 ee87 bd f1 ec                     JSR  L90AA          ; CLEAR CARRY IF NUMERIC INPUT VALUE
6696 ee8a 25 f9                        BLO  L8B24          ; BRANCH IF NON-NUMERIC
6697 ee8c 30 01                        LEAX $01,X          ; MOVE POINTER UP ONE
6698 ee8e 1f 10                        TFR  X,D            ; NOW ACCD POINTS TO ONE PAST END OF LINE NUMBER
6699 ee90 e0 61                        SUBB $01,S          ; SUBTRACT PRE-NUMERIC POINTER LS BYTE
6700 ee92 c0 05                        SUBB #$05           ; MAKE SURE THERE ARE AT LEAST 5 CHARACTERS IN THE NUMERIC LINE
6701                         *
6702 ee94 27 20                        BEQ  L8B55          ; BRANCH IF EXACTLY 5
6703 ee96 25 0a                        BLO  L8B41          ; BRANCH IF < 5
6704 ee98 33 84                        LEAU ,X             ; TRANSFER X TO U
6705 ee9a 50                           NEGB                ; NEGATE B
6706 ee9b 30 85                        LEAX B,X            ; MOVE X BACK B BYTES
6707 ee9d bd ed 2b                     JSR  L89B8          ; *MOVE BYTES FROM (U) TO (X) UNTIL
6708                         *         *U   = END OF BASIC; (I) = NEW END OF BASIC
6709 eea0 20 14                        BRA  L8B55
6710                         * FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER
6711 eea2 9f 47              L8B41     STX  V47            ; SAVE END OF NUMERIC VALUE
6712 eea4 9e 1b                        LDX  VARTAB         ; GET END OF BASIC PROGRAM
6713 eea6 9f 43                        STX  V43            ; SAVE IT
6714 eea8 50                           NEGB                ; NEGATE B
6715 eea9 30 85                        LEAX B,X            ; ADD IT TO END OF NUMERIC POiNTER
6716 eeab 9f 41                        STX  V41            ; SAVE POINTER
6717 eead 9f 1b                        STX  VARTAB         ; STORE END OF BASIC PROGRAM
6718 eeaf bd d3 de                     JSR  LAC1E          ; ACCD = TOP OF ARRAYS - CHECK FOR ENOUGH ROOM
6719 eeb2 9e 45                        LDX  V45            ; * GET AND SAVE THE
6720 eeb4 9f 83                        STX  CHARAD         ; * NEW CURRENT INPUT POINTER
6721 eeb6 35 10              L8B55     PULS X              ; RESTORE POINTER TO START OF NUMERIC VALUE
6722 eeb8 86 01                        LDA  #$01           ; NEW LINE NUMBER FLAG
6723 eeba a7 84                        STA  ,X             ; * SAVE NEW LINE FLAG
6724 eebc a7 02                        STA  $02,X          ; *
6725 eebe a7 04                        STA  $04,X          ; *
6726 eec0 d6 2b                        LDB  BINVAL         ; GET MS BYTE OF BINARY LINE NUMBER
6727 eec2 26 04                        BNE  L8B67          ; BRANCH IF IT IS NOT ZERO
6728 eec4 c6 01                        LDB  #$01           ; ; SAVE A 1 IF BYTE IS 0; OTHERWISE, BASIC WILL
6729                         *              ; THINK IT IS THE END OF A LINE
6730 eec6 6c 02                        INC  $02,X          ; IF 2,X = 2, THEN PREVIOUS BYTE WAS A ZERO
6731 eec8 e7 01              L8B67     STB  $01,X          ; SAVE MS BYTE OF BINARY LINE NUMBER
6732 eeca d6 2c                        LDB  BINVAL+1       ; GET IS BYTE OF BINARY LINE NUMBER
6733 eecc 26 04                        BNE  L8B71          ; BRANCH IF NOT A ZERO BYTE
6734 eece c6 01                        LDB  #$01           ; SAVE A 1 IF BYTE IS A 0
6735 eed0 6c 04                        INC  $04,X          ; IF 4,X = 2, THEN PREVIOUS BYTE WAS A 0
6736 eed2 e7 03              L8B71     STB  $03,X          ; SAVE LS BYTE OF BINARY LINE NUMBER
6737 eed4 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6738 eed6 81 2c                        CMPA #',            ; IS IT A COMMA?
6739 eed8 27 9a                        BEQ  L8B13          ; YES - PROCESS ANOTHER NUMERIC VALUE
6740 eeda 20 9c                        BRA  L8B17          ; NO - GO GET AND PROCESS AN INPUT CHARACTER
6741 eedc 9e 19              L8B7B     LDX  TXTTAB         ; POINT X TO START OF BASIC PROGRAM
6742 eede 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
6743 eee0 30 01              L8B7F     LEAX $01,X          ; MOVE POINTER UP ONE
6744 eee2 ec 02                        LDD  $02,X          ; GET ADDRESS OF NEXT LINE
6745 eee4 dd 68                        STD  CURLIN         ; SAVE IT IN CURLIN
6746 eee6 bd ed ea                     JSR  L8A86          ; RETURN IF END OF PROGRAM
6747 eee9 30 03                        LEAX $03,X          ; SKIP OVER ADDRESS OF NEXT LINE AND 1ST BYTE OF LINE NUMBER
6748 eeeb 30 01              L8B8A     LEAX $01,X          ; MOVE POINTER UP ONE
6749 eeed a6 84              L8B8C     LDA  ,X             ; GET CURRENT CHARACTER
6750 eeef 27 ef                        BEQ  L8B7F          ; BRANCH IF END OF LINE
6751 eef1 4a                           DECA                ; INPUT CHARACTER = 1? - VALID LINE NUMBER
6752 eef2 27 1b                        BEQ  L8BAE          ; YES
6753 eef4 80 02                        SUBA #$02           ; INPUT CHARACTER 3? - UL LINE NUMBER
6754 eef6 26 f3                        BNE  L8B8A          ; NO
6755 eef8 34 10                        PSHS X              ; SAVE CURRENT POSITION OF INPUT POINTER
6756 eefa 8e ef 39                     LDX  #L8BD9-1       ; POINT X TO 'UL' MESSAGE
6757 eefd bd e0 e8                     JSR  LB99C          ; PRINT STRING TO THE SCREEN
6758 ef00 ae e4                        LDX  ,S             ; GET INPUT POINTER
6759 ef02 ec 01                        LDD  $01,X          ; GET THE UNDEFINED LINE NUMBER
6760 ef04 bd e5 18                     JSR  LBDCC          ; CONVERT NUMBER IN ACCD TO DECIMAL AND DISPLAY IT
6761 ef07 bd e5 11                     JSR  LBDC5          ; PRINT 'IN XXXX' XXXX = CURRENT LINE NUMBER
6762 ef0a bd e0 a8                     JSR  LB958          ; SEND A CR TO CONSOLE OUT
6763 ef0d 35 10                        PULS X              ; GET INPUT POINTER BACK
6764 ef0f 34 10              L8BAE     PSHS X              ; SAVE CURRENT POSITION OF INPUT POINTER
6765 ef11 ec 01                        LDD  $01,X          ; LOAD ACCD WITH BINARY VALUE OF LINE NUMBER
6766 ef13 dd 52                        STD  FPA0+2         ; SAVE IN BOTTOM 2 BYTES OF FPA0
6767 ef15 bd eb c4                     JSR  L880E          ; ADJUST REST OF FPA0 AS AN INTEGER
6768 ef18 bd e5 25                     JSR  LBDD9          ; CONVERT FPA0 TO ASCII, STORE IN LINE NUMBER
6769 ef1b 35 40                        PULS U              ; LOAD U WITH PREVIOUS ADDRESS OF INPUT POINTER
6770 ef1d c6 05                        LDB  #$05           ; EACH EXPANDED LINE NUMBER USES 5 BYTES
6771 ef1f 30 01              L8BBE     LEAX $01,X          ; MOVE POINTER FORWARD ONE
6772 ef21 a6 84                        LDA  ,X             ; GET AN ASCII BYTE
6773 ef23 27 05                        BEQ  L8BC9          ; BRANCH IF END OF NUMBER
6774 ef25 5a                           DECB                ; DECREMENT BYTE COUNTER
6775 ef26 a7 c0                        STA  ,U+            ; STORE ASCII NUMBER IN BASIC LINE
6776 ef28 20 f5                        BRA  L8BBE          ; CHECK FOR ANOTHER DIGIT
6777 ef2a 30 c4              L8BC9     LEAX ,U             ; TRANSFER NEW LINE POINTER TO (X)
6778 ef2c 5d                           TSTB                ; DOES THE NEW LINE NUMBER REQUIRE 5 BYTES?
6779 ef2d 27 be                        BEQ  L8B8C          ; YES - GO GET ANOTHER INPUT CHARACTER
6780 ef2f 31 c4                        LEAY ,U             ; SAVE NEW LINE POINTER IN Y
6781 ef31 33 c5                        LEAU B,U            ; POINT U TO END OF 5 BYTE PACKED LINE NUMBER BLOCK
6782 ef33 bd ed 2b                     JSR  L89B8          ; MOVE BYTES FROM (U) TO (X) UNTIL END OF PROGRAM
6783 ef36 30 a4                        LEAX ,Y             ; LOAD (X) WITH NEW LINE POINTER
6784 ef38 20 b3                        BRA  L8B8C          ; GO GET ANOTHER INPUT CHARACTER
6785                         
6786 ef3a 55 4c 20           L8BD9     FCC  "UL "          ; UNKNOWN LINE NUMBER MESSAGE
6787 ef3d 00                           FCB  0
6788                         
6789                         
6790 ef3e bd de c7           HEXDOL    JSR  LB740          ; CONVERT FPA0 INTO A POSITIVE 2 BYTE INTEGER
6791 ef41 8e 01 f0                     LDX  #STRBUF+2      ; POINT TO TEMPORARY BUFFER
6792 ef44 c6 04                        LDB  #$04           ; CONVERT 4 NIBBLES
6793 ef46 34 04              L8BE5     PSHS B              ; SAVE NIBBLE COUNTER
6794 ef48 5f                           CLRB                ; CLEAR CARRY FLAG
6795 ef49 86 04                        LDA  #$04           ; 4 SHIFTS
6796 ef4b 08 53              L8BEA     ASL  FPA0+3         ; * SHIFT BOTTOM TWO BYTES OF
6797 ef4d 09 52                        ROL  FPA0+2         ; * FPA0 LEFT ONE BIT (X2)
6798 ef4f 59                           ROLB                ; IF OVERFLOW, ACCB <> 0
6799 ef50 4a                           DECA                ; * DECREMENT SHIFT COUNTER AND
6800 ef51 26 f8                        BNE  L8BEA          ; * BRANCH IF NOT DONE
6801 ef53 5d                           TSTB                ; CHECK FOR OVERFLOW
6802 ef54 26 0a                        BNE  L8BFF          ; BRANCH IF OVERFLOW
6803 ef56 a6 e4                        LDA  ,S             ; * GET NIBBLE COUNTER,
6804 ef58 4a                           DECA                ; * DECREMENT IT AND
6805 ef59 27 05                        BEQ  L8BFF          ; * BRANCH IF DONE
6806 ef5b 8c 01 f0                     CMPX #STRBUF+2      ; DO NOT DO A CONVERSION UNTIL A NON-ZERO
6807 ef5e 27 0c                        BEQ  L8C0B          ; BYTE IS FOUND - LEADING ZERO SUPPRESSION
6808 ef60 cb 30              L8BFF     ADDB #'0            ; ADD IN ASCII ZERO
6809 ef62 c1 39                        CMPB #'9            ; COMPARE TO ASCII 9
6810 ef64 23 02                        BLS  L8C07          ; BRANCH IF < 9
6811 ef66 cb 07                        ADDB #7             ; ADD ASCII OFFSET IF HEX LETTER
6812 ef68 e7 80              L8C07     STB  ,X+            ; STORE HEX VALUE AND ADVANCE POINTER
6813 ef6a 6f 84                        CLR  ,X             ; CLEAR NEXT BYTE - END OF STRING FLAG
6814 ef6c 35 04              L8C0B     PULS B              ; * GET NIBBLE COUNTER,
6815 ef6e 5a                           DECB                ; * DECREMENT IT AND
6816 ef6f 26 d5                        BNE  L8BE5          ; * BRANCH IF NOT DONE
6817 ef71 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF STACK
6818 ef73 8e 01 ef                     LDX  #STRBUF+1      ; RESET POINTER
6819 ef76 7e dc 9f                     JMP  LB518          ; SAVE STRING ON STRING STACK
6820                         * PROCESS EXCLAMATION POINT
6821 ef79 86 01              L8E37     LDA  #$01           ; * SET SPACES
6822 ef7b 97 99                        STA  VD9            ; * COUNTER = 1
6823                         * PROCESS STRING ITEM - LIST
6824 ef7d 5a                 L8E3B     DECB                ; DECREMENT FORMAT STRING LENGTH COUNTER
6825 ef7e bd f1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <>0
6826 ef81 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
6827 ef83 10 27 00 93                  LBEQ L8ED8          ; EXIT PRINT USING IF END OF LINE
6828 ef87 d7 93                        STB  VD3            ; SAVE REMAINDER FORMAT STRING LENGTH
6829 ef89 bd d8 e2                     JSR  LB156          ; EVALUATE EXPRESSION
6830 ef8c bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
6831 ef8f 9e 52                        LDX  FPA0+2         ; * GET ITEM - LIST DESCRIPTOR ADDRESS
6832 ef91 9f 4d                        STX  V4D            ; * AND SAVE IT IN V4D
6833 ef93 d6 99                        LDB  VD9            ; GET SPACES COUNTER
6834 ef95 bd de 34                     JSR  LB6AD          ; PUT ACCB BYTES INTO STRING SPACE & PUT DESCRIPTOR ON STRING STACK
6835 ef98 bd e0 eb                     JSR  LB99F          ; PRINT THE FORMATTED STRING TO CONSOLE OUT
6836                         * PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING < FORMAT STRING LENGTH
6837 ef9b 9e 52                        LDX  FPA0+2         ; POINT X TO FORMATTED STRING DESCRIPTOR ADDRESS
6838 ef9d d6 99                        LDB  VD9            ; GET SPACES COUNTER
6839 ef9f e0 84                        SUBB ,X             ; SUBTRACT LENGTH OF FORMATTED STRING
6840 efa1 5a                 L8E5F     DECB                ; DECREMENT DIFFERENCE
6841 efa2 10 2b 01 4f                  LBMI L8FB3          ; GO INTERPRET ANOTHER ITEM - LIST
6842 efa6 bd e0 f8                     JSR  LB9AC          ; PAD FORMAT STRING WITH A SPACE
6843 efa9 20 f6                        BRA  L8E5F          ; KEEP PADDING
6844                         * PERCENT SIGN - PROCESS A %SPACES% COMMAND
6845 efab d7 93              L8E69     STB  VD3            ; * SAVE THE CURRENT FORMAT STRING
6846 efad 9f 0f                        STX  TEMPTR         ; * COUNTER AND POINTER
6847 efaf 86 02                        LDA  #$02           ; INITIAL SPACES COUNTER = 2
6848 efb1 97 99                        STA  VD9            ; SAVE IN SPACES COUNTER
6849 efb3 a6 84              L8E71     LDA  ,X             ; GET A CHARACTER FROM FORMAT STRING
6850 efb5 81 25                        CMPA #'%            ; COMPARE TO TERMINATOR CHARACTER
6851 efb7 27 c4                        BEQ  L8E3B          ; BRANCH IF END OF SPACES COMMAND
6852 efb9 81 20                        CMPA #'             ; BLANK
6853 efbb 26 07                        BNE  L8E82          ; BRANCH IF ILLEGAL CHARACTER
6854 efbd 0c 99                        INC  VD9            ; ADD ONE TO SPACES COUNTER
6855 efbf 30 01                        LEAX $01,X          ; MOVE FORMAT POINTER UP ONE
6856 efc1 5a                           DECB                ; DECREMENT LENGTH COUNTER
6857 efc2 26 ef                        BNE  L8E71          ; BRANCH IF NOT END OF FORMAT STRING
6858 efc4 9e 0f              L8E82     LDX  TEMPTR         ; * RESTORE CURRENT FORMAT STRING COUNTER
6859 efc6 d6 93                        LDB  VD3            ; * AND POINTER TO POSITION BEFORE SPACES COMMAND
6860 efc8 86 25                        LDA  #'%            ; SEND A '%' TO CONSOLE OUT AS A DEBUGGING AID
6861                         * ERROR PROCESSOR - ILLEGAL CHARACTER OR BAD SYNTAX IN FORMAT STRING
6862 efca bd f1 1a           L8E88     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
6863 efcd bd d0 17                     JSR  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
6864 efd0 20 29                        BRA  L8EB9          ; GET NEXT CHARACTER IN FORMAT STRING
6865                         
6866                         * PRINT RAM HOOK
6867 efd2 81 b1              XVEC9     CMPA #TOK_USING     ; USING TOKEN
6868 efd4 27 01                        BEQ  L8E95          ; BRANCH IF PRINT USING
6869 efd6 39                           RTS
6870                         
6871                         * PRINT USING
6872                         * VDA IS USED AS A STATUS BYTE: BIT 6 = COMMA FORCE
6873                         * BIT 5=LEADING ASTERISK FORCE; BIT 4 = FLOATING $ FORCE
6874                         * BIT 3 = PRE SIGN FORCE; BIT 2 = POST SIGN FORCE; BIT 0 = EXPONENTIAL FORCE
6875 efd7 32 62              L8E95     LEAS $02,S          ; PURGE RETURN ADDRESS OFF THE STACK
6876 efd9 bd d8 e4                     JSR  LB158          ; EVALUATE FORMAT STRING
6877 efdc bd d8 d2                     JSR  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
6878 efdf c6 3b                        LDB  #';            ; CHECK FOR ITEM LIST SEPARATOR
6879 efe1 bd d9 fb                     JSR  LB26F          ; SYNTAX CHECK FOR ;
6880 efe4 9e 52                        LDX  FPA0+2         ; * GET FORMAT STRING DESCRIPTOR ADDRESS
6881 efe6 9f 95                        STX  VD5            ; * AND SAVE IT IN VD5
6882 efe8 20 06                        BRA  L8EAE          ; GO PROCESS FORMAT STRING
6883 efea 96 97              L8EA8     LDA  VD7            ; *CHECK NEXT PRINT ITEM FLAG AND
6884 efec 27 08                        BEQ  L8EB4          ; *'FC' ERROR IF NO FURTHER PRINT ITEMS
6885 efee 9e 95                        LDX  VD5            ; RESET FORMAT STRING POINTER TO START OF STRING
6886 eff0 0f 97              L8EAE     CLR  VD7            ; RESET NEXT PRINT ITEM FLAG
6887 eff2 e6 84                        LDB  ,X             ; GET LENGTH OF FORMAT STRING
6888 eff4 26 03                        BNE  L8EB7          ; INTERPRET FORMAT STRING IF LENGTH > 0
6889 eff6 7e db d1           L8EB4     JMP  LB44A          ; 'FC' ERROR IF FORMAT STRING = NULL
6890 eff9 ae 02              L8EB7     LDX  $02,X          ; POINT X TO START OF FORMAT STRING
6891                         * INTERPRET THE FORMAT STRING
6892 effb 0f 9a              L8EB9     CLR  VDA            ; CLEAR THE STATUS BYTE
6893 effd 0f 99              L8EBB     CLR  VD9            ; CLEAR LEFT DIGIT COUNTER
6894 efff a6 80                        LDA  ,X+            ; GET A CHARACTER FROM FORMAT STRING
6895 f001 81 21                        CMPA #'!            ; EXCLAMATION POINT?
6896 f003 10 27 ff 72                  LBEQ L8E37          ; YES - STRING TYPE FORMAT
6897 f007 81 23                        CMPA #'#            ; NUMBER SIGN? (DIGIT LOCATOR)
6898 f009 27 5b                        BEQ  L8F24          ; YES - NUMERIC TYPE FORMAT
6899 f00b 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH
6900 f00c 26 16                        BNE  L8EE2          ; BRANCH IF NOT DONE
6901 f00e bd f1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
6902 f011 bd d0 17                     JSR  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
6903 f014 9d 82              L8ED2     JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
6904 f016 26 d2                        BNE  L8EA8          ; BRANCH IF NOT END OF LINE
6905 f018 96 97                        LDA  VD7            ; GET NEXT PRINT ITEM FLAG
6906 f01a 26 03              L8ED8     BNE  L8EDD          ; BRANCH IF MORE PRINT ITEMS
6907 f01c bd e0 a8                     JSR  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
6908 f01f 9e 95              L8EDD     LDX  VD5            ; POINT X TO FORMAT STRING DESCRIPTOR
6909 f021 7e dd e0                     JMP  LB659          ; RETURN ADDRESS AND LENGTH OF FORMAT STRING - EXIT PRINT USING
6910 f024 81 2b              L8EE2     CMPA #'+            ; CHECK FOR '+' (PRE-SIGN FORCE)
6911 f026 26 09                        BNE  L8EEF          ; NO PLUS
6912 f028 bd f1 1a                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
6913 f02b 86 08                        LDA  #$08           ; * LOAD THE STATUS BYTE WITH 8;
6914 f02d 97 9a                        STA  VDA            ; * PRE-SIGN FORCE FLAG
6915 f02f 20 cc                        BRA  L8EBB          ; INTERPRET THE REST OF THE FORMAT STRING
6916 f031 81 2e              L8EEF     CMPA #'.            ; DECIMAL POINT?
6917 f033 27 4e                        BEQ  L8F41          ; YES
6918 f035 81 25                        CMPA #'%            ; PERCENT SIGN?
6919 f037 10 27 ff 70                  LBEQ L8E69          ; YES
6920 f03b a1 84                        CMPA ,X             ; COMPARE THE PRESENT FORMAT STRING INPUT
6921                         *              ; CHARACTER TO THE NEXT ONE IN THE STRING
6922 f03d 26 8b              L8EFB     BNE  L8E88          ; NO MATCH - ILLEGAL CHARACTER
6923                         * TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING
6924 f03f 81 24                        CMPA #'$            ; DOLLAR SIGN?
6925 f041 27 19                        BEQ  L8F1A          ; YES - MAKE THE DOLLAR SIGN FLOAT
6926 f043 81 2a                        CMPA #'*            ; ASTERISK?
6927 f045 26 f6                        BNE  L8EFB          ; NO - ILLEGAL CHARACTER
6928 f047 96 9a                        LDA  VDA            ; * GRAB THE STATUS BYTE AND BET BIT 5
6929 f049 8a 20                        ORA  #$20           ; * TO INDICATE THAT THE OUTPUT WILL
6930 f04b 97 9a                        STA  VDA            ; * BE LEFT PADDED WITH ASTERISKS
6931 f04d c1 02                        CMPB #2             ; * CHECK TO SEE IF THE $$ ARE THE LAST TWO
6932 f04f 25 11                        BLO  L8F20          ; * CHARACTERS IN THE FORMAT STRING AND BRANCH IF SO
6933 f051 a6 01                        LDA  $01,X          ; GET THE NEXT CHARACTER AFTER **
6934 f053 81 24                        CMPA #'$            ; CHECK FOR **$
6935 f055 26 0b                        BNE  L8F20          ; CHECK FOR MORE CHARACTERS
6936 f057 5a                           DECB                ; DECREMENT STRING LENGTH COUNTER
6937 f058 30 01                        LEAX $01,X          ; MOVE FORMAT STRING POINTER UP ONE
6938 f05a 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER - FOR ASTERISK PAD AND
6939                         *              ; FLOATING DOLLAR SIGN COMBINATION
6940 f05c 96 9a              L8F1A     LDA  VDA            ; * GET THE STATUS BYTE AND SET
6941 f05e 8a 10                        ORA  #$10           ; * BIT 4 TO INDICATE A
6942 f060 97 9a                        STA  VDA            ; * FLOATING DOLLAR SIGN
6943 f062 30 01              L8F20     LEAX $01,X          ; MOVE FORMAT STRING POINTER UP ONE
6944 f064 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT (FLOATING $ OR ASTERISK PAD)
6945                         * PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT IN THE FORMAT STRING
6946 f066 0f 98              L8F24     CLR  VD8            ; CLEAR THE RIGHT DIGIT COUNTER
6947 f068 0c 99              L8F26     INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER
6948 f06a 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH COUNTER
6949 f06b 27 49                        BEQ  L8F74          ; BRANCH IF END OF FORMAT STRING
6950 f06d a6 80                        LDA  ,X+            ; GET THE NEXT FORMAT CHARACTER
6951 f06f 81 2e                        CMPA #'.            ; DECIMAL POINT?
6952 f071 27 1e                        BEQ  L8F4F          ; YES
6953 f073 81 23                        CMPA #'#            ; NUMBER SIGN?
6954 f075 27 f1                        BEQ  L8F26          ; YES
6955 f077 81 2c                        CMPA #',            ; COMMA?
6956 f079 26 21                        BNE  L8F5A          ; NO
6957 f07b 96 9a                        LDA  VDA            ; * GET THE STATUS BYTE
6958 f07d 8a 40                        ORA  #$40           ; * AND SET BIT 6 WHICH IS THE
6959 f07f 97 9a                        STA  VDA            ; * COMMA SEPARATOR FLAG
6960 f081 20 e5                        BRA  L8F26          ; PROCESS MORE CHARACTERS TO LEFT OF DECIMAL POINT
6961                         * PROCESS DECIMAL POINT IF NO DIGITS TO LEFT OF IT
6962 f083 a6 84              L8F41     LDA  ,X             ; GET NEXT FORMAT CHARACTER
6963 f085 81 23                        CMPA #'#            ; IS IT A NUMBER SIGN?
6964 f087 10 26 ff 3f                  LBNE L8E88          ; NO
6965 f08b 86 01                        LDA  #1             ; * SET THE RIGHT DIGIT COUNTER TO 1 -
6966 f08d 97 98                        STA  VD8            ; * ALLOW ONE SPOT FOR DECIMAL POINT
6967 f08f 30 01                        LEAX $01,X          ; MOVE FORMAT POINTER UP ONE
6968                         * PROCESS DIGITS TO RIGHT OF DECIMAL POINT
6969 f091 0c 98              L8F4F     INC  VD8            ; ADD ONE TO RIGHT DIGIT COUNTER
6970 f093 5a                           DECB                ; DECREMENT FORMAT LENGTH COUNTER
6971 f094 27 20                        BEQ  L8F74          ; BRANCH IF END OF FORMAT STRING
6972 f096 a6 80                        LDA  ,X+            ; GET A CHARACTER FROM FORMAT STRING
6973 f098 81 23                        CMPA #'#            ; IS IT NUMBER SIGN?
6974 f09a 27 f5                        BEQ  L8F4F          ; YES - KEEP CHECKING
6975                         * CHECK FOR EXPONENTIAL FORCE
6976 f09c 81 5e              L8F5A     CMPA #$5E           ; CHECK FOR UP ARROW
6977 f09e 26 16                        BNE  L8F74          ; NO UP ARROW
6978 f0a0 a1 84                        CMPA ,X             ; IS THE NEXT CHARACTER AN UP ARROW?
6979 f0a2 26 12                        BNE  L8F74          ; NO
6980 f0a4 a1 01                        CMPA $01,X          ; AND THE NEXT CHARACTER?
6981 f0a6 26 0e                        BNE  L8F74          ; NO
6982 f0a8 a1 02                        CMPA $02,X          ; HOW ABOUT THE 4TH CHARACTER?
6983 f0aa 26 0a                        BNE  L8F74          ; NO, ALSO
6984 f0ac c1 04                        CMPB #4             ; * CHECK TO SEE IF THE 4 UP ARROWS ARE IN THE
6985 f0ae 25 06                        BLO  L8F74          ; * FORMAT STRING AND BRANCH IF NOT
6986 f0b0 c0 04                        SUBB #4             ; * MOVE POINTER UP 4 AND SUBTRACT
6987 f0b2 30 04                        LEAX $04,X          ; * FOUR FROM LENGTH
6988 f0b4 0c 9a                        INC  VDA            ; INCREMENT STATUS BYTE - EXPONENTIAL FORM
6989                         
6990                         * CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMAT STRING
6991 f0b6 30 1f              L8F74     LEAX -1,X           ; MOVE POINTER BACK ONE
6992 f0b8 0c 99                        INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER FOR PRE-SIGN FORCE
6993 f0ba 96 9a                        LDA  VDA            ; * PRE-SIGN
6994 f0bc 85 08                        BITA #$08           ; * FORCE AND
6995 f0be 26 18                        BNE  L8F96          ; * BRANCH IF SET
6996 f0c0 0a 99                        DEC  VD9            ; DECREMENT LEFT DIGIT - NO PRE-SIGN FORCE
6997 f0c2 5d                           TSTB                ; * CHECK LENGTH COUNTER AND BRANCH
6998 f0c3 27 13                        BEQ  L8F96          ; * IF END OF FORMAT STRING
6999 f0c5 a6 84                        LDA  ,X             ; GET NEXT FORMAT STRING CHARACTER
7000 f0c7 80 2d                        SUBA #'-            ; CHECK FOR MINUS SIGN
7001 f0c9 27 06                        BEQ  L8F8F          ; BRANCH IF MINUS SIGN
7002 f0cb 81 fe                        CMPA #$FE           ; * WAS CMPA #('+')-('-')
7003 f0cd 26 09                        BNE  L8F96          ; BRANCH IF NO PLUS SIGN
7004 f0cf 86 08                        LDA  #$08           ; GET THE PRE-SIGN FORCE FLAG
7005 f0d1 8a 04              L8F8F     ORA  #$04           ; 'OR' IN POST-SIGN FORCE FLAG
7006 f0d3 9a 9a                        ORA  VDA            ; 'OR' IN THE STATUS BYTE
7007 f0d5 97 9a                        STA  VDA            ; SAVE THE STATUS BYTE
7008 f0d7 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH
7009                         
7010                         * EVALUATE NUMERIC ITEM-LIST
7011 f0d8 9d 82              L8F96     JSR  GETCCH         ; GET CURRENT CHARACTER
7012 f0da 10 27 ff 3c                  LBEQ L8ED8          ; BRANCH IF END OF LINE
7013 f0de d7 93                        STB  VD3            ; SAVE FORMAT STRING LENGTH WHEN FORMAT EVALUATION ENDED
7014 f0e0 bd d8 cd                     JSR  LB141          ; EVALUATE EXPRESSION
7015 f0e3 96 99                        LDA  VD9            ; GET THE LEFT DIGIT COUNTER
7016 f0e5 9b 98                        ADDA VD8            ; ADD IT TO THE RIGHT DIGIT COUNTER
7017 f0e7 81 11                        CMPA #17            ; *
7018 f0e9 10 22 ea e4                  LBHI LB44A          ; *'FC' ERROR IF MORE THAN 16 DIGITS AND DECIMAL POiNT
7019 f0ed bd f1 27                     JSR  L8FE5          ; CONVERT ITEM-LIST TO FORMATTED ASCII STRING
7020 f0f0 30 1f                        LEAX -1,X           ; MOVE BUFFER POINTER BACK ONE
7021 f0f2 bd e0 e8                     JSR  LB99C          ; DISPLAY THE FORMATTED STRING TO CONSOLE OUT
7022 f0f5 0f 97              L8FB3     CLR  VD7            ; RESET NEXT PRINT ITEM FLAG
7023 f0f7 9d 82                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
7024 f0f9 27 0d                        BEQ  L8FC6          ; BRANCH IF END OF LINE
7025 f0fb 97 97                        STA  VD7            ; SAVE CURRENT CHARACTER (<>0) IN NEXT PRINT ITEM FLAG
7026 f0fd 81 3b                        CMPA #';            ; * CHECK FOR ; - ITEM-LIST SEPARATOR AND
7027 f0ff 27 05                        BEQ  L8FC4          ; * BRANCH IF SEMICOLON
7028 f101 bd d9 f9                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
7029 f104 20 02                        BRA  L8FC6          ; PROCESS NEXT PRINT ITEM
7030 f106 9d 7c              L8FC4     JSR  GETNCH         ; GET NEXT INPUT CHARACTER
7031 f108 9e 95              L8FC6     LDX  VD5            ; GET FORMAT STRING DESCRIPTOR ADDRESS
7032 f10a e6 84                        LDB  ,X             ; GET LENGTH OF FORMAT STRING
7033 f10c d0 93                        SUBB VD3            ; SUBTRACT AMOUNT OF FORMAT STRING LEFT AFTER LAST PRINT ITEM
7034 f10e ae 02                        LDX  $02,X          ; *GET FORMAT STRING START ADDRESS AND ADVANCE
7035 f110 3a                           ABX                 ; *POINTER TO START OF UNUSED FORMAT STRING
7036 f111 d6 93                        LDB  VD3            ; * GET AMOUNT OF UNUSED FORMAT STRING
7037 f113 10 26 fe e4                  LBNE L8EB9          ; * REINTERPRET FORMAT STRING FROM THAT POINT
7038 f117 7e f0 14                     JMP  L8ED2          ; REINTERPRET FORMAT STRING FROM THE START IF ENTIRELY
7039                         *         USED ON LAST PRINT ITEM
7040                         
7041                         * PRINT A '+' TO CONSOLE OUT IF THE STATUS BYTE <> 0
7042 f11a 34 02              L8FD8     PSHS A              ; RESTORE ACCA AND RETURN
7043 f11c 86 2b                        LDA  #'+            ; GET ASCII PLUS SIGN
7044 f11e 0d 9a                        TST  VDA            ; * CHECK THE STATUS BYTE AND
7045 f120 27 03                        BEQ  L8FE3          ; * RETURN IF = 0
7046 f122 bd d0 17                     JSR  PUTCHR         ; SEND A CHARACTER TO CONSOLE OUT
7047 f125 35 82              L8FE3     PULS A,PC           ; RETURN ACCA AND RETURN
7048                         
7049                         * CONVERT ITEM-LIST TO DECIMAL ASCII STRING
7050 f127 ce 01 f2           L8FE5     LDU  #STRBUF+4      ; POINT U TO STRING BUFFER
7051 f12a c6 20                        LDB  #SPACE         ; BLANK
7052 f12c 96 9a                        LDA  VDA            ; * GET THE STATUS FLAG AND
7053 f12e 85 08                        BITA #$08           ; * CHECK FOR A PRE-SIGN FORCE
7054 f130 27 02                        BEQ  L8FF2          ; * BRANCH IF NO PRE-SIGN FORCE
7055 f132 c6 2b                        LDB  #'+            ; PLUS SIGN
7056 f134 0d 54              L8FF2     TST  FP0SGN         ; CHECK THE SIGN OF FPA0
7057 f136 2a 04                        BPL  L8FFA          ; BRANCH IF POSITIVE
7058 f138 0f 54                        CLR  FP0SGN         ; FORCE FPA0 SIGN TO BE POSITIVE
7059 f13a c6 2d                        LDB  #'-            ; MINUS SIGN
7060 f13c e7 c0              L8FFA     STB  ,U+            ; SAVE THE SIGN IN BUFFER
7061 f13e c6 30                        LDB  #'0            ; * PUT A ZERO INTO THE BUFFER
7062 f140 e7 c0                        STB  ,U+            ; *
7063 f142 84 01                        ANDA #$01           ; * CHECK THE EXPONENTIAL FORCE FLAG IN
7064 f144 10 26 01 07                  LBNE L910D          ; * THE STATUS BYTE - BRANCH IF ACTIVE
7065 f148 8e e5 0c                     LDX  #LBDC0         ; POINT X TO FLOATING POINT 1E + 09
7066 f14b bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO (X)
7067 f14e 2b 15                        BMI  L9023          ; BRANCH IF FPA0 < 1E+09
7068 f150 bd e5 25                     JSR  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
7069 f153 a6 80              L9011     LDA  ,X+            ; * ADVANCE POINTER TO END OF
7070 f155 26 fc                        BNE  L9011          ; * ASCII STRING (ZERO BYTE)
7071 f157 a6 82              L9015     LDA  ,-X            ; MOVE THE
7072 f159 a7 01                        STA  $01,X          ; ENTIRE STRING
7073 f15b 8c 01 f1                     CMPX #STRBUF+3      ; UP ONE
7074 f15e 26 f7                        BNE  L9015          ; BYTE
7075 f160 86 25                        LDA  #'%            ; * INSERT A % SIGN AT START OF
7076 f162 a7 84                        STA  ,X             ; * STRING - OVERFLOW ERROR
7077 f164 39                           RTS
7078                         
7079 f165 96 4f              L9023     LDA  FP0EXP         ; GET EXPONENT OF FPA0
7080 f167 97 47                        STA  V47            ; AND SAVE IT IN V74
7081 f169 27 03                        BEQ  L902C          ; BRANCH IF FPA0 = 0
7082 f16b bd f3 0f                     JSR  L91CD          ; CONVERT FPA0 TO NUMBER WITH 9 SIGNIFICANT
7083                         *              ; PLACES TO LEFT OF DECIMAL POINT
7084 f16e 96 47              L902C     LDA  V47            ; GET BASE 10 EXPONENT OFFSET
7085 f170 10 2b 00 81                  LBMI L90B3          ; BRANCH IF FPA0 < 100,000,000
7086 f174 40                           NEGA                ; * CALCULATE THE NUMBER OF LEADING ZEROES TO INSERT -
7087 f175 9b 99                        ADDA VD9            ; * SUBTRACT BASE 10 EXPONENT OFFSET AND 9 (FPA0 HAS
7088 f177 80 09                        SUBA #$09           ; * 9 PLACES TO LEFT OF EXPONENT) FROM LEFT DIGIT COUNTER
7089 f179 bd f2 2c                     JSR  L90EA          ; PUT ACCA ZEROES IN STRING BUFFER
7090 f17c bd f3 a5                     JSR  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
7091 f17f bd f3 44                     JSR  L9202          ; CONVERT FPA0 TO DECIMAL ASCII IN THE STRING BUFFER
7092 f182 96 47                        LDA  V47            ; * GET BASE 10 EXPONENT AND PUT THAT MANY
7093 f184 bd f3 c3                     JSR  L9281          ; * ZEROES IN STRING BUFFER - STOP AT DECIMAL POINT
7094 f187 96 47                        LDA  V47            ; WASTED INSTRUCTION - SERVES NO PURPOSE
7095 f189 bd f3 8b                     JSR  L9249          ; CHECK FOR DECIMAL POINT
7096 f18c 96 98                        LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
7097 f18e 26 02                        BNE  L9050          ; BRANCH IF RIGHT DIGlT COUNTER <> 0
7098 f190 33 5f                        LEAU -1,U           ; * MOVE BUFFER POINTER BACK ONE - DELETE
7099                         *                             ; * DECIMAL POINT IF NO RIGHT DIGITS SPECiFIED
7100 f192 4a                 L9050     DECA                ; SUBTRACT ONE (DECIMAL POINT)
7101 f193 bd f2 2c                     JSR  L90EA          ; PUT ACCA ZEROES INTO BUFFER (TRAILING ZEROES)
7102 f196 bd f2 c7           L9054     JSR  L9185          ; INSERT ASTERISK PADDING, FLOATING $, AND POST-SIGN
7103 f199 4d                           TSTA                ; WAS THERE A POST-SIGN?
7104 f19a 27 06                        BEQ  L9060          ; NO
7105 f19c c1 2a                        CMPB #'*            ; IS THE FIRST CHARACTER AN $?
7106 f19e 27 02                        BEQ  L9060          ; YES
7107 f1a0 e7 c0                        STB  ,U+            ; STORE THE POST-SIGN
7108 f1a2 6f c4              L9060     CLR  ,U             ; CLEAR THE LAST CHARACTER IN THE BUFFER
7109                         *
7110                         * REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE
7111                         * STRING BUFFER TO THE LEFT OF THE DECIMAL POINT
7112 f1a4 8e 01 f1                     LDX  #STRBUF+3      ; POINT X TO THE START OF THE BUFFER
7113 f1a7 30 01              L9065     LEAX $01,X          ; MOVE BUFFER POINTER UP ONE
7114 f1a9 9f 0f                        STX  TEMPTR         ; SAVE BUFFER POINTER IN TEMPTR
7115 f1ab 96 3a                        LDA  VARPTR+1       ; * GET ADDRESS OF DECIMAL POINT IN BUFFER, SUBTRACT
7116 f1ad 90 10                        SUBA TEMPTR+1       ; * CURRENT POSITION AND SUBTRACT LEFT DIGIT COUNTER -
7117 f1af 90 99                        SUBA VD9            ; * THE RESULT WILL BE ZERO WHEN TEMPTR+1 IS POINTING
7118                         *              ; * TO THE FIRST DIGIT OF THE FORMAT STRING
7119 f1b1 27 38                        BEQ  L90A9          ; RETURN IF NO DIGITS TO LEFT OF THE DECiMAL POINT
7120 f1b3 a6 84                        LDA  ,X             ; GET THE CURRENT BUFFER CHARACTER
7121 f1b5 81 20                        CMPA #SPACE         ; SPACE?
7122 f1b7 27 ee                        BEQ  L9065          ; YES - ADVANCE POINTER
7123 f1b9 81 2a                        CMPA #'*            ; ASTERISK?
7124 f1bb 27 ea                        BEQ  L9065          ; YES - ADVANCE POINTER
7125 f1bd 4f                           CLRA                ; A ZERO ON THE STACK IS END OF DATA POINTER
7126 f1be 34 02              L907C     PSHS A              ; PUSH A CHARACTER ONTO THE STACK
7127 f1c0 a6 80                        LDA  ,X+            ; GET NEXT CHARACTER FROM BUFFER
7128 f1c2 81 2d                        CMPA #'-            ; MINUS SIGN?
7129 f1c4 27 f8                        BEQ  L907C          ; YES
7130 f1c6 81 2b                        CMPA #'+            ; PLUS SIGN?
7131 f1c8 27 f4                        BEQ  L907C          ; YES
7132 f1ca 81 24                        CMPA #'$            ; DOLLAR SIGN?
7133 f1cc 27 f0                        BEQ  L907C          ; YES
7134 f1ce 81 30                        CMPA #'0            ; ZERO?
7135 f1d0 26 0e                        BNE  L909E          ; NO - ERROR
7136 f1d2 a6 01                        LDA  $01,X          ; GET CHARACTER FOLLOWING ZERO
7137 f1d4 8d 16                        BSR  L90AA          ; CLEAR CARRY IF NUMERIC
7138 f1d6 25 08                        BLO  L909E          ; BRANCH IF NOT A NUMERIC CHARACTER - ERROR
7139 f1d8 35 02              L9096     PULS A              ; * PULL A CHARACTER OFF OF THE STACK
7140 f1da a7 82                        STA  ,-X            ; * AND PUT IT BACK IN THE STRING BUFFER
7141 f1dc 26 fa                        BNE  L9096          ; * KEEP GOING UNTIL ZERO FLAG
7142 f1de 20 c7                        BRA  L9065          ; KEEP CLEANING UP THE INPUT BUFFER
7143 f1e0 35 02              L909E     PULS A              ;
7144 f1e2 4d                           TSTA                ; * THE STACK AND EXIT WHEN
7145 f1e3 26 fb                        BNE  L909E          ; * ZERO FLAG FOUND
7146 f1e5 9e 0f                        LDX  TEMPTR         ; GET THE STRING BUFFER START POINTER
7147 f1e7 86 25                        LDA  #'%            ; * PUT A % SIGN BEFORE THE ERROR POSITION TO
7148 f1e9 a7 82                        STA  ,-X            ; * INDICATE AN ERROR
7149 f1eb 39                 L90A9     RTS
7150                         *
7151                         * CLEAR CARRY IF NUMERIC
7152 f1ec 81 30              L90AA     CMPA #'0            ; ASCII ZERO
7153 f1ee 25 04                        BLO  L90B2          ; RETURN IF ACCA < ASCII 0
7154 f1f0 80 3a                        SUBA #$3A           ; *  #'9'+1
7155 f1f2 80 c6                        SUBA #$C6           ; * #-('9'+1)  CARRY CLEAR IF NUMERIC
7156 f1f4 39                 L90B2     RTS
7157                         *
7158                         * PROCESS AN ITEM-LIST WHICH IS < 100,000,000
7159 f1f5 96 98              L90B3     LDA  VD8            ; GET RIGHT DIGIT COUNTER
7160 f1f7 27 01                        BEQ  L90B8          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT OF DECIMAL PT
7161 f1f9 4a                           DECA                ; SUBTRACT ONE FOR DECIMAL POINT
7162 f1fa 9b 47              L90B8     ADDA V47            ; *ADD THE BASE 10 EXPONENT OFFSET - ACCA CONTAINS THE
7163                         *         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO THE SPECIFIED
7164                         *         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMAL POINT
7165 f1fc 2b 01                        BMI  L90BD          ; IF ACCA >= 0 THEN NO SHIFTS ARE REQUIRED
7166 f1fe 4f                           CLRA                ; FORCE SHIFT COUNTER = 0
7167 f1ff 34 02              L90BD     PSHS A              ; SAVE INITIAL SHIFT COUNTER ON THE STACK
7168 f201 2a 0a              L90BF     BPL  L90CB          ; EXIT ROUTINE IF POSITIVE
7169 f203 34 02                        PSHS A              ; SAVE SHIFT COUNTER ON STACK
7170 f205 bd e2 ce                     JSR  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT ONE DIGIT TO RIGHT
7171 f208 35 02                        PULS A              ; GET SHIFT COUNTER FROM THE STACK
7172 f20a 4c                           INCA                ; BUMP SHIFT COUNTER UP BY ONE
7173 f20b 20 f4                        BRA  L90BF          ; CHECK FOR FURTHER DIVISION
7174 f20d 96 47              L90CB     LDA  V47            ; * GET BASE 10 EXPONENT OFFSET, ADD INITIAL SHIFT COUNTER
7175 f20f a0 e0                        SUBA ,S+            ; * AND SAVE NEW BASE 10 EXPONENT OFFSET - BECAUSE
7176 f211 97 47                        STA  V47            ; * FPA0 WAS SHIFTED ABOVE
7177 f213 8b 09                        ADDA #$09           ; * ADD NINE (SIGNIFICANT PLACES) AND BRANCH IF THERE ARE NO
7178 f215 2b 19                        BMI  L90EE          ; * ZEROES TO THE LEFT OF THE DECIMAL POINT IN THIS PRINT ITEM
7179 f217 96 99                        LDA  VD9            ; *DETERMINE HOW MANY FILLER ZEROES TO THE LEFT OF THE DECIMAL
7180 f219 80 09                        SUBA #$09           ; *POINT. GET THE NUMBER OF FORMAT PLACES TO LEFT OF DECIMAL
7181 f21b 90 47                        SUBA V47            ; *POINT, SUBTRACT THE BASE 10 EXPONENT OFFSET AND THE CONSTANT 9
7182 f21d 8d 0d                        BSR  L90EA          ; *(UNNORMALIZATION)-THEN OUTPUT THAT MANY ZEROES TO THE BUFFER
7183 f21f bd f3 a5                     JSR  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
7184 f222 20 1d                        BRA  L90FF          ; PROCESS THE REMAINDER OF THE PRINT ITEM
7185                         *
7186                         * PUT (ACCA+1) ASCII ZEROES IN BUFFER
7187 f224 34 02              L90E2     PSHS A              ; SAVE ZERO COUNTER
7188 f226 86 30                        LDA  #'0            ; * INSERT A ZERO INTO
7189 f228 a7 c0                        STA  ,U+            ; * THE BUFFER
7190 f22a 35 02                        PULS A              ; RESTORE ZERO COUNTER
7191                         
7192                         * PUT ACCA ASCII ZEROES INTO THE BUFFER
7193 f22c 4a                 L90EA     DECA                ; DECREMENT ZERO COUNTER
7194 f22d 2a f5                        BPL  L90E2          ; BRANCH IF NOT DONE
7195 f22f 39                           RTS
7196                         
7197 f230 96 99              L90EE     LDA  VD9            ; * GET THE LEFT DIGIT COUNTER AND PUT
7198 f232 8d f8                        BSR  L90EA          ; * THAT MANY ZEROES IN THE STRiNG BUFFER
7199 f234 bd f3 8f                     JSR  L924D          ; PUT THE DECIMAL POINT IN THE STRING BUFFER
7200 f237 86 f7                        LDA  #-9            ; *DETERMINE HOW MANY FILLER ZEROES BETWEEN THE DECIMAL POINT
7201 f239 90 47                        SUBA V47            ; *AND SIGNIFICANT DATA. SUBTRACT BASE 10 EXPONENT FROM -9
7202 f23b 8d ef                        BSR  L90EA          ; *(UNNORMALIZATION) AND OUTPUT THAT MANY ZEROES TO BUFFER
7203 f23d 0f 45                        CLR  V45            ; CLEAR THE DECIMAL POINT COUNTER - SUPPRESS THE DECIMAL POINT
7204 f23f 0f 97                        CLR  VD7            ; CLEAR THE COMMA COUNTER - SUPPRESS COMMAS
7205 f241 bd f3 44           L90FF     JSR  L9202          ; DECODE FPA0 INTO A DECIMAL ASCII STRING
7206 f244 96 98                        LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
7207 f246 26 02                        BNE  L9108          ; BRANCH IF RIGHT DIGIT COUNTER <> 0
7208 f248 de 39                        LDU  VARPTR         ; RESET BUFFER PTR TO THE DECIMAL POINT IF NO DIGITS TO RIGHT
7209 f24a 9b 47              L9108     ADDA V47            ; *ADD BASE 10 EXPONENT - A POSITIVE ACCA WILL CAUSE THAT MANY
7210                         * *FILLER ZEROES TO BE OUTPUT ; TO THE RIGHT OF LAST SIGNIFICANT DATA
7211                         *         *SIGNIFICANT DATA
7212 f24c 16 ff 43                     LBRA L9050          ; INSERT LEADING ASTERISKS, FLOATING DOLLAR SIGN, ETC
7213                         *
7214                         * FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FORMAT
7215 f24f 96 4f              L910D     LDA  FP0EXP         ; * GET EXPONENT OF FPA0 AND
7216 f251 34 02                        PSHS A              ; * SAVE IT ON THE STACK
7217 f253 27 03                        BEQ  L9116          ; BRANCH IF FPA0 = 0
7218 f255 bd f3 0f                     JSR  L91CD          ; *CONVERT FPA0 INTO A NUMBER WITH 9 SIGNIFICANT
7219                         *         *DIGITS TO THE LEFT OF THE DECIMAL POINT
7220 f258 96 98              L9116     LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
7221 f25a 27 01                        BEQ  L911B          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT
7222 f25c 4a                           DECA                ; SUBTRACT ONE FOR THE DECIMAL POINT
7223 f25d 9b 99              L911B     ADDA VD9            ; ADD TO THE LEFT DIGIT COUNTER
7224 f25f 7f 01 f1                     CLR  STRBUF+3       ; CLEAR BUFFER BYTE AS TEMPORARY STORAGE LOCATION
7225 f262 d6 9a                        LDB  VDA            ; * GET THE STATUS BYTE FOR A
7226 f264 c4 04                        ANDB #$04           ; * POST-BYTE FORCE; BRANCH IF
7227 f266 26 03                        BNE  L9129          ; * A POST-BYTE FORCE
7228 f268 73 01 f1                     COM  STRBUF+3       ; TOGGLE BUFFER BYTE TO -1 IF NO POST-BYTE FORCE
7229 f26b bb 01 f1           L9129     ADDA STRBUF+3       ; SUBTRACT 1 IF NO POST BYTE FORCE
7230 f26e 80 09                        SUBA #$09           ; *SUBTRACT 9 (DUE TO THE CONVERSION TO 9
7231                         *         *SIGNIFICANT DIGITS TO LEFT OF DECIMAL POINT)
7232 f270 34 02                        PSHS A              ; * SAVE SHIFT COUNTER ON THE STACK - ACCA CONTAINS THE NUMBER
7233                         *         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE NUMBER OF
7234                         *         FORMATTED PLACES TO THE RIGHT OF THE DECIMAL POINT.
7235 f272 2a 0a              L9130     BPL  L913C          ; NO MORE SHIFTS WHEN ACCA >= 0
7236 f274 34 02                        PSHS A              ; SAVE SHIFT COUNTER
7237 f276 bd e2 ce                     JSR  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT TO RIGHT ONE
7238 f279 35 02                        PULS A              ; RESTORE THE SHIFT COUNTER
7239 f27b 4c                           INCA                ; ADD 1 TO SHIFT COUNTER
7240 f27c 20 f4                        BRA  L9130          ; CHECK FOR FURTHER SHIFTING (DIVISION)
7241 f27e a6 e4              L913C     LDA  ,S             ; *GET THE INITIAL VALUE OF THE SHIFT COUNTER
7242 f280 2b 01                        BMI  L9141          ; *AND BRANCH IF SHIFTING HAS TAKEN PLACE
7243 f282 4f                           CLRA                ; RESET ACCA IF NO SHIFTING HAS TAKEN PLACE
7244 f283 40                 L9141     NEGA                ; *CALCULATE THE POSITION OF THE DECIMAL POINT BY
7245 f284 9b 99                        ADDA VD9            ; *NEGATING SHIFT COUNTER, ADDING THE LEFT DIGIT COUNTER
7246 f286 4c                           INCA                ; *PLUS ONE AND THE POST-BYTE POSlTION, IF USED
7247 f287 bb 01 f1                     ADDA STRBUF+3       ; *
7248 f28a 97 45                        STA  V45            ; SAVE DECIMAL POINT COUNTER
7249 f28c 0f 97                        CLR  VD7            ; CLEAR COMMA COUNTER - NO COMMAS INSERTED
7250 f28e bd f3 44                     JSR  L9202          ; CONVERT FPA0 INTO ASCII DECIMAL STRING
7251 f291 35 02                        PULS A              ; * GET THE INITIAL VALUE OF SHIFT COUNTER AND
7252 f293 bd f3 c3                     JSR  L9281          ; * INSERT THAT MANY ZEROES INTO THE BUFFER
7253 f296 96 98                        LDA  VD8            ; *GET THE RIGHT DIGIT COUNTER AND BRANCH
7254 f298 26 02                        BNE  L915A          ; *IF NOT ZERO
7255 f29a 33 5f                        LEAU -1,U           ; MOVE BUFFER POINTER BACK ONE
7256                         
7257                         * CALCULATE VALUE OF EXPONENT AND PUT IN STRING BUFFER
7258 f29c e6 e0              L915A     LDB  ,S+            ; GET ORIGINAL EXPONENT OF FPA0
7259 f29e 27 09                        BEQ  L9167          ; BRANCH IF EXPONENT = 0
7260 f2a0 d6 47                        LDB  V47            ; GET BASE 10 EXPONENT
7261 f2a2 cb 09                        ADDB #$09           ; ADD 9 FOR 9 SIGNIFICANT DIGIT CONVERSION
7262 f2a4 d0 99                        SUBB VD9            ; SUBTRACT LEFT DIGIT COUNTER
7263 f2a6 f0 01 f1                     SUBB STRBUF+3       ; ADD ONE TO EXPONENT IF POST-SIGN FORCE
7264 f2a9 86 2b              L9167     LDA  #'+            ; PLUS SIGN
7265 f2ab 5d                           TSTB                ; TEST EXPONENT
7266 f2ac 2a 03                        BPL  L916F          ; BRANCH IF POSITIVE EXPONENT
7267 f2ae 86 2d                        LDA  #'-            ; MINUS SIGN
7268 f2b0 50                           NEGB                ; CONVERT EXPONENT TO POSITIVE NUMBER
7269 f2b1 a7 41              L916F     STA  $01,U          ; PUT SIGN OF EXPONENT IN STRING BUFFER
7270 f2b3 86 45                        LDA  #'E            ; * PUT AN 'E' (EXPONENTIATION FLAG) IN
7271 f2b5 a7 c1                        STA  ,U++           ; * BUFFER AND SKIP OVER THE SIGN
7272 f2b7 86 2f                        LDA  #$2F           ; * WAS LDA #'0'-1
7273                         *CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACCA
7274 f2b9 4c                 L9177     INCA                ; ADD ONE TO TENS DIGIT COUNTER
7275 f2ba c0 0a                        SUBB #10            ; *SUBTRACT 10 FROM EXPONENT AND ADD ONE TO TENS
7276 f2bc 24 fb                        BCC  L9177          ; * DIGIT IF NO CARRY. TENS DIGIT DONE IF THERE IS A CARRY
7277 f2be cb 3a                        ADDB #$3A           ; WAS ADDB #'9'+1
7278 f2c0 ed c1                        STD  ,U++           ; SAVE EXPONENT IN BUFFER
7279 f2c2 6f c4                        CLR  ,U             ; CLEAR FINAL BYTE IN BUFFER - PRINT TERMINATOR
7280 f2c4 7e f1 96                     JMP  L9054          ; INSERT ASTERISK PADDING, FLOATING DOLLAR SIGN, ETC.
7281                         
7282                         * INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN
7283 f2c7 8e 01 f2           L9185     LDX  #STRBUF+4      ; POINT X TO START OF PRINT ITEM BUFFER
7284 f2ca e6 84                        LDB  ,X             ; * GET SIGN BYTE OF ITEM-LIST BUFFER
7285 f2cc 34 04                        PSHS B              ; * AND SAVE IT ON THE STACK
7286 f2ce 86 20                        LDA  #SPACE         ; DEFAULT PAD WITH BLANKS
7287 f2d0 d6 9a                        LDB  VDA            ; * GET STATUS BYTE AND CHECK FOR
7288 f2d2 c5 20                        BITB #$20           ; * ASTERISK LEFT PADDING
7289 f2d4 35 04                        PULS B              ; GET SIGN BYTE AGAIN
7290 f2d6 27 08                        BEQ  L919E          ; BRANCH IF NO PADDING
7291 f2d8 86 2a                        LDA  #'*            ; PAD WITH ASTERISK
7292 f2da c1 20                        CMPB #SPACE         ; WAS THE FIRST BYTE A BLANK (POSITIVE)?
7293 f2dc 26 02                        BNE  L919E          ; NO
7294 f2de 1f 89                        TFR  A,B            ; TRANSFER PAD CHARACTER TO ACCB
7295 f2e0 34 04              L919E     PSHS B              ; SAVE FIRST CHARACTER ON STACK
7296 f2e2 a7 80              L91A0     STA  ,X+            ; STORE PAD CHARACTER IN BUFFER
7297 f2e4 e6 84                        LDB  ,X             ; GET NEXT CHARACTER IN BUFFER
7298 f2e6 27 10                        BEQ  L91B6          ; INSERT A ZERO IF END OF BUFFER
7299 f2e8 c1 45                        CMPB #'E            ; * CHECK FOR AN 'E' AND
7300 f2ea 27 0c                        BEQ  L91B6          ; * PUT A ZERO BEFORE IT
7301 f2ec c1 30                        CMPB #'0            ; * REPLACE LEADING ZEROES WITH
7302 f2ee 27 f2                        BEQ  L91A0          ; * PAD CHARACTERS
7303 f2f0 c1 2c                        CMPB #',            ; * REPLACE LEADING COMMAS
7304 f2f2 27 ee                        BEQ  L91A0          ; * WITH PAD CHARACTERS
7305 f2f4 c1 2e                        CMPB #'.            ; * CHECK FOR DECIMAL POINT
7306 f2f6 26 04                        BNE  L91BA          ; * AND DON'T PUT A ZERO BEFORE IT
7307 f2f8 86 30              L91B6     LDA  #'0            ; * REPLACE PREVIOUS CHARACTER
7308 f2fa a7 82                        STA  ,-X            ; * WITH A ZERO
7309 f2fc 96 9a              L91BA     LDA  VDA            ; * GET STATUS BYTE, CHECK
7310 f2fe 85 10                        BITA #$10           ; * FOR FLOATING $
7311 f300 27 04                        BEQ  L91C4          ; * BRANCH IF NO FLOATING $
7312 f302 c6 24                        LDB  #'$            ; * STORE A $ IN
7313 f304 e7 82                        STB  ,-X            ; * BUFFER
7314 f306 84 04              L91C4     ANDA #$04           ; CHECK PRE-SIGN FLAG
7315 f308 35 04                        PULS B              ; GET SIGN CHARACTER
7316 f30a 26 02                        BNE  L91CC          ; RETURN IF POST-SIGN REQUIRED
7317 f30c e7 82                        STB  ,-X            ; STORE FIRST CHARACTER
7318 f30e 39                 L91CC     RTS
7319                         *
7320                         * CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN X 10**M.
7321                         * THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPONENT).
7322 f30f 34 40              L91CD     PSHS U              ; SAVE BUFFER POINTER
7323 f311 4f                           CLRA                ; INITIAL EXPONENT OFFSET = 0
7324 f312 97 47              L91D0     STA  V47            ; SAVE EXPONENT OFFSET
7325 f314 d6 4f                        LDB  FP0EXP         ; GET EXPONENT OF FPA0
7326 f316 c1 80                        CMPB #$80           ; * COMPARE TO EXPONENT OF .5
7327 f318 22 11                        BHI  L91E9          ; * AND BRANCH IF FPA0 > = 1.0
7328                         
7329                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1
7330 f31a 8e e5 0c                     LDX  #LBDC0         ; POINT X TO FP NUMBER (1E+09)
7331 f31d bd e2 16                     JSR  LBACA          ; MULTIPLY FPA0 BY 1E+09
7332 f320 96 47                        LDA  V47            ; GET EXPONENT OFFSET
7333 f322 80 09                        SUBA #$09           ; SUBTRACT 9 (BECAUSE WE MULTIPLIED BY 1E+09 ABOVE)
7334 f324 20 ec                        BRA  L91D0          ; CHECK TO SEE IF > 1.0
7335 f326 bd e2 ce           L91E4     JSR  LBB82          ; DIVIDE FPA0 BY 10
7336 f329 0c 47                        INC  V47            ; INCREMENT EXPONENT OFFSET
7337 f32b 8e e5 07           L91E9     LDX  #LBDBB         ; POINT X TO FP NUMBER (999,999,999)
7338 f32e bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO X
7339 f331 2e f3                        BGT  L91E4          ; BRANCH IF FPA0 > 999,999,999
7340 f333 8e e5 02           L91F1     LDX  #LBDB6         ; POINT X TO FP NUMBER (99,999,999.9)
7341 f336 bd e3 ec                     JSR  LBCA0          ; COMPARE FPA0 TO X
7342 f339 2e 07                        BGT  L9200          ; RETURN IF 999,999,999 > FPA0 > 99,999,999.9
7343 f33b bd e2 b6                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
7344 f33e 0a 47                        DEC  V47            ; DECREMENT EXPONENT OFFSET
7345 f340 20 f1                        BRA  L91F1          ; KEEP UNNORMALIZING
7346 f342 35 c0              L9200     PULS U,PC           ; RESTORE BUFFER POINTER AND RETURN
7347                         *
7348                         * CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT
7349                         * INTO A DECIMAL ASCII STRING IN THE BUFFER
7350 f344 34 40              L9202     PSHS U              ; SAVE BUFFER POINTER
7351 f346 bd e1 00                     JSR  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
7352 f349 bd e4 14                     JSR  LBCC8          ; CONVERT FPA0 TO INTEGER FORMAT
7353 f34c 35 40                        PULS U              ; RESTORE BUFFER POINTER
7354                         *
7355                         * CONVERT FPA0 INTO A DECIMAL ASCII STRING
7356 f34e 8e e6 11                     LDX  #LBEC5         ; POINT X TO UNNORMALIZED POWERS OF 10
7357 f351 c6 80                        LDB  #$80           ; INITIALIZE DIGIT COUNTER TO 0 + $80.
7358                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
7359                         * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
7360                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB
7361                         * IS HOW THIS ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURRING.
7362 f353 8d 36              L9211     BSR  L9249          ; CHECK FOR COMMA INSERTION
7363 f355 96 53              L9213     LDA  FPA0+3         ; * 'ADD' A POWER OF 10 MANTISSA TO FPA0.
7364 f357 ab 03                        ADDA $03,X          ; * IF THE MANTISSA IS NEGATIVE, A SUBTRACTION
7365 f359 97 53                        STA  FPA0+3         ; * WILL BE WHAT REALLY TAKES PLACE.
7366 f35b 96 52                        LDA  FPA0+2         ; *
7367 f35d a9 02                        ADCA $02,X          ; *
7368 f35f 97 52                        STA  FPA0+2         ; *
7369 f361 96 51                        LDA  FPA0+1         ; *
7370 f363 a9 01                        ADCA $01,X          ; *
7371 f365 97 51                        STA  FPA0+1         ; *
7372 f367 96 50                        LDA  FPA0           ; *
7373 f369 a9 84                        ADCA ,X             ; *
7374 f36b 97 50                        STA  FPA0           ; *
7375 f36d 5c                           INCB                ; ADD ONE TO DIGIT COUNTER
7376 f36e 56                           RORB                ; ROTATE CARRY INTO BIT 7
7377 f36f 59                           ROLB                ; * SET OVERFLOW FLAG - BRANCH IF CARRY SET AND
7378 f370 28 e3                        BVC  L9213          ; * ADDING MANTISSA OR CARRY CLEAR AND SUBTRACTING MANTISSA
7379 f372 24 03                        BCC  L9235          ; BRANCH IF SUBTRACTING MANTISSA
7380 f374 c0 0b                        SUBB #10+1          ; WAS SUBB #10+1
7381 f376 50                           NEGB                ; * IF ADDING MANTISSA
7382 f377 cb 2f              L9235     ADDB #$2F           ; WAS ADDB #'0'-1
7383 f379 30 04                        LEAX $04,X          ; MOVE TO NEXT POWER OF 10 MANTISSA
7384 f37b 1f 98                        TFR  B,A            ; SAVE DIGIT IN ACCA
7385 f37d 84 7f                        ANDA #$7F           ; MASK OFF ADD/SUBTRACT FLAG (BIT 7)
7386 f37f a7 c0                        STA  ,U+            ; STORE DIGIT IN BUFFER
7387 f381 53                           COMB                ; TOGGLE ADD/SUBTRACT FLAG
7388 f382 c4 80                        ANDB #$80           ; MASK OFF EVERYTHING BUT ADD/SUB FLAG
7389 f384 8c e6 35                     CMPX #LBEE9         ; COMPARE TO END OF UNNORMALIZED POWERS OF 10
7390 f387 26 ca                        BNE  L9211          ; BRANCH IF NOT DONE
7391 f389 6f c4                        CLR  ,U             ; PUT A ZERO AT END OF INTEGER
7392                         
7393                         * DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA INSERTION
7394 f38b 0a 45              L9249     DEC  V45            ; DECREMENT DECIMAL POINT COUNTER
7395 f38d 26 09                        BNE  L9256          ; NOT TIME FOR DECIMAL POINT
7396 f38f df 39              L924D     STU  VARPTR         ; SAVE BUFFER POINTER-POSITION OF THE DECIMAL POINT
7397 f391 86 2e                        LDA  #'.            ; * STORE A DECIMAL
7398 f393 a7 c0                        STA  ,U+            ; * POINT IN THE OUTPUT BUFFER
7399 f395 0f 97                        CLR  VD7            ; * CLEAR COMMA COUNTER - NOW IT WILL TAKE 255
7400                         *                             ; * DECREMENTS BEFORE ANOTHER COMMA WILL BE INSERTED
7401 f397 39                           RTS
7402 f398 0a 97              L9256     DEC  VD7            ; DECREMENT COMMA COUNTER
7403 f39a 26 08                        BNE  L9262          ; RETURN IF NOT TIME FOR COMMA
7404 f39c 86 03                        LDA  #$03           ; * RESET COMMA COUNTER TO 3; THREE
7405 f39e 97 97                        STA  VD7            ; * DIGITS BETWEEN COMMAS
7406 f3a0 86 2c                        LDA  #',            ; * PUT A COMMA INTO
7407 f3a2 a7 c0                        STA  ,U+            ; * THE BUFFER
7408 f3a4 39                 L9262     RTS
7409                         
7410                         * INITIALIZE DECIMAL POINT AND COMMA COUNTERS
7411 f3a5 96 47              L9263     LDA  V47            ; GET THE BASE 10 EXPONENT OFFSET
7412 f3a7 8b 0a                        ADDA #10            ; * ADD 10 (FPA0 WAS 'NORMALIZED' TO 9 PLACES LEFT
7413 f3a9 97 45                        STA  V45            ; * OF DECIMAL POINT) - SAVE IN DECIMAL POINT COUNTER
7414 f3ab 4c                           INCA                ; ADD ONE FOR THE DECIMAL POINT
7415 f3ac 80 03              L926A     SUBA #$03           ; * DIVIDE DECIMAL POINT COUNTER BY 3; LEAVE
7416 f3ae 24 fc                        BCC  L926A          ; * THE REMAINDER IN ACCA
7417 f3b0 8b 05                        ADDA #$05           ; CONVERT REMAINDER INTO A NUMBER FROM 1-3
7418 f3b2 97 97                        STA  VD7            ; SAVE COMMA COUNTER
7419 f3b4 96 9a                        LDA  VDA            ; GET STATUS BYTE
7420 f3b6 84 40                        ANDA #$40           ; CHECK FOR COMMA FLAG
7421 f3b8 26 02                        BNE  L927A          ; BRANCH IF COMMA FLAG ACTIVE
7422 f3ba 97 97                        STA  VD7            ; CLEAR COMMA COUNTER - 255 DIGITS OUTPUT BEFORE A COMMA
7423 f3bc 39                 L927A     RTS
7424                         *
7425                         * INSERT ACCA ZEROES INTO THE BUFFER
7426 f3bd 34 02              L927B     PSHS A              ; SAVE ZEROES COUNTER
7427 f3bf 8d ca                        BSR  L9249          ; CHECK FOR DECIMAL POINT
7428 f3c1 35 02                        PULS A              ; RESTORE ZEROES COUNTER
7429 f3c3 4a                 L9281     DECA                ; * DECREMENT ZEROES COUNTER AND
7430 f3c4 2b 0a                        BMI  L928E          ; * RETURN IF < 0
7431 f3c6 34 02                        PSHS A              ; SAVE ZEROES COUNTER
7432 f3c8 86 30                        LDA  #'0            ; * PUT A ZERO INTO
7433 f3ca a7 c0                        STA  ,U+            ; * THE BUFFER
7434 f3cc a6 e0                        LDA  ,S+            ; RESTORE THE ZEROES COUNTER
7435 f3ce 26 ed                        BNE  L927B          ; BRANCH IF NOT DONE
7436 f3d0 39                 L928E     RTS
7437                         
7438                         
7439                         * LINE
7440 f3d1 81 89              LINE      CMPA #TOK_INPUT     ; 'INPUT' TOKEN
7441 f3d3 10 27 f9 5c                  LBEQ L89C0          ; GO DO 'LINE INPUT' COMMAND
7442 f3d7 7e da 03                     JMP  LB277          ; 'SYNTAX ERROR' IF NOT "LINE INPUT"
7443                         
7444                         * END OF EXTENDED BASIC
7445                         
7446 f3da ff ff ff ff ff ff          FILL    $FF, $F800-*   ; Fill ROM with FFs until start of ASSIST09
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff ff ff
     ff ff ff ff
7447                         
7448                         *************************************
7449                         * COPYRIGHT (C) MOTOROLA, INC. 1979 *
7450                         *************************************
7451                         
7452                         *************************************
7453                         * THIS IS THE BASE ASSIST09 ROM.
7454                         * IT MAY RUN WITH OR WITHOUT THE
7455                         * EXTENSION ROM WHICH
7456                         * WHEN PRESENT WILL BE AUTOMATICALLY
7457                         * INCORPORATED BY THE BLDVTR
7458                         * SUBROUTINE.
7459                         *************************************
7460                         
7461                         *********************************************
7462                         * GLOBAL MODULE EQUATES
7463                         ********************************************
7464 f800                    ROMBEG  EQU     $F800           ; ROM START ASSEMBLY ADDRESS
7465 ffff7800                    RAMOFS  EQU     -$8800          ; ROM OFFSET TO RAM WORK PAGE
7466 0800                    ROMSIZ  EQU     2048            ; ROM SIZE
7467 f000                    ROM2OF  EQU     ROMBEG-ROMSIZ   ; START OF EXTENSION ROM
7468 a000                    ACIA    EQU     $A000           ; DEFAULT ACIA ADDRESS
7469 0000                    PTM     EQU     $0000           ; DEFAULT PTM ADDRESS
7470 0000                    DFTCHP  EQU     0               ; DEFAULT CHARACTER PAD COUNT
7471 0005                    DFTNLP  EQU     5               ; DEFAULT NEW LINE PAD COUNT
7472 003e                    PROMPT  EQU     '>              ; PROMPT CHARACTER
7473 0008                    NUMBKP  EQU     8               ; NUMBER OF BREAKPOINTS
7474                         *********************************************
7475                         
7476                         *********************************************
7477                         * MISCELANEOUS EQUATES
7478                         *********************************************
7479 0004                    EOT     EQU     $04             ; END OF TRANSMISSION
7480 0007                    BELL    EQU     $07             ; BELL CHARACTER
7481 000a                    LF      EQU     $0A             ; LINE FEED
7482                         *CR     EQU     $0D             ; CARRIAGE RETURN
7483 0010                    DLE     EQU     $10             ; DATA LINK ESCAPE
7484 0018                    CAN     EQU     $18             ; CANCEL (CTL-X)
7485                         
7486                         * PTM ACCESS DEFINITIONS
7487 0001                    PTMSTA  EQU     PTM+1           ; READ STATUS REGISTER
7488 0000                    PTMC13  EQU     PTM             ; CONTROL REGISTERS 1 AND 3
7489 0001                    PTMC2   EQU     PTM+1           ; CONTROL REGISTER 2
7490 0002                    PTMTM1  EQU     PTM+2           ; LATCH 1
7491 0004                    PTMTM2  EQU     PTM+4           ; LATCH 2
7492 0006                    PTMTM3  EQU     PTM+6           ; LATCH 3
7493 008c                    SKIP2   EQU     $8C             ; "CMPX #" OPCODE - SKIPS TWO BYTES
7494                         
7495                         *******************************************
7496                         * ASSIST09 MONITOR SWI FUNCTIONS
7497                         * THE FOLLOWING EQUATES DEFINE FUNCTIONS PROVIDED
7498                         * BY THE ASSIST09 MONITOR VIA THE SWI INSTRUCTION.
7499                         ******************************************
7500 0000                    INCHNP  EQU     0               ; INPUT CHAR IN A REG - NO PARITY
7501 0001                    OUTCH   EQU     1               ; OUTPUT CHAR FROM A REG
7502 0002                    PDATA1  EQU     2               ; OUTPUT STRING
7503 0003                    PDATA   EQU     3               ; OUTPUT CR/LF THEN STRING
7504 0004                    OUT2HS  EQU     4               ; OUTPUT TWO HEX AND SPACE
7505 0005                    OUT4HS  EQU     5               ; OUTPUT FOUR HEX AND SPACE
7506 0006                    PCRLF   EQU     6               ; OUTPUT CR/LF
7507 0007                    SPACEF  EQU     7               ; OUTPUT A SPACE
7508 0008                    MONITR  EQU     8               ; ENTER ASSIST09 MONITOR
7509 0009                    VCTRSW  EQU     9               ; VECTOR EXAMINE/SWITCH
7510 000a                    BRKPT   EQU     10              ; USER PROGRAM BREAKPOINT
7511 000b                    PAUSE   EQU     11              ; TASK PAUSE FUNCTION
7512 000b                    NUMFUN  EQU     11              ; NUMBER OF AVAILABLE FUNCTIONS
7513                         
7514                         * NEXT SUB-CODES FOR ACCESSING THE VECTOR TABLE.
7515                         * THEY ARE EQUIVALENT TO OFFSETS IN THE TABLE.
7516                         * RELATIVE POSITIONING MUST BE MAINTAINED
7517                         
7518 0000                    .AVTBL  EQU     0               ; ADDRESS OF VECTOR TABLE
7519 0002                    .CMDL1  EQU     2               ; FIRST COMMAND LIST
7520 0004                    .RSVD   EQU     4               ; RESERVED HARDWARE VECTOR
7521 0006                    .SWI3   EQU     6               ; SWI3 ROUTINE
7522 0008                    .SWI2   EQU     8               ; SWI2 ROUTINE
7523 000a                    .FIRQ   EQU     10              ; FIRQ ROUTINE
7524 000c                    .IRQ    EQU     12              ; IRQ ROUTINE
7525 000e                    .SWI    EQU     14              ; SWI ROUTINE
7526 0010                    .NMI    EQU     16              ; NMI ROUTINE
7527 0012                    .RESET  EQU     18              ; RESET ROUTINE
7528 0014                    .CION   EQU     20              ; CONSOLE ON
7529 0016                    .CIDTA  EQU     22              ; CONSOLE INPUT DATA
7530 0018                    .CIOFF  EQU     24              ; CONSOLE INPUT OFF
7531 001a                    .COON   EQU     26              ; CONSOLE OUTPUT ON
7532 001c                    .CODTA  EQU     28              ; CONSOLE OUTPUT DATA
7533 001e                    .COOFF  EQU     30              ; CONSOLE OUTPUT OFF
7534 0020                    .HSDTA  EQU     32              ; HIGH SPEED PRINTDATA
7535 0022                    .BSON   EQU     34              ; PUNCH/LOAD ON
7536 0024                    .BSDTA  EQU     36              ; PUNCH/LOAD DATA
7537 0026                    .BSOFF  EQU     38              ; PUNCH/LOAD OFF
7538 0028                    .PAUSE  EQU     40              ; TASK PAUSE ROUTINE
7539 002a                    .EXPAN  EQU     42              ; EXPRESSION ANALYZER
7540 002c                    .CMDL2  EQU     44              ; SECOND COMMAND LIST
7541 002e                    .ACIA   EQU     46              ; ACIA ADDRESS
7542 0030                    .PAD    EQU     48              ; CHARACTER PAD AND NEW LINE PAD
7543 0032                    .ECHO   EQU     50              ; ECHO/LOAD AND NULL BKPT FLAG
7544 0034                    .PTM    EQU     52              ; PTM ADDRESS
7545 001b                    NUMVTR  EQU     52/2+1          ; NUMBER OF VECTORS
7546 0034                    HIVTR   EQU     52              ; HIGHEST VECTOR OFFSET
7547                         
7548                         ******************************************
7549                         *           WORK AREA
7550                         * THIS WORK AREA IS ASSIGNED TO THE PAGE ADDRESSED BY
7551                         * -$1800,PCR FROM THE BASE ADDRESS OF THE ASSIST09
7552                         * ROM. THE DIRECT PAGE REGISTER DURING MOST ROUTINE
7553                         * OPERATIONS WILL POINT TO THIS WORK AREA. THE STACK
7554                         * INITIALLY STARTS UNDER THE RESERVED WORK AREAS AS
7555                         * DEFINED HEREIN.
7556                         ******************************************
7557 7000                    WORKPG  EQU     ROMBEG+RAMOFS   ; SETUP DIRECT PAGE ADDRESS
7558                         *       SETDP   =WORKPG         ; NOTIFY ASSEMBLER
7559 7100                            ORG     WORKPG+256      ; READY PAGE DEFINITIONS
7560                         
7561                         * THE FOLLOWING THRU BKPTOP MUST RESIDE IN THIS ORDER
7562                         * FOR PROPER INITIALIZATION
7563 70fc                            ORG     *-4
7564 70fc                    PAUSER  EQU     *               ; PAUSE ROUTINE
7565 70fb                            ORG     *-1
7566 70fb                    SWIBFL  EQU     *               ; BYPASS SWI AS BREAKPOINT FLAG
7567 70fa                            ORG     *-1
7568 70fa                    BKPTCT  EQU     *               ; BREAKPOINT COUNT
7569 70f8                            ORG     *-2             ; SLEVEL EQU
7570 70f8                    SLEVEL  EQU     *               ; STACK TRACE LEVEL
7571 70c2                            ORG     -NUMVTR*2+*
7572 70c2                    VECTAB  EQU     *               ; VECTOR TABLE
7573 70b2                            ORG     -2*NUMBKP+*
7574 70b2                    BKPTBL  EQU     *               ; BREAKPOINT TABLE
7575 70a2                            ORG     -2*NUMBKP+*
7576 70a2                    BKPTOP  EQU     *               ; BREAKPOINT OPCODE TABLE
7577 70a0                            ORG     *-2
7578 70a0                    WINDOW  EQU     *               ; WINDOW
7579 709e                            ORG     *-2
7580 709e                    ADDR    EQU     *               ; ADDRESS POINTER VALUE
7581 709d                            ORG     *-1
7582 709d                    BASEPG  EQU     *               ; BASE PAGE VALUE
7583 709b                            ORG     *-2
7584 709b                    NUMBER  EQU     *               ; BINARY BUILD AREA
7585 7099                            ORG     *-2
7586 7099                    LASTOP  EQU     *               ; LAST OPCODE TRACED
7587 7097                            ORG     *-2
7588 7097                    RSTACK  EQU     *               ; RESET STACK POINTER
7589 7095                            ORG     *-2
7590 7095                    PSTACK  EQU     *               ; COMMAND RECOVERY STACK
7591 7093                            ORG     *-2
7592 7093                    PCNTER  EQU     *               ; LAST PROGRAM COUNTER
7593 7091                            ORG     *-2
7594 7091                    TRACEC  EQU     *               ; TRACE COUNT
7595 7090                            ORG     *-1
7596 7090                    SWICNT  EQU     *               ; TRACE "SWI" NEST LEVEL COUNT
7597 708f                            ORG     *-1             ; (MISFLG MUST FOLLOW SWICNT)
7598 708f                    MISFLG  EQU     *               ; LOAD CMD/THRU BREAKPOINT FLAG
7599 708e                            ORG     *-1
7600 708e                    DELIM   EQU     *               ; EXPRESSION DELIMITER/WORK BYTE
7601 7066                            ORG     *-40
7602 7066                    ROM2WK  EQU     *               ; EXTENSION ROM RESERVED AREA
7603 7051                            ORG     *-21
7604 7051                    TSTACK  EQU     *               ; TEMPORARY STACK HOLD
7605 7051                    STACK   EQU     *               ; START OF INITIAL STACK
7606                         
7607                         ******************************************
7608                         * DEFAULT THE ROM BEGINNING ADDRESS TO 'ROMBEG'
7609                         * ASSIST09 IS POSITION ADDRESS INDEPENDENT, HOWEVER
7610                         * WE ASSEMBLE ASSUMING CONTROL OF THE HARDWARE VECTORS.
7611                         * NOTE THAT THE WORK RAM PAGE MUST BE 'RAMOFS'
7612                         * FROM THE ROM BEGINNING ADDRESS.
7613                         ********************************************
7614 f800                            ORG     ROMBEG          ; ROM ASSEMBLY/DEFAULT ADDRESS
7615                         
7616                         *****************************************************
7617                         * BLDVTR - BUILD ASSIST09 VECTOR TABLE
7618                         * HARDWARE RESET CALLS THIS SUBROUTINE TO BUILD THE
7619                         * ASSIST09 VECTOR TABLE. THIS SUBROUTINE RESIDES AT
7620                         * THE FIRST BYTE OF THE ASSIST09 ROM, AND CAN BE
7621                         * CALLED VIA EXTERNAL CONTROL CODE FOR REMOTE
7622                         * ASSIST09 EXECUTION.
7623                         * INPUT: S->VALID STACK RAM
7624                         * OUTPUT: U->VECTOR TABLE ADDRESS
7625                         * DPR->ASSIST09 WORK AREA PAGE
7626                         * THE VECTOR TABLE AND DEFAULTS ARE INITIALIZED
7627                         * ALL REGISTERS VOLATILE
7628                         *************************************************
7629 f800 30 8d 78 be        BLDVTR  LEAX    VECTAB,PCR      ; ADDRESS VECTOR TABLE
7630 f804 1f 10                      TFR     X,D             ; OBTAIN BASE PAGE ADDRESS
7631 f806 1f 8b                      TFR     A,DP            ; SETUP DPR
7632 f808 97 9d                      STA     <BASEPG         ; STORE FOR QUICK REFERENCE
7633 f80a 33 84                      LEAU    ,X              ; RETURN TABLE TO CALLER
7634 f80c 31 8c 35                   LEAY    <INITVT,PCR     ; LOAD FROM ADDR
7635 f80f ef 81                      STU     ,X++            ; INIT VECTOR TABLE ADDRESS
7636 f811 c6 16                      LDB     #NUMVTR-5       ; NUMBER RELOCATABLE VECTORS
7637 f813 34 04                      PSHS    B               ; STORE INDEX ON STACK
7638 f815 1f 20              BLD2    TFR     Y,D             ; PREPARE ADDRESS RESOLVE
7639 f817 e3 a1                      ADDD    ,Y++            ; TO ABSOLUTE ADDRESS
7640 f819 ed 81                      STD     ,X++            ; INTO VECTOR TABLE
7641 f81b 6a e4                      DEC     ,S              ; COUNT DOWN
7642 f81d 26 f6                      BNE     BLD2            ; BRANCH IF MORE TO INSERT
7643 f81f c6 0d                      LDB     #INTVE-INTVS    ; STATIC VALUE INIT LENGTH
7644 f821 a6 a0              BLD3    LDA     ,Y+             ; LOAD NEXT BYTE
7645 f823 a7 80                      STA     ,X+             ; STORE INTO POSITION
7646 f825 5a                         DECB                    ; COUNT DOWN
7647 f826 26 f9                      BNE     BLD3            ; LOOP UNTIL DONE
7648 f828 31 8d f7 d4                LEAY    ROM2OF,PCR      ; TEST POSSIBLE EXTENSION ROM
7649 f82c 8e 20 fe                   LDX     #$20FE          ; LOAD "BRA *" FLAG PATTERN
7650 f82f ac a1                      CMPX    ,Y++            ; ? EXTENDED ROM HERE
7651 f831 26 02                      BNE     BLDRTN          ; BRANCH NOT OUR ROM TO RETURN
7652 f833 ad a4                      JSR     ,Y              ; CALL EXTENDED ROM INITIALIZE
7653 f835 35 84              BLDRTN  PULS    PC,B            ; RETURN TO INITIALIZER
7654                         
7655                         *****************************************************
7656                         *                RESET ENTRY POINT
7657                         * HARDWARE RESET ENTERS HERE IF ASSIST09 IS ENABLED
7658                         * TO RECEIVE THE MC6809 HARDWARE VECTORS. WE CALL
7659                         * THE BLDVTR SUBROUTINE TO INITIALIZE THE VECTOR
7660                         * TABLE, STACK, AND THEN FIREUP THE MONITOR VIA SWI
7661                         * CALL.
7662                         *******************************************************
7663 f837 32 8d 78 16        RESET   LEAS    STACK,PCR       ; SETUP INITIAL STACK
7664 f83b 8d c3                      BSR     BLDVTR          ; BUILD VECTOR TABLE
7665 f83d 4f                 RESET2  CLRA                    ; ISSUE STARTUP MESSAGE
7666 f83e 1f 8b                      TFR     A,DP            ; DEFAULT TO PAGE ZERO
7667 f840 3f                         SWI                     ; PERFORM MONITOR FIREUP
7668 f841 08                         FCB     MONITR          ; TO ENTER COMMAND PROCESSING
7669 f842 20 f9                      BRA     RESET2          ; REENTER MONITOR IF 'CONTINUE'
7670                         
7671                         ******************************************************
7672                         *        INITVT - INITIAL VECTOR TABLE
7673                         * THIS TABLE IS RELOCATED TO RAM AND REPRESENTS THE
7674                         * INITIAL STATE OF THE VECTOR TABLE. ALL ADDRESSES
7675                         * ARE CONVERTED TO ABSOLUTE FORM. THIS TABLE STARTS
7676                         * WITH THE SECOND ENTRY, ENDS WITH STATIC CONSTANT
7677                         * INITIALIZATION DATA WHICH CARRIES BEYOND THE TABLE.
7678                         ************************************************
7679 f844 01 5c              INITVT  FDB     CMDTBL-*        ; DEFAULT FIRST COMMAND TABLE
7680 f846 02 96                      FDB     RSRVDR-*        ; DEFAULT UNDEFINED HARDWARE VECTOR
7681 f848 02 94                      FDB     SWI3R-*         ; DEFAULT SWI3
7682 f84a 02 92                      FDB     SWI2R-*         ; DEFAULT SWI2
7683 f84c 02 74                      FDB     FIRQR-*         ; DEFAULT FIRQ
7684 f84e 02 8e                      FDB     IRQR-*          ; DEFAULT IRQ ROUTINE
7685 f850 00 45                      FDB     SWIR-*          ; DEFAULT SWI ROUTINE
7686 f852 02 2f                      FDB     NMIR-*          ; DEFAULT NMI ROUTINE
7687 f854 ff e3                      FDB     RESET-*         ; RESTART VECTOR
7688 f856 02 94                      FDB     CION-*          ; DEFAULT CION
7689 f858 02 88                      FDB     CIDTA-*         ; DEFAULT CIDTA
7690 f85a 02 9a                      FDB     CIOFF-*         ; DEFAULT CIOFF
7691 f85c 02 8e                      FDB     COON-*          ; DEFAULT COON
7692 f85e 02 97                      FDB     CODTA-*         ; DEFAULT CODTA
7693 f860 02 94                      FDB     COOFF-*         ; DEFAULT COOFF
7694 f862 03 9e                      FDB     HSDTA-*         ; DEFAULT HSDTA
7695 f864 02 bb                      FDB     BSON-*          ; DEFAULT BSON
7696 f866 02 d6                      FDB     BSDTA-*         ; DEFAULT BSDTA
7697 f868 02 c3                      FDB     BSOFF-*         ; DEFAULT BSOFF
7698 f86a 78 92                      FDB     PAUSER-*        ; DEFAULT PAUSE ROUTINE
7699 f86c 04 81                      FDB     EXP1-*          ; DEFAULT EXPRESSION ANALYZER
7700 f86e 01 2d                      FDB     CMDTB2-*        ; DEFAULT SECOND COMMAND TABLE
7701                         * CONSTANTS
7702 f870 a0 00              INTVS   FDB     ACIA            ; DEFAULT ACIA
7703 f872 00 05                      FCB     DFTCHP,DFTNLP   ; DEFAULT NULL PADDS
7704 f874 00 00                      FDB     0               ; DEFAULT ECHO
7705 f876 00 00                      FDB     PTM             ; DEFAULT PTM
7706 f878 00 00                      FDB     0               ; INITIAL STACK TRACE LEVEL
7707 f87a 00                         FCB     0               ; INITIAL BREAKPOINT COUNT
7708 f87b 00                         FCB     0               ; SWI BREAKPOINT LEVEL
7709 f87c 39                         FCB     $39             ; DEFAULT PAUSE ROUTINE (RTS)
7710 f87d                    INTVE   EQU     *
7711                         *B
7712                         ***********************************************
7713                         *            ASSIST09 SWI HANDLER
7714                         * THE SWI HANDLER PROVIDES ALL INTERFACING NECESSARY
7715                         * FOR A USER PROGRAM. A FUNCTION BYTE IS ASSUMED TO
7716                         * FOLLOW THE SWI INSTRUCTION. IT IS BOUND CHECKED
7717                         * AND THE PROPER ROUTINE IS GIVEN CONTROL. THIS
7718                         * INVOCATION MAY ALSO BE A BREAKPOINT INTERRUPT.
7719                         * IF SO, THE BREAKPOINT HANDLER IS ENTERED.
7720                         * INPUT: MACHINE STATE DEFINED FOR SWI
7721                         * OUTPUT: VARIES ACCORDING TO FUNCTION CALLED. PC ON
7722                         * CALLERS STACK INCREMENTED BY ONE IF VALID CALL.
7723                         * VOLATILE REGISTERS: SEE FUNCTIONS CALLED
7724                         * STATE: RUNS DISABLED UNLESS FUNCTION CLEARS I FLAG.
7725                         ************************************************
7726                         * SWI FUNCTION VECTOR TABLE
7727 f87d 01 98              SWIVTB  FDB     ZINCH-SWIVTB    ; INCHNP
7728 f87f 01 b5                      FDB     ZOTCH1-SWIVTB   ; OUTCH
7729 f881 01 cf                      FDB     ZPDTA1-SWIVTB   ; PDATA1
7730 f883 01 c7                      FDB     ZPDATA-SWIVTB   ; PDATA
7731 f885 01 79                      FDB     ZOT2HS-SWIVTB   ; OUT2HS
7732 f887 01 77                      FDB     ZOT4HS-SWIVTB   ; OUT4HS
7733 f889 01 c4                      FDB     ZPCRLF-SWIVTB   ; PCRLF
7734 f88b 01 7d                      FDB     ZSPACE-SWIVTB   ; SPACE
7735 f88d 00 55                      FDB     ZMONTR-SWIVTB   ; MONITR
7736 f88f 01 81                      FDB     ZVSWTH-SWIVTB   ; VCTRSW
7737 f891 02 5a                      FDB     ZBKPNT-SWIVTB   ; BREAKPOINT
7738 f893 01 d5                      FDB     ZPAUSE-SWIVTB   ; TASK PAUSE
7739                         
7740 f895 6a 8d 77 f7        SWIR    DEC     SWICNT,PCR      ; UP "SWI" LEVEL FOR TRACE
7741 f899 17 02 29                   LBSR    LDDP            ; SETUP PAGE AND VERIFY STACK
7742                         * CHECK FOR BREAKPOINT TRAP
7743 f89c ee 6a                      LDU     10,S            ; LOAD PROGRAM COUNTER
7744 f89e 33 5f                      LEAU    -1,U            ; BACK TO SWI ADDRESS
7745 f8a0 0d fb                      TST     <SWIBFL         ; ? THIS "SWI" BREAKPOINT
7746 f8a2 26 11                      BNE     SWIDNE          ; BRANCH IF SO TO LET THROUGH
7747 f8a4 17 06 9f                   LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
7748 f8a7 50                         NEGB                    ; OBTAIN POSITIVE COUNT
7749 f8a8 5a                 SWILP   DECB                    ; COUNT DOWN
7750 f8a9 2b 0a                      BMI     SWIDNE          ; BRANCH WHEN DONE
7751 f8ab 11 a3 a1                   CMPU    ,Y++            ; ? WAS THIS A BREAKPOINT
7752 f8ae 26 f8                      BNE     SWILP           ; BRANCH IF NOT
7753 f8b0 ef 6a                      STU     10,S            ; SET PROGRAM COUNTER BACK
7754 f8b2 16 02 22                   LBRA    ZBKPNT          ; GO DO BREAKPOINT
7755 f8b5 0f fb              SWIDNE  CLR     <SWIBFL         ; CLEAR IN CASE SET
7756 f8b7 37 06                      PULU    D               ; OBTAIN FUNCTION BYTE, UP PC
7757 f8b9 c1 0b                      CMPB    #NUMFUN         ; ? TOO HIGH
7758 f8bb 10 22 02 13                LBHI    ERROR           ; YES, DO BREAKPOINT
7759 f8bf ef 6a                      STU     10,S            ; BUMP PROGRAM COUNTER PAST SWI
7760 f8c1 58                         ASLB                    ; FUNCTION CODE TIMES TWO
7761 f8c2 33 8c b8                   LEAU    SWIVTB,PCR      ; OBTAIN VECTOR BRANCH ADDRESS
7762 f8c5 ec c5                      LDD     B,U             ; LOAD OFFSET
7763 f8c7 6e cb                      JMP     D,U             ; JUMP TO ROUTINE
7764                         
7765                         **********************************************
7766                         * REGISTERS TO FUNCTION ROUTINES:
7767                         *  DP-> WORK AREA PAGE
7768                         *  D,Y,U=UNRELIABLE           X=AS CALLED FROM USER
7769                         *  S=AS FROM SWI INTERRUPT
7770                         *********************************************
7771                         
7772                         **************************************************
7773                         *            [SWI FUNCTION 8]
7774                         *              MONITOR ENTRY
7775                         *  FIREUP THE ASSIST09 MONITOR.
7776                         *  THE STACK WITH ITS VALUES FOR THE DIRECT PAGE
7777                         *  REGISTER AND CONDITION CODE FLAGS ARE USED AS IS.
7778                         *   1) INITIALIZE CONSOLE I/O
7779                         *   2) OPTIONALLY PRINT SIGNON
7780                         *   3) INITIALIZE PTM FOR SINGLE STEPPING
7781                         *   4) ENTER COMMAND PROCESSOR
7782                         * INPUT: A=0 INIT CONSOLE AND PRINT STARTUP MESSAGE
7783                         *        A#0 OMIT CONSOLE INIT AND STARTUP MESSAGE
7784                         *************************************************
7785                         
7786 f8c9 41 53 53 49 53 54  SIGNON  FCC     /ASSIST09/      ; SIGNON EYE-CATCHER
     30 39
7787 f8d1 04                         FCB     EOT
7788 f8d2 10 df 97           ZMONTR  STS     <RSTACK         ; SAVE FOR BAD STACK RECOVERY
7789 f8d5 6d 61                      TST     1,S             ; ? INIT CONSOLE AND SEND MSG
7790 f8d7 26 0d                      BNE     ZMONT2          ; BRANCH IF NOT
7791 f8d9 ad 9d 77 f9                JSR     [VECTAB+.CION,PCR] ; READY CONSOLE INPUT
7792 f8dd ad 9d 77 fb                JSR     [VECTAB+.COON,PCR] ; READY CONSOLE OUTPUT
7793 f8e1 30 8c e5                   LEAX    SIGNON,PCR         ; READY SIGNON EYE-CATCHER
7794 f8e4 3f                         SWI                     ; PERFORM
7795 f8e5 03                         FCB     PDATA           ; PRINT STRING
7796 f8e6 9e f6              ZMONT2  LDX     <VECTAB+.PTM    ; LOAD PTM ADDRESS
7797 f8e8 27 0d                      BEQ     CMD             ; BRANCH IF NOT TO USE A PTM
7798 f8ea 6f 02                      CLR     PTMTM1-PTM,X    ; SET LATCH TO CLEAR RESET
7799 f8ec 6f 03                      CLR     PTMTM1+1-PTM,X  ; AND SET GATE HIGH
7800 f8ee cc 01 a6                   LDD     #$01A6          ; SETUP TIMER 1 MODE
7801 f8f1 a7 01                      STA     PTMC2-PTM,X     ; SETUP FOR CONTROL REGISTER1
7802 f8f3 e7 84                      STB     PTMC13-PTM,X    ; SET OUTPUT ENABLED/
7803                         * SINGLE SHOT/ DUAL 8 BIT/INTERNAL MODE/OPERATE
7804 f8f5 6f 01                      CLR     PTMC2-PTM,X     ; SET CR2 BACK TO RESET FORM
7805                         * FALL INTO COMMAND PROCESSOR
7806                         
7807                         ***************************************************
7808                         *          COMMAND HANDLER
7809                         *  BREAKPOINTS ARE REMOVED AT THIS TIME.
7810                         *  PROMPT FOR A COMMAND, AND STORE ALL CHARACTERS
7811                         *  UNTIL A SEPARATOR ON THE STACK.
7812                         *  SEARCH FOR FIRST MATCHING COMMAND SUBSET,
7813                         *  CALL IT OR GIVE '?' RESPONSE.
7814                         *  DURING COMMAND SEARCH:
7815                         *      B=OFFSET TO NEXT ENTRY ON X
7816                         *      U=SAVED S
7817                         *      U-1=ENTRY SIZE+2
7818                         *      U-2=VALID NUMBER FLAG (>=0 VALID)/COMPARE CNT
7819                         *      U-3=CARRIAGE RETURN FLAG (0=CR HAS BEEN DONE)
7820                         *      U-4=START OF COMMAND STORE
7821                         *      S+0=END OF COMMAND STORE
7822                         ***********************************************
7823                         
7824 f8f7 3f                 CMD     SWI                     ; TO NEW LINE
7825 f8f8 06                         FCB     PCRLF           ; FUNCTION
7826                         * DISARM THE BREAKPOINTS
7827 f8f9 17 06 4a           CMDNEP  LBSR    CBKLDR          ; OBTAIN BREAKPOINT POINTERS
7828 f8fc 2a 0c                      BPL     CMDNOL          ; BRANCH IF NOT ARMED OR NONE
7829 f8fe 50                         NEGB                    ; MAKE POSITIVE
7830 f8ff d7 fa                      STB     <BKPTCT         ; FLAG AS DISARMED
7831 f901 5a                 CMDDDL  DECB                    ; ? FINISHED
7832 f902 2b 06                      BMI     CMDNOL          ; BRANCH IF SO
7833 f904 a6 30                      LDA     -NUMBKP*2,Y     ; LOAD OPCODE STORED
7834 f906 a7 b1                      STA     [,Y++]          ; STORE BACK OVER "SWI"
7835 f908 20 f7                      BRA     CMDDDL          ; LOOP UNTIL DONE
7836 f90a ae 6a              CMDNOL  LDX     10,S            ; LOAD USERS PROGRAM COUNTER
7837 f90c 9f 93                      STX     <PCNTER         ; SAVE FOR EXPRESSION ANALYZER
7838 f90e 86 3e                      LDA     #PROMPT         ; LOAD PROMPT CHARACTER
7839 f910 3f                         SWI                     ; SEND TO OUTPUT HANDLER
7840 f911 01                         FCB     OUTCH           ; FUNCTION
7841 f912 33 e4                      LEAU    ,S              ; REMEMBER STACK RESTORE ADDRESS
7842 f914 df 95                      STU     <PSTACK         ; REMEMBER STACK FOR ERROR USE
7843 f916 4f                         CLRA                    ; PREPARE ZERO
7844 f917 5f                         CLRB                    ; PREPARE ZERO
7845 f918 dd 9b                      STD     <NUMBER         ; CLEAR NUMBER BUILD AREA
7846 f91a dd 8f                      STD     <MISFLG         ; CLEAR MISCEL. AND SWICNT FLAGS
7847 f91c dd 91                      STD     <TRACEC         ; CLEAR TRACE COUNT
7848 f91e c6 02                      LDB     #2              ; SET D TO TWO
7849 f920 34 07                      PSHS    D,CC            ; PLACE DEFAULTS ONTO STACK
7850                         * CHECK FOR "QUICK" COMMANDS.
7851 f922 17 04 58                   LBSR    READC           ; OBTAIN FIRST CHARACTER
7852 f925 30 8d 05 85                LEAX    CDOT+2,PCR      ; PRESET FOR SINGLE TRACE
7853 f929 81 2e                      CMPA    #'.             ; ? QUICK TRACE
7854 f92b 27 5a                      BEQ     CMDXQT          ; BRANCH EQUAL FOR TRACE ONE
7855 f92d 30 8d 04 ed                LEAX    CMPADP+2,PCR    ; READY MEMORY ENTRY POINT
7856 f931 81 2f                      CMPA    #'/             ; ? OPEN LAST USED MEMORY
7857 f933 27 52                      BEQ     CMDXQT          ; BRANCH TO DO IT IF SO
7858                         * PROCESS NEXT CHARACTER
7859 f935 81 20              CMD2    CMPA    #'              ; ? BLANK OR DELIMITER
7860 f937 23 14                      BLS    CMDGOT           ; BRANCH YES, WE HAVE IT
7861 f939 34 02                      PSHS   A                ; BUILD ONTO STACK
7862 f93b 6c 5f                      INC    -1,U             ; COUNT THIS CHARACTER
7863 f93d 81 2f                      CMPA   #'/              ; ? MEMORY COMMAND
7864 f93f 27 4f                      BEQ    CMDMEM           ; BRANCH IF SO
7865 f941 17 04 0f                   LBSR   BLDHXC           ; TREAT AS HEX VALUE
7866 f944 27 02                      BEQ    CMD3             ; BRANCH IF STILL VALID NUMBER
7867 f946 6a 5e                      DEC    -2,U             ; FLAG AS INVALID NUMBER
7868 f948 17 04 32           CMD3    LBSR   READC            ; OBTAIN NEXT CHARACTER
7869 f94b 20 e8                      BRA    CMD2             ; TEST NEXT CHARACTER
7870                         * GOT COMMAND, NOW SEARCH TABLES
7871 f94d 80 0d              CMDGOT  SUBA   #CR              ; SET ZERO IF CARRIAGE RETURN
7872 f94f a7 5d                      STA    -3,U             ; SETUP FLAG
7873 f951 9e c4                      LDX    <VECTAB+.CMDL1   ; START WITH FIRST CMD LIST
7874 f953 e6 80              CMDSCH  LDB    ,X+              ; LOAD ENTRY LENGTH
7875 f955 2a 10                      BPL    CMDSME           ; BRANCH IF NOT LIST END
7876 f957 9e ee                      LDX    <VECTAB+.CMDL2   ; NOW TO SECOND CMD LITS
7877 f959 5c                         INCB                    ; ? TO CONTINUE TO DEFAULT LIST
7878 f95a 27 f7                      BEQ     CMDSCH          ; BRANCH IF SO
7879 f95c 10 de 95           CMDBAD  LDS     <PSTACK         ; RESTORE STACK
7880 f95f 30 8d 01 5e                LEAX    ERRMSG,PCR      ; POINT TO ERROR STRING
7881 f963 3f                         SWI                     ; SEND OUT
7882 f964 02                         FCB     PDATA1          ; TO CONSOLE
7883 f965 20 90                      BRA     CMD             ; AND TRY AGAIN
7884                         * SEARCH NEXT ENTRY
7885 f967 5a                 CMDSME  DECB                    ; TAKE ACCOUNT OF LENGTH BYTE
7886 f968 e1 5f                      CMPB    -1,U            ; ? ENTERED LONGER THAN ENTRY
7887 f96a 24 03                      BHS     CMDSIZ          ; BRANCH IF NOT TOO LONG
7888 f96c 3a                 CMDFLS  ABX                     ; SKIP TO NEXT ENTRY
7889 f96d 20 e4                      BRA     CMDSCH          ; AND TRY NEXT
7890 f96f 31 5d              CMDSIZ  LEAY    -3,U            ; PREPARE TO COMPARE
7891 f971 a6 5f                      LDA     -1,U            ; LOAD SIZE+2
7892 f973 80 02                      SUBA    #2              ; TO ACTUAL SIZE ENTERED
7893 f975 a7 5e                      STA     -2,U            ; SAVE SIZE FOR COUNTDOWN
7894 f977 5a                 CMDCMP  DECB                    ; DOWN ONE BYTE
7895 f978 a6 80                      LDA     ,X+             ; NEXT COMMAND CHARACTER
7896 f97a a1 a2                      CMPA    ,-Y             ; ? SAME AS THAT ENTERED
7897 f97c 26 ee                      BNE     CMDFLS          ; BRANCH TO FLUSH IF NOT
7898 f97e 6a 5e                      DEC     -2,U            ; COUNT DOWN LENGTH OF ENTRY
7899 f980 26 f5                      BNE     CMDCMP          ; BRANCH IF MORE TO TEST
7900 f982 3a                         ABX                     ; TO NEXT ENTRY
7901 f983 ec 1e                      LDD     -2,X            ; LOAD OFFSET
7902 f985 30 8b                      LEAX    D,X             ; COMPUTE ROUTINE ADDRESS+2
7903 f987 6d 5d              CMDXQT  TST     -3,U            ; SET CC FOR CARRIAGE RETURN TEST
7904 f989 32 c4                      LEAS    ,U              ; DELETE STACK WORK AREA
7905 f98b ad 1e                      JSR     -2,X            ; CALL COMMAND
7906 f98d 16 ff 7a                   LBRA    CMDNOL          ; GO GET NEXT COMMAND
7907 f990 6d 5e              CMDMEM  TST     -2,U            ; ? VALID HEX NUMBER ENTERED
7908 f992 2b c8                      BMI     CMDBAD          ; BRANCH ERROR IF NOT
7909 f994 30 88 ae                   LEAX    <CMEMN-CMPADP,X ; TO DIFFERENT ENTRY
7910 f997 dc 9b                      LDD     <NUMBER         ; LOAD NUMBER ENTERED
7911 f999 20 ec                      BRA     CMDXQT          ; AND ENTER MEMORY COMMAND
7912                         
7913                         ** COMMANDS ARE ENTERED AS A SUBROUTINE WITH:
7914                         **    DPR->ASSIST09 DIRECT PAGE WORK AREA
7915                         **    Z=1 CARRIAGE RETURN ENTERED
7916                         **    Z=0 NON CARRIAGE RETURN DELIMITER
7917                         **    S=NORMAL RETURN ADDRESS
7918                         ** THE LABEL "CMDBAD" MAY BE ENTERED TO ISSUE AN
7919                         ** AN ERROR FLAG (*).
7920                         **************************************************
7921                         *       ASSIST09 COMMAND TABLES
7922                         * THESE ARE THE DEFAULT COMMAND TABLES. EXTERNAL
7923                         * TABLES OF THE SAME FORMAT MAY EXTEND/REPLACE
7924                         * THESE BY USING THE VECTOR SWAP FUNCTION.
7925                         *
7926                         * ENTRY FORMAT:
7927                         *    +0...TOTAL SIZE OF ENTRY (INCLUDING THIS BYTE)
7928                         *    +1...COMMAND STRING
7929                         *    +N...TWO BYTE OFFSET TO COMMAND (ENTRYADDR-*)
7930                         *
7931                         * THE TABLES TERMINATE WITH A ONE BYTE -1 OR -2.
7932                         * THE -1 CONTINUES THE COMMAND SEARCH WITH THE
7933                         *        SECOND COMMAND TABLE.
7934                         * THE -2 TERMINATES COMMAND SEARCHES.
7935                         *****************************************************
7936                         
7937                         * THIS IS THE DEFAULT LIST FOR THE SECOND COMMAND
7938                         * LIST ENTRY.
7939                         
7940 f99b 04                 CMDTB2  FCB     4               ; TABLE ENTRY LENGTH
7941 f99c 55                         FCC     'U'             ; 'UNASSEMBLE' COMMAND
7942 f99d c6 63                      FDB     CUNAS-*         ; POINTER TO COMMAND (RELATIVE TO HERE)
7943 f99f fe                         FCB     -2              ; -2 INDICATES END OF TABLE
7944                         
7945                         * THIS IS THE DEFAULT LIST FOR THE FIRST COMMAND
7946                         * LIST ENTRY.
7947                         
7948 f9a0                    CMDTBL  EQU     *               ; MONITOR COMMAND TABLE
7949 f9a0 04                         FCB     4
7950 f9a1 42                         FCC     /B/             ; 'BREAKPOINT' COMMAND
7951 f9a2 05 4d                      FDB     CBKPT-*
7952 f9a4 04                         FCB     4
7953 f9a5 43                         FCC     /C/             ; 'CALL' COMMAND
7954 f9a6 04 17                      FDB     CCALL-*
7955 f9a8 04                         FCB     4
7956 f9a9 44                         FCC     /D/             ; 'DISPLAY' COMMAND
7957 f9aa 04 9d                      FDB     CDISP-*
7958 f9ac 04                         FCB     4
7959 f9ad 45                         FCC     /E/             ; 'ENCODE' COMMAND
7960 f9ae 05 9f                      FDB     CENCDE-*
7961 f9b0 04                         FCB     4
7962 f9b1 47                         FCC     /G/             ; 'GO' COMMAND
7963 f9b2 03 d2                      FDB     CGO-*
7964 f9b4 04                         FCB     4
7965 f9b5 4c                         FCC     /L/             ; 'LOAD' COMMAND
7966 f9b6 04 dd                      FDB     CLOAD-*
7967 f9b8 04                         FCB     4
7968 f9b9 4d                         FCC     /M/             ; 'MEMORY' COMMAND
7969 f9ba 04 0d                      FDB     CMEM-*
7970 f9bc 04                         FCB     4
7971 f9bd 4e                         FCC     /N/             ; 'NULLS' COMMAND
7972 f9be 04 fd                      FDB     CNULLS-*
7973 f9c0 04                         FCB     4
7974 f9c1 4f                         FCC     /O/             ; 'OFFSET' COMMAND
7975 f9c2 05 0a                      FDB     COFFS-*
7976 f9c4 04                         FCB     4
7977 f9c5 50                         FCC     /P/             ; 'PUNCH' COMMAND
7978 f9c6 04 af                      FDB     CPUNCH-*
7979 f9c8 04                         FCB     4
7980 f9c9 52                         FCC     /R/             ; 'REGISTERS' COMMAND
7981 f9ca 02 84                      FDB     CREG-*
7982 f9cc 04                         FCB     4
7983 f9cd 53                         FCC     /S/             ; 'STLEVEL' COMMAND
7984 f9ce 04 f2                      FDB     CSTLEV-*
7985 f9d0 04                         FCB     4
7986 f9d1 54                         FCC     /T/             ; 'TRACE' COMMAND
7987 f9d2 04 d6                      FDB     CTRACE-*
7988 f9d4 04                         FCB     4
7989 f9d5 56                         FCC     /V/             ; 'VERIFY' COMMAND
7990 f9d6 04 cf                      FDB     CVER-*
7991 f9d8 04                         FCB     4
7992 f9d9 57                         FCC     /W/             ; 'WINDOW' COMMAND
7993 f9da 04 68                      FDB     CWINDO-*
7994 f9dc ff                         FCB     -1              ; END, CONTINUE WITH THE SECOND
7995                         
7996                         *************************************************
7997                         *             [SWI FUNCTIONS 4 AND 5]
7998                         *      4 - OUT2HS - DECODE BYTE TO HEX AND ADD SPACE
7999                         *      5 - OUT4HS - DECODE WORD TO HEX AND ADD SPACE
8000                         * INPUT: X->BYTE OR WORD TO DECODE
8001                         * OUTPUT: CHARACTERS SENT TO OUTPUT HANDLER
8002                         *         X->NEXT BYTE OR WORD
8003                         *************************************************
8004 f9dd a6 80              ZOUT2H  LDA     ,X+             ; LOAD NEXT BYTE
8005 f9df 34 06                      PSHS    D               ; SAVE - DO NOT REREAD
8006 f9e1 c6 10                      LDB     #16             ; SHIFT BY 4 BITS
8007 f9e3 3d                         MUL                     ; WITH MULTIPLY
8008 f9e4 8d 04                      BSR     ZOUTHX          ; SEND OUT AS HEX
8009 f9e6 35 06                      PULS    D               ; RESTORE BYTES
8010 f9e8 84 0f                      ANDA    #$0F            ; ISOLATE RIGHT HEX
8011 f9ea 8b 90              ZOUTHX  ADDA    #$90            ; PREPARE A-F ADJUST
8012 f9ec 19                         DAA                     ; ADJUST
8013 f9ed 89 40                      ADCA    #$40            ; PREPARE CHARACTER BITS
8014 f9ef 19                         DAA                     ; ADJUST
8015 f9f0 6e 9d 76 ea        SEND    JMP     [VECTAB+.CODTA,PCR] ; SEND TO OUT HANDLER
8016                         
8017 f9f4 8d e7              ZOT4HS  BSR     ZOUT2H          ; CONVERT FIRST BYTE
8018 f9f6 8d e5              ZOT2HS  BSR     ZOUT2H          ; CONVERT BYTE TO HEX
8019 f9f8 af 64                      STX     4,S             ; UPDATE USERS X REGISTER
8020                         * FALL INTO SPACE ROUTINE
8021                         
8022                         *************************************************
8023                         *            [SWI FUNCTION 7]
8024                         *         SPACE - SEND BLANK TO OUTPUT HANDLER
8025                         * INPUT: NONE
8026                         * OUTPUT: BLANK SEND TO CONSOLE HANDLER
8027                         *************************************************
8028 f9fa 86 20              ZSPACE  LDA     #'              ; LOAD BLANK
8029 f9fc 20 3d                      BRA     ZOTCH2          ; SEND AND RETURN
8030                         
8031                         ***********************************************
8032                         *             [SWI FUNCTION 9]
8033                         *          SWAP VECTOR TABLE ENTRY
8034                         * INPUT: A=VECTOR TABLE CODE (OFFSET)
8035                         * X=0 OR REPLACEMENT VALUE
8036                         * OUTPUT: X=PREVIOUS VALUE
8037                         ***********************************************
8038 f9fe a6 61              ZVSWTH  LDA     1,S             ; LOAD REQUESTERS A
8039 fa00 81 34                      CMPA    #HIVTR          ; ? SUB-CODE TOO HIGH
8040 fa02 22 39                      BHI     ZOTCH3          ; IGNORE CALL IF SO
8041 fa04 10 9e c2                   LDY     <VECTAB+.AVTBL  ; LOAD VECTOR TABLE ADDRESS
8042 fa07 ee a6                      LDU     A,Y             ; U=OLD ENTRY
8043 fa09 ef 64                      STU     4,S             ; RETURN OLD VALUE TO CALLERS X
8044 fa0b af 7e                      STX     -2,S            ; ? X=0
8045 fa0d 27 2e                      BEQ     ZOTCH3          ; YES, DO NOT CHANGE ENTRY
8046 fa0f af a6                      STX     A,Y             ; REPLACE ENTRY
8047 fa11 20 2a                      BRA     ZOTCH3          ; RETURN FROM SWI
8048                         *D
8049                         
8050                         ************************************************
8051                         *               [SWI FUNCTION 0]
8052                         *  INCHNP - OBTAIN INPUT CHAR IN A (NO PARITY)
8053                         * NULLS AND RUBOUTS ARE IGNORED.
8054                         * AUTOMATIC LINE FEED IS SENT UPON RECEIVING A
8055                         * CARRIAGE RETURN.
8056                         * UNLESS WE ARE LOADING FROM TAPE.
8057                         ************************************************
8058 fa13 8d 5d              ZINCHP  BSR     XQPAUS          ; RELEASE PROCESSOR
8059 fa15 8d 5f              ZINCH   BSR     XQCIDT          ; CALL INPUT DATA APPENDAGE
8060 fa17 24 fa                      BCC     ZINCHP          ; LOOP IF NONE AVAILABLE
8061 fa19 4d                         TSTA                    ; ? TEST FOR NULL
8062 fa1a 27 f9                      BEQ     ZINCH           ; IGNORE NULL
8063 fa1c 81 7f                      CMPA    #$7F            ; ? RUBOUT
8064 fa1e 27 f5                      BEQ     ZINCH           ; BRANCH YES TO IGNORE
8065 fa20 a7 61                      STA     1,S             ; STORE INTO CALLERS A
8066 fa22 0d 8f                      TST     <MISFLG         ; ? LOAD IN PROGRESS
8067 fa24 26 17                      BNE     ZOTCH3          ; BRANCH IF SO TO NOT ECHO
8068 fa26 81 0d                      CMPA    #CR             ; ? CARRIAGE RETURN
8069 fa28 26 04                      BNE     ZIN2            ; NO, TEST ECHO BYTE
8070 fa2a 86 0a                      LDA     #LF             ; LOAD LINE FEED
8071 fa2c 8d c2                      BSR     SEND            ; ALWAYS ECHO LINE FEED
8072 fa2e 0d f4              ZIN2    TST     <VECTAB+.ECHO   ; ? ECHO DESIRED
8073 fa30 26 0b                      BNE     ZOTCH3          ; NO, RETURN
8074                         * FALL THROUGH TO OUTCH
8075                         ************************************************
8076                         *            [SWI FUNCTION 1]
8077                         *        OUTCH - OUTPUT CHARACTER FROM A
8078                         * INPUT: NONE
8079                         * OUTPUT: IF LINEFEED IS THE OUTPUT CHARACTER THEN
8080                         * C=0 NO CTL-X RECEIVED, C=1 CTL-X RECEIVED
8081                         ************************************************
8082 fa32 a6 61              ZOTCH1  LDA     1,S             ; LOAD CHARACTER TO SEND
8083 fa34 30 8c 09                   LEAX    <ZPCRLS,PCR     ; DEFAULT FOR LINE FEED
8084 fa37 81 0a                      CMPA    #LF             ; ? LINE FEED
8085 fa39 27 0f                      BEQ     ZPDTLP          ; BRANCH TO CHECK PAUSE IF SO
8086 fa3b 8d b3              ZOTCH2  BSR     SEND            ; SEND TO OUTPUT ROUTINE
8087 fa3d 0c 90              ZOTCH3  INC     <SWICNT         ; BUMP UP "SWI" TRACE NEST LEVEL
8088 fa3f 3b                         RTI                     ; RETURN FROM "SWI" FUNCTION
8089                         
8090                         **************************************************
8091                         * [SWI FUNCTION 6]
8092                         * PCRLF - SEND CR/LF TO CONSOLE HANDLER
8093                         * INPUT: NONE
8094                         * OUTPUT: CR AND LF SENT TO HANDLER
8095                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
8096                         **************************************************
8097 fa40 04                 ZPCRLS  FCB     EOT             ; NULL STRING
8098 fa41 30 8c fc           ZPCRLF LEAX     ZPCRLS,PCR      ; READY CR,LF STRING
8099                         * FALL INTO CR/LF CODE
8100                         
8101                         **************************************************
8102                         * [SWI FUNCTION 3]
8103                         * PDATA - OUTPUT CR/LF AND STRING
8104                         * INPUT: X->STRING
8105                         * OUTPUT: CR/LF AND STRING SENT TO OUTPUT CONSOLE
8106                         * HANDLER.
8107                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
8108                         * NOTE: LINE FEED MUST FOLLOW CARRIAGE RETURN FOR
8109                         * PROPER PUNCH DATA.
8110                         **************************************************
8111                         
8112 fa44 86 0d              ZPDATA  LDA     #CR             ; LOAD CARRIAGE RETURN
8113 fa46 8d a8                      BSR     SEND            ; SEND IT
8114 fa48 86 0a                      LDA     #LF             ; LOAD LINE FEED
8115                         * FALL INTO PDATA1
8116                         
8117                         *************************************************
8118                         * [SWI FUNCTION 2]
8119                         * PDATA1 - OUTPUT STRING TILL EOT ($04)
8120                         * THIS ROUTINE PAUSES IF AN INPUT BYTE BECOMES
8121                         * AVAILABLE DURING OUTPUT TRANSMISSION UNTIL A
8122                         * SECOND IS RECEIVED.
8123                         * INPUT: X->STRING
8124                         * OUTPUT: STRING SENT TO OUTPUT CONSOLE DRIVER
8125                         * C=0 NO CTL-X, C=1 CTL-X RECEIVED
8126                         *************************************************
8127                         
8128 fa4a 8d a4              ZPDTLP  BSR     SEND            ; SEND CHARACTER TO DRIVER
8129 fa4c a6 80              ZPDTA1  LDA     ,X+             ; LOAD NEXT CHARACTER
8130 fa4e 81 04                      CMPA    #EOT            ; ? EOT
8131 fa50 26 f8                      BNE     ZPDTLP          ; LOOP IF NOT
8132                         * FALL INTO PAUSE CHECK FUNCTION
8133                         
8134                         ********************************************
8135                         * [SWI FUNCTION 12]
8136                         * PAUSE - RETURN TO TASK DISPATCHING AND CHECK
8137                         * FOR FREEZE CONDITION OR CTL-X BREAK
8138                         * THIS FUNCTION ENTERS THE TASK PAUSE HANDLER SO
8139                         * OPTIONALLY OTHER 6809 PROCESSES MAY GAIN CONTROL.
8140                         * UPON RETURN, CHECK FOR A 'FREEZE' CONDITION
8141                         * WITH A RESULTING WAIT LOOP, OR CONDITION CODE
8142                         * RETURN IF A CONTROL-X IS ENTERED FROM THE INPUT
8143                         * HANDLER.
8144                         * OUTPUT: C=1 IF CTL-X HAS ENTERED, C=0 OTHERWISE
8145                         ******************************************
8146                         
8147 fa52 8d 1e              ZPAUSE  BSR     XQPAUS          ; RELEASE CONTROL AT EVERY LINE
8148 fa54 8d 06                      BSR     CHKABT          ; CHECK FOR FREEZE OR ABORT
8149 fa56 1f a9                      TFR     CC,B            ; PREPARE TO REPLACE CC
8150 fa58 e7 e4                      STB     ,S              ; OVERLAY OLD ONE ON STACK
8151 fa5a 20 e1                      BRA     ZOTCH3          ; RETURN FROM "SWI"
8152                         
8153                         * CHKABT - SCAN FOR INPUT PAUSE/ABORT DURING OUTPUT
8154                         * OUTPUT: C=0 OK, C=1 ABORT (CTL-X ISSUED)
8155                         * VOLATILE: U,X,D
8156 fa5c 8d 18              CHKABT  BSR     XQCIDT          ; ATTEMPT INPUT
8157 fa5e 24 05                      BCC     CHKRTN          ; BRANCH NO TO RETURN
8158 fa60 81 18                      CMPA    #CAN            ; ? CTL-X FOR ABORT
8159 fa62 26 02                      BNE     CHKWT           ; BRANCH NO TO PAUSE
8160 fa64 53                 CHKSEC  COMB                    ; SET CARRY
8161 fa65 39                 CHKRTN  RTS                     ; RETURN TO CALLER WITH CC SET
8162 fa66 8d 0a              CHKWT   BSR     XQPAUS          ; PAUSE FOR A MOMENT
8163 fa68 8d 0c                      BSR     XQCIDT          ; ? KEY FOR START
8164 fa6a 24 fa                      BCC     CHKWT           ; LOOP UNTIL RECEIVED
8165 fa6c 81 18                      CMPA    #CAN            ; ? ABORT SIGNALED FROM WAIT
8166 fa6e 27 f4                      BEQ     CHKSEC          ; BRANCH YES
8167 fa70 4f                         CLRA                    ; SET C=0 FOR NO ABORT
8168 fa71 39                         RTS                     ; AND RETURN
8169                         
8170                         * SAVE MEMORY WITH JUMPS
8171 fa72 6e 9d 76 74        XQPAUS  JMP   [VECTAB+.PAUSE,PCR] ; TO PAUSE ROUTINE
8172 fa76 ad 9d 76 5e        XQCIDT  JSR   [VECTAB+.CIDTA,PCR] ; TO INPUT ROUTINE
8173 fa7a 84 7f                      ANDA  #$7F              ; STRIP PARITY
8174 fa7c 39                         RTS                     ; RETURN TO CALLER
8175                         
8176                         ********************************************
8177                         * NMI DEFAULT INTERRUPT HANDLER
8178                         * THE NMI HANDLER IS USED FOR TRACING INSTRUCTIONS.
8179                         * TRACE PRINTOUTS OCCUR ONLY AS LONG AS THE STACK
8180                         * TRACE LEVEL IS NOT BREACHED BY FALLING BELOW IT.
8181                         * TRACING CONTINUES UNTIL THE COUNT TURNS ZERO OR
8182                         * A CTL-X IS ENTERED FROM THE INPUT CONSOLE DEVICE.
8183                         *********************************************
8184                         
8185 fa7d 4f 50 2d 04        MSHOWP  FCB     'O,'P,'-,EOT    ; OPCODE PREP
8186                         
8187 fa81 8d 42              NMIR    BSR     LDDP            ; LOAD PAGE AND VERIFY STACK
8188 fa83 0d 8f                      TST     <MISFLG         ; ? THRU A BREAKPOINT
8189 fa85 26 34                      BNE     NMICON          ; BRANCH IF SO TO CONTINUE
8190 fa87 0d 90                      TST     <SWICNT         ; ? INHIBIT "SWI" DURING TRACE
8191 fa89 2b 29                      BMI     NMITRC          ; BRANCH YES
8192 fa8b 30 6c                      LEAX    12,S            ; OBTAIN USERS STACK POINTER
8193 fa8d 9c f8                      CMPX    <SLEVEL         ; ? TO TRACE HERE
8194 fa8f 25 23                      BLO     NMITRC          ; BRANCH IF TOO LOW TO DISPLAY
8195 fa91 30 8c e9                   LEAX    MSHOWP,PCR      ; LOAD OP PREP
8196 fa94 3f                         SWI                     ; SEND TO CONSOLE
8197 fa95 02                         FCB     PDATA1          ; FUNCTION
8198 fa96 09 8e                      ROL     <DELIM          ; SAVE CARRY BIT
8199 fa98 30 8d 75 fd                LEAX    LASTOP,PCR      ; POINT TO LAST OP
8200 fa9c 3f                         SWI                     ; SEND OUT AS HEX
8201 fa9d 05                         FCB     OUT4HS          ; FUNCTION
8202 fa9e 8d 17                      BSR     REGPRS          ; FOLLOW MEMORY WITH REGISTERS
8203 faa0 25 37                      BCS     ZBKCMD          ; BRANCH IF "CANCEL"
8204 faa2 06 8e                      ROR     <DELIM          ; RESTORE CARRY BIT
8205 faa4 25 33                      BCS     ZBKCMD          ; BRANCH IF "CANCEL"
8206 faa6 9e 91                      LDX     <TRACEC         ; LOAD TRACE COUNT
8207 faa8 27 2f                      BEQ     ZBKCMD          ; IF ZERO TO COMMAND HANDLER
8208 faaa 30 1f                      LEAX    -1,X            ; MINUS ONE
8209 faac 9f 91                      STX     <TRACEC         ; REFRESH
8210 faae 27 29                      BEQ     ZBKCMD          ; STOP TRACE WHEN ZERO
8211 fab0 8d aa                      BSR     CHKABT          ; ? ABORT THE TRACE
8212 fab2 25 25                      BCS     ZBKCMD          ; BRANCH YES TO COMMAND HANDLER
8213 fab4 16 03 f7           NMITRC  LBRA    CTRCE3          ; NO, TRACE ANOTHER INSTRUCTION
8214                         
8215 fab7 17 01 b9           REGPRS  LBSR    REGPRT          ; PRINT REGISTERS AS FROM COMMAND
8216 faba 39                         RTS                     ; RETURN TO CALLER
8217                         
8218                         * JUST EXECUTED THRU A BRKPNT. NOW CONTINUE NORMALLY
8219                         
8220 fabb 0f 8f              NMICON  CLR     <MISFLG        ; CLEAR THRU FLAG
8221 fabd 17 02 eb                   LBSR    ARMBK2         ; ARM BREAKPOINTS
8222 fac0 3b                 RTI     RTI                    ; AND CONTINUE USERS PROGRAM
8223                         
8224                         * LDDP - SETUP DIRECT PAGE REGISTER, VERIFY STACK.
8225                         * AN INVALID STACK CAUSES A RETURN TO THE COMMAND
8226                         * HANDLER.
8227                         * INPUT: FULLY STACKED REGISTERS FROM AN INTERRUPT
8228                         * OUTPUT: DPR LOADED TO WORK PAGE
8229                         
8230 fac1 3f 07 20 04        ERRMSG  FCB     '?,BELL,$20,EOT ; ERROR RESPONSE
8231                         
8232 fac5 e6 8d 75 d4        LDDP    LDB     BASEPG,PCR      ; LOAD DIRECT PAGE HIGH BYTE
8233 fac9 1f 9b                      TFR     B,DP            ; SETUP DIRECT PAGE REGISTER
8234 facb a1 63                      CMPA    3,S             ; ? IS STACK VALID
8235 facd 27 25                      BEQ     RTS             ; YES, RETURN
8236 facf 10 de 97                   LDS     <RSTACK         ; RESET TO INITIAL STACK POINTER
8237 fad2 30 8c ec           ERROR   LEAX    ERRMSG,PCR      ; LOAD ERROR REPORT
8238 fad5 3f                         SWI                     ; SEND OUT BEFORE REGISTERS
8239 fad6 03                         FCB     PDATA           ; ON NEXT LINE
8240                         * FALL INTO BREAKPOINT HANDLER
8241                         
8242                         **********************************************
8243                         * [SWI FUNCTION 10]
8244                         * BREAKPOINT PROGRAM FUNCTION
8245                         * PRINT REGISTERS AND GO TO COMMAND HANLER
8246                         ***********************************************
8247                         
8248 fad7 8d de              ZBKPNT  BSR     REGPRS          ; PRINT OUT REGISTERS
8249 fad9 16 fe 1d           ZBKCMD  LBRA    CMDNEP          ; NOW ENTER COMMAND HANDLER
8250                         
8251                         ********************************************
8252                         * IRQ, RESERVED, SWI2 AND SWI3 INTERRUPT HANDLERS
8253                         * THE DEFAULT HANDLING IS TO CAUSE A BREAKPOINT.
8254                         ********************************************
8255 fadc                    SWI2R   EQU     *               ; SWI2 ENTRY
8256 fadc                    SWI3R   EQU     *               ; SWI3 ENTRY
8257 fadc                    IRQR    EQU     *               ; IRQ ENTRY
8258 fadc 8d e7              RSRVDR  BSR     LDDP            ; SET BASE PAGE, VALIDATE STACK
8259 fade 20 f7                      BRA     ZBKPNT          ; FORCE A BREAKPOINT
8260                         
8261                         ******************************************
8262                         * FIRQ HANDLER
8263                         * JUST RETURN FOR THE FIRQ INTERRUPT
8264                         ******************************************
8265 fac0                    FIRQR   EQU     RTI             ; IMMEDIATE RETURN
8266                         
8267                         **************************************************
8268                         * DEFAULT I/O DRIVERS
8269                         **************************************************
8270                         * CIDTA - RETURN CONSOLE INPUT CHARACTER
8271                         * OUTPUT: C=0 IF NO DATA READY, C=1 A=CHARACTER
8272                         * U VOLATILE
8273                         
8274 fae0 de f0              CIDTA   LDU     <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
8275 fae2 a6 c4                      LDA     ,U              ; LOAD STATUS REGISTER
8276 fae4 44                         LSRA                    ; TEST RECEIVER REGISTER FLAG
8277 fae5 24 02                      BCC     CIRTN           ; RETURN IF NOTHING
8278 fae7 a6 41                      LDA     1,U             ; LOAD DATA BYTE
8279 fae9 39                 CIRTN   RTS                     ; RETURN TO CALLER
8280                         
8281                         * CION - INPUT CONSOLE INITIALIZATION
8282                         * COON - OUTPUT CONSOLE INITIALIZATION
8283                         * A,X VOLATILE
8284 faea                    CION   EQU      *
8285 faea 86 13              COON   LDA      #$13            ; RESET ACIA CODE
8286 faec 9e f0                     LDX      <VECTAB+.ACIA   ; LOAD ACIA ADDRESS
8287 faee a7 84                     STA      ,X              ; STORE INTO STATUS REGISTER
8288 faf0 86 15                     LDA      #$15            ; SET CONTROL
8289 faf2 a7 84                     STA      ,X              ; REGISTER UP
8290 faf4 39                 RTS    RTS                      ; RETURN TO CALLER
8291                         
8292                         * THE FOLLOWING HAVE NO DUTIES TO PERFORM
8293 faf4                    CIOFF EQU       RTS             ; CONSOLE INPUT OFF
8294 faf4                    COOFF EQU       RTS             ; CONSOLE OUTPUT OFF
8295                         
8296                         * CODTA - OUTPUT CHARACTER TO CONSOLE DEVICE
8297                         * INPUT: A=CHARACTER TO SEND
8298                         * OUTPUT: CHAR SENT TO TERMINAL WITH PROPER PADDING
8299                         * ALL REGISTERS TRANSPARENT
8300                         
8301 faf5 34 47              CODTA   PSHS    U,D,CC          ; SAVE REGISTERS,WORK BYTE
8302 faf7 de f0                      LDU     <VECTAB+.ACIA   ; ADDRESS ACIA
8303 faf9 8d 1b                      BSR     CODTAO          ; CALL OUTPUT CHAR SUBROUTINE
8304 fafb 81 10                      CMPA    #DLE            ; ? DATA LINE ESCAPE
8305 fafd 27 12                      BEQ     CODTRT          ; YES, RETURN
8306 faff d6 f2                      LDB     <VECTAB+.PAD    ; DEFAULT TO CHAR PAD COUNT
8307 fb01 81 0d                      CMPA    #CR             ; ? CR
8308 fb03 26 02                      BNE     CODTPD          ; BRANCH NO
8309 fb05 d6 f3                      LDB     <VECTAB+.PAD+1  ; LOAD NEW LINE PAD COUNT
8310 fb07 4f                 CODTPD  CLRA                    ; CREATE NULL
8311 fb08 e7 e4                      STB     ,S              ; SAVE COUNT
8312 fb0a 8c                         FCB     SKIP2           ; ENTER LOOP
8313 fb0b 8d 09              CODTLP  BSR     CODTAO          ; SEND NULL
8314 fb0d 6a e4                      DEC     ,S              ; ? FINISHED
8315 fb0f 2a fa                      BPL     CODTLP          ; NO, CONTINUE WITH MORE
8316 fb11 35 c7              CODTRT  PULS    PC,U,D,CC       ; RESTORE REGISTERS AND RETURN
8317                         
8318 fb13 17 ff 5c           CODTAD  LBSR    XQPAUS          ; TEMPORARY GIVE UP CONTROL
8319 fb16 e6 c4              CODTAO  LDB     ,U              ; LOAD ACIA CONTROL REGISTER
8320 fb18 c5 02                      BITB    #$02            ; ? TX REGISTER CLEAR >LSAB FIXME
8321 fb1a 27 f7                      BEQ     CODTAD          ; RELEASE CONTROL IF NOT
8322 fb1c a7 41                      STA     1,U             ; STORE INTO DATA REGISTER
8323 fb1e 39                         RTS                     ; RETURN TO CALLER
8324                         *E
8325                         
8326                         * BSON - TURN ON READ/VERIFY/PUNCH MECHANISM
8327                         * A IS VOLATILE
8328                         
8329 fb1f 86 11              BSON    LDA     #$11            ; SET READ CODE
8330 fb21 6d 66                      TST     6,S             ; ? READ OR VERIFY
8331 fb23 26 01                      BNE     BSON2           ; BRANCH YES
8332 fb25 4c                         INCA                    ; SET TO WRITE
8333 fb26 3f                 BSON2   SWI                     ; PERFORM OUTPUT
8334 fb27 01                         FCB     OUTCH           ; FUNCTION
8335 fb28 0c 8f                      INC     <MISFLG         ; SET LOAD IN PROGRESS FLAG
8336 fb2a 39                         RTS                     ; RETURN TO CALLER
8337                         
8338                         * BSOFF - TURN OFF READ/VERIFY/PUNCH MECHANISM
8339                         * A,X VOLATILE
8340                         
8341 fb2b 86 14              BSOFF   LDA     #$14            ; TO DC4 - STOP
8342 fb2d 3f                         SWI                     ; SEND OUT
8343 fb2e 01                         FCB     OUTCH           ; FUNCTION
8344 fb2f 4a                         DECA                    ; CHANGE TO DC3 (X-OFF)
8345 fb30 3f                         SWI                     ; SEND OUT
8346 fb31 01                         FCB     OUTCH           ; FUNCTION
8347 fb32 0a 8f                      DEC     <MISFLG         ; CLEAR LOAD IN PROGRESS FLAG
8348 fb34 8e 61 a8                   LDX     #25000          ; DELAY 1 SECOND (2MHZ CLOCK)
8349 fb37 30 1f              BSOFLP  LEAX    -1,X            ; COUNT DOWN
8350 fb39 26 fc                      BNE     BSOFLP          ; LOOP TILL DONE
8351 fb3b 39                         RTS                     ; RETURN TO CALLER
8352                         
8353                         * BSDTA - READ/VERIFY/PUNCH HANDLER
8354                         * INPUT: S+6=CODE BYTE, VERIFY(-1),PUNCH(0),LOAD(1)
8355                         * S+4=START ADDRESS
8356                         * S+2=STOP ADDRESS
8357                         * S+0=RETURN ADDRESS
8358                         * OUTPUT: Z=1 NORMAL COMPLETION, Z=0 INVALID LOAD/VER
8359                         * REGISTERS ARE VOLATILE
8360 fb3c ee 62              BSDTA   LDU     2,S             ; U=TO ADDRESS OR OFFSET
8361 fb3e 6d 66                      TST     6,S             ; ? PUNCH
8362 fb40 27 54                      BEQ     BSDPUN          ; BRANCH YES
8363                         
8364                         * DURING READ/VERIFY: S+2=MSB ADDRESS SAVE BYTE
8365                         * S+1=BYTE COUNTER
8366                         * S+0=CHECKSUM
8367                         * U HOLDS OFFSET
8368 fb42 32 7d                      LEAS    -3,S            ; ROOM FOR WORK/COUNTER/CHECKSUM
8369 fb44 3f                 BSDLD1  SWI                     ; GET NEXT CHARACTER
8370 fb45 00                         FCB     INCHNP          ; FUNCTION
8371 fb46 81 53              BSDLD2  CMPA    #'S             ; ? START OF S1/S9
8372 fb48 26 fa                      BNE     BSDLD1          ; BRANCH NOT
8373 fb4a 3f                         SWI                     ; GET NEXT CHARACTER
8374 fb4b 00                         FCB     INCHNP          ; FUNCTION
8375 fb4c 81 39                      CMPA    #'9             ; ? HAVE S9
8376 fb4e 27 22                      BEQ     BSDSRT          ; YES, RETURN GOOD CODE
8377 fb50 81 31                      CMPA    #'1             ; ? HAVE NEW RECORD
8378 fb52 26 f2                      BNE     BSDLD2          ; BRANCH IF NOT
8379 fb54 6f e4                      CLR     ,S              ; CLEAR CHECKSUM
8380 fb56 8d 21                      BSR     BYTE            ; OBTAIN BYTE COUNT
8381 fb58 e7 61                      STB     1,S             ; SAVE FOR DECREMENT
8382                         
8383                         * READ ADDRESS
8384 fb5a 8d 1d                      BSR     BYTE            ; OBTAIN HIGH VALUE
8385 fb5c e7 62                      STB     2,S             ; SAVE IT
8386 fb5e 8d 19                      BSR     BYTE            ; OBTAIN LOW VALUE
8387 fb60 a6 62                      LDA     2,S             ; MAKE D=VALUE
8388 fb62 31 cb                      LEAY    D,U             ; Y=ADDRESS+OFFSET
8389                         * STORE TEXT
8390 fb64 8d 13              BSDNXT  BSR     BYTE            ; NEXT BYTE
8391 fb66 27 0c                      BEQ     BSDEOL          ; BRANCH IF CHECKSUM
8392 fb68 6d 69                      TST     9,S             ; ? VERIFY ONLY
8393 fb6a 2b 02                      BMI     BSDCMP          ; YES, ONLY COMPARE
8394 fb6c e7 a4                      STB     ,Y              ; STORE INTO MEMORY
8395 fb6e e1 a0              BSDCMP  CMPB    ,Y+             ; ? VALID RAM
8396 fb70 27 f2                      BEQ     BSDNXT          ; YES, CONTINUE READING
8397 fb72 35 92              BSDSRT  PULS    PC,X,A          ; RETURN WITH Z SET PROPER
8398 fb74 4c                 BSDEOL  INCA                    ; ? VALID CHECKSUM
8399 fb75 27 cd                      BEQ     BSDLD1          ; BRANCH YES
8400 fb77 20 f9                      BRA     BSDSRT          ; RETURN Z=0 INVALID
8401                         
8402                         * BYTE BUILDS 8 BIT VALUE FROM TWO HEX DIGITS IN
8403 fb79 8d 12              BYTE    BSR     BYTHEX         ; OBTAIN FIRST HEX
8404 fb7b c6 10                      LDB     #16            ; PREPARE SHIFT
8405 fb7d 3d                         MUL                    ; OVER TO A
8406 fb7e 8d 0d                      BSR     BYTHEX         ; OBTAIN SECOND HEX
8407 fb80 34 04                      PSHS    B              ; SAVE HIGH HEX
8408 fb82 ab e0                      ADDA    ,S+            ; COMBINE BOTH SIDES
8409 fb84 1f 89                      TFR     A,B            ; SEND BACK IN B
8410 fb86 ab 62                      ADDA    2,S            ; COMPUTE NEW CHECKSUM
8411 fb88 a7 62                      STA     2,S            ; STORE BACK
8412 fb8a 6a 63                      DEC     3,S            ; DECREMENT BYTE COUNT
8413 fb8c 39                 BYTRTS  RTS                    ; RETURN TO CALLER
8414                         
8415 fb8d 3f                 BYTHEX  SWI                    ; GET NEXT HEX
8416 fb8e 00                         FCB     INCHNP         ; CHARACTER
8417 fb8f 17 01 d4                   LBSR    CNVHEX         ; CONVERT TO HEX
8418 fb92 27 f8                      BEQ     BYTRTS         ; RETURN IF VALID HEX
8419 fb94 35 f2                      PULS    PC,U,Y,X,A     ; RETURN TO CALLER WITH Z=0
8420                         
8421                         * PUNCH STACK USE: S+8=TO ADDRESS
8422                         *                  S+6=RETURN ADDRESS
8423                         *                  S+4=SAVED PADDING VALUES
8424                         *                  S+2 FROM ADDRESS
8425                         *                  S+1=FRAME COUNT/CHECKSUM
8426                         *                  S+0=BYTE COUNT
8427                         
8428 fb96 de f2              BSDPUN  LDU     <VECTAB+.PAD    ; LOAD PADDING VALUES
8429 fb98 ae 64                      LDX     4,S             ; X=FROM ADDRESS
8430 fb9a 34 56                      PSHS    U,X,D           ; CREATE STACK WORK AREA
8431 fb9c cc 00 18                   LDD     #24             ; SET A=0, B=24
8432 fb9f d7 f2                      STB     <VECTAB+.PAD    ; SETUP 24 CHARACTER PADS
8433 fba1 3f                         SWI                     ; SEND NULLS OUT
8434 fba2 01                         FCB     OUTCH           ; FUNCTION
8435 fba3 c6 04                      LDB     #4              ; SETUP NEW LINE PAD TO 4
8436 fba5 dd f2                      STD     <VECTAB+.PAD    ; SETUP PUNCH PADDING
8437                         * CALCULATE SIZE
8438 fba7 ec 68              BSPGO   LDD     8,S             ; LOAD TO
8439 fba9 a3 62                      SUBD    2,S             ; MINUS FROM=LENGTH
8440 fbab 10 83 00 18                CMPD    #24             ; ? MORE THAN 23
8441 fbaf 25 02                      BLO     BSPOK           ; NO, OK
8442 fbb1 c6 17                      LDB     #23             ; FORCE TO 23 MAX
8443 fbb3 5c                 BSPOK   INCB                    ; PREPARE COUNTER
8444 fbb4 e7 e4                      STB     ,S              ; STORE BYTE COUNT
8445 fbb6 cb 03                      ADDB    #3              ; ADJUST TO FRAME COUNT
8446 fbb8 e7 61                      STB     1,S             ; SAVE
8447                         
8448                         *PUNCH CR,LF,NULS,S,1
8449 fbba 30 8c 33                  LEAX     <BSPSTR,PCR     ; LOAD START RECORD HEADER
8450 fbbd 3f                        SWI                      ; SEND OUT
8451 fbbe 03                        FCB      PDATA           ; FUNCTION
8452                         * SEND FRAME COUNT
8453 fbbf 5f                        CLRB                     ; INITIALIZE CHECKSUM
8454 fbc0 30 61                     LEAX     1,S             ; POINT TO FRAME COUNT AND ADDR
8455 fbc2 8d 27                     BSR      BSPUN2          ; SEND FRAME COUNT
8456                         *DATA ADDRESS
8457 fbc4 8d 25                    BSR       BSPUN2          ; SEND ADDRESS HI
8458 fbc6 8d 23                    BSR       BSPUN2          ; SEND ADDRESS LOW
8459                         *PUNCH DATA
8460 fbc8 ae 62                     LDX      2,S             ; LOAD START DATA ADDRESS
8461 fbca 8d 1f              BSPMRE BSR      BSPUN2          ; SEND OUT NEXT BYTE
8462 fbcc 6a e4                     DEC      ,S              ; ? FINAL BYTE
8463 fbce 26 fa                     BNE      BSPMRE          ; LOOP IF NOT DONE
8464 fbd0 af 62                     STX      2,S             ; UPDATE FROM ADDRESS VALUE
8465                         *PUNCH CHECKSUM
8466 fbd2 53                        COMB                     ; COMPLEMENT
8467 fbd3 e7 61                     STB      1,S             ; STORE FOR SENDOUT
8468 fbd5 30 61                     LEAX     1,S             ; POINT TO IT
8469 fbd7 8d 14                     BSR      BSPUNC          ; SEND OUT AS HEX
8470 fbd9 ae 68                     LDX      8,S             ; LOAD TOP ADDRESS
8471 fbdb ac 62                     CMPX     2,S             ; ? DONE
8472 fbdd 24 c8                     BHS      BSPGO           ; BRANCH NOT
8473 fbdf 30 8c 11                  LEAX     <BSPEOF,PCR     ; PREPARE END OF FILE
8474 fbe2 3f                        SWI                      ; SEND OUT STRING
8475 fbe3 03                        FCB      PDATA           ; FUNCTION
8476 fbe4 ec 64                     LDD      4,S             ; RECOVER PAD COUNTS
8477 fbe6 dd f2                     STD      <VECTAB+.PAD    ; RESTORE
8478 fbe8 4f                        CLRA                     ; SET Z=1 FOR OK RETURN
8479 fbe9 35 d6                     PULS     PC,U,X,D        ; RETURN WITH OK CODE
8480 fbeb eb 84              BSPUN2 ADDB     ,X              ; ADD TO CHECKSUM
8481 fbed 16 fd ed           BSPUNC LBRA     ZOUT2H          ; SEND OUT AS HEX AND RETURN
8482                         
8483 fbf0 53 01 04           BSPSTR FCB      'S,1,EOT        ; CR,LF,NULLS,S,1
8484 fbf3 53 39 30 33 30 30  BSPEOF FCC      /S9030000FC/         ; EOF STRING
     30 30 46 43
8485 fbfd 0d 0a 04                  FCB      CR,LF,EOT
8486                         
8487                         * HSDTA - HIGH SPEED PRINT MEMORY
8488                         * INPUT: S+4=START ADDRESS
8489                         * S+2=STOP ADDRESS
8490                         * S+0=RETURN ADDRESS
8491                         * X,D VOLATILE
8492                         
8493                         * SEND TITLE
8494                         
8495 fc00 3f                 HSDTA   SWI                     ; SEND NEW LINE
8496 fc01 06                         FCB     PCRLF           ; FUNCTION
8497 fc02 c6 06                      LDB     #6              ; PREPARE 6 SPACES
8498 fc04 3f                 HSBLNK  SWI                     ; SEND BLANK
8499 fc05 07                         FCB     SPACEF          ; FUNCTION
8500 fc06 5a                         DECB                    ; COUNT DOWN
8501 fc07 26 fb                      BNE     HSBLNK          ; LOOP IF MORE
8502 fc09 5f                         CLRB                    ; SETUP BYTE COUNT
8503 fc0a 1f 98              HSHTTL  TFR     B,A             ; PREPARE FOR CONVERT
8504 fc0c 17 fd db                   LBSR    ZOUTHX          ; CONVERT TO A HEX DIGIT
8505 fc0f 3f                         SWI                     ; SEND BLANK
8506 fc10 07                         FCB     SPACEF          ; FUNCTION
8507 fc11 3f                         SWI                     ; SEND ANOTHER
8508 fc12 07                         FCB     SPACEF          ; BLANK
8509 fc13 5c                         INCB                    ; UP ANOTHER
8510 fc14 c1 10                      CMPB    #$10            ; ? PAST 'F'
8511 fc16 25 f2                      BLO     HSHTTL          ; LOOP UNTIL SO
8512 fc18 3f                 HSHLNE  SWI                     ; TO NEXT LINE
8513 fc19 06                         FCB     PCRLF           ; FUNCTION
8514 fc1a 25 2f                      BCS     HSDRTN          ; RETURN IF USER ENTERED CTL-X
8515 fc1c 30 64                      LEAX    4,S             ; POINT AT ADDRESS TO CONVERT
8516 fc1e 3f                         SWI                     ; PRINT OUT ADDRESS
8517 fc1f 05                         FCB     OUT4HS          ; FUNCTION
8518 fc20 ae 64                      LDX     4,S             ; LOAD ADDRESS PROPER
8519 fc22 c6 10                      LDB     #16             ; NEXT SIXTEEN
8520 fc24 3f                 HSHNXT  SWI                     ; CONVERT BYTE TO HEX AND SEND
8521 fc25 04                         FCB     OUT2HS          ; FUNCTION
8522 fc26 5a                         DECB                    ; COUNT DOWN
8523 fc27 26 fb                      BNE     HSHNXT          ; LOOP IF NOT SIXTEENTH
8524 fc29 3f                         SWI                     ; SEND BLANK
8525 fc2a 07                         FCB     SPACEF          ; FUNCTION
8526 fc2b ae 64                      LDX     4,S             ; RELOAD FROM ADDRESS
8527 fc2d c6 10                      LDB     #16             ; COUNT
8528 fc2f a6 80              HSHCHR  LDA     ,X+             ; NEXT BYTE
8529 fc31 2b 04                      BMI     HSHDOT          ; TOO LARGE, TO A DOT
8530 fc33 81 20                      CMPA    #'              ; ? LOWER THAN A BLANK
8531 fc35 24 02                      BHS     HSHCOK          ; NO, BRANCH OK
8532 fc37 86 2e              HSHDOT  LDA     #'.             ; CONVERT INVALID TO A BLANK
8533 fc39 3f                 HSHCOK  SWI                     ; SEND CHARACTER
8534 fc3a 01                         FCB     OUTCH           ; FUNCTION
8535 fc3b 5a                         DECB                    ; ? DONE
8536 fc3c 26 f1                      BNE     HSHCHR          ; BRANCH NO
8537 fc3e ac 62                      CPX     2,S             ; ? PAST LAST ADDRESS
8538 fc40 24 09                      BHS     HSDRTN          ; QUIT IF SO
8539 fc42 af 64                      STX     4,S             ; UPDATE FROM ADDRESS
8540 fc44 a6 65                      LDA     5,S             ; LOAD LOW BYTE ADDRESS
8541 fc46 48                         ASLA                    ; ? TO SECTION BOUNDARY
8542 fc47 26 cf                      BNE     HSHLNE          ; BRANCH IF NOT
8543 fc49 20 b5                      BRA     HSDTA           ; BRANCH IF SO
8544 fc4b 3f                 HSDRTN  SWI                     ; SEND NEW LINE
8545 fc4c 06                         FCB     PCRLF           ; FUNCTION
8546 fc4d 39                         RTS                     ; RETURN TO CALLER
8547                         *F
8548                         
8549                         ***********************************************
8550                         *     A S S I S T 0 9    C O M M A N D S
8551                         ***********************************************
8552                         
8553                         *************REGISTERS - DISPLAY AND CHANGE REGISTERS
8554 fc4e 8d 23              CREG    BSR     REGPRT          ; PRINT REGISTERS
8555 fc50 4c                         INCA                    ; SET FOR CHANGE FUNCTION
8556 fc51 8d 21                      BSR     REGCHG          ; GO CHANGE, DISPLAY REGISTERS
8557 fc53 39                         RTS                     ; RETURN TO COMMAND PROCESSOR
8558                         
8559                         ********************************************
8560                         * REGPRT - PRINT/CHANGE REGISTERS SUBROUTINE
8561                         * WILL ABORT TO 'CMDBAD' IF OVERFLOW DETECTED DURING
8562                         * A CHANGE OPERATION. CHANGE DISPLAYS REGISTERS WHEN
8563                         * DONE.
8564                         
8565                         * REGISTER MASK LIST CONSISTS OF:
8566                         * A) CHARACTERS DENOTING REGISTER
8567                         * B) ZERO FOR ONE BYTE, -1 FOR TWO
8568                         * C) OFFSET ON STACK TO REGISTER POSITION
8569                         * INPUT: SP+4=STACKED REGISTERS
8570                         * A=0 PRINT, A#0 PRINT AND CHANGE
8571                         * OUTPUT: (ONLY FOR REGISTER DISPLAY)
8572                         * C=1 CONTROL-X ENTERED, C=0 OTHERWISE
8573                         * VOLATILE: D,X (CHANGE)
8574                         * B,X (DISPLAY)
8575                         *******************************************
8576                         
8577 fc54 50 43 ff 13        REGMSK  FCB     'P,'C,-1,19     ; PC REG
8578 fc58 41 00 0a                   FCB     'A,0,10         ; A REG
8579 fc5b 42 00 0b                   FCB     'B,0,11         ; B REG
8580 fc5e 58 ff 0d                   FCB     'X,-1,13        ; X REG
8581 fc61 59 ff 0f                   FCB     'Y,-1,15        ; Y REG
8582 fc64 55 ff 11                   FCB     'U,-1,17        ; U REG
8583 fc67 53 ff 01                   FCB     'S,-1,1         ; S REG
8584 fc6a 43 43 00 09                FCB     'C,'C,0,9       ; CC REG
8585 fc6e 44 50 00 0c                FCB     'D,'P,0,12      ; DP REG
8586 fc72 00                         FCB     0               ; END OF LIST
8587                         
8588 fc73 4f                 REGPRT  CLRA                    ; SETUP PRINT ONLY FLAG
8589 fc74 30 e8 10           REGCHG  LEAX    4+12,S          ; READY STACK VALUE
8590 fc77 34 32                      PSHS    Y,X,A           ; SAVE ON STACK WITH OPTION
8591 fc79 31 8c d8                   LEAY    REGMSK,PCR      ; LOAD REGISTER MASK
8592 fc7c ec a0              REGP1   LDD     ,Y+             ; LOAD NEXT CHAR OR <=0
8593 fc7e 4d                         TSTA                    ; ? END OF CHARACTERS
8594 fc7f 2f 04                      BLE     REGP2           ; BRANCH NOT CHARACTER
8595 fc81 3f                         SWI                     ; SEND TO CONSOLE
8596 fc82 01                         FCB     OUTCH           ; FUNCTION BYTE
8597 fc83 20 f7                      BRA     REGP1           ; CHECK NEXT
8598 fc85 86 2d              REGP2   LDA     #'-             ; READY '-'
8599 fc87 3f                         SWI                     ; SEND OUT
8600 fc88 01                         FCB     OUTCH           ; WITH OUTCH
8601 fc89 30 e5                      LEAX    B,S             ; X->REGISTER TO PRINT
8602 fc8b 6d e4                      TST     ,S              ; ? CHANGE OPTION
8603 fc8d 26 12                      BNE     REGCNG          ; BRANCH YES
8604 fc8f 6d 3f                      TST     -1,Y            ; ? ONE OR TWO BYTES
8605 fc91 27 03                      BEQ     REGP3           ; BRANCH ZERO MEANS ONE
8606 fc93 3f                         SWI                     ; PERFORM WORD HEX
8607 fc94 05                         FCB     OUT4HS          ; FUNCTION
8608 fc95 8c                         FCB     SKIP2           ; SKIP BYTE PRINT
8609 fc96 3f                 REGP3   SWI                     ; PERFORM BYTE HEX
8610 fc97 04                         FCB     OUT2HS          ; FUNCTION
8611 fc98 ec a0              REG4    LDD     ,Y+             ; TO FRONT OF NEXT ENTRY
8612 fc9a 5d                         TSTB                    ; ? END OF ENTRIES
8613 fc9b 26 df                      BNE     REGP1           ; LOOP IF MORE
8614 fc9d 3f                         SWI                     ; FORCE NEW LINE
8615 fc9e 06                         FCB     PCRLF           ; FUNCTION
8616 fc9f 35 b2              REGRTN  PULS    PC,Y,X,A        ; RESTORE STACK AND RETURN
8617                         
8618 fca1 8d 40              REGCNG  BSR     BLDNNB          ; INPUT BINARY NUMBER
8619 fca3 27 10                      BEQ     REGNXC          ; IF CHANGE THEN JUMP
8620 fca5 81 0d                      CMPA    #CR             ; ? NO MORE DESIRED
8621 fca7 27 1e                      BEQ     REGAGN          ; BRANCH NOPE
8622 fca9 e6 3f                      LDB     -1,Y            ; LOAD SIZE FLAG
8623 fcab 5a                         DECB                    ; MINUS ONE
8624 fcac 50                         NEGB                    ; MAKE POSITIVE
8625 fcad 58                         ASLB                    ; TIMES TWO (=2 OR =4)
8626 fcae 3f                 REGSKP  SWI                     ; PERFORM SPACES
8627 fcaf 07                         FCB     SPACEF          ; FUNCTION
8628 fcb0 5a                         DECB
8629 fcb1 26 fb                      BNE     REGSKP          ; LOOP IF MORE
8630 fcb3 20 e3                      BRA     REG4            ; CONTINUE WITH NEXT REGISTER
8631 fcb5 a7 e4              REGNXC  STA     ,S              ; SAVE DELIMITER IN OPTION
8632                         *                               ; (ALWAYS > 0)
8633 fcb7 dc 9b                      LDD     <NUMBER         ; OBTAIN BINARY RESULT
8634 fcb9 6d 3f                      TST     -1,Y            ; ? TWO BYTES WORTH
8635 fcbb 26 02                      BNE     REGTWO          ; BRANCH YES
8636 fcbd a6 82                      LDA     ,-X             ; SETUP FOR TWO
8637 fcbf ed 84              REGTWO  STD     ,X              ; STORE IN NEW VALUE
8638 fcc1 a6 e4                      LDA     ,S              ; RECOVER DELIMITER
8639 fcc3 81 0d                      CMPA    #CR             ; ? END OF CHANGES
8640 fcc5 26 d1                      BNE     REG4            ; NO, KEEP ON TRUCK'N
8641                         * MOVE STACKED DATA TO NEW STACK IN CASE STACK
8642                         * POINTER HAS CHANGED
8643 fcc7 30 8d 73 86        REGAGN  LEAX    TSTACK,PCR      ; LOAD TEMP AREA
8644 fccb c6 15                      LDB     #21             ; LOAD COUNT
8645 fccd 35 02              REGTF1  PULS    A               ; NEXT BYTE
8646 fccf a7 80                      STA     ,X+             ; STORE INTO TEMP
8647 fcd1 5a                         DECB                    ; COUNT DOWN
8648 fcd2 26 f9                      BNE     REGTF1          ; LOOP IF MORE
8649 fcd4 10 ee 88 ec                LDS     -20,X           ; LOAD NEW STACK POINTER
8650 fcd8 c6 15                      LDB     #21             ; LOAD COUNT AGAIN
8651 fcda a6 82              REGTF2 LDA      ,-X             ; NEXT TO STORE
8652 fcdc 34 02                     PSHS     A               ; BACK ONTO NEW STACK
8653 fcde 5a                        DECB                     ; COUNT DOWN
8654 fcdf 26 f9                     BNE      REGTF2          ; LOOP IF MORE
8655 fce1 20 bc                     BRA      REGRTN          ; GO RESTART COMMAND
8656                         
8657                         *********************************************
8658                         * BLDNUM - BUILDS BINARY VALUE FROM INPUT HEX
8659                         * THE ACTIVE EXPRESSION HANDLER IS USED.
8660                         * INPUT: S=RETURN ADDRESS
8661                         * OUTPUT: A=DELIMITER WHICH TERMINATED VALUE
8662                         * (IF DELM NOT ZERO)
8663                         * "NUMBER"=WORD BINARY RESULT
8664                         * Z=1 IF INPUT RECEIVED, Z=0 IF NO HEX RECEIVED
8665                         * REGISTERS ARE TRANSPARENT
8666                         **********************************************
8667                         * EXECUTE SINGLE OR EXTENDED ROM EXPRESSION HANDLER
8668                         *
8669                         * THE FLAG "DELIM" IS USED AS FOLLOWS:
8670                         * DELIM=0 NO LEADING BLANKS, NO FORCED TERMINATOR
8671                         * DELIM=CHR ACCEPT LEADING 'CHR'S, FORCED TERMINATOR
8672 fce3 4f                 BLDNNB  CLRA                    ; NO DYNAMIC DELIMITER
8673 fce4 8c                         FCB     SKIP2           ; SKIP NEXT INSTRUCTION
8674                         * BUILD WITH LEADING BLANKS
8675 fce5 86 20              BLDNUM  LDA     #'              ; ALLOW LEADING BLANKS
8676 fce7 97 8e                      STA     <DELIM          ; STORE AS DELIMITER
8677 fce9 6e 9d 73 ff                JMP     [VECTAB+.EXPAN,PCR]   ; TO EXP ANALYZER
8678                         * THIS IS THE DEFAULT SINGLE ROM ANALYZER. WE ACCEPT:
8679                         * 1) HEX INPUT
8680                         * 2) 'M' FOR LAST MEMORY EXAMINE ADDRESS
8681                         * 3) 'P' FOR PROGRAM COUNTER ADDRESS
8682                         * 4) 'W' FOR WINDOW VALUE
8683                         * 5) '@' FOR INDIRECT VALUE
8684                         
8685 fced 34 14              EXP1    PSHS    X,B             ; SAVE REGISTERS
8686 fcef 8d 5c              EXPDLM  BSR     BLDHXI          ; CLEAR NUMBER, CHECK FIRST CHAR
8687 fcf1 27 18                      BEQ     EXP2            ; IF HEX DIGIT CONTINUE BUILDING
8688                         * SKIP BLANKS IF DESIRED
8689 fcf3 91 8e                      CMPA    <DELIM          ; ? CORRECT DELIMITER
8690 fcf5 27 f8                      BEQ     EXPDLM          ; YES, IGNORE IT
8691                         * TEST FOR M OR P
8692 fcf7 9e 9e                      LDX     <ADDR           ; DEFAULT FOR 'M'
8693 fcf9 81 4d                      CMPA    #'M             ; ? MEMORY EXAMINE ADDR WANTED
8694 fcfb 27 16                      BEQ     EXPTDL          ; BRANCH IF SO
8695 fcfd 9e 93                      LDX     <PCNTER         ; DEFAULT FOR 'P'
8696 fcff 81 50                      CMPA    #'P             ; ? LAST PROGRAM COUNTER WANTED
8697 fd01 27 10                      BEQ     EXPTDL          ; BRANCH IF SO
8698 fd03 9e a0                      LDX     <WINDOW         ; DEFAULT TO WINDOW
8699 fd05 81 57                      CMPA    #'W             ; ? WINDOW WANTED
8700 fd07 27 0a                      BEQ     EXPTDL
8701                         
8702 fd09 35 94              EXPRTN  PULS    PC,X,B          ; RETURN AND RESTORE REGISTERS
8703                         * GOT HEX, NOW CONTINUE BUILDING
8704 fd0b 8d 44              EXP2    BSR     BLDHEX          ; COMPUTE NEXT DIGIT
8705 fd0d 27 fc                      BEQ     EXP2            ; CONTINUE IF MORE
8706 fd0f 20 0a                      BRA     EXPCDL          ; SEARCH FOR +/-
8707                         * STORE VALUE AND CHECK IF NEED DELIMITER
8708 fd11 ae 84              EXPTDI  LDX     ,X              ; INDIRECTION DESIRED
8709 fd13 9f 9b              EXPTDL  STX     <NUMBER         ; STORE RESULT
8710 fd15 0d 8e                      TST     <DELIM          ; ? TO FORCE A DELIMITER
8711 fd17 27 f0                      BEQ     EXPRTN          ; RETURN IF NOT WITH VALUE
8712 fd19 8d 62                      BSR     READC           ; OBTAIN NEXT CHARACTER
8713                         * TEST FOR + OR -
8714 fd1b 9e 9b              EXPCDL  LDX     <NUMBER         ; LOAD LAST VALUE
8715 fd1d 81 2b                      CMPA    #'+             ; ? ADD OPERATOR
8716 fd1f 26 0e                      BNE     EXPCHM          ; BRANCH NOT
8717 fd21 8d 23                      BSR     EXPTRM          ; COMPUTE NEXT TERM
8718 fd23 34 02                      PSHS    A               ; SAVE DELIMITER
8719 fd25 dc 9b                      LDD     <NUMBER         ; LOAD NEW TERM
8720 fd27 30 8b              EXPADD  LEAX    D,X             ; ADD TO X
8721 fd29 9f 9b                      STX     <NUMBER         ; STORE AS NEW RESULT
8722 fd2b 35 02                      PULS    A               ; RESTORE DELIMITER
8723 fd2d 20 ec                      BRA     EXPCDL          ; NOW TEST IT
8724 fd2f 81 2d              EXPCHM  CMPA    #'-             ; ? SUBTRACT OPERATOR
8725 fd31 27 07                      BEQ     EXPSUB          ; BRANCH IF SO
8726 fd33 81 40                      CMPA    #'@             ; ? INDIRECTION DESIRED
8727 fd35 27 da                      BEQ     EXPTDI          ; BRANCH IF SO
8728 fd37 5f                         CLRB                    ; SET DELIMITER RETURN
8729 fd38 20 cf                      BRA     EXPRTN          ; AND RETURN TO CALLER
8730 fd3a 8d 0a              EXPSUB  BSR     EXPTRM          ; OBTAIN NEXT TERM
8731 fd3c 34 02                      PSHS    A               ; SAVE DELIMITER
8732 fd3e dc 9b                      LDD     <NUMBER         ; LOAD UP NEXT TERM
8733 fd40 40                         NEGA                    ; NEGATE A
8734 fd41 50                         NEGB                    ; NEGATE B
8735 fd42 82 00                      SBCA    #0              ; CORRECT FOR A
8736 fd44 20 e1                      BRA     EXPADD          ; GO ADD TO EXPRESSION
8737                         * COMPUTE NEXT EXPRESSION TERM
8738                         * OUTPUT: X=OLD VALUE
8739                         * 'NUMBER'=NEXT TERM
8740 fd46 8d 9d              EXPTRM  BSR     BLDNUM          ; OBTAIN NEXT VALUE
8741 fd48 27 32                      BEQ     CNVRTS          ; RETURN IF VALID NUMBER
8742 fd4a 16 fc 0f           BLDBAD  LBRA    CMDBAD          ; ABORT COMMAND IF INVALID
8743                         
8744                         *********************************************
8745                         * BUILD BINARY VALUE USING INPUT CHARACTERS.
8746                         * INPUT: A=ASCII HEX VALUE OR DELIMITER
8747                         * SP+0=RETURN ADDRESS
8748                         * SP+2=16 BIT RESULT AREA
8749                         * OUTPUT: Z=1 A=BINARY VALUE
8750                         * Z=0 IF INVALID HEX CHARACTER (A UNCHANGED)
8751                         * VOLATILE: D
8752                         ****************************************
8753 fd4d 0f 9b              BLDHXI  CLR     <NUMBER         ; CLEAR NUMBER
8754 fd4f 0f 9c                      CLR     <NUMBER+1       ; CLEAR NUMBER
8755 fd51 8d 2a              BLDHEX  BSR     READC           ; GET INPUT CHARACTER
8756 fd53 8d 11              BLDHXC  BSR     CNVHEX          ; CONVERT AND TEST CHARACTER
8757 fd55 26 25                      BNE     CNVRTS          ; RETURN IF NOT A NUMBER
8758 fd57 c6 10                      LDB     #16             ; PREPARE SHIFT
8759 fd59 3d                         MUL                     ; BY FOUR PLACES
8760 fd5a 86 04                      LDA     #4              ; ROTATE BINARY INTO VALUE
8761 fd5c 58                 BLDSHF  ASLB                    ; OBTAIN NEXT BIT
8762 fd5d 09 9c                      ROL     <NUMBER+1       ; INTO LOW BYTE
8763 fd5f 09 9b                      ROL     <NUMBER         ; INTO HI BYTE
8764 fd61 4a                         DECA                    ; COUNT DOWN
8765 fd62 26 f8                      BNE     BLDSHF          ; BRANCH IF MORE TO DO
8766 fd64 20 14                      BRA     CNVOK           ; SET GOOD RETURN CODE
8767                         
8768                         ****************************************
8769                         * CONVERT ASCII CHARACTER TO BINARY BYTE
8770                         * INPUT: A=ASCII
8771                         * OUTPUT: Z=1 A=BINARY VALUE
8772                         * Z=0 IF INVALID
8773                         * ALL REGISTERS TRANSPARENT
8774                         * (A UNALTERED IF INVALID HEX)
8775                         **************************************
8776 fd66 81 30              CNVHEX  CMPA    #'0             ; ? LOWER THAN A ZERO
8777 fd68 25 12                      BLO     CNVRTS          ; BRANCH NOT VALUE
8778 fd6a 81 39                      CMPA    #'9             ; ? POSSIBLE A-F
8779 fd6c 2f 0a                      BLE     CNVGOT          ; BRANCH NO TO ACCEPT
8780 fd6e 81 41                      CMPA    #'A             ; ? LESS THEN TEN
8781 fd70 25 0a                      BLO     CNVRTS          ; RETURN IF MINUS (INVALID)
8782 fd72 81 46                      CMPA    #'F             ; ? NOT TOO LARGE
8783 fd74 22 06                      BHI     CNVRTS          ; NO, RETURN TOO LARGE
8784 fd76 80 07                      SUBA    #7              ; DOWN TO BINARY
8785 fd78 84 0f              CNVGOT  ANDA    #$0F            ; CLEAR HIGH HEX
8786 fd7a 1a 04              CNVOK   ORCC    #4              ; FORCE ZERO ON FOR VALID HEX
8787 fd7c 39                 CNVRTS  RTS                     ; RETURN TO CALLER
8788                         
8789                         * GET INPUT CHAR, ABORT COMMAND IF CONTROL-X (CANCEL)
8790 fd7d 3f                 READC    SWI                    ; GET NEXT CHARACTER
8791 fd7e 00                          FCB    INCHNP          ; FUNCTION
8792 fd7f 81 18                       CMPA   #CAN            ; ? ABORT COMMAND
8793 fd81 27 c7                       BEQ    BLDBAD          ; BRANCH TO ABORT IF SO
8794 fd83 39                          RTS                    ; RETURN TO CALLER
8795                         *G
8796                         
8797                         ***************GO - START PROGRAM EXECUTION
8798 fd84 8d 01              CGO      BSR    GOADDR          ; BUILD ADDRESS IF NEEDED
8799 fd86 3b                          RTI                    ; START EXECUTING
8800                         
8801                         * FIND OPTIONAL NEW PROGRAM COUNTER. ALSO ARM THE
8802                         * BREAKPOINTS.
8803 fd87 35 30              GOADDR   PULS   Y,X             ; RECOVER RETURN ADDRESS
8804 fd89 34 10                       PSHS   X               ; STORE RETURN BACK
8805 fd8b 26 19                       BNE    GONDFT          ; IF NO CARRIAGE RETURN THEN NEW PC
8806                         
8807                         * DEFAULT PROGRAM COUNTER, SO FALL THROUGH IF
8808                         * IMMEDIATE BREAKPOINT.
8809 fd8d 17 01 b6                    LBSR   CBKLDR          ; SEARCH BREAKPOINTS
8810 fd90 ae 6c                       LDX    12,S            ; LOAD PROGRAM COUNTER
8811 fd92 5a                 ARMBLP  DECB                    ; COUNT DOWN
8812 fd93 2b 16                      BMI     ARMBK2          ; DONE, NONE TO SINGLE TRACE
8813 fd95 a6 30                      LDA     -NUMBKP*2,Y     ; PRE-FETCH OPCODE
8814 fd97 ac a1                      CMPX    ,Y++            ; ? IS THIS A BREAKPOINT
8815 fd99 26 f7                      BNE     ARMBLP          ; LOOP IF NOT
8816 fd9b 81 3f                      CMPA    #$3F            ; ? SWI BREAKPOINTED
8817 fd9d 26 02                      BNE     ARMNSW          ; NO, SKIP SETTING OF PASS FLAG
8818 fd9f 97 fb                      STA     <SWIBFL         ; SHOW UPCOMING SWI NOT BRKPNT
8819 fda1 0c 8f              ARMNSW  INC     <MISFLG         ; FLAG THRU A BREAKPOINT
8820 fda3 16 01 06                   LBRA    CDOT            ; DO SINGLE TRACE W/O BREAKPOINTS
8821                         
8822                         * OBTAIN NEW PROGRAM COUNTER
8823 fda6 17 00 bb           GONDFT  LBSR    CDNUM           ; OBTAIN NEW PROGRAM COUNTER
8824 fda9 ed 6c                      STD     12,S            ; STORE INTO STACK
8825 fdab 17 01 98           ARMBK2  LBSR    CBKLDR          ; OBTAIN TABLE
8826 fdae 00 fa                      NEG     <BKPTCT         ; COMPLEMENT TO SHOW ARMED
8827 fdb0 5a                 ARMLOP  DECB                    ; ? DONE
8828 fdb1 2b c9                      BMI     CNVRTS          ; RETURN WHEN DONE
8829 fdb3 a6 b4                      LDA     [,Y]            ; LOAD OPCODE
8830 fdb5 a7 30                      STA     -NUMBKP*2,Y     ; STORE INTO OPCODE TABLE
8831 fdb7 86 3f                      LDA     #$3F            ; READY "SWI" OPCODE
8832 fdb9 a7 b1                      STA     [,Y++]          ; STORE AND MOVE UP TABLE
8833 fdbb 20 f3                      BRA     ARMLOP          ; AND CONTINUE
8834                         
8835                         *******************CALL - CALL ADDRESS AS SUBROUTINE
8836 fdbd 8d c8              CCALL   BSR     GOADDR          ; FETCH ADDRESS IF NEEDED
8837 fdbf 35 7f                      PULS    U,Y,X,DP,D,CC   ; RESTORE USERS REGISTERS
8838 fdc1 ad f1                      JSR     [,S++]          ; CALL USER SUBROUTINE
8839 fdc3 3f                 CGOBRK  SWI                     ; PERFORM BREAKPOINT
8840 fdc4 0a                         FCB     BRKPT           ; FUNCTION
8841 fdc5 20 fc                      BRA     CGOBRK          ; LOOP UNTIL USER CHANGES PC
8842                         
8843                         ****************MEMORY - DISPLAY/CHANGE MEMORY
8844                         * CMEMN AND CMPADP ARE DIRECT ENTRY POINTS FROM
8845                         * THE COMMAND HANDLER FOR QUICK COMMANDS
8846 fdc7 17 00 9a           CMEM    LBSR    CDNUM           ; OBTAIN ADDRESS
8847 fdca dd 9e              CMEMN   STD     <ADDR           ; STORE DEFAULT
8848 fdcc 9e 9e              CMEM2   LDX     <ADDR           ; LOAD POINTER
8849 fdce 17 fc 0c                   LBSR    ZOUT2H          ; SEND OUT HEX VALUE OF BYTE
8850 fdd1 86 2d                      LDA     #'-             ; LOAD DELIMITER
8851 fdd3 3f                         SWI                     ; SEND OUT
8852 fdd4 01                         FCB     OUTCH           ; FUNCTION
8853 fdd5 17 ff 0b           CMEM4   LBSR    BLDNNB          ; OBTAIN NEW BYTE VALUE
8854 fdd8 27 0a                      BEQ     CMENUM          ; BRANCH IF NUMBER
8855                         * COMA - SKIP BYTE
8856 fdda 81 2c                      CMPA    #',             ; ? COMMA
8857 fddc 26 0e                      BNE     CMNOTC          ; BRANCH NOT
8858 fdde 9f 9e                      STX     <ADDR           ; UPDATE POINTER
8859 fde0 30 01                      LEAX    1,X             ; TO NEXT BYTE
8860 fde2 20 f1                      BRA     CMEM4           ; AND INPUT IT
8861 fde4 d6 9c              CMENUM  LDB     <NUMBER+1       ; LOAD LOW BYTE VALUE
8862 fde6 8d 47                      BSR     MUPDAT          ; GO OVERLAY MEMORY BYTE
8863 fde8 81 2c                      CMPA    #',             ; ? CONTINUE WITH NO DISPLAY
8864 fdea 27 e9                      BEQ     CMEM4           ; BRANCH YES
8865                         * QUOTED STRING
8866 fdec 81 27              CMNOTC  CMPA    #$27            ; ? QUOTED STRING
8867 fdee 26 0c                      BNE     CMNOTQ          ; BRANCH NO
8868 fdf0 8d 8b              CMESTR  BSR     READC           ; OBTAIN NEXT CHARACTER
8869 fdf2 81 27                      CMPA    #$27            ; ? END OF QUOTED STRING
8870 fdf4 27 0c                      BEQ     CMSPCE          ; YES, QUIT STRING MODE
8871 fdf6 1f 89                      TFR     A,B             ; TO B FOR SUBROUTINE
8872 fdf8 8d 35                      BSR     MUPDAT          ; GO UPDATE BYTE
8873 fdfa 20 f4                      BRA     CMESTR          ; GET NEXT CHARACTER
8874                         * BLANK - NEXT BYTE
8875 fdfc 81 20              CMNOTQ  CMPA    #$20            ; ? BLANK FOR NEXT BYTE
8876 fdfe 26 06                      BNE     CMNOTB          ; BRANCH NOT
8877 fe00 9f 9e                      STX     <ADDR           ; UPDATE POINTER
8878 fe02 3f                 CMSPCE  SWI                     ; GIVE SPACE
8879 fe03 07                         FCB     SPACEF          ; FUNCTION
8880 fe04 20 c6                      BRA     CMEM2           ; NOW PROMPT FOR NEXT
8881                         
8882                         * LINE FEED - NEXT BYTE WITH ADDRESS
8883 fe06 81 0a              CMNOTB  CMPA    #LF             ; ? LINE FEED FOR NEXT BYTE
8884 fe08 26 08                      BNE     CMNOTL          ; BRANCH NO
8885 fe0a 86 0d                      LDA     #CR             ; GIVE CARRIAGE RETURN
8886 fe0c 3f                         SWI                     ; TO CONSOLE
8887 fe0d 01                         FCB     OUTCH           ; HANDLER
8888 fe0e 9f 9e                      STX     <ADDR           ; STORE NEXT ADDRESS
8889 fe10 20 0a                      BRA     CMPADP          ; BRANCH TO SHOW
8890                         
8891                         * UP ARROW - PREVIOUS BYTE AND ADDRESS
8892 fe12 81 5e              CMNOTL  CMPA    #'^             ; ? UP ARROW FOR PREVIOUS BYTE
8893 fe14 26 0a                      BNE     CMNOTU          ; BRANCH NOT
8894 fe16 30 1e                      LEAX    -2,X            ; DOWN TO PREVIOUS BYTE
8895 fe18 9f 9e                      STX     <ADDR           ; STORE NEW POINTER
8896 fe1a 3f                 CMPADS  SWI                     ; FORCE NEW LINE
8897 fe1b 06                         FCB     PCRLF           ; FUNCTION
8898 fe1c 8d 07              CMPADP  BSR     PRTADR          ; GO PRINT ITS VALUE
8899 fe1e 20 ac                      BRA     CMEM2           ; THEN PROMPT FOR INPUT
8900                         
8901                         * SLASH - NEXT BYTE WITH ADDRESS
8902 fe20 81 2f              CMNOTU  CMPA    #'/             ; ? SLASH FOR CURRENT DISPLAY
8903 fe22 27 f6                      BEQ     CMPADS          ; YES, SEND ADDRESS
8904 fe24 39                         RTS                     ; RETURN FROM COMMAND
8905                         
8906                         * PRINT CURRENT ADDRESS
8907 fe25 9e 9e              PRTADR  LDX     <ADDR           ; LOAD POINTER VALUE
8908 fe27 34 10                      PSHS    X               ; SAVE X ON STACK
8909 fe29 30 e4                      LEAX    ,S              ; POINT TO IT FOR DISPLAY
8910 fe2b 3f                         SWI                     ; DISPLAY POINTER IN HEX
8911 fe2c 05                         FCB     OUT4HS          ; FUNCTION
8912 fe2d 35 90                      PULS    PC,X            ; RECOVER POINTER AND RETURN
8913                         
8914                         * UPDATE BYTE
8915 fe2f 9e 9e              MUPDAT  LDX     <ADDR           ; LOAD NEXT BYTE POINTER
8916 fe31 e7 80                      STB     ,X+             ; STORE AND INCREMENT X
8917 fe33 e1 1f                      CMPB    -1,X            ; ? SUCCESFULL STORE
8918 fe35 26 03                      BNE     MUPBAD          ; BRANCH FOR '?' IF NOT
8919 fe37 9f 9e                      STX     <ADDR           ; STORE NEW POINTER VALUE
8920 fe39 39                         RTS                     ; BACK TO CALLER
8921 fe3a 34 02              MUPBAD  PSHS    A               ; SAVE A REGISTER
8922 fe3c 86 3f                      LDA     #'?             ; SHOW INVALID
8923 fe3e 3f                         SWI                     ; SEND OUT
8924 fe3f 01                         FCB     OUTCH           ; FUNCTION
8925 fe40 35 82                      PULS    PC,A            ; RETURN TO CALLER
8926                         
8927                         ********************WINDOW - SET WINDOW VALUE
8928 fe42 8d 20              CWINDO  BSR     CDNUM           ; OBTAIN WINDOW VALUE
8929 fe44 dd a0                      STD     <WINDOW         ; STORE IT IN
8930 fe46 39                         RTS                     ; END COMMAND
8931                         
8932                         ******************DISPLAY - HIGH SPEED DISPLAY MEMORY
8933 fe47 8d 1b              CDISP   BSR     CDNUM           ; FETCH ADDRESS
8934 fe49 c4 f0                      ANDB    #$F0            ; FORCE TO 16 BOUNDARY
8935 fe4b 1f 02                      TFR     D,Y             ; SAVE IN Y
8936 fe4d 30 2f                      LEAX    15,Y            ; DEFAULT LENGTH
8937 fe4f 25 04                      BCS     CDISPS          ; BRANCH IF END OF INPUT
8938 fe51 8d 11                      BSR     CDNUM           ; OBTAIN COUNT
8939 fe53 30 ab                      LEAX    D,Y             ; ASSUME COUNT, COMPUTE END ADDR
8940 fe55 34 30              CDISPS  PSHS    Y,X             ; SETUP PARAMETERS FOR HSDATA
8941 fe57 10 a3 62                   CMPD    2,S             ; ? WAS IT COUNT
8942 fe5a 23 02                      BLS     CDCNT           ; BRANCH YES
8943 fe5c ed e4                      STD     ,S              ; STORE HIGH ADDRESS
8944 fe5e ad 9d 72 80        CDCNT   JSR     [VECTAB+.HSDTA,PCR] ; CALL PRINT ROUTINE
8945 fe62 35 e0                      PULS    PC,U,Y          ; CLEAN STACK AND END COMMAND
8946                         
8947                         * OBTAIN NUMBER - ABORT IF NONE
8948                         * ONLY DELIMITERS OF CR, BLANK, OR '/' ARE ACCEPTED
8949                         * OUTPUT: D=VALUE, C=1 IF CARRIAGE RETURN DELMITER,
8950                         * ELSE C=0
8951 fe64 17 fe 7e           CDNUM   LBSR    BLDNUM          ; OBTAIN NUMBER
8952 fe67 26 09                      BNE     CDBADN          ; BRANCH IF INVALID
8953 fe69 81 2f                      CMPA    #'/             ; ? VALID DELIMITER
8954 fe6b 22 05                      BHI     CDBADN          ; BRANCH IF NOT FOR ERROR
8955 fe6d 81 0e                      CMPA    #CR+1           ; LEAVE COMPARE FOR CARRIAGE RET
8956 fe6f dc 9b                      LDD     <NUMBER         ; LOAD NUMBER
8957 fe71 39                         RTS                     ; RETURN WITH COMPARE
8958 fe72 16 fa e7           CDBADN  LBRA    CMDBAD          ; RETURN TO ERROR MECHANISM
8959                         
8960                         *****************PUNCH - PUNCH MEMORY IN S1-S9 FORMAT
8961 fe75 8d ed              CPUNCH  BSR     CDNUM           ; OBTAIN START ADDRESS
8962 fe77 1f 02                      TFR     D,Y             ; SAVE IN Y
8963 fe79 8d e9                      BSR     CDNUM           ; OBTAIN END ADDRESS
8964 fe7b 6f e2                      CLR     ,-S             ; SETUP PUNCH FUNCTION CODE
8965 fe7d 34 26                      PSHS    Y,D             ; STORE VALUES ON STACK
8966 fe7f ad 9d 72 61        CCALBS  JSR     [VECTAB+.BSON,PCR] ; INITIALIZE HANDLER
8967 fe83 ad 9d 72 5f                JSR     [VECTAB+.BSDTA,PCR] ; PERFORM FUNCTION
8968 fe87 34 01                      PSHS    CC              ; SAVE RETURN CODE
8969 fe89 ad 9d 72 5b                JSR     [VECTAB+.BSOFF,PCR] ; TURN OFF HANDLER
8970 fe8d 35 01                      PULS    CC              ; OBTAIN CONDITION CODE SAVED
8971 fe8f 26 e1                      BNE     CDBADN          ; BRANCH IF ERROR
8972 fe91 35 b2                      PULS    PC,Y,X,A        ; RETURN FROM COMMAND
8973                         
8974                         *****************LOAD - LOAD MEMORY FROM S1-S9 FORMAT
8975 fe93 8d 01              CLOAD   BSR     CLVOFS          ; CALL SETUP AND PASS CODE
8976 fe95 01                         FCB     1               ; LOAD FUNCTION CODE FOR PACKET
8977                         
8978 fe96 33 f1              CLVOFS  LEAU    [,S++]          ; LOAD CODE IN HIGH BYTE OF U
8979 fe98 33 d4                      LEAU    [,U]            ; NOT CHANGING CC AND RESTORE S
8980 fe9a 27 03                      BEQ     CLVDFT          ; BRANCH IF CARRIAGE RETURN NEXT
8981 fe9c 8d c6                      BSR     CDNUM           ; OBTAIN OFFSET
8982 fe9e 8c                         FCB     SKIP2           ; SKIP DEFAULT OFFSET
8983 fe9f 4f                 CLVDFT  CLRA                    ; CREATE ZERO OFFSET
8984 fea0 5f                         CLRB                    ; AS DEFAULT
8985 fea1 34 4e                      PSHS    U,DP,D          ; SETUP CODE, NULL WORD, OFFSET
8986 fea3 20 da                      BRA     CCALBS          ; ENTER CALL TO BS ROUTINES
8987                         
8988                         ******************VERIFY - COMPARE MEMORY WITH FILES
8989 fea5 8d ef              CVER    BSR     CLVOFS          ; COMPUTE OFFSET IF ANY
8990 fea7 ff                         FCB     -1              ; VERIFY FNCTN CODE FOR PACKET
8991                         
8992                         *******************TRACE - TRACE INSTRUCTIONS
8993                         ******************* . - SINGLE STEP TRACE
8994 fea8 8d ba              CTRACE  BSR     CDNUM           ; OBTAIN TRACE COUNT
8995 feaa dd 91                      STD     <TRACEC         ; STORE COUNT
8996 feac 32 62              CDOT    LEAS    2,S             ; RID COMMAND RETURN FROM STACK
8997 feae ee f8 0a           CTRCE3  LDU     [10,S]          ; LOAD OPCODE TO EXECUTE
8998 feb1 df 99                      STU     <LASTOP         ; STORE FOR TRACE INTERRUPT
8999 feb3 de f6                      LDU     <VECTAB+.PTM    ; LOAD PTM ADDRESS
9000 feb5 cc 07 01                   LDD     #$0701          ; 7,1 CYCLES DOWN+CYCLES UP
9001 feb8 ed 42                      STD     PTMTM1-PTM,U    ; START NMI TIMEOUT
9002 feba 3b                         RTI                     ; RETURN FOR ONE INSTRUCTION
9003                         
9004                         *************NULLS  -  SET NEW LINE AND CHAR PADDING
9005 febb 8d a7              CNULLS  BSR     CDNUM           ; OBTAIN NEW LINE PAD
9006 febd dd f2                      STD     <VECTAB+.PAD    ; RESET VALUES
9007 febf 39                         RTS                     ; END COMMAND
9008                         
9009                         ******************STLEVEL - SET STACK TRACE LEVEL
9010 fec0 27 05              CSTLEV  BEQ     STLDFT          ; TAKE DEFAULT
9011 fec2 8d a0                      BSR     CDNUM           ; OBTAIN NEW STACK LEVEL
9012 fec4 dd f8                      STD     <SLEVEL         ; STORE NEW ENTRY
9013 fec6 39                         RTS                     ; TO COMMAND HANDLER
9014 fec7 30 6e              STLDFT  LEAX    14,S            ; COMPUTE NMI COMPARE
9015 fec9 9f f8                      STX     <SLEVEL         ; AND STORE IT
9016 fecb 39                         RTS                     ; END COMMAND
9017                         
9018                         ******************OFFSET - COMPUTE SHORT AND LONG
9019                         ******************                  BRANCH OFFSETS
9020 fecc 8d 96              COFFS   BSR     CDNUM           ; OBTAIN INSTRUCTION ADDRESS
9021 fece 1f 01                      TFR     D,X             ; USE AS FROM ADDRESS
9022 fed0 8d 92                      BSR     CDNUM           ; OBTAIN TO ADDRESS
9023                         * D=TO INSTRUCTION, X=FROM INSTRUCTION OFFSET BYTE(S)
9024 fed2 30 01                      LEAX    1,X             ; ADJUST FOR *+2 SHORT BRANCH
9025 fed4 34 30                      PSHS    Y,X             ; STORE WORK WORD AND VALUE ON S
9026 fed6 a3 e4                      SUBD    ,S              ; FIND OFFSET
9027 fed8 ed e4                      STD     ,S              ; SAVE OVER STACK
9028 feda 30 61                      LEAX    1,S             ; POINT FOR ONE BYTE DISPLAY
9029 fedc 1d                         SEX                     ; SIGN EXTEND LOW BYTE
9030 fedd a1 e4                      CMPA    ,S              ; ? VALID ONE BYTE OFFSET
9031 fedf 26 02                      BNE     COFNO1          ; BRANCH IF NOT
9032 fee1 3f                         SWI                     ; SHOW ONE BYTE OFFSET
9033 fee2 04                         FCB     OUT2HS          ; FUNCTION
9034 fee3 ee e4              COFNO1  LDU     ,S              ; RELOAD OFFSET
9035 fee5 33 5f                      LEAU    -1,U            ; CONVERT TO LONG BRANCH OFFSET
9036 fee7 ef 84                      STU     ,X              ; STORE BACK WHERE X POINTS NOW
9037 fee9 3f                         SWI                     ; SHOW TWO BYTE OFFSET
9038 feea 05                         FCB     OUT4HS          ; FUNCTION
9039 feeb 3f                         SWI                     ; FORCE NEW LINE
9040 feec 06                         FCB     PCRLF           ; FUNCTION
9041 feed 35 96                      PULS    PC,X,D          ; RESTORE STACK AND END COMMAND
9042                         *H
9043                         
9044                         *************BREAKPOINT - DISPLAY/ENTER/DELETE/CLEAR
9045                         *************             BREAKPOINTS
9046 feef 27 23              CBKPT   BEQ     CBKDSP          ; BRANCH DISPLAY OF JUST 'B'
9047 fef1 17 fd f1                   LBSR    BLDNUM          ; ATTEMPT VALUE ENTRY
9048 fef4 27 2c                      BEQ     CBKADD          ; BRANCH TO ADD IF SO
9049 fef6 81 2d                      CMPA    #'-             ; ? CORRECT DELIMITER
9050 fef8 26 3f                      BNE     CBKERR          ; NO, BRANCH FOR ERROR
9051 fefa 17 fd e8                   LBSR    BLDNUM          ; ATTEMPT DELETE VALUE
9052 fefd 27 03                      BEQ     CBKDLE          ; GOT ONE, GO DELETE IT
9053 feff 0f fa                      CLR     <BKPTCT         ; WAS 'B -', SO ZERO COUNT
9054 ff01 39                 CBKRTS  RTS                     ; END COMMAND
9055                         * DELETE THE ENTRY
9056 ff02 8d 40              CBKDLE  BSR     CBKSET          ; SETUP REGISTERS AND VALUE
9057 ff04 5a                 CBKDLP  DECB                    ; ? ANY ENTRIES IN TABLE
9058 ff05 2b 32                      BMI     CBKERR          ; BRANCH NO, ERROR
9059 ff07 ac a1                      CMPX    ,Y++            ; ? IS THIS THE ENTRY
9060 ff09 26 f9                      BNE     CBKDLP          ; NO, TRY NEXT
9061                         * FOUND, NOW MOVE OTHERS UP IN ITS PLACE
9062 ff0b ae a1              CBKDLM  LDX     ,Y++            ; LOAD NEXT ONE UP
9063 ff0d af 3c                      STX     -4,Y            ; MOVE DOWN BY ONE
9064 ff0f 5a                         DECB                    ; ? DONE
9065 ff10 2a f9                      BPL     CBKDLM          ; NO, CONTINUE MOVE
9066 ff12 0a fa                      DEC     <BKPTCT         ; DECREMENT BREAKPOINT COUNT
9067 ff14 8d 2e              CBKDSP  BSR     CBKSET          ; SETUP REGISTERS AND LOAD VALUE
9068 ff16 27 e9                      BEQ     CBKRTS          ; RETURN IF NONE TO DISPLY
9069 ff18 30 a1              CBKDSL  LEAX    ,Y++            ; POINT TO NEXT ENTRY
9070 ff1a 3f                         SWI                     ; DISPLAY IN HEX
9071 ff1b 05                         FCB     OUT4HS          ; FUNCTION
9072 ff1c 5a                         DECB                    ; COUNT DOWN
9073 ff1d 26 f9                      BNE     CBKDSL          ; LOOP IF NGABLE RAM
9074 ff1f 3f                         SWI                     ; SKIP TO NEW LINK
9075 ff20 06                         FCB     PCRLF           ; FUNCTIONRTS
9076 ff21 39                         RTS
9077                         
9078                         * ADD NEW ENTRY
9079 ff22 8d 20              CBKADD  BSR     CBKSET          ; SETUP REGISTERS
9080 ff24 c1 08                      CMPB    #NUMBKP         ; ? ALREADY FULL
9081 ff26 27 11                      BEQ     CBKERR          ; BRANCH ERROR IF SO
9082 ff28 a6 84                      LDA     ,X              ; LOAD BYTE TO TRAP
9083 ff2a e7 84                      STB     ,X              ; TRY TO CHANGE
9084 ff2c e1 84                      CMPB    ,X              ; ? CHANGEABLE RAM
9085 ff2e 26 09                      BNE     CBKERR          ; BRANCH ERROR IF NOT
9086 ff30 a7 84                      STA ,X                  ; RESTORE BYTE
9087 ff32 5a                 CBKADL  DECB                    ; COUNT DOWN
9088 ff33 2b 07                      BMI     CBKADT          ; BRANCH IF DONE TO ADD IT
9089 ff35 ac a1                      CMPX    ,Y++            ; ? ENTRY ALREADY HERE
9090 ff37 26 f9                      BNE     CBKADL          ; LOOP IF NOT
9091 ff39 16 fa 20           CBKERR  LBRA    CMDBAD          ; RETURN TO ERROR PRODUCE
9092 ff3c af a4              CBKADT  STX ,Y                  ; ADD THIS ENTRY
9093 ff3e 6f 31                      CLR     -NUMBKP*2+1,Y   ; CLEAR OPTIONAL BYTE
9094 ff40 0c fa                      INC     <BKPTCT         ; ADD ONE TO COUNT
9095 ff42 20 d0                      BRA     CBKDSP          ; AND NOW DISPLAY ALL OF 'EM
9096                         * SETUP REGISTERS FOR SCAN
9097 ff44 9e 9b              CBKSET  LDX     <NUMBER         ; LOAD VALUE DESIRED
9098 ff46 31 8d 71 68        CBKLDR  LEAY    BKPTBL,PCR      ; LOAD START OF TABLE
9099 ff4a d6 fa                      LDB     <BKPTCT         ; LOAD ENTRY COUNT
9100 ff4c 39                         RTS                     ; RETURN
9101                         
9102                         *****************ENCODE  -  ENCODE A POSTBYTE
9103 ff4d 6f e2              CENCDE  CLR     ,-S             ; DEFAULT TO NOT INDIRECT
9104 ff4f 5f                         CLRB                    ; ZERO POSTBYTE VALUE
9105 ff50 30 8c 3f                   LEAX    <CONV1,PCR      ; START TABLE SEARCH
9106 ff53 3f                         SWI                     ; OBTAIN FIRST CHARACTER
9107 ff54 00                         FCB     INCHNP          ; FUNCTION
9108 ff55 81 5b                      CMPA    #'[             ; ? INDIRECT HERE
9109 ff57 26 06                      BNE     CEN2            ; BRANCH IF NOT
9110 ff59 86 10                      LDA     #$10            ; SET INDIRECT BIT ON
9111 ff5b a7 e4                      STA     ,S              ; SAVE FOR LATER
9112 ff5d 3f                 CENGET  SWI                     ; OBTAIN NEXT CHARACTER
9113 ff5e 00                         FCB     INCHNP          ; FUNCTION
9114 ff5f 81 0d              CEN2    CMPA    #CR             ; ? END OF ENTRY
9115 ff61 27 0c                      BEQ     CEND1           ; BRANCH YES
9116 ff63 6d 84              CENLP1  TST     ,X              ; ? END OF TABLE
9117 ff65 2b d2                      BMI     CBKERR          ; BRANCH ERROR IF SO
9118 ff67 a1 81                      CMPA    ,X++            ; ? THIS THE CHARACTER
9119 ff69 26 f8                      BNE     CENLP1          ; BRANCH IF NOT
9120 ff6b eb 1f                      ADDB    -1,X            ; ADD THIS VALUE
9121 ff6d 20 ee                      BRA     CENGET          ; GET NEXT INPUT
9122 ff6f 30 8c 49           CEND1   LEAX    <CONV2,PCR      ; POINT AT TABLE 2
9123 ff72 1f 98                      TFR     B,A             ; SAVE COPY IN A
9124 ff74 84 60                      ANDA    #$60            ; ISOLATE REGISTER MASK
9125 ff76 aa e4                      ORA     ,S              ; ADD IN INDIRECTION BIT
9126 ff78 a7 e4                      STA     ,S              ; SAVE BACK AS POSTBYTE SKELETON
9127 ff7a c4 9f                      ANDB    #$9F            ; CLEAR REGISTER BITS
9128 ff7c 6d 84              CENLP2  TST     ,X              ; ? END OF TABLE
9129 ff7e 27 b9                      BEQ     CBKERR          ; BRANCH ERROR IF SO
9130 ff80 e1 81                      CMPB    ,X++            ; ? SAME VALUE
9131 ff82 26 f8                      BNE     CENLP2          ; LOOP IF NOT
9132 ff84 e6 1f                      LDB     -1,X            ; LOAD RESULT VALUE
9133 ff86 ea e4                      ORB     ,S              ; ADD TO BASE SKELETON
9134 ff88 e7 e4                      STB     ,S              ; SAVE POSTBYTE ON STACK
9135 ff8a 30 e4                      LEAX    ,S              ; POINT TO IT
9136 ff8c 3f                         SWI                     ; SEND OUT AS HEX
9137 ff8d 04                         FCB     OUT2HS          ; FUNCTION
9138 ff8e 3f                         SWI                     ; TO NEXT LINE
9139 ff8f 06                         FCB     PCRLF           ; FUNCTION
9140 ff90 35 84                      PULS    PC,B            ; END OF COMMAND
9141                         
9142                         * TABLE ONE DEFINES VALID INPUT IN SEQUENCE
9143                         CONV1
9144 ff92 41 04 42 05 44 06          FCB     'A,$04,'B,$05,'D,$06,'H,$01
     48 01
9145 ff9a 48 01 48 01 48 00          FCB     'H,$01,'H,$01,'H,$00,',,$00
     2c 00
9146 ffa2 2d 09 2d 01 53 70          FCB     '-,$09,'-,$01,'S,$70,'Y,$30
     59 30
9147 ffaa 55 50 58 10 2b 07          FCB     'U,$50,'X,$10,'+,$07,'+,$01
     2b 01
9148 ffb2 50 80 43 00 52 00          FCB     'P,$80,'C,$00,'R,$00,'],$00
     5d 00
9149 ffba ff                         FCB     $FF             ; END OF TABLE
9150                         
9151                         * CONV2 USES ABOVE CONVERSION TO SET POSTBYTE
9152                         * BIT SKELETON.
9153                         CONV2
9154 ffbb 10 84 11 00                FDB     $1084,$1100     ; R,      H,R
9155 ffbf 12 88 13 89                FDB     $1288,$1389     ; HH,R    HHHH,R
9156 ffc3 14 86 15 85                FDB     $1486,$1585     ; A,R     B,R
9157 ffc7 16 8b 17 80                FDB     $168B,$1780     ; D,R     ,R+
9158 ffcb 18 81 19 82                FDB     $1881,$1982     ; ,R++    ,-R
9159 ffcf 1a 83 82 8c                FDB     $1A83,$828C     ; ,--R    HH,PCR
9160 ffd3 83 8d 03 9f                FDB     $838D,$039F     ; HHHH,PCR [HHHH]
9161 ffd7 00                         FCB     0               ; END OF TABLE
9162                         
9163                         ****************************************************
9164                         *            DEFAULT INTERRUPT TRANSFERS           *
9165                         ****************************************************
9166 ffd8 6e 9d 70 ea        RSRVD   JMP     [VECTAB+.RSVD,PCR]      ; RESERVED VECTOR
9167 ffdc 6e 9d 70 e8        SWI3    JMP     [VECTAB+.SWI3,PCR]      ; SWI3 VECTOR
9168 ffe0 6e 9d 70 e6        SWI2    JMP     [VECTAB+.SWI2,PCR]      ; SWI2 VECTOR
9169 ffe4 6e 9d 70 e4        FIRQ    JMP     [VECTAB+.FIRQ,PCR]      ; FIRQ VECTOR
9170 ffe8 6e 9d 70 e2        IRQ     JMP     [VECTAB+.IRQ,PCR]       ; IRQ VECTOR
9171 ffec 6e 9d 70 e0        SWI     JMP     [VECTAB+.SWI,PCR]       ; SWI VECTOR
9172 fff0 6e 9d 70 de        NMI     JMP     [VECTAB+.NMI,PCR]       ; NMI VECTOR
9173                         
9174                         ******************************************************
9175                         *            ASSIST09 HARDWARE VECTOR TABLE
9176                         * THIS TABLE IS USED IF THE ASSIST09 ROM ADDRESSES
9177                         * THE MC6809 HARDWARE VECTORS.
9178                         ******************************************************
9179 fff0                            ORG     ROMBEG+ROMSIZ-16 ; SETUP HARDWARE VECTORS
9180 fff0 ff d8                      FDB     RSRVD           ; RESERVED SLOT
9181 fff2 ff dc                      FDB     SWI3            ; SOFTWARE INTERRUPT 3
9182 fff4 ff e0                      FDB     SWI2            ; SOFTWARE INTERRUPT 2
9183 fff6 ff e4                      FDB     FIRQ            ; FAST INTERRUPT REQUEST
9184 fff8 ff e8                      FDB     IRQ             ; INTERRUPT REQUEST
9185 fffa ff ec                      FDB     SWI             ; SOFTWARE INTERRUPT
9186 fffc ff f0                      FDB     NMI             ; NON-MASKABLE INTERRUPT
9187 fffe f8 37                      FDB     RESET           ; RESTART
