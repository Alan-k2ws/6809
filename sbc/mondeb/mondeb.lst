0001                         ; This is a port of the MONDEB monitor/debugger to the 6809,
0002                         ; specifically my 6809-based Single Board Computer.
0003                         ;
0004                         ; It is a port of the 6800 version, with some additional changes taken
0005                         ; from a 6809 version written by Alan R. Baldwin.
0006                         ;
0007                         ; To Do:
0008                         ; Test all commands.
0009                         ; Test running from ROM as well as in RAM.
0010                         ; 6809-specific optimizing.
0011                         
0012                                 NAM   MONDEB
0013                         
0014                         ;THIS SOURCE CODE WAS SENT TO WALTER BANKS AT
0015                         ;THE UNIVERSITY OF WATERLOO BY DON PETERS ON PAPER TAPE
0016                         ;CROSS ASSEMBLY WAS DONE ON THE U OF W HONEYWELL 66/60
0017                         ;THE BARCODE AND LISTING WERE SET ON A PHOTON PHOTO-
0018                         ;TYPESETTER DRIVEN BY THE HONEYWELL.
0019                         ;
0020                         ;       M O N D E B  - A MONITOR/DEBUGGER FOR THE M6800 MICROPROCESSOR
0021                         
0022                         ; AUTHOR: DON PETERS
0023                         ; DATE: APRIL 1977
0024                         ; MEMORY REQ'D: 3K BYTES AT HIGH END OF ADDRESS SPACE
0025                         
0026                         ; SEE USER MANUAL FOR CAPABILITIES & INSTRUCTIONS ON USE
0027                         
0028 0400                           ORG     $400    ;DEBUG ORG AT 1K
0029                         ;      ORG    $F000    ;NORMAL ORIGIN AT 60K
0030                         
0031                         
0032                         ;I/O DEVICE ADDRESSES
0033 a001                    ACIA1  EQU    $A001    ;ACIA #1 - MAIN TERMINAL ACIA
0034 a001                    ACIA2  EQU    $A001    ;ACIA #2 - AUXILIARY TERMINAL ACIA
0035                         
0036                         ;OTHER CONSTANTS
0037 000d                    CR     EQU    13       ;CARRIAGE RETURN
0038 000a                    LF     EQU    10       ;LINE FEED
0039                         
0040                         
0041 0400                    START  EQU    *        ;PROGRAM ENTRY POINT
0042 0400 10 ce 7f b9               LDS    #STACK   ;INITIALIZE THE STACK POINTER
0043 0404 10 ff 7f 0e               STS    SP       ;SAVE THE POINTER
0044 0408 bd 0f 21                  JSR    INITAL   ;INITIALIZE VARIABLES
0045                         
0046                         
0047                         ;TYPE OUT MONITOR NAME & VERSION
0048 040b bd 0f e5                  JSR    DOCRLF   ;ADVANCE TO A CLEAN LINE
0049 040e 8e 10 08                  LDX    #MSGHED  ;GET ADDRESS OF HEADER
0050 0411 bd 0f 5e                  JSR    OUTSTR   ;TYPE IT
0051                         
0052                         ;SET UP DESTINATION OF INPUT LINE
0053                         ;DEFINE BEGINNING OF INPUT BUFFER
0054 0414 8e 7f 37                  LDX    #TTYBUF-1   ;GET ADDRESS OF TERMINAL INPUT BUFFER
0055 0417 bf 7f 34                  STX    BUFBEG   ;SAVE IT
0056                         
0057                         ;DEFINE END OF INPUT BUFFER - 72 CHAR CAPACITY, INCL CR
0058 041a 8e 7f 80                  LDX    #TTYEND
0059 041d bf 7f 36                  STX    BUFEND
0060                         
0061                         ;DELIMITER CLASS DEFINITION - SPACE OR COMMA (CODE 3)
0062 0420 86 03                     LDA    #3
0063 0422 b7 7f 17                  STA    DELIM
0064 0425 20 0f                     BRA    PROMP1
0065                         
0066                         ;PREPARE TO GET A NEW COMMAND
0067 0427 bd 0f e5           PROMPT JSR    DOCRLF   ;TYPE CR-LF
0068 042a 7c 7f 16                  INC    BOLFLG   ;SET "BEGINNING OF LINE" FLAG
0069 042d be 7f 12                  LDX    SYNPTR   ;POINT TO CURRENT CHARACTER
0070 0430 a6 84                     LDA    ,X       ;GET IT
0071 0432 81 3b                     CMPA   #';'     ;SEMICOLON?
0072 0434 27 1a                     BEQ    GETCMD   ;CONTINUE SCAN IF IT IS, SKIPPING THE PROMPT
0073                         
0074                         ;TYPE PROMPT
0075 0436 8e 10 1a           PROMP1 LDX    #MSGPRM
0076 0439 bd 0f 5e                  JSR    OUTSTR
0077 043c bd 0e 9c                  JSR    GETLIN  ;GET LINE OF INPUT
0078                         
0079                         ;ABORT LINE ON A CONTROL-C
0080 043f c1 03                     CMPB   #3
0081 0441 27 e4                     BEQ    PROMPT
0082                         
0083                         ;SET SYNTAX SCANNING POINTER TO BEGINNING OF BUFFER/LINE
0084 0443 be 7f 34                  LDX    BUFBEG
0085 0446 bf 7f 12                  STX    SYNPTR
0086                         
0087                         ;REPROMPT ON AN EMPTY LINE (FIRST CHAR = CR, LF, OR ;)
0088 0449 a6 01                     LDA    1,X      ;GET FIRST CHAR
0089 044b bd 0b 62                  JSR    TSTEOL   ;TEST IT
0090 044e 27 d7                     BEQ    PROMPT   ;IF IT IS, PROMPT AGAIN
0091                         
0092                         ;USE LIST 1 WHEN MATCHING
0093 0450 86 01              GETCMD LDA    #1
0094                         
0095                         ;NOW GO FOR A MATCH
0096 0452 bd 0a 97                  JSR    COMAND
0097                         
0098                         ;-AND TEST THE RESULT OF THE SCAN
0099 0455 27 d0                     BEQ    PROMPT   ;REPROMPT IF JUST A CR WAS TYPED
0100 0457 2e 20                     BGT    JMPCMD   ;GOOD COMMAND IF POSITIVE
0101                         
0102                         ;*****
0103                         ;UNRECOGNIZABLE SYNTAX - POINT TO ERROR
0104 0459 be 7f 34           BADSYN LDX    BUFBEG   ;GET START OF LINE
0105                         ;SPACE OVER TO ERROR IN SYNTAX
0106 045c bc 7f 14           BADS1  CPX    LINPTR   ;AT ERROR?
0107 045f 27 07                     BEQ    BADS2
0108 0461 bd 0c cd                  JSR    OUTSP    ;OUTPUT A SPACE
0109 0464 30 01                     LEAX   1,X      ;NO, MOVE ON
0110 0466 20 f4                     BRA    BADS1
0111                         
0112                         ;THE "EXTRA" CHAR "1" IS COMPENSATED FOR BY THE PROMPT CHAR ON THE PRECEDING LINE
0113 0468 86 5e              BADS2  LDA    #'^'     ;AT ERROR - GET AN UP-ARROW
0114 046a bd 0f 8d                  JSR    OUTCHR   ;PRINT IT
0115 046d bd 0f e5                  JSR    DOCRLF
0116 0470 20 c4                     BRA    PROMP1   ;IGNORE ANY SUCCEEDING PACKED COMMANDS
0117                         
0118                         ;*****
0119                         ;THERE SHOULD BE NO MORE CHARACTERS ON THE INPUT LINE
0120                         ;                       (EXCEPT DELIMITERS)
0121 0472 bd 0b 40           NOMORE JSR    SKPDLM
0122 0475 25 b0                     BCS    PROMPT   ;IF CARRY BIT SET, END OF LINE (NORMAL)
0123                         ;THERE IS SOMETHING THERE BUT SHOULDN'T BE
0124 0477 20 e0                     BRA    BADSYN
0125                         
0126                         ;*****
0127                         ;EXECUTE A COMPUTED "GOTO" TO THE PROPER COMMAND
0128 0479 1f 89              JMPCMD TFR    A,B      ;SAVE COMMAND # IN ACCB
0129 047b 48                        ASLA            ;MULTIPLY COMMAND BY 2
0130 047c 34 04                     PSHS   B        ;ABA
0131 047e ab e0                     ADDA  ,S+       ;ACCA NOW HOLDS COMMAND # MULTIPLIED BY 3
0132                         ;ADD IT TO BASE OF JUMP TABLE
0133 0480 c6 04                     LDB    #JMPHI   ;GET HI BYTE OF START OF JUMP TABLE IN ACCB
0134 0482 8b 91                     ADDA   #JMPLO   ;ADD LO BYTE OF START OF JUMP TABLE TO ACCA
0135 0484 c9 00                     ADCB   #0       ;ADD CARRY IF THERE WAS ONE
0136                         ;MOVE ACCA & ACCB TO IX (CODE IS WEIRD, BUT BRIEF)
0137 0486 34 02                     PSHS   A
0138 0488 34 04                     PSHS   B
0139 048a 1f 41                     TFR    S,X      ;PUT ADDRESS OF "GOTO" INTO X
0140 048c ae 84                     LDX    ,X       ;GET THE ADDRESS ITSELF
0141 048e 35 04                     PULS   B        ;RESTORE THE STACK
0142 0490 35 02                     PULS   A
0143 0492 6e 84                     JMP    ,X       ;JUMP TO RIGHT COMMAND
0144                         
0145 0491                    JMPTBL EQU    *-3
0146                         
0147 0004                    JMPHI  EQU    JMPTBL/256
0148 0400                    JMP256 EQU    JMPHI*256
0149 0091                    JMPLO  EQU    JMPTBL-JMP256
0150                         
0151 0494 7e 04 e8                  JMP    REG
0152 0497 7e 05 3d                  JMP    GOTO
0153 049a 7e 05 4f                  JMP    LSEI
0154 049d 7e 05 57                  JMP    LCLI
0155 04a0 7e 05 5f                  JMP    COPY
0156 04a3 7e 05 8d                  JMP    BREAK
0157 04a6 7e 05 ed                  JMP    IBASE
0158 04a9 7e 06 04                  JMP    DBASE
0159 04ac 7e 06 3d                  JMP    CONTIN
0160 04af 7e 06 42                  JMP    DISPLA
0161 04b2 7e 06 ae                  JMP    SET
0162 04b5 7e 07 83                  JMP    VERIFY
0163 04b8 7e 07 cb                  JMP    SEARCH
0164 04bb 7e 08 5c                  JMP    TEST
0165 04be 7e 08 b6                  JMP    INT
0166 04c1 7e 08 be                  JMP    NMI
0167 04c4 7e 08 c6                  JMP    LSWI
0168 04c7 7e 08 ee                  JMP    COMPAR
0169 04ca 7e 09 17                  JMP    DUMP
0170 04cd 7e 09 b4                  JMP    LOAD
0171 04d0 7e 0a 4b                  JMP    DELAY
0172 04d3 7e 0a 5e                  JMP    HELP
0173 04d6 7e 05 5b                  JMP    LCLF
0174 04d9 7e 05 53                  JMP    LSEF
0175 04dc 7e 08 de                  JMP    FIRQ
0176 04df 7e 08 e6                  JMP    RSRVD
0177 04e2 7e 08 ce                  JMP    LSWI2
0178 04e5 7e 08 d6                  JMP    LSWI3
0179                         
0180                         ;*****
0181                         ;REG - DISPLAY REGISTERS
0182 04e8                    REG    EQU    *
0183                         ;PRINT STACK STORED SWI DATA
0184 04e8 be 7f 0e           DISREG LDX    SP       ;GET SAVED STACK POINTER
0185 04eb 30 01                     LEAX   1,X
0186                         ;REGISTER NAME TYPEOUT INITIALIZATION
0187 04ed 7f 7f e3                  CLR    COMNUM   ;START AT BEGINNING OF THE REGISTER NAME LIST
0188                         
0189 04f0 8d 19                     BSR    OUT2     ;TYPE CONDITION CODES
0190 04f2 8d 17                     BSR    OUT2     ;TYPE ACCA
0191 04f4 8d 15                     BSR    OUT2     ;TYPE ACCB
0192 04f6 8d 13                     BSR    OUT2     ;TYPE DP
0193                         
0194 04f8 8d 19                     BSR    OUT4     ;TYPE X REG
0195 04fa 8d 17                     BSR    OUT4     ;TYPE Y REG
0196 04fc 8d 15                     BSR    OUT4     ;TYPE U REG
0197 04fe 8d 13                     BSR    OUT4     ;TYPE PROGRAM COUNTER
0198                         
0199                         ;TYPE THE STACK POINTER LOCATION
0200 0500 8d 19                     BSR    OUT2A4   ;TYPE STACK POINTER ID
0201 0502 8e 7f 0e                  LDX    #SP
0202 0505 bd 0c e2                  JSR    OUT2BY   ;TYPE THE VALUE
0203 0508 7e 04 72                  JMP    NOMORE
0204                         
0205                         ;OUTPUT CONTENT OF A 1 BYTE REGISTER
0206 050b 8d 0e              OUT2   BSR    OUT2A4
0207 050d bd 0c d9                  JSR    OUT1BY
0208 0510 30 01                     LEAX   1,X
0209 0512 39                        RTS
0210                         
0211                         ;OUTPUT CONTENT OF A 2 BYTE REGISTER
0212 0513 8d 06              OUT4   BSR    OUT2A4
0213 0515 bd 0c e2                  JSR    OUT2BY
0214 0518 30 02                     LEAX   2,X      ;SKIP TO NEXT 2 BYTES IN STACK
0215 051a 39                        RTS
0216                         
0217                         ;MISC SETUP FOR REGISTER DISPLAY
0218 051b bd 0c cd           OUT2A4 JSR    OUTSP    ;OUTPUT A SPACE
0219 051e 7c 7f e3                  INC    COMNUM   ;SKIP TO NEXT REGISTER NAME
0220 0521 86 05                     LDA    #5       ;REGISTER NAME IS IN LIST 5
0221 0523 bd 0b 01                  JSR    TYPCMD   ;TYPE IT
0222 0526 bd 0c d3                  JSR    OUTEQ    ;TYPE AN "="
0223 0529 39                        RTS
0224                         
0225                         ;ENTER HERE FROM SOFTWARE INTERRUPT
0226 052a 8e 10 1c           TYPSWI LDX    #MSGSWI
0227 052d bd 0f 5e                  JSR    OUTSTR
0228                         ;DECREMENT PC SO IT POINTS TO "SWI" INSTRUCTION
0229 0530 be 7f 0e                  LDX    SP
0230 0533 6d 0c                     TST    12,X      ;TEST LO BYTE OF PC FOR PENDING BORROW
0231 0535 26 02                     BNE    TYPSW1
0232 0537 6a 0b                     DEC    11,X      ;NEED TO BORROW, DEC HI BYTE OF PC
0233 0539 6a 0c              TYPSW1 DEC    12,X      ;DECR LO BYTE OF PC
0234 053b 20 ab                     BRA    DISREG   ;GO DISPLAY REGISTERS
0235                         ;*****
0236                         ;GOTO - GO TO MEMORY ADDRESS
0237 053d bd 0c 23           GOTO   JSR    NUMBER   ;GET DESTINATION
0238 0540 27 08                     BEQ    GOTO1    ;IF NONE, USE DEFAULT
0239 0542 be 7f 1b                  LDX    NBRHI
0240 0545 bf 7f 21                  STX    LASTGO   ;SAVE IT
0241 0548 6e 84                     JMP    ,X       ;GO TO DESTINATION
0242                         
0243 054a be 7f 21           GOTO1  LDX   LASTGO    ;GET LAST GOTO ADDRESS
0244 054d 6e 84                     JMP   ,X        ;GO TO IT
0245                         
0246                         ;*****
0247                         ;SEI - SET INTERRUPT MASK
0248 054f 1a 10              LSEI   ORCC   #$10     ;SEI
0249 0551 20 37                     BRA    COPY3
0250                         
0251                         ;*****
0252                         ;SEF - SET FAST INTERRUPT MASK
0253 0553 1a 40              LSEF   ORCC   #$40     ;SEF
0254 0555 20 33                     BRA    COPY3
0255                         
0256                         ;*****
0257                         ;CLI - CLEAR INTERRUPT MASK
0258 0557 1c ef              LCLI   ANDCC  #$EF     ;CLI
0259 0559 20 2f                     BRA    COPY3
0260                         
0261                         ;*****
0262                         ;CLF - CLEAR FAST INTERRUPT MASK
0263 055b 1c ef              LCLF   ANDCC  #$EF     ;CLF
0264 055d 20 2b                     BRA    COPY3
0265                         
0266                         ;*****
0267                         ;COPY - COPY FROM ONE LOCATION TO ANOTHER
0268 055f bd 0b d8           COPY   JSR    GTRANG   ;GET SOURCE RANGE INTO RANGLO & RANGHI
0269 0562 2f 23                     BLE    COPY2    ;ERROR IF NO SOURCE
0270 0564 bd 0c 23                  JSR    NUMBER   ;GET DESTINATION
0271 0567 2f 1e                     BLE    COPY2    ;ERROR IF NO DESTINATION
0272                         
0273 0569 be 7f 1d                  LDX    RANGLO   ;GET SOURCE ADDRESS POINTER
0274 056c a6 84              COPY1  LDA    ,X       ;GET BYTE FROM SOURCE
0275 056e be 7f 1b                  LDX    NBRHI    ;GET DESTINATION ADDRESS POINTER
0276 0571 a7 84                     STA    ,X       ;SAVE BYTE IN DESTINATION
0277 0573 30 01                     LEAX   1,X      ;INC DESTINATION POINTER
0278 0575 bf 7f 1b                  STX    NBRHI    ;SAVE IT
0279 0578 be 7f 1d                  LDX    RANGLO   ;GET SOURCE ADDRESS POINTER
0280 057b bc 7f 1f                  CPX    RANGHI   ;COMPARE TO END OF INPUT RANGE
0281 057e 27 0a                     BEQ    COPY3    ;DONE IF EQUAL
0282 0580 30 01                     LEAX   1,X      ;NOT EQUAL, INC SOURCE POINTER
0283 0582 bf 7f 1d                  STX    RANGLO   ;SAVE IT
0284 0585 20 e5                     BRA    COPY1    ;LOOP FOR NEXT BYTE
0285                         
0286 0587 7e 04 59           COPY2  JMP    BADSYN   ;BAD SYNTAX
0287 058a 7e 04 72           COPY3  JMP    NOMORE   ;SHOULD BE NO MORE ON THE INPUT LINE
0288                         
0289                         ;*****
0290                         ;BREAK - SET BREAKPOINT AT SPECIFIED ADDRESS & REMOVE OLD ONE
0291 058d bd 0c 23           BREAK  JSR    NUMBER   ;GET BREAKPOINT LOCATION
0292 0590 2b 31                     BMI    BREAK3   ;IF NOT NUMERIC, LOOK FOR "?"
0293 0592 27 1f                     BEQ    BREAK2   ;IF NO MODIFIER, REMOVE OLD BREAKPOINT
0294                         
0295                         ;*****
0296                         ;CHECK IF A "SWI" IS STORED AT THE BREAK ADDRESS
0297 0594 be 7f 28                  LDX    BRKADR   ;GET CURRENT BREAK ADDRESS
0298 0597 a6 84                     LDA    ,X       ;AND THE CHAR THERE
0299 0599 81 3f                     CMPA   #$3F     ;COMPARE TO "SWI"
0300 059b 26 05                     BNE    BREAK1   ;EQUAL?
0301                         ;YES, RESTORE THE OLD INSTRUCTION
0302 059d b6 7f 2a                  LDA    BRKINS   ;GET IT
0303 05a0 a7 84                     STA    ,X       ;RESTORE IT
0304                         
0305                         ;PUT BREAK AT NEWLY SPECIFIED LOCATION
0306 05a2 be 7f 1b           BREAK1 LDX    NBRHI    ;GET NEW BREAKPOINT (BREAK ADDRESS)
0307 05a5 bf 7f 28                  STX    BRKADR   ;SAVE IT
0308 05a8 a6 84                     LDA    ,X       ;GET INSTRUCTION STORED THERE
0309 05aa b7 7f 2a                  STA    BRKINS   ;SAVE IT
0310 05ad 86 3f                     LDA    #$3F     ;GET CODE FOR SOFTWARE INTERRUPT
0311 05af a7 84                     STA    ,X       ;PUT IT AT BREAKPOINT
0312 05b1 20 34                     BRA    BREAK5   ;ALL DONE
0313                         
0314                         ;REMOVE BREAKPOINT
0315 05b3 be 7f 28           BREAK2 LDX    BRKADR   ;GET ADDRESS OF BREAK
0316 05b6 a6 84                     LDA    ,X       ;GET INST. THERE
0317 05b8 81 3f                     CMPA   #$3F     ;SWI?
0318 05ba 26 2b                     BNE    BREAK5   ;IF NOT,, RETURN & PROMPT
0319 05bc b6 7f 2a                  LDA    BRKINS   ;WAS A SWI - GET PREVIOUS INST.
0320 05bf a7 84                     STA    ,X       ;& RESTORE IT
0321 05c1 20 24                     BRA    BREAK5
0322                         
0323                         ;LOOK FOR A QUESTION MARK IN LIST 4
0324 05c3 86 04              BREAK3 LDA    #4
0325 05c5 bd 0a 97                  JSR    COMAND   ;SCAN FOR IT
0326 05c8 2f 20                     BLE    BREAK6   ;BAD SYNTAX IF NOT "?"
0327 05ca be 7f 28                  LDX    BRKADR   ;IT IS, GET BREAK ADDRESS
0328 05cd a6 84                     LDA    ,X       ;GET INSTRUCTION THERE
0329 05cf 81 3f                     CMPA   #$3F     ;IS IT A "SWI"?
0330 05d1 27 08                     BEQ    BREAK4   ;IF YES, SAY SO
0331                         ;NO BREAKPOINT SET
0332 05d3 8e 10 2b                  LDX    #MSGNBR  ;GET THAT MESSAGE
0333 05d6 bd 0f 5e                  JSR    OUTSTR   ;SAY IT
0334 05d9 20 0c                     BRA    BREAK5
0335                         ;BREAKPOINT SET
0336 05db 8e 10 33           BREAK4 LDX    #MSGBAT  ;GET THAT MESSAGE
0337 05de bd 0f 5e                  JSR    OUTSTR   ;SAY IT
0338 05e1 8e 7f 28                  LDX    #BRKADR  ;GET BREAK ADDRESS
0339 05e4 bd 0c e2                  JSR    OUT2BY   ;TYPE IT
0340                         
0341 05e7 7e 04 72           BREAK5 JMP    NOMORE
0342 05ea 7e 04 59           BREAK6 JMP    BADSYN
0343                         
0344                         ;*****
0345                         ;IBASE - SET INPUT BASE
0346                         ;LOOK FOR HEX, DEC, OR OCT IN LIST #3
0347 05ed 86 03              IBASE  LDA    #3
0348 05ef bd 0a 97                  JSR    COMAND
0349 05f2 2b 09                     BMI    IBASE2   ;UNRECOGNIZABLE BASE, TRY "?"
0350 05f4 2e 02                     BGT    IBASE1
0351 05f6 86 01                     LDA    #1       ;NO BASE GIVEN - DEFAULT TO HEX
0352 05f8 b7 7f 18           IBASE1 STA    IBCODE   ;SAVE BASE CODE
0353 05fb 20 ea                     BRA    BREAK5
0354                         
0355                         ;LOOK FOR "?" IN LIST #4
0356 05fd b6 7f 18           IBASE2 LDA    IBCODE   ;GET IB CODE IN CASE ITS NEEDED
0357 0600 34 02                     PSHS   A        ;SAVE IT ON STACK TEMPORARILY
0358 0602 20 26                     BRA    DBASE4
0359                         
0360                         ;*****
0361                         ;DBASE - SET DISPLAY BASE
0362                         ;LOOK FOR HEX,DEC,OCT OR BIN IN LIST #3
0363 0604 86 03              DBASE  LDA    #3
0364 0606 bd 0a 97                  JSR    COMAND
0365 0609 2b 1a                     BMI    DBASE3   ;UNRECOGNIZABLE BASE, TRY "?"
0366 060b 2e 02                     BGT    DBASE1
0367 060d 86 01                     LDA    #1       ;NO BASE GIVEN - DEFAULT TO HEX
0368 060f b7 7f 19           DBASE1 STA    DBCODE
0369                         
0370                         ;COMPUTE THE NUMERIC DISPLAY BASE (FOR THE "DISPLAY" COMMAND)
0371 0612 8e 06 20                  LDX    #DBTBL-1 ;POINT TO HEAD OF DISPLAY BASE TABLE
0372 0615 30 01              DBASE2 LEAX   1,X      ;INC TABLE POINTER
0373 0617 4a                        DECA            ;DECR DISPLAY BASE CODE
0374 0618 26 fb                     BNE    DBASE2   ;LOOP IF NOT EQUAL
0375 061a a6 84                     LDA    ,X       ;EQUAL - GET NUMERIC BASE FROM TABLE
0376 061c b7 7f 1a                  STA    DBNBR    ;SAVE IT
0377 061f 20 c6                     BRA    BREAK5   ;DONE
0378                         
0379                         ;DISPLAY BASE TABLE
0380 0621 10                 DBTBL  FCB    16
0381 0622 0a                        FCB    10
0382 0623 08                        FCB    8
0383 0624 02                        FCB    2
0384                         
0385                         ;LOOK FOR "?" IN LIST #4
0386 0625 b6 7f 19           DBASE3 LDA    DBCODE   ;GET DB CODE IN CASE ITS NEEDED
0387 0628 34 02                     PSHS   A        ;SAVE IT ON STACK TEMPORARILY
0388 062a 86 04              DBASE4 LDA    #4
0389 062c bd 0a 97                  JSR    COMAND
0390 062f 35 04                     PULS   B        ;RETRIEVE INPUT BASE/DISPLAY BASE CODE
0391 0631 2f b7                     BLE    BREAK6   ;ERROR IF THE "SOMETHING" WAS NOT AN "?"
0392                         ;SET UP FOR TYPEOUT OF BASE CODE
0393 0633 86 03                     LDA    #3       ;ITS IN LIST
0394 0635 f7 7f e3                  STB    COMNUM   ;STORE BASE CODE
0395 0638 bd 0b 01                  JSR    TYPCMD   ;TYPE OUT BASE
0396 063b 20 aa                     BRA    BREAK5
0397                         ;*****
0398                         ;CONTINUE - CONTINUE FROM A "SWI"
0399                         ;RETURN TO LOCATION WHERE SWI WAS
0400 063d 10 fe 7f 0e        CONTIN LDS    SP       ;IN CASE SP WAS MODIFIED VIA SET COMMAND
0401 0641 3b                        RTI
0402                         
0403                         ;*****
0404                         ;DISPLAY - DISPLAY MEMORY DATA
0405 0642 bd 0b d8           DISPLA JSR    GTRANG   ;GET MEMORY DISPLAY RANGE
0406 0645 2f 61                     BLE    DISPL9   ;ADDRESS IS REQUIRED
0407                         
0408                         ;INITIALIZE ADDRESS POINTER TO START OF MEMORY
0409 0647 be 7f 1d                  LDX    RANGLO
0410 064a bf 7f c5                  STX    MEMADR
0411                         
0412                         ;SEARCH LIST 6 FOR DISPLAY MODIFIERS "DATA" OR "USED"
0413 064d 86 06                     LDA    #6
0414 064f bd 0a 97                  JSR    COMAND
0415 0652 2b 54                     BMI    DISPL9   ;ANY OTHER MODIFIER IS ILLEGAL
0416                         ;ADJ DISPLAY MODIFIER CODE SO THAT: -1=ADDR & DATA, 0=DATA, I=USED
0417 0654 4a                        DECA
0418 0655 b7 7f e3                  STA    COMNUM   ;SAVE FOR LATER TESTS
0419                         ;INIT "DATA VALUES PER LINE" COUNTER
0420 0658 5f                        CLRB
0421 0659 5c                        INCB
0422 065a 8e 7f c5           DISPL1 LDX    #MEMADR
0423 065d 7d 7f e3                  TST    COMNUM   ;WHICH DISPLAY OPTION?
0424 0660 2b 2c                     BMI    DISPL6   ;IF "ADDRESS & DATA", GO THERE
0425                         
0426                         ;OUTPUT DATA WITH ADDRESS ONLY AT LINE BEGINNING
0427 0662 5a                        DECB            ;COUNT DATA VALUES PER LINE
0428 0663 26 0c                     BNE    DISPL2   ;IF COUNT NOT UP, SKIP ADDRESS OUTPUT
0429                         
0430 0665 bd 0f e5                  JSR    DOCRLF   ;GET TO LINE BEGINNING
0431 0668 bd 0c e2                  JSR    OUT2BY   ;OUTPUT ADDRESS
0432 066b bd 0c cd                  JSR    OUTSP    ;AND A SPACE
0433 066e f6 7f 1a                  LDB    DBNBR    ;RESET LINE COUNTER
0434                         
0435 0671 be 7f c5           DISPL2 LDX    MEMADR   ;POINT TO DATA AT THAT ADDRESS
0436 0674 7d 7f e3                  TST    COMNUM   ;WANT "DATA" OPTION?
0437 0677 2e 05                     BGT    DISPL3   ;IF NOT, GO TO "USES" CODE
0438                         
0439                         ;"DATA" OPTION
0440 0679 bd 0c cd                  JSR    OUTSP    ;OUTPUT PRECEDING SPACE
0441 067c 20 1b                     BRA    DISPL7
0442                         ;"USED" OPTION
0443 067e a6 84              DISPL3 LDA    ,X       ;GET THE DATA
0444 0680 4d                        TSTA            ;EXAMINE IT FOR ZERO
0445 0681 26 04                     BNE    DISPL4
0446 0683 86 2e                     LDA    #'.'     ;ITS ZERO, GET A "."
0447 0685 20 02                     BRA    DISPL5
0448 0687 86 2b              DISPL4 LDA    #'+'     ;ITS NON-ZERO. GET A "+"
0449 0689 bd 0f 8d           DISPL5 JSR    OUTCHR   ;OUTPUT THE "." OR "+"
0450 068c 20 0e                     BRA    DISPL8
0451                         
0452 068e bd 0c cd           DISPL6 JSR    OUTSP    ;OUTPUT A PRECEEDING SPACE
0453 0691 bd 0c e2                  JSR    OUT2BY   ;TYPE ADDRESS
0454 0694 bd 0c d3                  JSR    OUTEQ    ;TYPE "="
0455 0697 ae 84                     LDX    ,X       ;GET CONTENT
0456 0699 bd 0c d9           DISPL7 JSR    OUT1BY   ;TYPE IT
0457                         
0458 069c bc 7f 1f           DISPL8 CPX    RANGHI   ;ARE WE DONE?
0459 069f 27 0a                     BEQ    DISP10   ;IF YES, BACK TO PROMPT
0460 06a1 30 01                     LEAX   1,X      ;NO, INC MEMORY ADDRESS
0461 06a3 bf 7f c5                  STX    MEMADR   ;SAVE IT
0462 06a6 20 b2                     BRA    DISPL1
0463                         
0464 06a8 7e 04 59           DISPL9 JMP    BADSYN
0465 06ab 7e 04 72           DISP10 JMP    NOMORE
0466                         
0467                         ;*****
0468                         ;SET - SET MEMORY LOCATIONS
0469 06ae bd 0b d8           SET    JSR    GTRANG   ;GET MEMORY LOCATION/RANGE
0470 06b1 2b 52                     BMI    SET5     ;IF NOT AN ADDRESS, LOOK FOR A REGISTER NAME
0471 06b3 27 f3                     BEQ    DISPL9   ;AN ADDRESS MODIFIER IS REQUIRED
0472                         
0473                         ;RANGE OF ADDRESSES SPECIFIED?
0474 06b5 be 7f 1d                  LDX    RANGLO
0475 06b8 bc 7f 1f                  CPX    RANGHI
0476 06bb 27 13                     BEQ    SET2     ;IF SINGLE ADDRESS, SET UP ADDRESSES INDIVIDUALLY
0477                         ;SET A RANGE OF ADDRESSES TO A SINGLE VALUE
0478 06bd bd 0c 23                  JSR    NUMBER   ;GET THAT VALUE
0479 06c0 2f e6                     BLE    DISPL9   ;ITS REQUIRED
0480 06c2 b6 7f 1c                  LDA    NBRLO    ;PUT IT IN ACCA
0481 06c5 a7 84              SET1   STA    ,X       ;STORE IT IN DESTINATION
0482 06c7 bc 7f 1f                  CPX    RANGHI   ;END OF RANGE HIT?
0483 06ca 27 df                     BEQ    DISP10   ;IF YES,ALL DONE
0484 06cc 30 01                     LEAX   1,X      ;NO, ON TO NEXT ADDRESS IN RANGE
0485 06ce 20 f5                     BRA    SET1     ;LOOP TO SET IT
0486                         ;SET ADDRESSES UP INDIVIDUALLY
0487 06d0 bf 7f c5           SET2   STX    MEMADR   ;SAVE MEMORY LOC
0488 06d3 bd 0c 23           SET3   JSR    NUMBER   ;GET DATA TO PUT THERE
0489 06d6 27 0e                     BEQ    SET4     ;END OF LINE?
0490 06d8 2d ce                     BLT    DISPL9   ;ABORT IF BAD SYNTAX
0491 06da b6 7f 1c                  LDA    NBRLO    ;LOAD DATA BYTE
0492 06dd be 7f c5                  LDX    MEMADR   ;LOAD ADDRESS
0493 06e0 a7 84                     STA    ,X       ;STORE DATA
0494                         
0495                         ;INCREMENT ADDRESS IN CASE USER WANTS TO INDIVIDUALLY SET SEVERAL
0496                         ;SUCCESSIVE LOCATIONS
0497 06e2 30 01                     LEAX   1,X
0498 06e4 20 ea                     BRA    SET2
0499                         
0500                         ;END OF LINE - WAS IT TERMINATED WITH A LINE FEED?
0501 06e6 be 7f 12           SET4   LDX    SYNPTR   ;POINT TO END OF LINE
0502 06e9 a6 84                     LDA    ,X       ;GET CHAR THERE
0503 06eb 81 0a                     CMPA   #LF      ;LINE FEED?
0504 06ed 10 26 00 8f               LBNE   SET12    ;IF NOT, BACK TO PROMPT
0505 06f1 8e 7f c5                  LDX    #MEMADR  ;YES, GET NEXT ADDRESS TO BE SET
0506 06f4 bd 0c e2                  JSR    OUT2BY   ;TYPE IT
0507 06f7 bd 0c cd                  JSR    OUTSP    ;AND A SPACE
0508 06fa bd 0e 9c                  JSR    GETLIN   ;GET A NEW LINE
0509 06fd be 7f 34                  LDX    BUFBEG   ;GET BUFFER BEGINNING
0510 0700 bf 7f 12                  STX    SYNPTR   ;EQUATE IT TO SYNTAX SCAN POINTER
0511 0703 20 ce                     BRA    SET3     ;GO PICK UP DATA
0512                         
0513                         
0514                         ;LOOK FOR (REGISTER NAME, REGISTER VALUE) PAIRS
0515 0705 86 05              SET5   LDA    #5
0516 0707 bd 0a 97                  JSR    COMAND   ;PICK UP A REGISTER NAME
0517 070a 2b 71                     BMI    SET11    ;ERROR IF UNRECOGNIZABLE
0518 070c 27 72                     BEQ    SET12    ;DONE IF END OF LINE
0519 070e 34 02                     PSHS   A        ;SAVE REGISTER NAME(NUMBER)
0520 0710 bd 0c 23                  JSR    NUMBER   ;GET NEW REGISTER VALUE
0521 0713 35 02                     PULS   A        ;RESTORE REGISTER NAME(NUMBER)
0522 0715 2f 66                     BLE    SET11    ;GOT GOOD REGISTER VALUE?
0523 0717 be 7f 0e                  LDX    SP       ;YES, POINT TO TOP OF STACK
0524 071a f6 7f 1c                  LDB    NBRLO    ;GET REGISTER VALUE
0525                         
0526                         ;CONDITION CODES
0527 071d 81 01                     CMPA   #1
0528 071f 26 04                     BNE    SET6
0529 0721 e7 01                     STB    1,X
0530 0723 20 e0                     BRA    SET5
0531                         ;ACCA
0532 0725 81 02              SET6   CMPA   #2
0533 0727 26 04                     BNE    SET7
0534 0729 e7 02                     STB    2,X
0535 072b 20 d8                     BRA    SET5
0536                         
0537                         ;ACCB
0538 072d 81 03              SET7   CMPA   #3
0539 072f 26 04                     BNE    SET7A
0540 0731 e7 03                     STB    3,X
0541 0733 20 d0                     BRA    SET5
0542                         
0543                         ;DP
0544 0735 81 04              SET7A  CMPA   #4
0545 0737 26 04                     BNE    SET8
0546 0739 e7 04                     STB    4,X
0547 073b 20 c8                     BRA    SET5
0548                         
0549                         ;X
0550 073d 81 05              SET8   CMPA   #5
0551 073f 26 09                     BNE    SET8A
0552 0741 b6 7f 1b                  LDA    NBRHI
0553 0744 a7 05                     STA    5,X      ;UPDATE HI BYTE
0554 0746 e7 06                     STB    6,X      ;UPDATE LO BYTE
0555 0748 20 bb                     BRA    SET5
0556                         
0557                         ;Y
0558 074a 81 06              SET8A  CMPA   #6
0559 074c 26 09                     BNE    SET8B
0560 074e b6 7f 1b                  LDA    NBRHI
0561 0751 a7 07                     STA    7,X      ;UPDATE HI BYTE
0562 0753 e7 08                     STB    8,X      ;UPDATE LO BYTE
0563 0755 20 ae                     BRA    SET5
0564                         
0565                         ;U
0566 0757 81 07              SET8B  CMPA   #7
0567 0759 26 09                     BNE    SET9
0568 075b b6 7f 1b                  LDA    NBRHI
0569 075e a7 09                     STA    9,X      ;UPDATE HI BYTE
0570 0760 e7 0a                     STB    10,X     ;UPDATE LO BYTE
0571 0762 20 a1                     BRA    SET5
0572                         
0573                         ;PC
0574 0764 81 08              SET9   CMPA   #8
0575 0766 26 09                     BNE    SET10
0576 0768 b6 7f 1b                  LDA    NBRHI
0577 076b a7 0b                     STA    11,X     ;UPDATE HI BYTE
0578 076d e7 0c                     STB    12,X     ;UPDATE LO BYTE
0579 076f 20 94                     BRA    SET5
0580                         
0581                         ;S
0582 0771 81 09              SET10  CMPA   #9
0583 0773 26 08                     BNE    SET11
0584 0775 be 7f 1b                  LDX    NBRHI    ;DON'T NEED IX TO SET SP
0585 0778 bf 7f 0e                  STX    SP
0586 077b 20 88                     BRA    SET5
0587                         
0588 077d 7e 04 59           SET11  JMP    BADSYN
0589 0780 7e 04 72           SET12  JMP    NOMORE
0590                         ;*****
0591                         ;VERIFY - CHECKSUM VERIFY A BLOCK OF MEMORY
0592 0783 bd 0b d8           VERIFY JSR    GTRANG   ;GET A NUMBER RANGE
0593 0786 27 1b                     BEQ    VERIF1   ;NO MODIFIER MEANS CHECK WHAT WE HAVE
0594 0788 2b f3                     BMI    SET11    ;ANYTHING ELSE IS ILLEGAL
0595                         ;GOOD RANGE GIVEN, TRANSFER IT TO CHECKSUM ADDRESSES
0596 078a be 7f 1d                  LDX    RANGLO
0597 078d bf 7f 23                  STX    VERFRM
0598 0790 be 7f 1f                  LDX    RANGHI
0599 0793 bf 7f 25                  STX    VERTO
0600                         
0601 0796 8d 22                     BSR    CKSUM    ;COMPUTE CHECKSUM
0602 0798 b7 7f 27                  STA    CHKSUM   ;SAVE IT
0603 079b 8e 7f 27                  LDX    #CHKSUM  ;TYPE THE CHECKSUM
0604 079e bd 0c d9                  JSR    OUT1BY
0605 07a1 20 dd                     BRA    SET12
0606                         
0607                         ;NO MODIFIER GIVEN - JUST VERIFY CHECKSUM
0608 07a3 8d 15              VERIF1 BSR    CKSUM    ;COMPUTE CHECKSUM
0609 07a5 b1 7f 27                  CMPA   CHKSUM   ;SAME AS STORED CHECKSUM?
0610 07a8 26 08                     BNE    VERIF2
0611                         
0612                         ;THEY VERIFY - SAY SO
0613 07aa 8e 10 3a                  LDX    #MSGVER
0614 07ad bd 0f 5e                  JSR    OUTSTR
0615 07b0 20 ce                     BRA    SET12
0616                         
0617                         ;THEY DON'T - SAY SO
0618 07b2 8e 10 3d           VERIF2 LDX    #MSGNVE
0619 07b5 bd 0f 5e                  JSR    OUTSTR
0620 07b8 20 c6                     BRA    SET12
0621                         
0622                         ;COMPUTE THE CHECKSUM FROM ADDRESSES VERFRM TO VERTO
0623                         ;RETURN THE CHECKSUM IN ACCA
0624 07ba 4f                 CKSUM  CLRA            ;INIT CHECKSUM TO ZERO
0625 07bb be 7f 23                  LDX    VERFRM   ;GET FIRST ADDRESS
0626 07be 30 1f                     LEAX   -1,X     ;INIT TO ONE LESS
0627 07c0 30 01              CKSUM1 LEAX   1,X      ;START OF CHECKSUM LOOP
0628 07c2 ab 84                     ADDA   ,X       ;UPDATE CHECKSUM IN ACCA WITH BYTE POINTED TO
0629 07c4 bc 7f 25                  CPX    VERTO    ;HIT END OF RANGE?
0630 07c7 26 f7                     BNE    CKSUM1   ;IF NOT, LOOP BACK
0631 07c9 43                        COMA            ;COMPLEMENT THE SUM
0632 07ca 39                        RTS             ;RETURN WITH IT
0633                         ;*****
0634                         ;SEARCH - SEARCH MEMORY FOR A BYTE STRING
0635                         
0636                         ;GLOBAL VARIABLES USED
0637                         ;LINPTR - INPUT LINE CHARACTER POINTER
0638                         ;LISPTR - COMMAND LIST CHARACTER POINTER
0639                         ;RANGLO - "SEARCH FROM" ADDRESS
0640                         ;RANGHI - "SEARCH TO" ADDRESS
0641                         
0642                         ;LOCAL VARIABLES USE
0643                         ;MEMADR - STARTING MEMORY ADDRESS WHERE A MATCH OCCURRED
0644                         ;BYTPTR - ADDRESS POINTER USED TO FILL BYTSTR AND SUBSTR BUFFERS
0645                         ;NBYTES - NUMBER OF BYTES IN BYTE STRING
0646                         ;NBRMAT - NUMBER OF CHARS THAT MATCH SO FAR IN THE MATCHING PROCESS
0647                         ;BYTSTR - STARTING ADDRESS OF 6 CHARACTER BYTE STRING BUFFER
0648                         
0649                         ;THE SEARCH STRING OCCUPIES TEMP4, TEMP5, & TEMP6 (6 BYTES MAX)
0650                         
0651                         ;GET SEARCH RANGE BEGINNING (RANGLO) & END (RANGHI)
0652 07cb bd 0b d8           SEARCH JSR    GTRANG
0653 07ce 10 2f 00 84               LBLE   SEARC9   ;ABORT IF NO PAIR
0654                         
0655                         ;INITIALIZED BYTE STRING POINTER
0656 07d2 8e 7f cb                  LDX    #BYTSTR  ;GET START OF BYTE STRING TO SEARCH FOR
0657 07d5 bf 7f c7                  STX    BYTPTR   ;SET POINTER TO IT
0658                         
0659 07d8 7f 7f c9                  CLR    NBYTES   ;ZERO # OF BYES IN BYTE STRING
0660                         
0661                         ;GET BYTE STRING
0662 07db bd 0c 23           SEARC1 JSR    NUMBER   ;GET A BYTE
0663 07de 27 1b                     BEQ    SEARC2   ;BEGIN SEARCH IF EOL
0664 07e0 2d 74                     BLT    SEARC9
0665                         
0666                         ;GOOD BYTE, ADD IT TO STRING
0667 07e2 7c 7f c9                  INC    NBYTES   ;COUNT THIS BYTE
0668                         ;DON'T ACCEPT OVER 6 BYTES
0669 07e5 b6 7f c9                  LDA    NBYTES
0670 07e8 81 06                     CMPA   #6
0671 07ea 2e 6a                     BGT    SEARC9
0672                         
0673 07ec b6 7f 1c                  LDA    NBRLO    ;GET (LOW ORDER) BYTE
0674 07ef be 7f c7                  LDX    BYTPTR   ;GET BYTE POINTER
0675 07f2 a7 84                     STA    ,X       ;SAVE BYTE
0676 07f4 30 01                     LEAX   1,X      ;MOVE BYTE POINTER TO NEXT LOCATION IN STRING
0677 07f6 bf 7f c7                  STX    BYTPTR   ;SAVE IT
0678 07f9 20 e0                     BRA    SEARC1
0679                         
0680                         ;BEGIN SEARCH FOR BYTE STRING
0681                         ;IS # OF BYTES TO LOOK FOR >0
0682 07fb 7d 7f c9           SEARC2 TST    NBYTES
0683 07fe 27 56                     BEQ    SEARC9   ;IF NOT, BAD SYNTAX
0684                         
0685                         ;MAKE USE OF INPUT LINE CHARACTER FETCH & COMMAND LIST CHAR FETCH ROUTINES
0686                         
0687                         ;INITIALIZE MEMORY POINTER TO START OF SEARCH RANGE
0688 0800 be 7f 1d                  LDX    RANGLO
0689 0803 30 1f                     LEAX   -1,X
0690 0805 bf 7f 14                  STX    LINPTR
0691                         
0692                         ;INITIALIZE BYTE POINTER TO START OF BYTE STRING
0693 0808 8e 7f ca           SEARC3 LDX    #BYTSTR-1
0694 080b bf 7f e4                  STX    LISPTR
0695                         
0696 080e 7f 7f ca                  CLR    NBRMAT   ;SET "NUMBER OF BYTES THAT MATCHED" TO ZERO
0697                         ;GET BYTE FROM BYTE STRING & RETURN IT IN ACCA
0698 0811 bd 0d b2                  JSR    GETLST
0699                         ;GET BYTE FROM MEMORY RANGE & RETURN IT IN ACCB
0700 0814 bd 0d a4           SEARC4 JSR    GETCHR
0701                         
0702 0817 34 04                     PSHS   B        ;CBA
0703 0819 a1 e0                     CMPA   ,S+      ;COMPARE MEMORY & BYTE STRING CHARACTERS
0704 081b 27 07                     BEQ    SEARC5   ;IF NO MATCH, TEST FOR RANGE END
0705 081d bc 7f 1f                  CPX    RANGHI   ;HAVE WE REACHED THE RANGE SEARCH UPPER LIMIT?
0706 0820 27 37                     BEQ    SEAR10   ;YES, GO PROMPT FOR NEXT COMMAND
0707 0822 20 f0                     BRA    SEARC4
0708                         
0709                         ;MATCH ACHIEVED - SAVE ADDRESS OF MATCH
0710 0824 bf 7f c5           SEARC5 STX    MEMADR
0711 0827 7c 7f ca           SEARC6 INC    NBRMAT   ;BUMP NUMBER MATCHED
0712 082a b6 7f ca                  LDA    NBRMAT
0713 082d b1 7f c9                  CMPA   NBYTES   ;HAVE ALL CHARACTERS MATCHED?
0714 0830 27 19                     BEQ    SEARC8   ;IF SO, MATCH ACHIEVED
0715                         ;HAVEN'T MATCHED ALL YET, GO GET NEXT PAIR EVEN IF PAST "SEARCH TO" ADDRESS
0716 0832 bd 0d b2                  JSR    GETLST
0717 0835 bd 0d a4                  JSR    GETCHR
0718 0838 34 04                     PSHS   B        ;CBA
0719 083a a1 e0                     CMPA   ,S+
0720 083c 27 e9                     BEQ    SEARC6
0721                         ;MISMATCH ON SOME BYTE PAST THE FIRST ONE
0722                         ;RESET THE MEMORY POINTER TO GET NEXT UNTESTED MEMORY LOCATION
0723 083e be 7f c5           SEARC7 LDX    MEMADR
0724                         ;THIS TEST HANDLES SPECIAL CASE OF A MATCH ON RANGE END
0725 0841 bc 7f 1f                  CPX    RANGHI
0726 0844 27 13                     BEQ    SEAR10
0727 0846 bf 7f 14                  STX    LINPTR
0728                         ;GO RESET THE BYTE STRING POINTER
0729 0849 20 bd                     BRA    SEARC3
0730                         
0731                         ;MATCH ON BYTE STRING ACHIEVED, TYPE OUT MEMORY ADDRESS
0732 084b 8e 7f c5           SEARC8 LDX    #MEMADR
0733 084e bd 0c e2                  JSR    OUT2BY
0734 0851 bd 0c cd                  JSR    OUTSP    ;AND A SPACE
0735                         ;ASSUME A MISMATCH (I.E., RESET MEMORY & BYTE STRING POINTERS & CONTINUE
0736 0854 20 e8                     BRA    SEARC7
0737                         
0738 0856 7e 04 59           SEARC9 JMP    BADSYN
0739 0859 7e 04 72           SEAR10 JMP    NOMORE
0740                         
0741                         ;*****
0742                         ;TEST - TEST RAM FOR BAD BYTES
0743                         ;GET AN ADDRESS RANGE
0744 085c bd 0b d8           TEST   JSR    GTRANG
0745 085f 2f f5                     BLE    SEARC9   ;ABORT IF NO PAIR
0746                         ;RANGLO HOLS STARTING ADDRESS OF RANGE
0747                         ;RANGHI HOLDS ENDING ADDRESS OF RANGE
0748 0861 be 7f 1d                  LDX    RANGLO
0749 0864 bf 7f c5                  STX    MEMADR
0750                         ;GET BYTE STORED AT TEST LOCATION & SAVE IT
0751 0867 a6 84              TEST1  LDA    ,X
0752 0869 34 02                     PSHS   A
0753                         
0754 086b 6f 84                     CLR    ,X       ;ZERO THE LOCATION
0755 086d 6d 84                     TST    ,X       ;TEST IT
0756 086f 27 05                     BEQ    TEST2    ;OK IF = ZERO
0757                         
0758                         ;CAN'T CLEAR LOCATION
0759 0871 8e 10 4d                  LDX    #MSGCCL
0760 0874 20 20                     BRA    TEST4
0761                         
0762 0876 6a 84              TEST2  DEC    ,X       ;SET LOCATION TO FF
0763 0878 86 ff                     LDA    #$FF
0764 087a a1 84                     CMPA   ,X       ;DID IT GET SET TO FF?
0765 087c 27 05                     BEQ    TEST3
0766                         
0767                         ;CAN'T SET LOCATION TO ONE'S
0768 087e 8e 10 59                  LDX    #MSGCSO
0769 0881 20 13                     BRA    TEST4
0770                         
0771 0883 be 7f c5           TEST3  LDX    MEMADR   ;GET LOCATION BEING TESTED
0772 0886 35 02                     PULS   A
0773 0888 a7 84                     STA    ,X       ;RESTORE PREVIOUS CONTENT
0774                         
0775                         ;HIT END OF TEST RANGE?
0776 088a bc 7f 1f                  CPX    RANGHI
0777 088d 27 ca                     BEQ    SEAR10   ;YES, ALL DONE
0778                         
0779                         ;NO, MOVE TO TEST NEXT LOCATION
0780 088f 30 01                     LEAX   1,X
0781 0891 bf 7f c5                  STX    MEMADR
0782 0894 20 d1                     BRA    TEST1
0783                         
0784                         ;*LOCATION IS BAD
0785 0896 bf 7f c9           TEST4  STX    TEMP3    ;SAVE ERROR MESSAGE TEMPORARILY
0786                         
0787 0899 8e 7f c5                  LDX    #MEMADR
0788 089c bd 0c e2                  JSR    OUT2BY   ;TYPE OUT BAD ADDRESS.
0789 089f bd 0c d3                  JSR    OUTEQ    ;AN EQUAL SIGN
0790                         
0791 08a2 be 7f c5                  LDX    MEMADR
0792 08a5 bd 0c d9                  JSR    OUT1BY   ;ITS CONTENT.
0793 08a8 bd 0c cd                  JSR    OUTSP    ;A SPACE.
0794 08ab be 7f c9                  LDX    TEMP3
0795 08ae bd 0f 5e                  JSR    OUTSTR   ;AND THE TYPE OF ERROR
0796                         
0797 08b1 bd 0f e5                  JSR    DOCRLF   ;SEND CR-LF
0798 08b4 20 cd                     BRA    TEST3
0799                         ;*****
0800                         ;INT - SET UP INTERRUPT POINTER
0801 08b6 bd 0c 18           INT    JSR    NUMINX   ;GET POINTER IN IX
0802 08b9 bf 7f 00                  STX    INTVEC   ;SAVE IT
0803 08bc 20 4c                     BRA    COMPA1
0804                         
0805                         ;*****
0806                         ;NMI - SET UP NON-MASKABLE INTERRUPT POINTER
0807 08be bd 0c 18           NMI    JSR    NUMINX   ;GET POINTER IN IX
0808 08c1 bf 7f 04                  STX    NMIVEC   ;SAVE IT
0809 08c4 20 44                     BRA    COMPA1
0810                         
0811                         ;*****
0812                         ;SWI - SET UP SWI POINTER
0813 08c6 bd 0c 18           LSWI   JSR    NUMINX   ;GET POINTER TO IX
0814 08c9 bf 7f 08                  STX    SWIVEC   ;SAVE IT
0815 08cc 20 3c                     BRA    COMPA1
0816                         
0817                         ;*****
0818                         ;SWI2 - SET UP SWI2 POINTER
0819 08ce bd 0c 18           LSWI2  JSR    NUMINX   ;GET POINTER TO IX
0820 08d1 bf 7f 0a                  STX    SWI2VC   ;SAVE IT
0821 08d4 20 34                     BRA    COMPA1
0822                         
0823                         ;*****
0824                         ;SWI3 - SET UP SW3 POINTER
0825 08d6 bd 0c 18           LSWI3  JSR    NUMINX   ;GET POINTER TO IX
0826 08d9 bf 7f 0c                  STX    SWI3VC   ;SAVE IT
0827 08dc 20 2c                     BRA    COMPA1
0828                         
0829                         ;*****
0830                         ;FIRQ - SET UP FAST INTERRUPT POINTER
0831 08de bd 0c 18           FIRQ   JSR    NUMINX   ;GET POINTER IN IX
0832 08e1 bf 7f 02                  STX    FIRQVC   ;SAVE IT
0833 08e4 20 24                     BRA    COMPA1
0834                         
0835                         ;*****
0836                         ;RSRVD - SET UP RESERVED INTERRUPT POINTER
0837 08e6 bd 0c 18           RSRVD  JSR    NUMINX   ;GET POINTER IN IX
0838 08e9 bf 7f 06                  STX    RSRVDVC  ;SAVE IT
0839 08ec 20 1c                     BRA    COMPA1
0840                         
0841                         ;*****
0842                         ;COMPARE - OUTPUT SUM & DIFFERENCE OF TWO INPUT NUMBERS
0843 08ee bd 0c 18           COMPAR JSR    NUMINX   ;GET FIRST NUMBER
0844 08f1 bf 7f 1d                  STX    RANGLO   ;PUT IT IN RANGLO
0845                         
0846 08f4 bd 0c 18                  JSR    NUMINX   ;GET SECOND NUMBER
0847 08f7 bf 7f 1b                  STX    NBRHI    ;SAVE IT IN NBRHI
0848                         
0849                         ;COMPUTE AND OUTPUT THE SUM
0850 08fa bd 0b b2                  JSR    SUMNUM   ;COMPUTE SUM
0851 08fd 8e 10 6b                  LDX    #MSGSIS  ;GETS ITS TITLE
0852 0900 8d 0b                     BSR    OUTSD    ;OUTPUT TITLE & SUM
0853                         
0854 0902 bd 0b c5                  JSR    DIFNUM   ;COMPUTE DIFFERENCE
0855 0905 8e 10 73                  LDX    #MSGDIS  ;GET ITS TITLE
0856 0908 8d 03                     BSR    OUTSD    ;OUTPUT TITLE & DIFFERENCE
0857                         
0858 090a 7e 04 72           COMPA1 JMP    NOMORE
0859                         
0860                         ;COMPUTE AND OUTPUT THE RESULT
0861 090d bd 0f 5e           OUTSD  JSR    OUTSTR   ;OUTPUT IT
0862 0910 8e 7f 1f                  LDX    #RANGHI  ;GET RESULT
0863 0913 bd 0c e2                  JSR    OUT2BY   ;DISPLAY RESULT
0864 0916 39                        RTS
0865                         ;*****
0866                         ;DUMP - DUMP A PORTION OF MEMORY, IN MIKBUG FORMAT, TO A SPECIFIED ACIA ADDRESS
0867                         
0868                         ;GET ADDRESS RANGE: START IN RANGLO (2 BYTES), END IN RANGHI (2 BYTES)
0869                         ;IF NO ADDRESS RANGE IS GIVEN, USE WHATEVER IS IN RANGLO & RANGHI
0870 0917 bd 0b d8           DUMP   JSR    GTRANG
0871                         
0872 091a 7f 7f cd                  CLR    TEMP5    ;INITIALIZE TO DUMP TO TERMINAL
0873                         
0874                         ;LOOK FOR A "TO" MODIFIER
0875 091d 86 02              DUMP1  LDA    #2
0876 091f bd 0a 97                  JSR    COMAND
0877 0922 27 15                     BEQ    DUMP4
0878 0924 10 2f 00 80        DUMP2  LBLE   DUMP10   ;ERROR IF BAD SYNTAX
0879 0928 81 01                     CMPA   #1       ;TO?
0880 092a 27 02                     BEQ    DUMP3
0881 092c 20 ef                     BRA    DUMP1    ;GO LOOK FOR ANOTHER MODIFIER
0882                         
0883 092e bd 0c 18           DUMP3  JSR    NUMINX   ;GET "TO" ADDRESS
0884 0931 bf 7f 2f                  STX    OUTADR   ;SAVE IT
0885 0934 7c 7f cd                  INC    TEMP5    ;REMEMBER THIS
0886 0937 20 e4                     BRA    DUMP1    ;GO LOOK FOR ANOTHER MODIFIER
0887                         
0888 0939 7d 7f cd           DUMP4  TST    TEMP5
0889 093c 27 03                     BEQ    DUMP5
0890 093e 7c 7f 2e                  INC    OUTFLG   ;SET FLAG FOR PROPER OUTPUT DEVICE
0891 0941 8d 68              DUMP5  BSR    NULLS    ;SEND SOME NULLS
0892                         
0893                         ;MIKBUG MODE
0894                         ;OUTPUT AN "S0" TYPE RECORD
0895 0943 8e 10 7e                  LDX    #MSGS0
0896 0946 bd 0f 5e                  JSR    OUTSTR
0897                         
0898                         ;COMPUTER # OF BYTES TO OUTPUT (RANGE END - RANGE START + 1)
0899                         ;SUBTRACT LO BYTES
0900 0949 b6 7f 20           DUMP6  LDA    RANGHI+1
0901 094c b0 7f 1e                  SUBA   RANGLO+1
0902                         ;SUBTRACT HI BYTES
0903 094f f6 7f 1f                  LDB    RANGHI
0904 0952 f2 7f 1d                  SBCB   RANGLO
0905                         ;NON-ZERO HI BYTE IMPLIES LOTS TO OUTPUT
0906 0955 26 04                     BNE    DUMP7
0907                         ;HI BYTE DIFF IS ZERO
0908 0957 81 10                     CMPA   #16      ;LO BYTE OF DIFF 0 TO 15
0909 0959 25 02                     BCS    DUMP8    ;IF YES, TO DUMP8
0910 095b 86 0f              DUMP7  LDA    #15      ;NO, LO BYTE IS 16-255; SET BYTES TO 15
0911                         ;TO GET FRAME COUNT, ADD 1 (DIFF OF 0 IMPLIES 1 OUTPUT) + # OF DATA BYTES,
0912                         ; + 2 ADDR BYTES + 1 CHECKSUM BYTE
0913 095d 8b 04              DUMP8  ADDA   #4
0914 095f b7 7f c9                  STA    TEMP3    ;TEMP3 IS THE FRAME COUNT
0915 0962 80 03                     SUBA   #3
0916 0964 b7 7f cb                  STA    TEMP4    ;TEMP4 IS THE RECORD BYTE COUNT
0917                         ;OUTPUT A MIKBUG "S1" HEADER DATA RECORD
0918 0967 8e 10 91                  LDX    #MSGS1
0919 096a bd 0f 5e                  JSR    OUTSTR
0920 096d 5f                        CLRB            ;ZERO CHECKSUM
0921                         ;PUNCH FRAME COUNT
0922 096e 8e 7f c9                  LDX    #TEMP3
0923 0971 8d 39                     BSR    OUTP2
0924                         
0925                         ;PUNCH ADDRESS
0926 0973 8e 7f 1d                  LDX    #RANGLO
0927 0976 8d 34                     BSR    OUTP2
0928 0978 8d 32                     BSR    OUTP2
0929                         
0930                         ;OUTPUT DATA
0931 097a be 7f 1d                  LDX    RANGLO
0932 097d 8d 2d              DUMP9  BSR    OUTP2    ;OUTPUT DATA BYTE
0933 097f 7a 7f cb                  DEC    TEMP4    ;DEC BYTE COUNT
0934 0982 26 f9                     BNE    DUMP9
0935                         
0936                         ;COMPLEMENT AND PUNCH THE CHECKSUM
0937 0984 bf 7f 1d                  STX    RANGLO   ;SAVE MEMORY POINTER
0938 0987 53                        COMB            ;COMPLEMENT CHECKSUM
0939 0988 34 04                     PSHS   B        ;PUT IT ON STACK
0940 098a 1f 41                     TFR    S,X      ;LET IX POINT TO IT
0941 098c 8d 1e                     BSR    OUTP2    ;OUTPUT CHECKSUM
0942 098e 35 04                     PULS   B        ;PULL IT OFF STACK
0943 0990 be 7f 1d                  LDX    RANGLO   ;RESTORE MEMORY POINTER
0944 0993 30 1f                     LEAX   -1,X
0945 0995 bc 7f 1f                  CPX    RANGHI   ;HIT END OF RANGE?
0946 0998 26 af                     BNE    DUMP6
0947                         
0948                         ;YES, OUTPUT AN "S9" RECORD
0949 099a 8e 10 96                  LDX    #MSGS9
0950 099d bd 0f 5e                  JSR    OUTSTR
0951 09a0 8d 09                     BSR    NULLS    ;GENERATE BLANK TAPE
0952 09a2 7f 7f 2e                  CLR    OUTFLG   ;SET TO TERMINAL OUTPUT
0953 09a5 7e 04 72                  JMP    NOMORE   ;ALL DONE
0954 09a8 7e 04 59           DUMP10 JMP    BADSYN   ;BAD SYNTAX
0955                         
0956                         ;SEND A STRING OF NULLS
0957 09ab 39                 NULLS  RTS
0958                         
0959                         ;OUTPUT A BYTE POINTED TO BY IX AS 2 HEX CHARACTERS
0960 09ac eb 84              OUTP2  ADDB   ,X       ;UPDATE CHECKSUM
0961 09ae bd 0c d9                  JSR    OUT1BY
0962 09b1 30 01                     LEAX   1,X
0963 09b3 39                        RTS
0964                         ;*****
0965                         ;LOAD - LOAD A MIKBUG TAPE
0966                         ;LOOK FOR A "FROM" MODIFIER
0967 09b4 86 07              LOAD   LDA    #7       ;IN LIST 7
0968 09b6 bd 0a 97                  JSR    COMAND
0969 09b9 2b ed                     BMI    DUMP10   ;ERROR, UNRECOGNIZABLE MODIFIER
0970 09bb 27 09                     BEQ    LOAD1
0971                         
0972 09bd bd 0c 18                  JSR    NUMINX   ;GET "FROM" ADDRESS
0973 09c0 bf 7f 2c                  STX    INPADR   ;SAVE IT
0974 09c3 7c 7f 2b                  INC    INPFLG   ;SET FLAG FOR NON-TERMINAL ACIA
0975                         
0976                         ;KEEP READING CHARACTERS UNTIL AN "S" IS READ
0977 09c6 bd 0f 6f           LOAD1  JSR    INPCHR   ;GET A CHAR
0978 09c9 81 53                     CMPA   #'S'     ;IS IT AN S?
0979 09cb 26 f9                     BNE    LOAD1
0980                         
0981                         ;GOT AN "S", EXAMINE NEXT CHARACTER
0982 09cd bd 0f 6f                  JSR   INPCHR
0983 09d0 81 39                     CMPA   #'9'     ;DONE IF ITS A "9"
0984 09d2 27 2f                     BEQ    LOAD4
0985                         
0986 09d4 81 31                     CMPA   #'1'     ;IS IT A "1"?
0987 09d6 26 ee                     BNE    LOAD1    ;IF NOT, LOOK FOR NEXT "S"
0988                         ;VALID S1 RECORD
0989 09d8 7f 7f ee                  CLR    CKSM     ;CLEAR CHECKSUM
0990                         ;READ RECORD BYTE COUNT
0991 09db bd 0a 17                  JSR    RDBYTE
0992 09de 80 02                     SUBA   #2
0993 09e0 b7 7f ed                  STA    BYTECT   ;SAVE COUNT MINUS 2 ADDRESS BYTES
0994                         
0995 09e3 8d 24                     BSR    BLDADR   ;BUILD ADDRESS
0996                         
0997 09e5 8d 30              LOAD2  BSR    RDBYTE   ;READ A DATA BYTE INTO ACCA
0998 09e7 7a 7f ed                  DEC    BYTECT   ;COUNT IT
0999 09ea 27 06                     BEQ    LOAD3    ;IF DONE WITH RECORD, CHECK CHECKSUM
1000 09ec a7 84                     STA    ,X       ;NOT DONE, STORE BYTE IN MEMORY
1001 09ee 30 01                     LEAX   1,X      ;ON TO NEXT MEMORY ADDRESS
1002 09f0 20 f3                     BRA    LOAD2
1003                         
1004                         ;RECORD READ IN COMPLETE
1005 09f2 7c 7f ee           LOAD3  INC    CKSM     ;TEST CHECKSUM BY ADDING 1
1006 09f5 27 cf                     BEQ    LOAD1    ;IF OK, RESULT SHOULD BE ZERO
1007                         
1008                         ;RECORD CHECKSUM ERROR
1009 09f7 8e 10 3d                  LDX    #MSGNVE  ;SAY SO
1010 09fa bd 0f 5e                  JSR    OUTSTR
1011 09fd 8e 7f c5                  LDX    #TEMP1   ;GET RECORD ADDRESS OF IT
1012 0a00 bd 0c e2                  JSR    OUT2BY   ;TYPE IT TOO
1013 0a03 7f 7f 2b           LOAD4  CLR    INPFLG   ;RESET FLAG TO NORMAL TERMINAL INPUT
1014 0a06 7e 04 72                  JMP    NOMORE
1015                         
1016                         ;BUILD ADDRESS
1017 0a09 8d 0c              BLDADR BSR    RDBYTE
1018 0a0b b7 7f c5                  STA    TEMP1
1019 0a0e 8d 07                     BSR    RDBYTE
1020 0a10 b7 7f c6                  STA    TEMP1+1
1021 0a13 be 7f c5                  LDX    TEMP1
1022 0a16 39                        RTS
1023 0a17 8d 15              RDBYTE BSR    INHEX    ;GET LEFT HEX DIGIT
1024                         ;MOVE TO HI 4 BITS
1025 0a19 48                        ASLA
1026 0a1a 48                        ASLA
1027 0a1b 48                        ASLA
1028 0a1c 48                        ASLA
1029 0a1d 1f 89                     TFR    A,B      ;SAVE IT IN ACCA
1030 0a1f 8d 0d                     BSR    INHEX    ;GET RIGHT HEX DIGIT
1031 0a21 34 04                     PSHS   B
1032 0a23 ab e0                     ADDA   ,S+      ;COMBINE THEM IN ACCA
1033                         ;UPDATE THE CHECKSUM
1034 0a25 1f 89                     TFR    A,B
1035 0a27 fb 7f ee                  ADDB   CKSM
1036 0a2a f7 7f ee                  STB    CKSM
1037 0a2d 39                        RTS
1038                         
1039                         ;INPUT A HEX CHAR & CONVERT TO INTERNAL FORM
1040 0a2e bd 0f 6f           INHEX  JSR    INPCHR   ;INPUT A CHAR
1041 0a31 80 30                     SUBA   #$30
1042 0a33 2b 0f                     BMI    INHEX2   ;NOT HEX IF BELOW ASCII "1"
1043 0a35 81 09                     CMPA   #$09
1044 0a37 2f 0a                     BLE    INHEX1   ;OK IF ASCII "9" OR LESS
1045 0a39 81 11                     CMPA   #$11     ;BELOW ASCII "A"?
1046 0a3b 2b 07                     BMI    INHEX2   ;ERROR IF IT IS
1047 0a3d 81 16                     CMPA   #$16     ;OVER ASCII "F"?
1048 0a3f 2e 03                     BGT    INHEX2   ;ERROR IF IT IS
1049 0a41 80 07                     SUBA   #7       ;CONVERT ASCII A-F TO HEX A-F
1050 0a43 39                 INHEX1 RTS
1051                         ;ERROR - CHAR NOT HEX, SAY SO
1052 0a44 8e 10 a5           INHEX2 LDX    #MSGCNH
1053 0a47 bd 0f 5e                  JSR    OUTSTR
1054 0a4a 39                        RTS
1055                         
1056                         ;*****
1057                         ;DELAY - DELAY SPECIFIED # OF MILLISECONDS
1058 0a4b bd 0c 18           DELAY  JSR    NUMINX   ;GET DELAY TIME
1059 0a4e 8d 03                     BSR    TIMDEL
1060 0a50 7e 04 72                  JMP    NOMORE
1061                         
1062                         ;**
1063                         ;TIME DELAY SUBROUTINE
1064                         ;IX IS INPUT AS THE # OF MILLISECONDS TO DELAY
1065                         ;ACCA IS ALTERED
1066                         ;ACCB IS PRESERVED
1067                         ;ADJ TIMCON SO (6*TIMCON*CYCLE TIME=1 MS)
1068 0a53 b6 7f eb           TIMDEL LDA    TIMCON
1069                         ;ENTER A 6 CYCLE LOOP
1070 0a56 4a                 TIMDE1 DECA
1071 0a57 26 fd                     BNE    TIMDE1
1072 0a59 30 1f                     LEAX   -1,X     ;DECREMENT MILLISECOND COUNTER
1073 0a5b 26 f6                     BNE    TIMDEL
1074 0a5d 39                        RTS
1075                         
1076                         ;HELP COMMAND
1077 0a5e bd 0f e5           HELP   JSR    DOCRLF   ;NEXT LINE
1078 0a61 8e 0d bd                  LDX    #COMLST  ;COMMAND LIST
1079                         
1080 0a64 c6 04              HEL1   LDB    #4       ;COMMANDS PER LINE
1081 0a66 f7 7f c5                  STB    TEMP1
1082                         
1083 0a69 c6 0c              HEL2   LDB    #12      ;POSITIONS PER COMMAND
1084                                                ;MUST BE LARGER THAN LONGEST COMMAND
1085 0a6b a6 80              HEL3   LDA    ,X+      ;GET CHARACTER
1086 0a6d 81 0d                     CMPA   #CR      ;<CR> IS END OF COMMAND
1087 0a6f 27 06                     BEQ    HEL4
1088 0a71 bd 0f 8d                  JSR    OUTCHR   ;PRINT COMMAND CHARACTER
1089 0a74 5a                        DECB
1090 0a75 26 f4                     BNE    HEL3
1091                         
1092 0a77 a6 84              HEL4   LDA    ,X       ;GET CHARACTER
1093 0a79 81 0a                     CMPA   #LF      ;<LF> IS END OF LIST
1094 0a7b 27 14                     BEQ    HEL6     ;FINISHED
1095 0a7d 7a 7f c5                  DEC    TEMP1    ;PER LINE DONE ?
1096 0a80 26 05                     BNE    HEL5     ;NO - SKIP
1097                         
1098 0a82 bd 0f e5                  JSR    DOCRLF   ;NEXT LINE
1099 0a85 20 dd                     BRA    HEL1
1100                         
1101 0a87 86 20              HEL5   LDA    #' '     ;SPACE
1102 0a89 bd 0f 8d                  JSR    OUTCHR
1103 0a8c 5a                        DECB
1104 0a8d 26 f8                     BNE    HEL5
1105 0a8f 20 d8                     BRA    HEL2
1106                         
1107 0a91 bd 0f e5           HEL6   JSR    DOCRLF   ;NEXT LINE
1108 0a94 7e 04 72                  JMP    NOMORE
1109                         
1110                         ;====================================================
1111                         
1112                         ;  C O M M A N D     L I S T     S C A N N I N G    R O U T I N E
1113                         
1114                         ;THIS ROUTINE SEEKS A MATCH OF THE CHARACTERS POINTED AT
1115                         ;BY THE INPUT LINE SCANNING POINTER TO ONE OF THE COMMANDS
1116                         ;IN A LIST SPECIFIED BY ACCA.
1117                         ;
1118                         ; AS FOLLOWS:
1119                         ;
1120                         ;      ACCA=-1: THE MATCH WAS UNSUCCESSFUL.  THE SYNTAX
1121                         ;               POINTER (SYNPTR) WAS NOT UPDATED (ADVANCED).
1122                         ;
1123                         ;      ACCA= 0: THE MATCH WAS UNSUCCESSFUL SINCE THERE WERE
1124                         ;               NO MORE CHARACTERS, I.E., THE END OF THE
1125                         ;               LINE WAS REACHED.
1126                         ;
1127                         ;      ACCA=+N: SUCCESSFUL MATCH.  THE SYNTAX POINTER WAS UPDATED
1128                         ;               TO THE FIRST CHARACTER FOLLOWING THE COMMAND
1129                         ;               DELIMITER.  ACCA HOLDS THE NUMBER OF THE
1130                         ;               COMMAND MATCHED.
1131                         ;GLOBAL VARIABLES FOR EXTERNAL COMMUNICATION
1132                         ;SYNPTR - GOOD SYNTAX INPUT CHAR LINE POINTER
1133                         ;LINPTR - INPUT LINE CHARACTER POINTER
1134                         ;DELIM - CLASS OF PERMISSIBLE COMMAND DELIMITERS
1135                         
1136                         ;TEMPORARY 2 BYTE INTERNAL VARIABLES
1137                         ;LISPTR - COMMAND LIST CHARACTER POINTER
1138                         
1139                         ;TEMPORARY 1 BYTE INTERNAL VARIABLES
1140                         ;NUMMAT - NUMBER OF CHARACTERS THAT SUCCESSFULLY MATCH
1141                         ;LISNUM - # OF LIST WITHIN WHICH A MATCH WILL BE SOUGHT
1142                         ;COMNUM - COMMAND NUMBER MATCHED
1143                         
1144                         ;CONSTANTS USED
1145                         ;CR - CARRIAGE RETURN
1146                         ;LF - LINE FEED
1147                         
1148                         ;ACCB & IX ARE NOT PRESERVED.
1149                         
1150 0a97 b7 7f e2           COMAND STA    LISNUM   ;SAVE LIST # TO MATCH WITHIN
1151                         ;TEST IF WE ARE AT THE END OF THE LINE
1152 0a9a bd 0b 40                  JSR    SKPDLM
1153 0a9d 24 02                     BCC    INILST
1154 0a9f 4f                        CLRA
1155 0aa0 39                        RTS
1156                         
1157                         ;INITIALIZE THE COMMAND LIST POINTER TO ONE LESS THAN
1158                         ;                       THE BEGINNING OF THE COMMAND LISTS
1159 0aa1 be 7f 10           INILST LDX    COMADR   ;ENTRY POINT
1160                         
1161                         ;MOVE TO THE BEGINNING OF THE DESIRED COMMAND LIST
1162 0aa4 b6 7f e2                  LDA    LISNUM   ;SEARCH FOR "STRING" # LISNUM
1163 0aa7 c6 0a                     LDB    #LF      ;USE LF AS A "STRING" TERMINATOR
1164 0aa9 8d 7c                     BSR    FNDSTR
1165 0aab bf 7f e4                  STX    LISPTR
1166                         
1167                         ;THE LIST POINTER, LISPTR, NOW POINTS TO ONE LESS THAN THE FIRST CHARACTER
1168                         ;OF THE FIRST COMMAND IN THE DESIRED LIST.
1169 0aae 7f 7f e3                  CLR    COMNUM
1170                         
1171                         ;RESET INPUT LINE POINTER TO: 1) BEGINNING OF LINE, OR TO
1172                         ;  2) POINT WHERE LAST SUCCESSFUL SCAN TERMINATED
1173 0ab1 7c 7f e3           CMD3   INC    COMNUM
1174 0ab4 be 7f 12                  LDX    SYNPTR
1175 0ab7 bf 7f 14                  STX    LINPTR
1176 0aba 7f 7f e1                  CLR    NUMMAT   ;CLEAR NUMBER OF CHARACTERS MATCHED
1177                         
1178 0abd bd 0d a4           CMD4   JSR    GETCHR   ;GET INPUT LINE CHAR IN ACCB
1179 0ac0 bd 0b 6d                  JSR    TSTDLM   ;TEST FOR A DELIMITER
1180 0ac3 26 16                     BNE    MATCH    ;SUCCESS (FOUND DELIMITER) IF NOT = ZERO
1181 0ac5 bd 0d b2                  JSR    GETLST   ;GET COMMAND LIST CHAR IN ACCA
1182 0ac8 81 0a                     CMPA   #LF      ;HAS END OF COMMAND LIST BEEN REACHED?
1183 0aca 27 19                     BEQ    NMATCH   ;IF SO, POTENTIAL MATCH FAILURE
1184 0acc 81 0d                     CMPA   #CR      ;HAS END OF COMMAND BEEN REACHED?
1185 0ace 27 15                     BEQ    NMATCH   ;IF SO, POTENTIAL MATCH FAILURE
1186                         
1187 0ad0 34 04                     PSHS   B        ;CBA
1188 0ad2 a1 e0                     CMPA   ,S+      ;COMPARE THE TWO CHARACTERS
1189 0ad4 26 1b                     BNE    NEXCOM   ;MATCH NOT POSSIBLE ON THIS COMMAND
1190                         
1191                         ;THEY MATCH, COMPARE THE SUCCEEDING CHARACTERS
1192 0ad6 7c 7f e1                  INC    NUMMAT   ;INC NUMBER OF CHARACTERS MATCHED
1193 0ad9 20 e2                     BRA    CMD4
1194                         
1195                         ;***
1196                         ;SUCCESSFUL MATCH - RETURN COMMAND NUMBER MATCHED IN ACCA
1197 0adb b6 7f e3           MATCH  LDA    COMNUM
1198 0ade be 7f 14                  LDX    LINPTR
1199 0ae1 bf 7f 12                  STX    SYNPTR   ;UPDATE GOOD SYNTAX POINTER
1200 0ae4 39                        RTS
1201                         
1202                         ;***
1203                         ;NO MATCH
1204                         ;DID AT LEAST ONE MATCH?
1205 0ae5 7d 7f e1           NMATCH TST    NUMMAT
1206 0ae8 27 07                     BEQ    NEXCOM   ;TO NEXT COMMAND IF NONE MATCHED
1207                         
1208                         ;AT LEAST ONE MATCHED - TEST FOR DELIMITER (NON-MATCHING CHAR)
1209 0aea bd 0b 6d                  JSR    TSTDLM
1210 0aed 26 ec                     BNE    MATCH    ;IF A DELIMITER, MATCH HAS BEEN ACHIEVED
1211 0aef a6 84                     LDA    ,X       ;RETRIEVE LAST CHARACTER
1212                         ;
1213                         ;ILLEGAL DELIMITER
1214                         
1215                         ;MOVE TO NEXT COMMAND WITHIN LIST
1216 0af1 81 0a              NEXCOM CMPA   #LF      ;END OF THIS LIST?
1217 0af3 27 09                     BEQ    MFAIL    ;IF SO, NOTHING ON LIST MATCHED
1218 0af5 81 0d                     CMPA   #CR      ;IS IT A CR?
1219 0af7 27 b8                     BEQ    CMD3     ;YES, NEXT COMMAND
1220 0af9 bd 0d b2                  JSR    GETLST   ;GET NEXT COMMAND LIST CHARACTER
1221 0afc 20 f3                     BRA    NEXCOM   ;NO, GET TO END OF COMMAND
1222                         
1223                         ;***
1224                         ;MATCH FAILURE - NO MATCH POSSIBLE WITHIN THIS LIST
1225 0afe 4f                 MFAIL  CLRA            ;MATCH FAILURE
1226 0aff 4a                        DECA            ;NO MATCH POSSIBLE WITHIN THIS LIST
1227 0b00 39                        RTS
1228                         
1229                         ;======================================================
1230                         ;THIS ROUTINE TYPES OUT COMMAND NUMBER "COMNUM"
1231                         ;THE LIST IS SPECIFIED IN ACCA
1232                         ;ACCB & IX ARE PRESERVED
1233 0b01 bf 7f db           TYPCMD STX    XTEMP
1234 0b04 34 04                     PSHS   B
1235 0b06 8e 0d bc                  LDX    #COMLST-1 ;MOVE TO HEAD OF COMMAND LISTS
1236 0b09 c6 0a                     LDB    #LF      ;AND LIST TERMINATOR
1237 0b0b 8d 1a                     BSR    FNDSTR   ;GO TO HEAD OF DESIRED LIST
1238 0b0d b6 7f e3                  LDA    COMNUM   ;GET COMMAND NUMBER
1239 0b10 c6 0d                     LDB    #CR      ;GET COMMAND TERMINATOR
1240 0b12 8d 13                     BSR    FNDSTR   ;GO TO HEAD OF DESIRED COMMAND
1241                         
1242 0b14 30 01              TYPCM1 LEAX   1,X      ;MOVE TO NEXT CHARACTER
1243 0b16 a6 84                     LDA    ,X       ;GET A COMMAND CHARACTER
1244 0b18 81 0d                     CMPA   #CR      ;IS IT A COMMAND TERMINATOR?
1245 0b1a 27 05                     BEQ    TYPCM2   ;IF SO, RETURN
1246 0b1c bd 0f 8d                  JSR    OUTCHR   ;NO, TYPE IT
1247 0b1f 20 f3                     BRA    TYPCM1
1248                         
1249 0b21 be 7f db           TYPCM2 LDX    XTEMP
1250 0b24 35 04                     PULS   B
1251 0b26 39                        RTS
1252                         
1253                         ;======================================================
1254                         ;MOVE TO BEGINNING OF DESIRED STRING NUMBER (IN ACCA)
1255                         ;EACH STRING IS TERMINATED BY AN END OF STRING CHARACTER (IN ACCB)
1256                         ;THE INDEX REGISTER IS ASSUMED INITIALIZED POINTING TO
1257                         ;ONE LESS THAT THE FIRST CHARACTER OF THE FIRST STRING
1258                         ;ACCA, ACCB & IX ARE NOT PRESERVED
1259                         ;LOCAL VARIABLES
1260                         ;STRNUM - STRING # TO FIND
1261                         ;EOSCHR - "END OF STRING" CHARACTER
1262                         
1263 0b27 b7 7f c7           FNDSTR STA    STRNUM   ;SAVE STRING NUMBER
1264 0b2a f7 7f c8                  STB    EOSCHR   ;SAVE TERMINATOR
1265 0b2d 5f                        CLRB
1266 0b2e 5c                 FNDST1 INCB            ;STRING 1 IS THE FIRST STRING
1267 0b2f f1 7f c7                  CMPB   STRNUM   ;IS THIS THE RIGHT STRING?
1268 0b32 27 0b                     BEQ    FNDST3   ;IF SO, DONE
1269                         
1270                         ;NO, SWALLOW UP CHARACTERS UNTIL AND END OF STRING CHAR IS HIT
1271 0b34 30 01              FNDST2 LEAX   1,X      ;BUMP POINTER TO NEXT ONE
1272 0b36 a6 84                     LDA    ,X       ;GET CHAR POINTED AT
1273 0b38 b1 7f c8                  CMPA   EOSCHR   ;END OF STRING HIT?
1274 0b3b 27 f1                     BEQ    FNDST1   ;IF IT IS, BUMP THE STRING COUNTER
1275 0b3d 20 f5                     BRA    FNDST2   ;NO, MOVE ON TO NEXT CHAR
1276 0b3f 39                 FNDST3 RTS             ;IX SET PROPERLY, RETURN
1277                         
1278                         ;======================================================
1279                         ;SKIP LEADING DELIMITERS
1280                         ;THIS ROUTINE SHOULD BE CALLED PRIOR TO SCANNING FOR ANY INFORMATION
1281                         ;ON THE INPUT LINE
1282                         ;THE CURRENT CHARACTER IS IGNORED IF THE SCANNING POINTER IS AT THE
1283                         ;BEGINNING OF A LINE.  IF NOT, THE SCANNING POINTER SKIPS OVER SPACES
1284                         ;AND COMMAS UNTIL AN END OF LINE OR NON-DELIMITER IS FOUND.
1285                         ;THE CARRY BIT IS SET IF AN END OF LINE IS ENCOUNTERED.
1286                         
1287                         ;ACCA, ACCB & IX ARE NOT PRESERVED
1288                         
1289 0b40 1c fe              SKPDLM ANDCC  #$FE     ;CLC
1290 0b42 7d 7f 16                  TST    BOLFLG   ;AT BEGINNING OF LINE?
1291 0b45 2e 0c                     BGT    SKPDL2
1292                         
1293                         ;LOOK AT CURRENT INPUT CHARACTER
1294 0b47 be 7f 12           SKPDL1 LDX    SYNPTR   ;GET POINTER TO IT
1295 0b4a a6 84                     LDA    ,X       ;GET CHAR
1296 0b4c 8d 14                     BSR    TSTEOL   ;TEST FOR END OF LINE
1297 0b4e 26 03                     BNE    SKPDL2
1298 0b50 1a 01                     ORCC   #$01     ;SEC YES, END HIT, SET CARRY
1299 0b52 39                        RTS
1300                         ;"PEEK" AT NEXT CHAR IN LINE
1301 0b53 e6 01              SKPDL2 LDB    1,X     ;GET IT
1302 0b55 8d 16                     BSR    TSTDLM  ;SEE IF ITS A DELIMITER
1303 0b57 26 01                     BNE    SKPDL3
1304 0b59 39                        RTS            ;ITS NOT, RETURN
1305                         
1306                         ;NEXT CHAR IS A DELIMITER
1307 0b5a bd 0d a4           SKPDL3 JSR    GETCHR   ;MOVE TO NEXT CHAR IN INPUT LINE
1308 0b5d bf 7f 12                  STX    SYNPTR   ;UPDATE SYNTAX POINTER
1309 0b60 20 e5                     BRA    SKPDL1   ;GO TEST FOR END OF LINE
1310                         
1311                         ;======================================================
1312                         ;TEST FOR END-OF-LINE CHARACTER
1313                         ;Z BIT OF CC REG SET IF CHAR IN ACCA IS A TERMINATOR
1314                         ;ACCA, ACCB, & IX ARE PRESERVED
1315 0b62 81 0d              TSTEOL CMPA   #CR      ;CARRIAGE RETURN?
1316 0b64 27 06                     BEQ    TSTEO1
1317 0b66 81 0a                     CMPA   #LF      ;LINE FEED? (CONTINUED LINES)
1318 0b68 27 02                     BEQ     TSTEO1
1319 0b6a 81 3b                     CMPA    #';'    ;FOR SEVERAL COMMANDS ON ONE LINE
1320 0b6c 39                 TSTEO1 RTS
1321                         
1322                         ;======================================================
1323                         ;CHECK THE CHARACTER IN ACCB
1324                         ;AGAINST THE DELIMITER(S) SPECIFIED BY VARIABLE DELIM
1325                         ;ACCB & IX ARE PRESERVED
1326                         ;ACCA IS SET TO 0 IF ACCB IS NOT A DELIMITER, TO 1 IF IT IS
1327                         ;  IF DELIM=1, SPACE IS DELIMITER
1328                         ;  IF DELIM-2, COMMA IS DELIMITER
1329                         ;  IF DELIM=3, SPACE OR COMMAND IS DELIMITER
1330                         ;  IF DELIM=4, ANY NON-ALPHANUMERIC IS A DELIMITER
1331                         ;TEST FOR END-OF-LINE (LOGICAL OR PHYSICAL)
1332 0b6d 34 04              TSTDLM PSHS   B
1333 0b6f 1f 98                     TFR    B,A
1334 0b71 8d ef                     BSR    TSTEOL
1335 0b73 35 04                     PULS   B
1336 0b75 27 35                     BEQ    DLMYES
1337                         
1338 0b77 b6 7f 17                  LDA    DELIM
1339 0b7a 81 01                     CMPA   #1
1340 0b7c 26 06                     BNE    ISDLM2
1341 0b7e c1 20                     CMPB   #32      ;WANT A SPACE - IS IT?
1342 0b80 26 2d                     BNE    DLMNO
1343 0b82 20 28                     BRA    DLMYES
1344                         
1345 0b84 81 02              ISDLM2 CMPA   #2
1346 0b86 26 06                     BNE    ISDLM3
1347 0b88 c1 2c              TSTCMA CMPB   #','     ;WANT A COMMA - IS IT?
1348 0b8a 26 23                     BNE    DLMNO
1349 0b8c 20 1e                     BRA    DLMYES
1350 0b8e 81 03              ISDLM3 CMPA   #3
1351 0b90 26 06                     BNE    ISDLM4
1352 0b92 c1 20                     CMPB   #32      ;WANT EITHER, IS IT A SPACE?
1353 0b94 27 16                     BEQ    DLMYES
1354 0b96 20 f0                     BRA    TSTCMA   ;OR A COMMA?
1355                         
1356 0b98 81 04              ISDLM4 CMPA   #4
1357 0b9a 26 15                     BNE    ERROR    ;ERROR IF DELIM NOT 1-4
1358                         ;TEST IF CHAR IS 0 TO 9 INCLUSIVE
1359 0b9c c1 30                     CMPB   #'0'
1360 0b9e 2d 0c                     BLT    DLMYES
1361 0ba0 c1 39                     CMPB   #'9'
1362 0ba2 2f 0b                     BLE    DLMNO
1363                         
1364                         ;TEST IF CHAR IS A TO 9 INCLUSIVE
1365 0ba4 c1 41                     CMPB   #'A'
1366 0ba6 2d 04                     BLT    DLMYES
1367 0ba8 c1 5a                     CMPB   #'Z'
1368 0baa 2f 03                     BLE    DLMNO
1369                         ;OVER Z - ITS A DELIMITER
1370                         
1371                         ;CHAR IN ACCB IS A DELIMITER
1372 0bac 86 01              DLMYES LDA    #1
1373 0bae 39                        RTS
1374                         
1375                         ;CHAR IN ACCB IS NOT A DELIMITER
1376 0baf 4f                 DLMNO  CLRA
1377 0bb0 39                        RTS
1378                         
1379                         ;ERROR IN SPECIFYING DELIMITER CLASS
1380 0bb1 3f                 ERROR  SWI             ;HAVE MONITOR TYPE OUT PERTINENT STATISTICS
1381                         
1382                         ;=====================================================
1383                         ;ADD THE 2 BYE NUMBER STORED IN (RANGLO,RANGLO+1) TO THE NUMBER
1384                         ;STORED IN (NBRHI,NBRLO) AND PUT THE RESULT IN (RANGHI,RANGHI+1)
1385                         ;ACCB & IX ARE PRESERVED
1386                         ;ACCA IS ALTERED
1387                         
1388                         ;ADD LO ORDER BYTES
1389 0bb2 b6 7f 1e           SUMNUM LDA    RANGLO+1
1390 0bb5 bb 7f 1c                  ADDA   NBRLO
1391 0bb8 b7 7f 20                  STA    RANGHI+1
1392                         
1393                         ;ADD HI ORDER BYTES
1394 0bbb b6 7f 1d                  LDA    RANGLO
1395 0bbe b9 7f 1b                  ADCA   NBRHI
1396 0bc1 b7 7f 1f                  STA    RANGHI
1397 0bc4 39                        RTS
1398                         
1399                         ;========================================================
1400                         ;SUBTRACT THE TWO BYTE NUMBER STORED IN (NBRHI,NBRLO) FROM THE
1401                         ;TWO BYTE NUMBER STORED IN (RANGLO,RANGLO+1) AND PUT THE
1402                         ;RESULT IN (RANGHI,RANGHI+1)
1403                         ;ACCB & IX ARE PRESERVED
1404                         ;ACCA IS ALTERED
1405                         
1406                         ;SUBTRACT LO ORDER BYTES
1407 0bc5 b6 7f 1e           DIFNUM LDA    RANGLO+1
1408 0bc8 b0 7f 1c                  SUBA   NBRLO
1409 0bcb b7 7f 20                  STA    RANGHI+1
1410                         
1411                         ;SUBTRACT HI ORDER BYES
1412 0bce b6 7f 1d                  LDA    RANGLO
1413 0bd1 b2 7f 1b                  SBCA   NBRHI
1414 0bd4 b7 7f 1f                  STA    RANGHI
1415 0bd7 39                        RTS
1416                         
1417                         ;======================================================
1418                         ;THIS ROUTINE SCANS THE INPUT LINE FOR A PAIR OF NUMBERS
1419                         ;REPRESENTING AN ADDRESS RANGE.  A COLON SEPARATING THE
1420                         ;PAIR IMPLIES "THRU", WHILE AN "!" IMPLIED "THRU THE FOLLOWING"
1421                         ;E.G., 100:105 IS EQUIVALENT TO 100!5
1422                         ;A SINGLE NUMBER IMPLIES A RANGE OF 1
1423                         ;
1424                         ;ON RETURN (RANGLO,RANGLO+1) HOLDS THE RANGE START, AND
1425                         ;          (RANGHI,RANGHI+1) HOLDS THE RANGE END.
1426                         ;ACCA, ACCB, & IX ARE NOT PRESERVED
1427                         
1428 0bd8 8d 49              GTRANG BSR    NUMBER   ;PICK UP FIRST NUMBER
1429 0bda 2e 03                     BGT    GTRAN1
1430 0bdc 2d 09                     BLT    GTRAN2
1431 0bde 39                        RTS             ;NOTHING MORE ON INPUT LINE
1432                         
1433                         ;GOOD SINGLE NUMBER - TRANSFER IT TO RANGLO
1434 0bdf be 7f 1b           GTRAN1 LDX    NBRHI
1435 0be2 bf 7f 1d                  STX    RANGLO
1436 0be5 20 0d                     BRA    GTRAN3   ;AND TO RANGHI
1437                         
1438                         ;BAD NUMBER, BUT IS IT BAD DUE TO A ":" OR "!" DELIMITER?
1439 0be7 be 7f 14           GTRAN2 LDX    LINPTR
1440 0bea a6 84                     LDA    ,X
1441 0bec 81 3a                     CMPA   #':'     ;WAS IT A COLON
1442 0bee 26 0c                     BNE    GTRAN4   ;IF NOT, GO TEST FOR "!"
1443                         
1444 0bf0 8d 1a                     BSR    GTRAN8   ;WAS ":", PROCESS NUMBER & GET NEXT ONE
1445 0bf2 2f 0e                     BLE    GTRAN5   ;ILLEGAL IF END OF LINE OR NON-NUMERIC
1446                         
1447                         ;TRANSFER SECOND NUMBER TO RANGHI
1448 0bf4 be 7f 1b           GTRAN3 LDX    NBRHI
1449 0bf7 bf 7f 1f                  STX    RANGHI
1450 0bfa 20 0d                     BRA    GTRAN7
1451                         
1452 0bfc 81 21              GTRAN4 CMPA   #'!'     ;WAS DELIMITER A "!"?
1453 0bfe 27 03                     BEQ    GTRAN6   ;IF YES, GET 2ND NUMBER
1454                         
1455                         ;ILLEGAL DELIMITER, RETURN
1456 0c00 4f                        CLRA
1457 0c01 4a                        DECA
1458 0c02 39                 GTRAN5 RTS
1459                         
1460 0c03 8d 07              GTRAN6 BSR    GTRAN8   ;WAS "!", PROCESS FIRST NUMBER & GET NEXT ONE
1461 0c05 2f fb                     BLE    GTRAN5
1462 0c07 8d a9                     BSR    SUMNUM   ;COMPUTE RANGE END, PUT INTO RANGHI
1463                         
1464                         ;SUCCESSFUL EXIT
1465 0c09 86 01              GTRAN7 LDA    #1
1466 0c0b 39                        RTS
1467                         
1468                         ;UPDATE SYNTAX POINTER, MOVE FIRST NUMBER TO RANGLO, & GET 2ND NUMBER
1469 0c0c bf 7f 12           GTRAN8 STX    SYNPTR   ;UPDATE SYNTAX POINTER
1470 0c0f be 7f 1b                  LDX    NBRHI    ;GET FIRST NUMBER OF THE PAIR
1471 0c12 bf 7f 1d                  STX    RANGLO   ;SAVE IT IN "LOW RANGE" VALUE
1472 0c15 8d 0c                     BSR    NUMBER   ;PICK UP THE SECOND NUMBER OF THE PAIR
1473 0c17 39                        RTS
1474                         
1475                         ;======================================================
1476                         ;GET A 2 BYTE NUMBER & RETURN IT IN THE INDEX REGISTER
1477 0c18 8d 09              NUMINX BSR    NUMBER
1478 0c1a 2e 03                     BGT    NUMIN1
1479 0c1c 7e 04 59                  JMP    BADSYN
1480 0c1f be 7f 1b           NUMIN1 LDX    NBRHI
1481 0c22 39                        RTS
1482                         
1483                         ;======================================================
1484                         ;SCAN FOR A NUMBER
1485                         ;RETURN THE MOST SIGNIFICANT BYTE IN NBRHI
1486                         ;  AND THE LEAST SIGNIFICANT BYTE IN NBRLO
1487                         ;THE RESULT OF THE SCAN FOR A NUMBER IF RETURNED IN
1488                         ;ACCA AS FOLLOWS:
1489                         ;
1490                         ;      ACCA=-1: THE MATCH WAS UNSUCCESSFUL.  THE SYNTAX
1491                         ;               POINTER (SYNPTR) WAS NOT UPDATED.
1492                         ;
1493                         ;      ACCA= 0: THE MATCH WAS UNSUCCESSFUL SINCE THERE WERE NO
1494                         ;               MORE CHARACTERS. (I.E., THE END OF THE
1495                         ;               LINE WAS ENCOUNTERED.)
1496                         ;
1497                         ;      ACCA=+1: THE SCAN WAS SUCCESSFUL.  THE SYNTAX POINTER
1498                         ;               WAS UPDATED TO THE FIRST CHARACTER FOLLOWING
1499                         ;               THE COMMAND.
1500                         
1501                         ;IX IS PRESERVED
1502                         ;GLOBAL VARIABLES FOR EXTERNAL COMMUNICATION
1503                         ;NBRHI - NUMBER HI BYTE
1504                         ;NBRLO - NUMBER LO BYTE
1505                         ;IBCODE - INPUT BASE CODE
1506                         ;DBCODE - DISPLAY BASE CODE
1507                         
1508                         ;LOCAL VARIABLES
1509                         ;NBR2X - USED IN DECIMAL CONVERSION
1510                         ;XTEMP2 - SAVES IX
1511                         
1512                         ;INITIALIZE BOTH BYTES TO ZERO
1513 0c23 bf 7f df           NUMBER STX    XTEMP2   ;SAVE IX
1514 0c26 7f 7f 1b                  CLR    NBRHI
1515 0c29 7f 7f 1c                  CLR    NBRLO
1516                         
1517                         ;INITIALIZE THE LINE SCANNING POINTER
1518 0c2c be 7f 12                  LDX    SYNPTR
1519 0c2f bf 7f 14                  STX    LINPTR
1520                         
1521                         ;ARE WE AT END OF LINE?
1522 0c32 bd 0b 40                  JSR    SKPDLM
1523 0c35 24 05                     BCC    NUMLUP
1524 0c37 be 7f df                  LDX    XTEMP2
1525 0c3a 4f                        CLRA            ;YES, ZERO ACCA
1526 0c3b 39                        RTS
1527                         
1528 0c3c bd 0d a4           NUMLUP JSR    GETCHR   ;GET A CHARACTER FROM THE INPUT LINE INTO ACCB
1529                         
1530                         ;TEST FOR A DELIMITER
1531 0c3f bd 0b 6d                  JSR    TSTDLM
1532 0c42 26 65                     BNE    GUDNUM   ;GOOD DELIMITER IF ACCA NON-ZERO
1533                         
1534                         ;NOT A DELIMITER, TEST IF CHARACTER IS < ASCII 0
1535 0c44 c0 30                     SUBB   #'0'     ;SUBTRACT ASCII 0
1536 0c46 2b 6d                     BMI    CONERR   ;ERROR IF LESS
1537                         
1538                         ;DETERMINE INPUT BASE & GO TO RIGHT ROUTINE
1539 0c48 b6 7f 18                  LDA    IBCODE
1540 0c4b 81 01                     CMPA   #1
1541 0c4d 27 08                     BEQ    HEXNUM
1542                         
1543 0c4f 81 02                     CMPA   #2
1544 0c51 27 1e                     BEQ    DECNUM
1545                         
1546 0c53 81 03                     CMPA   #3
1547 0c55 27 41                     BEQ    OCTNUM
1548                         
1549                         ;DEFAULT AN ILLEGAL INPUT BASE TO HEX
1550                         ;*****
1551                         ;INPUT A HEX NUMBER
1552                         ;TEST FOR A LEGAL DIGIT
1553 0c57 c1 09              HEXNUM CMPB   #$09
1554 0c59 2f 0a                     BLE    HEXN1    ;OR IF 9 OR LESS
1555 0c5b c1 11                     CMPB   #$11
1556 0c5d 2b 56                     BMI    CONERR    ;NOT HEX IF < A
1557 0c5f c1 16                     CMPB   #$16
1558 0c61 2e 52                     BGT    CONERR    ;NOT HEX IF > F
1559 0c63 c0 07                     SUBB   #7        ;MOVE A-F ABOVE 0-9
1560                         
1561                         ;SHIFT LO & HI BYTES LEFT 4 BITS
1562 0c65 8d 54              HEXN1  BSR    SHIFT2
1563 0c67 8d 52                     BSR    SHIFT2
1564                         
1565 0c69 fa 7f 1c                  ORB    NBRLO
1566 0c6c f7 7f 1c                  STB    NBRLO
1567                         
1568 0c6f 20 cb                     BRA    NUMLUP
1569                         
1570                         ;*****
1571                         ;INPUT A DECIMAL NUMBER
1572                         ;TEST FOR A LEGAL DIGIT
1573 0c71 c1 09              DECNUM CMPB   #$09
1574 0c73 2e 40                     BGT    CONERR   ;NOT DECIMAL IF > 9
1575                         
1576                         ;MULTIPLE SAVED VALUE BY 10 & ADD IN NEW DIGIT
1577                         ;NOTE THAT 10X=2X+8x
1578                         ;MULTIPLY CURRENT NUMBER BY 2 TO GET 2X VALUE
1579 0c75 8d 49                     BSR    SHIFT
1580                         ;SAVE THIS *2 NUMBER TEMPORARILY
1581 0c77 be 7f 1b                  LDX    NBRHI
1582 0c7a bf 7f e9                  STX    NBR2X
1583                         ;MULTIPLY THIS # BY 4 TO GET 8X VALUE
1584 0c7d 8d 3c                     BSR    SHIFT2
1585                         ;(NBRHI,NBRLO) NOW HOLDS *8
1586                         ;GENERATE DIGIT+8x+2x
1587 0c7f 4f                        CLRA            ;ACCA WILL HOLD MS BYTE
1588 0c80 fb 7f ea                  ADDB   NBR2X+1  ;ADD 2X LS BYTE TO DIGIT
1589 0c83 b9 7f e9                  ADCA   NBR2X    ;ADD 2X MS BYTE
1590 0c86 25 2d                     BCS    CONERR   ;CARRY OUT OF MS BYTE IS AN ERROR
1591 0c88 fb 7f 1c                  ADDB   NBRLO    ;ADD 8X LS BYTE
1592 0c8b b9 7f 1b                  ADCA   NBRHI    ;ADD 8X MS BYTE
1593 0c8e 25 25                     BCS    CONERR   ;CARRY OUT OF MS BYTE IS AN ERROR
1594 0c90 f7 7f 1c                  STB    NBRLO    ;SAVE FINAL LS BYTE
1595 0c93 b7 7f 1b                  STA    NBRHI    ;SAVE FINAL MS BYTE
1596                         
1597 0c96 20 a4                     BRA    NUMLUP
1598                         ;*****
1599                         ;INPUT AN OCTAL NUMBER
1600 0c98 c1 07              OCTNUM CMPB   #$07
1601 0c9a 2e 19                     BGT    CONERR   ;NOT OCTAL IF > 7
1602                         
1603                         ;SHIFT HI & LO BYTES 2 PLACES LEFT - CARRY OUT OF HI BYTE IS ILLEGAL
1604 0c9c 8d 1d                     BSR    SHIFT2
1605 0c9e 8d 20                     BSR    SHIFT
1606                         
1607 0ca0 fa 7f 1c                  ORB    NBRLO    ;ADD IN NEW DIGIT
1608 0ca3 f7 7f 1c                  STB    NBRLO
1609                         
1610 0ca6 7e 0c 3c                  JMP    NUMLUP
1611                         
1612                         ;*****
1613                         ;GOOD NUMBER - SCAN WAS SUCCESSFUL
1614                         ;UPDATE GOOD SYNTAX LINE POINTER
1615 0ca9 be 7f 14           GUDNUM LDX    LINPTR
1616 0cac bf 7f 12                  STX    SYNPTR
1617 0caf be 7f df                  LDX    XTEMP2
1618 0cb2 86 01                     LDA    #1       ;SET "GOOD SCAN" FLAG
1619 0cb4 39                        RTS
1620                         
1621                         ;*****
1622                         ;CONVERSION ERROR - SCAN WAS UNSUCCESSFUL
1623 0cb5 be 7f df           CONERR LDX    XTEMP2
1624 0cb8 4f                        CLRA
1625 0cb9 4a                        DECA
1626 0cba 39                        RTS
1627                         ;----------------------------------
1628                         ;SHIFT LEFT 2 POSITIONS
1629 0cbb 8d 03              SHIFT2 BSR    SHIFT
1630 0cbd 8d 01                     BSR    SHIFT
1631 0cbf 39                        RTS
1632                         ;----------------------------------
1633                         ;SHIFT A TWO BYTE NUMBER LEFT ONE POSITION
1634 0cc0 78 7f 1c           SHIFT  ASL    NBRLO
1635 0cc3 79 7f 1b                  ROL    NBRHI
1636 0cc6 25 01                     BCS    SHFTER
1637 0cc8 39                        RTS
1638                         ;ERROR - HI ORDER BYTE OVERFLOW
1639                         ;ABORT NUMBER ROUTINE DIRECTLY THRU STACK ADJ. & A JUMP
1640 0cc9 32 62              SHFTER LEAS   2,S
1641 0ccb 20 e8                     BRA    CONERR
1642                         
1643                         ;======================================================
1644                         ;OUTPUT A SPACE
1645 0ccd 86 20              OUTSP  LDA    #$20
1646 0ccf bd 0f 8d                  JSR    OUTCHR
1647 0cd2 39                        RTS
1648                         
1649                         ;======================================================
1650                         ;OUTPUT AN "=" SIGN
1651 0cd3 86 3d              OUTEQ  LDA    #'='
1652 0cd5 bd 0f 8d                  JSR    OUTCHR
1653 0cd8 39                        RTS
1654                         
1655                         ;======================================================
1656                         ;OUTPUT A 1 BYTE NUMBER
1657                         ;ACCA, ACCB, & IX ARE PRESERVED
1658 0cd9 34 04              OUT1BY PSHS   B
1659 0cdb c6 01                     LDB    #1
1660 0cdd 8d 0c                     BSR    OUTNUM
1661 0cdf 35 04                     PULS   B
1662 0ce1 39                        RTS
1663                         
1664                         ;======================================================
1665                         ;OUTPUT A 2 BYTE NUMBER
1666                         ;ACCA, ACCB, & IX ARE PRESERVED
1667 0ce2 34 04              OUT2BY PSHS   B
1668 0ce4 c6 02                     LDB    #2
1669 0ce6 8d 03                     BSR    OUTNUM
1670 0ce8 35 04                     PULS   B
1671 0cea 39                        RTS
1672                         
1673                         ;======================================================
1674                         ;DISPLAY THE NUMBER POINTED AT BY THE ADDRESS IN THE INDEX REGISTER
1675                         ;AND OUTPUT IT ACCORDING TO THE BASE SPECIFIED IN "DBCODE"
1676                         ;LEADING ZEROES ARE INCLUDED
1677                         ;ACCA & IX ARE PRESERVED
1678                         ;ACCB IS INPUT AS THE NUMBER OF BYTES COMPRISING THE NUMBER
1679                         ;GLOBAL VARIABLES FOR EXTERNAL COMMUNICATION
1680                         ;IBCODE - INPUT BASE CODE
1681                         ;DBCODE - DISPLAY BASE CODE
1682                         
1683                         ;LOCAL VARIABLES
1684                         ;DECDIG - DECIMAL DIGIT BEING BUILT
1685                         ;NUMBHI - HI BYTE OF NUMBER BEING OUTPUT
1686                         ;NUMBLO - LO BYTE OF NUMBER BEING OUTPUT
1687                         
1688 0ceb bf 7f dd           OUTNUM STX    XTEMP1
1689 0cee 34 02                     PSHS   A
1690 0cf0 ae 84                     LDX    ,X       ;GET THE TO BYTES AT THAT ADDRESS
1691 0cf2 bf 7f e7                  STX    NUMBHI   ;PUT THEM IN A SCRATCH AREA FOR PROCESSING
1692 0cf5 b6 7f 19                  LDA    DBCODE   ;GET DISPLAY BASE
1693                         
1694 0cf8 81 01                     CMPA   #1
1695 0cfa 27 0c                     BEQ    OUTHEX
1696 0cfc 81 02                     CMPA   #2
1697 0cfe 27 1e                     BEQ    OUTDEC
1698 0d00 81 03                     CMPA   #3
1699 0d02 27 61                     BEQ    OUTOCT
1700 0d04 81 04                     CMPA   #4
1701 0d06 27 7b                     BEQ    OUTBIN
1702                         
1703                         ;*****
1704                         ;OUTPUT A HEX NUMBER
1705 0d08 58                 OUTHEX ASLB            ;1 BYTE=2 CHARS, 2 BYTES=4 CHARS
1706                         ;GET NEXT 4 BITS
1707 0d09 bd 0d 97           DISNU1 JSR    LSH2
1708 0d0c bd 0d 97                  JSR    LSH2
1709                         
1710 0d0f 84 0f                     ANDA   #$F      ;EXTRACT 4 BITS
1711 0d11 81 09                     CMPA   #9
1712 0d13 2f 02                     BLE    DISNU2
1713 0d15 8b 07                     ADDA   #7       ;CONVERT 10:15 TO A:F
1714                         
1715 0d17 8d 78              DISNU2 BSR    OUTIT
1716 0d19 5a                        DECB
1717 0d1a 26 ed                     BNE    DISNU1
1718 0d1c 20 37                     BRA    OUTDE5
1719                         
1720                         ;*****
1721                         ;OUTPUT A DECIMAL NUMBER
1722 0d1e 5a                 OUTDEC DECB            ;TEST # OF BYTES TO OUTPUT
1723 0d1f 27 0b                     BEQ    OUTDE1
1724                         ;INITIALIZE FOR OUTPUT OF A 2 BYTE NUMBER
1725 0d21 8e 0d 5b                  LDX    #C10K
1726 0d24 b6 7f e7                  LDA    NUMBHI
1727 0d27 f6 7f e8                  LDB    NUMBLO
1728 0d2a 20 07                     BRA    OUTDE2
1729                         
1730                         ;INITIALIZE FOR OUTPUT OF A 1 BYTE NUMBER
1731 0d2c 8e 0d 5f           OUTDE1 LDX    #C100
1732 0d2f 4f                        CLRA
1733 0d30 f6 7f e7                  LDB    NUMBHI
1734                         
1735 0d33 7f 7f e6           OUTDE2 CLR    DECDIG   ;CLEAR THE DIGIT TO OUTPUT
1736                         
1737                         ;SUBTRACT THE POWER OF 10 CONVERSION CONSTANT
1738 0d36 e0 01              OUTDE3 SUBB   1,X
1739 0d38 a2 84                     SBCA   0,X
1740 0d3a 25 05                     BCS    OUTDE4   ;TEST FOR BORROW (CARRY)
1741                         
1742 0d3c 7c 7f e6                  INC    DECDIG   ;NO BORROW YET - INC DIGIT BEING BUILT
1743 0d3f 20 f5                     BRA    OUTDE3   ;REPEAT LOOP
1744                         ;BORROW GENERATED - CANCEL LAST SUBTRACTION
1745 0d41 eb 01              OUTDE4 ADDB   1,X
1746 0d43 a9 84                     ADCA   0,X
1747                         
1748                         ;BUILDING OF DIGIT TO OUTPUT COMPLETE - PRINT IT
1749 0d45 34 02                     PSHS   A        ;SAVE LO BYTE OF NUMBER BEING OUTPUT
1750 0d47 b6 7f e6                  LDA    DECDIG   ;GET DIGIT
1751 0d4a 8d 45                     BSR    OUTIT    ;PRINT IT
1752 0d4c 35 02                     PULS   A        ;RESTORE LO BYTE
1753                         ;GET NEXT LOWER POWER OF 10
1754 0d4e 30 02                     LEAX   2,X
1755 0d50 8c 0d 65                  CPX    #C10K+10 ;ARE WE THRU WITH UNITS CONVERSION?
1756 0d53 26 de                     BNE    OUTDE2   ;IF NOT, BACK TO GET NEXT DIGIT
1757 0d55 35 02              OUTDE5 PULS   A        ;IF YES, RESTORE REGISTERS & RETURN
1758 0d57 be 7f dd                  LDX    XTEMP1
1759 0d5a 39                        RTS
1760                         
1761                         ;DECIMAL OUTPUT CONVERSION CONSTANTS
1762 0d5b 27 10              C10K   FDB    10000
1763 0d5d 03 e8                     FDB    1000
1764 0d5f 00 64              C100   FDB    100
1765 0d61 00 0a                     FDB    10
1766 0d63 00 01                     FDB    1
1767                         
1768                         ;*****
1769                         ;OUTPUT AN OCTAL NUMBER
1770                         ;FIRST DIGIT IS A ONE OR A ZERO
1771 0d65 58                 OUTOCT ASLB            ;FIRST APPROXIMATION OF # OF DIGITS TO OUTPUT
1772 0d66 4f                        CLRA
1773 0d67 c1 02                     CMPB   #2
1774 0d69 2e 06                     BGT    OUTOC1
1775 0d6b 8d 2a                     BSR    LSH2     ;1 BYTE - GET FIRST 2 BITS
1776 0d6d 8d 22                     BSR    OUTIT
1777 0d6f 20 05                     BRA    DISNU3   ;GO OUTPUT LAST 2 DIGITS
1778                         ;TWO BYTE # - OUTPUT HI ORDER BIT/DIGIT
1779 0d71 8d 29              OUTOC1 BSR    LEFSHF
1780 0d73 8d 1c                     BSR    OUTIT
1781 0d75 5c                        INCB           ;5 MORE DIGITS TO GO
1782                         ;GET NEXT 3 BITS
1783 0d76 8d 1f              DISNU3 BSR    LSH2
1784 0d78 8d 22                     BSR    LEFSHF
1785                         
1786 0d7a 84 07                     ANDA   #7      ;EXTRACT 3 BITS
1787 0d7c 8d 13                     BSR    OUTIT
1788 0d7e 5a                        DECB           ;COUNT THIS DIGIT
1789 0d7f 26 f5                     BNE    DISNU3  ;ARE WE DONE?
1790 0d81 20 d2                     BRA    OUTDE5  ;YES
1791                         ;*****
1792                         ;OUTPUT A BINARY NUMBER
1793 0d83 58                 OUTBIN ASLB
1794 0d84 58                        ASLB
1795 0d85 58                        ASLB
1796                         ;GET NEXT BIT
1797 0d86 8d 14              DISNU4 BSR    LEFSHF
1798 0d88 84 01                     ANDA   #1       ;EXTRACT THE BIT
1799                         
1800 0d8a 8d 05                     BSR    OUTIT    ;OUTPUT IT
1801 0d8c 5a                        DECB            ;COUNT IT
1802 0d8d 26 f7                     BNE    DISNU4   ;ARE WE DONE?
1803 0d8f 20 c4                     BRA    OUTDE5   ;YES
1804                         
1805                         ;**
1806                         ;CONVERT TO A NUMERIC ASCII DIGIT & OUTPUT IT
1807 0d91 8b 30              OUTIT  ADDA   #$30
1808 0d93 bd 0f 8d                  JSR    OUTCHR
1809 0d96 39                        RTS
1810                         ;**
1811                         ;LEFT SHIFT 2 BITS
1812 0d97 8d 03              LSH2   BSR    LEFSHF
1813 0d99 8d 01                     BSR    LEFSHF
1814 0d9b 39                        RTS
1815                         
1816                         ;**
1817                         ;LEFT SHIFT THE 3 BYTE NUMBER 1 BIT
1818 0d9c 78 7f e8           LEFSHF ASL    NUMBLO
1819 0d9f 79 7f e7                  ROL    NUMBHI
1820 0da2 49                        ROLA
1821 0da3 39                        RTS
1822                         
1823                         ;======================================================
1824                         ;THIS ROUTINE GETS THE NEXT CHARACTER FROM THE INPUT LINE BUFFER
1825                         ;ACCA IS PRESERVED
1826                         ;ACCB IS LOADED WITH THE CHARACTER
1827                         ;IX IS INCREMENTED & LEFT POINTING TO THE CHARACTER RETURNED
1828 0da4 be 7f 14           GETCHR LDX    LINPTR
1829 0da7 30 01                     LEAX   1,X
1830 0da9 e6 84                     LDB    ,X
1831 0dab bf 7f 14                  STX    LINPTR
1832 0dae 7f 7f 16                  CLR    BOLFLG   ;SET FLAG TO NOT AT "BEGINNING OF LINE"
1833 0db1 39                        RTS
1834                         
1835                         ;======================================================
1836                         ;THIS ROUTINE GETS THE NEXT CHARACTER IN THE COMMAND LISTS
1837                         ;ACCA IS THE CHARACTER RETRIEVED
1838                         ;ACCB IS PRESERVED
1839                         ;IX IS INCREMENTED & LEFT POINTING TO THE CHARACTER RETURNED
1840 0db2 be 7f e4           GETLST LDX    LISPTR   ;GET CURRENT LIST POINTER
1841 0db5 30 01                     LEAX   1,X      ;MOVE POINTER TO NEXT CHAR
1842 0db7 a6 84                     LDA    ,X       ;GET CHARACTER POINTED AT
1843 0db9 bf 7f e4                  STX    LISPTR   ;SAVE POINTER
1844 0dbc 39                        RTS             ;AND RETURN
1845                         
1846                         ;======================================================
1847                         ; COMMAND LISTS
1848                         ;  A CARRIAGE RETURN SIGNIFIES END-OF-COMMAND
1849                         ;  A LINE FEED SIGNIFIES END-OF-COMMAND-LST
1850                         ;LIST 1 - MAJOR COMMANDS
1851 0dbd                    COMLST EQU    *
1852 0dbd 52 45 47                  FCC    "REG"    ; DISPLAY REGISTERS
1853 0dc0 0d                        FCB    CR
1854 0dc1 47 4f 54 4f               FCC    "GOTO"   ;GO TO MEMORY ADDRESS
1855 0dc5 0d                        FCB    CR
1856 0dc6 53 45 49                  FCC    "SEI"    ;SET INTERRUPT MASK
1857 0dc9 0d                        FCB    CR
1858 0dca 43 4c 49                  FCC    "CLI"    ; CLEAR INTERRUPT MAST
1859 0dcd 0d                        FCB    CR
1860 0dce 43 4f 50 59               FCC    "COPY"   ;COPY FROM ONE LOCATION TO ANOTHER
1861 0dd2 0d                        FCB    CR
1862 0dd3 42 52 45 41 4b            FCC    "BREAK"  ;SET BREAKPOINT (SWI CODE)
1863 0dd8 0d                        FCB    CR
1864 0dd9 49 42 41 53 45            FCC    "IBASE"  ;SET INPUT BASE
1865 0dde 0d                        FCB    CR
1866 0ddf 44 42 41 53 45            FCC    "DBASE"  ;SET DISPLAY BASE
1867 0de4 0d                        FCB    CR
1868 0de5 43 4f 4e 54 49 4e         FCC    "CONTINUE" ;CONTINUE FROM "SWI"
     55 45
1869 0ded 0d                        FCB    CR
1870 0dee 44 49 53 50 4c 41         FCC    "DISPLAY" ;DISPLAY MEMORY DATA
     59
1871 0df5 0d                        FCB    CR
1872 0df6 53 45 54                  FCC    "SET"    ;SET MEMORY DATA
1873 0df9 0d                        FCB    CR
1874 0dfa 56 45 52 49 46 59         FCC    "VERIFY" ;VERIFY THAT MEMORY CONTENT IS UNCHANGED
1875 0e00 0d                        FCB    CR
1876 0e01 53 45 41 52 43 48         FCC    "SEARCH" ;SEARCH MEMORY FOR A BYTE STRING
1877 0e07 0d                        FCB    CR
1878 0e08 54 45 53 54               FCC    "TEST"   ;TEST A RANGE OF MEMORY
1879 0e0c 0d                        FCB    CR
1880 0e0d 49 4e 54                  FCC    "INT"    ;SET INTERRUPT POINTER
1881 0e10 0d                        FCB    CR
1882 0e11 4e 4d 49                  FCC    "NMI"    ;SET NON-MASKABLE INTERRUPT POINTER
1883 0e14 0d                        FCB    CR
1884 0e15 53 57 49                  FCC    "SWI"    ;SET SOFTWARE INTERRUPT POINTER
1885 0e18 0d                        FCB    CR
1886 0e19 43 4f 4d 50 41 52         FCC    "COMPARE" ;PRINT SUM & DIFFERENCE OF 2 NUMBERS
     45
1887 0e20 0d                        FCB    CR
1888 0e21 44 55 4d 50               FCC    "DUMP"   ;DUMP MEMORY IN MIKBUG OR IMAGE FORMAT
1889 0e25 0d                        FCB    CR
1890 0e26 4c 4f 41 44               FCC    "LOAD"   ;LOAD MIKBUG TAPE
1891 0e2a 0d                        FCB    CR
1892 0e2b 44 45 4c 41 59            FCC    "DELAY"  ;DELAY SPECIFIED # OF MSECS
1893 0e30 0d                        FCB    CR
1894 0e31 48 45 4c 50               FCC    "HELP"   ;HELP LISTING
1895 0e35 0d                        FCB    CR
1896 0e36 43 4c 46                  FCC    "CLF"    ;CLEAR FAST INTERRUPT MASK
1897 0e39 0d                        FCB    CR
1898 0e3a 53 45 46                  FCC    "SEF"    ;SET FAST INTERRUPT MASK
1899 0e3d 0d                        FCB    CR
1900 0e3e 46 49 52 51               FCC    "FIRQ"   ;SET FAST INTERRUPT POINTER
1901 0e42 0d                        FCB    CR
1902 0e43 52 53 52 56 44            FCC    "RSRVD"  ;SET RESERVED INTERRUPT POINTER
1903 0e48 0d                        FCB    CR
1904 0e49 53 57 49 32               FCC    "SWI2"   ;SET SWI2 INTERRUPT POINTER
1905 0e4d 0d                        FCB    CR
1906 0e4e 53 57 49 33               FCC    "SWI3"   ;SET SWI3 INTERRUPT POINTER
1907 0e52 0d                        FCB    CR
1908 0e53 0a                        FCB    LF       ;END OF LIST 1
1909                         
1910                         ;LIST 2 - MODIFIER TO DUMP
1911 0e54 54 4f                     FCC    "TO"     ;DESTINATION ACIA
1912 0e56 0d                        FCB    CR
1913 0e57 0a                        FCB    LF       ;END OF LIST 2
1914                         
1915                         ;LIST 3 - NUMBER BASE SPECIFIERS
1916 0e58 48 45 58                  FCC    "HEX"    ;BASE 16
1917 0e5b 0d                        FCB    CR
1918 0e5c 44 45 43                  FCC    "DEC"    ;BASE 10
1919 0e5f 0d                        FCB    CR
1920 0e60 4f 43 54                  FCC    "OCT"    ;BASE 8
1921 0e63 0d                        FCB    CR
1922 0e64 42 49 4e                  FCC    "BIN"    ;BASE 2
1923 0e67 0d                        FCB    CR
1924 0e68 0a                        FCB    LF       ;END OF LIST 3
1925                         
1926                         ;LIST 4 - INFORMATION REQUEST
1927 0e69 3f                        FCC    "?"
1928 0e6a 0d                        FCB    CR
1929 0e6b 0a                        FCB    LF       ; END OF LIST 4
1930                         
1931                         ;LIST 5 - REGISTER NAMES
1932 0e6c 2e 43 43                  FCC    ".CC"
1933 0e6f 0d                        FCB    CR
1934 0e70 2e 41                     FCC    ".A"
1935 0e72 0d                        FCB    CR
1936 0e73 2e 42                     FCC    ".B"
1937 0e75 0d                        FCB    CR
1938 0e76 2e 44 50                  FCC    ".DP"
1939 0e79 0d                        FCB    CR
1940 0e7a 2e 58                     FCC    ".X"
1941 0e7c 0d                        FCB    CR
1942 0e7d 2e 59                     FCC    ".Y"
1943 0e7f 0d                        FCB    CR
1944 0e80 2e 55                     FCC    ".U"
1945 0e82 0d                        FCB    CR
1946 0e83 2e 50 43                  FCC    ".PC"
1947 0e86 0d                        FCB    CR
1948 0e87 2e 53                     FCC    ".S"
1949 0e89 0d                        FCB    CR
1950 0e8a 0a                        FCB    LF       ;END OF LIST 5
1951                         
1952                         ;LIST 6 - MODIFIERS TO "DISPLAY"
1953 0e8b 44 41 54 41               FCC    "DATA"
1954 0e8f 0d                        FCB    CR
1955 0e90 55 53 45 44               FCC    "USED"
1956 0e94 0d                        FCB    CR
1957 0e95 0a                        FCB    LF       ;END OF LIST 6
1958                         
1959                         ;LIST 7 - MODIFIER TO "LOAD"
1960 0e96 46 52 4f 4d               FCC    "FROM"   ;SOURCE ACIA
1961 0e9a 0d                        FCB    CR
1962 0e9b 0a                        FCB    LF       ;END OF LIST 7
1963                         
1964                         ;======================================================
1965                         
1966                         ; THIS ROUTINE CONSTRUCTS A LINE OF INPUT BY GETTING ALL INPUT
1967                         ; CHARACTERS UP TO AND INCLUDING A CARRIAGE RETURN (WHICH THEN
1968                         ; DESIGNATES "END OF LINE").
1969                         ; TYPING RUBOUT WILL DELETE THE PREVIOUS CHARACTER
1970                         ; TYPING CONTROL-C WILL ABORT THE LINE
1971                         ; TYPING CONTROL-Z WILL USE THE PREVIOUS LINE
1972                         ; THE INPUT LINE IS STORED BEGINNING AT THE ADDRESS STORED IN BUFBEG
1973                         ; AND ENDING AT THE ADDRESS STORED IN BUFEND
1974                         ;ACCA, ACCB, & IX ARE NOT PRESERVED
1975                         ;
1976                         ;GLOBAL VARIABLES
1977                         ;BUFBEG - INPUT LINE START OF BUFFER
1978                         ;BUFEND - INPUT LINE END OF BUFFER
1979                         
1980                         ;LOCAL CONSTANTS
1981 005c                    BAKSLA EQU    92       ;A BACKSLASH
1982 0008                    DELETE EQU    8        ;CODE TO DELETE THE PREVIOUS CHARACTER (BACKSPACE)
1983                         ;
1984                         ;
1985                         ;*** ROUTINE ENTRY POINT
1986                         
1987 0e9c be 7f 34           GETLIN LDX    BUFBEG   ;SET POINTER TO ONE LESS THAN THE BEGINNING OF THE LINE BUFFER
1988 0e9f 5f                        CLRB            ;ACCB HOLS THE LAST INPUT CHAR
1989                         
1990 0ea0 bc 7f 36           NXTCHR CPX    BUFEND   ;CHECK CURRENT LINE END AGAINST BUFFER END
1991 0ea3 26 09                     BNE    GETIT
1992                         
1993                         ;LINE TOO LONG - ABORT IT AS IF A CONTROL-C HAD BEEN TYPED
1994 0ea5 8e 10 22                  LDX    #MSGLTL  ;GET MESSAGE
1995 0ea8 bd 0f 5e                  JSR    OUTSTR   ;OUTPUT IT
1996 0eab c6 03                     LDB    #3       ;PUT CTL-C IN ACCB
1997 0ead 39                        RTS
1998                         
1999 0eae bd 0f 6f           GETIT  JSR    INPCHR   ;GET A CHARACTER (RETURNED IN ACCA)
2000 0eb1 84 7f                     ANDA   #127     ;DROP PARITY BIT
2001                         
2002                         ;CONTROL-Z COPIES FROM PRESENT POSITION TO PREVIOUS END OF LINE
2003 0eb3 81 1a                     CMPA   #26      ;IS CHAR A CONTROL-A?
2004 0eb5 26 04                     BNE    TSTCR
2005 0eb7 bd 0f e5                  JSR    DOCRLF   ;YES, TYPE CR-LF
2006 0eba 39                        RTS
2007 0ebb 81 0d              TSTCR  CMPA   #13      ;IS CHAR A CR?
2008 0ebd 27 04                     BEQ    TSTCR1
2009 0ebf 81 0a                     CMPA   #10      ;OR A LF?
2010 0ec1 26 0d                     BNE    NOTEOL
2011 0ec3 30 01              TSTCR1 LEAX   1,X
2012 0ec5 a7 84                     STA    ,X       ;YES, STORE THE TERMINATOR
2013 0ec7 7d 7f 31                  TST    HDXFLG   ;TEST FOR HALF-DUPLEX TERMINAL
2014 0eca 26 03                     BNE    TSTCR2
2015 0ecc bd 0f e5                  JSR    DOCRLF   ;TYPE CR-LF
2016 0ecf 39                 TSTCR2 RTS             ;NOW RETURN
2017                         
2018 0ed0 81 03              NOTEOL CMPA   #3       ;IS CHAR A CONTROL-C?
2019 0ed2 26 08                     BNE    NOTCTC
2020                         ;ECHO AN UP-ARROW
2021 0ed4 1f 89                     TFR    A,B      ;RETURN CONTROL-C IN ACCB
2022 0ed6 86 5e                     LDA    #'^'
2023 0ed8 bd 0f 8d                  JSR    OUTCHR
2024 0edb 39                        RTS
2025                         
2026 0edc 81 08              NOTCTC CMPA   #DELETE  ;NO, IS IT DELETE
2027 0ede 27 29                     BEQ    RUBNOW   ;IF YES, GO TO RUBNOW
2028                         
2029                         ;CONVERT LOWER CASE TO UPPER CASE
2030 0ee0 81 60                     CMPA   #$60     ;BELOW L.C. A?
2031 0ee2 23 06                     BLS    STORIT
2032 0ee4 81 7a                     CMPA   #$7A     ;ABOVE L.C. Z?
2033 0ee6 22 02                     BHI    STORIT
2034 0ee8 80 20                     SUBA   #32      ;CONVERT L.C. ALPHABETIC TO U.C.
2035                         
2036 0eea 30 01              STORIT LEAX   1,X      ;NOT A DELETE, SO ADVANCE TO NEXT CHARACTER
2037 0eec a7 84                     STA    ,X       ;STORE IT IN INPLIN
2038                         
2039 0eee c1 08                     CMPB   #DELETE  ;IS LAST CHAR A DELETE?
2040 0ef0 27 04                     BEQ    OUTBAK   ;IF SO. GO TO OUTBAK
2041 0ef2 1f 89                     TFR    A,B      ;ITS NOT, UPDATE LAST CHAR
2042 0ef4 20 09                     BRA    ECHO     ;GO ECHO IT
2043                         
2044                         ;LAST CHAR WAS A DELETE, BUT THIS ONE ISN'T
2045 0ef6 1f 89              OUTBAK TFR    A,B      ;UPDATE LAST CHAR
2046 0ef8 86 5c                     LDA    #BAKSLA  ;PRINT A -
2047 0efa bd 0f 8d                  JSR    OUTCHR   ;BACKSLASH
2048 0efd 1f 98                     TFR    B,A      ;RESTORE CURRENT CHAR FOR ECHO
2049 0eff 7d 7f 31           ECHO   TST    HDXFLG   ;TEST FOR HALF DUPLEX TERMINAL
2050 0f02 26 03                     BNE    ECHO1
2051 0f04 bd 0f 8d                  JSR    OUTCHR   ;NOW ECHO IT
2052 0f07 20 97              ECHO1  BRA    NXTCHR   ;GET ANOTHER
2053                         ;
2054                         ; CURRENT CHARACTER IS A DELETE
2055                         ; TEST LINE LENGTH - IT ITS ZERO, IGNORE THIS DELETE SINCE
2056                         ; WE CAN'T DELETE PRIOR TO FIRST CHARACTER IN INPUT LINE
2057 0f09 bc 7f 34           RUBNOW CPX    BUFBEG
2058 0f0c 27 92                     BEQ    NXTCHR
2059 0f0e c1 08                     CMPB   #DELETE  ;WAS LAST CHAR A DELETE?
2060 0f10 27 07                     BEQ    LASWAS
2061                         
2062                         ;LAST CHAR WASN'T A DELETE
2063 0f12 1f 89                    TFR     A,B      ;UPDATE LAST CHAR (WITH A DELETE)
2064 0f14 86 5c                    LDA     #BAKSLA  ;PRINT A -
2065 0f16 bd 0f 8d                 JSR     OUTCHR   ;BACKSLASH
2066                         ;LAST CHAR WAS A DELETE
2067 0f19 a6 84              LASWAS LDA    ,X       ;GET THE CHAR TO BE DELETED
2068 0f1b 30 1f                     LEAX   -1,X     ;DECREMENT LINE POINTER
2069 0f1d 20 e0                     BRA    ECHO     ;ECHO DELETED CHARACTER
2070                         
2071                         ;======================================================
2072                         ;INITIALIZATION ROUTINE
2073                         ;DISABLE INTERRUPTS
2074 0f1f 1a 10                     ORCC   #$10     ;SEI
2075 0f21 86 01              INITAL LDA    #1
2076 0f23 b7 7f 18                  STA    IBCODE   ;SET INPUT BASE TO HEX
2077 0f26 b7 7f 19                  STA    DBCODE   ;SET DISPLAY BASE TO HEX
2078                         ;SET UP DISPLAY BASE NUMBER
2079 0f29 86 10                     LDA    #16
2080 0f2b b7 7f 1a                  STA    DBNBR
2081                         ;MAX # OF CHARACTERS PER LINE
2082 0f2e 86 48                     LDA    #72
2083 0f30 b7 7f 33                  STA    CPLMAX
2084 0f33 7f 7f 2b                  CLR    INPFLG   ;DEFAULT INPUT FROM THE TERMINAL
2085 0f36 7f 7f 2e                  CLR    OUTFLG   ;DEFAULT OUTPUT TO THE TERMINAL
2086 0f39 7f 7f 31                  CLR    HDXFLG   ;CLEAR HALF-DUPLEX FLAG
2087                         ;INITIALIZE ACIA1 & ACIA2 TO 8 BITS AND NO PARITY
2088                         ;RESET BOTH
2089 0f3c 86 03                     LDA    #3
2090 0f3e b7 a0 00                  STA    ACIA1-1
2091 0f41 b7 a0 00                  STA    ACIA2-1
2092                         ;SET EM UP
2093 0f44 86 15                     LDA    #$15
2094 0f46 b7 a0 00                  STA    ACIA1-1
2095 0f49 b7 a0 00                  STA    ACIA2-1
2096                         ;SET UP SWI INTERRUPT ADDRESS POINTER
2097 0f4c 8e 05 2a                  LDX    #TYPSWI  ;TYPE "SWI" & DO "REG" COMMAND
2098 0f4f bf 7f 08                  STX    SWIVEC
2099                         ;INITIALIZE TO MONDEB'S COMMAND LISTS
2100 0f52 8e 0d bc                  LDX    #COMLST-1
2101 0f55 bf 7f 10                  STX    COMADR
2102                         ;TIME CONSTANT FOR A 2 MICROSECOND CLOCK
2103 0f58 86 00                     LDA    #256
2104 0f5a b7 7f eb                  STA    TIMCON
2105 0f5d 39                        RTS
2106                         
2107                         ;======================================================
2108                         ;OUTPUT A CHARACTER STRING WHICH BEGINS AT THE ADDRESS IN THE INDEX REGISTER
2109                         ;ACCA & ACCB ARE PRESERVED
2110                         ;IX IS LEFT POINTING TO THE STRING TERMINATOR
2111 0f5e 34 02              OUTSTR PSHS   A
2112 0f60 a6 84              OUTST1 LDA    ,X       ;GET CHAR POINTED TO
2113 0f62 81 04                     CMPA   #4       ;IS IT A STRING TERMINATOR?
2114 0f64 27 06                     BEQ    OUTEND   ;DONE IF IT IS
2115 0f66 8d 25                     BSR    OUTCHR   ;ISN'T, OUTPUT IT
2116 0f68 30 01                     LEAX   1,X      ;ON TO NEXT CHARACTER
2117 0f6a 20 f4                     BRA    OUTST1
2118 0f6c 35 02              OUTEND PULS   A
2119 0f6e 39                        RTS             ;RETURN
2120                         
2121                         ;======================================================
2122                         ;INPUT A CHARACTER FROM AN ACIA TO ACCA
2123                         ;IF INPFLG = 0, INPUT IS FROM TERMINAL ACIA
2124                         ;IF INPFLG = 0, INPUT IS FROM ANY ACIA
2125                         ;ACCB & IX ARE PRESERVED
2126                         
2127 0f6f bf 7f db           INPCHR STX    XTEMP    ;SAVE IX
2128 0f72 7d 7f 2b                  TST    INPFLG   ;TEST INPUT SOURCE FLAG
2129 0f75 26 05                     BNE    INPCH1
2130                         ;INPFLG=0: INPUT FROM TERMINAL ACIA
2131 0f77 8e a0 01                  LDX    #ACIA1
2132 0f7a 20 03                     BRA    INPCH2
2133                         ;INPFLG=1: INPUT FROM ANY ACIA
2134 0f7c be 7f 2c           INPCH1 LDX    INPADR   ;GET ITS ADDRESS
2135 0f7f 30 1f              INPCH2 LEAX   -1,X     ;POINT TO CONTROL REG
2136 0f81 a6 84              INPCH3 LDA    ,X       ;GET ACIA STATUS BYTE
2137 0f83 85 01                     BITA   #1       ;CHAR WAITING?
2138 0f85 27 fa                     BEQ    INPCH3   ;IF NOT, TRY AGAIN
2139 0f87 a6 01                     LDA    1,X      ;YES, GET IT
2140 0f89 be 7f db                  LDX    XTEMP    ;RESTORE IX
2141 0f8c 39                        RTS
2142                         
2143                         ;======================================================
2144                         ;OUTPUT THE CHARACTER IN ACCA TO THE DESIRED OUTPUT DEVICE/LOCATION
2145                         ; IF OUTFLG = 0, OUTPUT IS TO TERMINAL
2146                         ; IF OUTFLG = 1, OUTPUT IS TO ACIA ADDRESS STORED IN OUTADR
2147                         ; IF OUTFLG = 2, OUTPUT IS TO ADDRESS IN OUTADR & THIS ADDR IS THEN INCREMENTED
2148                         ;ACCA, ACCB, & IX ARE PRESERVED
2149 0f8d 34 04              OUTCHR PSHS   B        ;SAVE ACCB
2150 0f8f 7d 7f 2e                  TST    OUTFLG   ;TEST OUTPUT DESTINATION FLAG
2151 0f92 27 24                     BEQ    OUTCH4   ;SKIP THIS CODE IF TERMINAL OUTPUT
2152                         
2153                         ;OUTPUT TO SOMETHING OTHER THAN THE TERMINAL
2154 0f94 bf 7f db                 STX     XTEMP    ;SAVE IX
2155 0f97 be 7f 2f                 LDX     OUTADR   ;GET OUTPUT CHAR DESTINATION ADDRESS
2156 0f9a c6 02                    LDB     #2
2157 0f9c f1 7f 2e                 CMPB    OUTFLG
2158 0f9f 27 0a                    BEQ     OUTCH2
2159                         
2160                         ;OUTFLG = 1: ANY ACIA OUTPUT
2161 0fa1 30 1f                     LEAX   -1,X     ;POINT TO ACIA STATUS REG
2162 0fa3 e5 84              OUTCH1 BITB   ,X       ;TEST TDRE BIT
2163 0fa5 27 fc                     BEQ    OUTCH1   ;LOOP IF NOT READY TO ACCEPT A NEW CHAR
2164 0fa7 a7 01                     STA    1,X      ;NOW READY - SEND IT
2165 0fa9 20 07                     BRA    OUTCH3
2166                         
2167                         ;OUTCLF = 2: MEMORY OUTPUT
2168 0fab a7 84              OUTCH2 STA    ,X       ;SAVE CHAR IN MEMORY
2169 0fad 30 01                     LEAX   1,X
2170 0faf bf 7f 2f                  STX    OUTADR   ; UPDATE OUTPUT ADDRESS
2171                         
2172 0fb2 be 7f db           OUTCH3 LDX    XTEMP    ;RESTORE IX
2173 0fb5 35 04                     PULS   B        ;RESTORE ACCB
2174 0fb7 39                        RTS
2175                         
2176                         ;OUTFLG = 0: TERMINAL ACIA OUTPUT
2177                         ;IGNORE LINE FEEDS
2178 0fb8 81 0a              OUTCH4 CMPA   #LF
2179 0fba 26 03                     BNE    OUTCH5
2180 0fbc 35 04                     PULS   B
2181 0fbe 39                        RTS
2182                         
2183 0fbf 81 0d              OUTCH5 CMPA   #CR      ;TEST FOR CARRIAGE RETURN
2184 0fc1 26 05                     BNE    OUTCH6
2185 0fc3 8d 20                     BSR    DOCRLF
2186 0fc5 35 04                     PULS   B
2187 0fc7 39                        RTS
2188                         
2189 0fc8 f6 7f 32           OUTCH6 LDB    CPLCNT   ;GET "CHARACTERS PER LINE" COUNT
2190 0fcb f1 7f 33                  CMPB   CPLMAX   ;COMPARE TO MAX PERMISSIBLE
2191 0fce 2c 0b                     BGE    OUTCH7   ;SEND CR-LF IF GREATER
2192                         ;LESS THAN MAX, BUT ALSO SEND CR-LF IF 10 FROM END AND PRINTING A SPACE
2193 0fd0 cb 0a                     ADDB   #10
2194 0fd2 f1 7f 33                  CMPB   CPLMAX
2195 0fd5 2d 06                     BLT    OUTCH8
2196 0fd7 81 20                     CMPA   #$20     ;NEAR END, TEST IF ABOUT TO PRINT A SPACE
2197 0fd9 26 02                     BNE    OUTCH8
2198                         
2199                         ;TERMINAL LINE FULL OR NEARLY FULL - INTERJECT A CR-LF
2200 0fdb 8d 08              OUTCH7 BSR    DOCRLF
2201 0fdd 7c 7f 32           OUTCH8 INC    CPLCNT   ;BUMP COUNTER
2202 0fe0 8d 17                     BSR    TOACIA   ;SEND IT TO ACIA1
2203 0fe2 35 04                     PULS   B
2204 0fe4 39                        RTS
2205                         
2206                         ;======================================================
2207                         ;SEND A CARRIAGE RETURN-LINE FEED TO THE TERMINAL
2208                         ;ACCA, ACCB, & IX ARE PRESERVED
2209 0fe5 34 02              DOCRLF PSHS   A
2210 0fe7 34 04                     PSHS   B
2211 0fe9 86 0d                     LDA    #CR
2212 0feb 8d 0c                     BSR    TOACIA
2213 0fed 86 0a                     LDA    #LF
2214 0fef 8d 08                     BSR    TOACIA
2215 0ff1 7f 7f 32                  CLR    CPLCNT   ;ZERO "CHARACTERS PER LINE" COUNT
2216 0ff4 35 04                     PULS   B
2217 0ff6 35 02                     PULS   A
2218 0ff8 39                        RTS
2219                         
2220                         ;======================================================
2221                         ;PUT CHAR IN ACCA INTO TERMINAL ACIA
2222                         ;ACCA, ACCB, & IX ARE PRESERVED
2223 0ff9 34 02              TOACIA PSHS   A        ;SAVE CHAR
2224 0ffb 86 02                     LDA    #2       ;GET ACIA TRANSMIT REG STATUS BIT
2225 0ffd b5 a0 00           TOACI1 BITA   ACIA1-1  ;REGISTER EMPTY?
2226 1000 27 fb                     BEQ    TOACI1   ;IF NOT, LOOP BACK
2227 1002 35 02                     PULS   A        ;YES, RESTORE CHARACTER
2228 1004 b7 a0 01                  STA    ACIA1    ;SEND IT
2229 1007 39                        RTS
2230                         
2231                         ;======================================================
2232                         ;MISC TEST
2233 1008 4d 4f 4e 44 45 42  MSGHED FCC    "MONDEB 6809 1.00" ;MONITOR HEADER TYPEOUT
     20 36 38 30 39 20
     31 2e 30 30
2234 1018 0d 04                     FCB    CR,4
2235                         
2236 101a 2a                 MSGPRM FCC   "*"        ;PROMPT STRING
2237 101b 04                        FCB    4
2238                         
2239 101c 0d                 MSGSWI FCB    CR
2240 101d 53 57 49 3a               FCC    "SWI:"
2241 1021 04                        FCB    4
2242                         
2243 1022 54 4f 4f 20 4c 4f  MSGLTL FCC    "TOO LONG" ; TYPED IF INPUT LINE IS TOO LONG
     4e 47
2244 102a 04                        FCB    4
2245                         
2246 102b 4e 4f 54 20 53 45  MSGNBR FCC    "NOT SET" ; BREAK NOT SET
     54
2247 1032 04                        FCB    4
2248                         
2249 1033 53 45 54 20 40 20  MSGBAT FCC    "SET @ " ; BREAK AT -
2250 1039 04                        FCB    4
2251                         
2252 103a 4f 4b              MSGVER FCC    "OK"     ;CHECKSUM VERIFIES
2253 103c 04                        FCB    4
2254                         
2255 103d 43 48 45 43 4b 53  MSGNVE FCC    "CHECKSUM ERROR " ; FOR VERIFY & LOAD COMMANDS
     55 4d 20 45 52 52
     4f 52 20
2256 104c 04                        FCB    4
2257                         
2258 104d 43 41 4e 27 54 20  MSGCCL FCC    "CAN'T CLEAR" ; TEST COMMAND
     43 4c 45 41 52
2259 1058 04                        FCB    4
2260                         
2261 1059 43 41 4e 27 54 20  MSGCSO FCC    "CAN'T SET TO ONES" ; TEST COMMAND
     53 45 54 20 54 4f
     20 4f 4e 45 53
2262 106a 04                        FCB    4
2263                         
2264 106b 53 55 4d 20 49 53  MSGSIS FCC    "SUM IS " ; COMPARE COMMAND
     20
2265 1072 04                        FCB    4
2266                         
2267 1073 2c 20 44 49 46 46  MSGDIS FCC    ", DIFF IS " ; COMPARE COMMAND
     20 49 53 20
2268 107d 04                        FCB    4
2269                         
2270 107e 0d 0a              MSGS0  FCB    CR,LF
2271 1080 53 30 30 36 30 30         FCC    "S00600004844521B"
     30 30 34 38 34 34
     35 32 31 42
2272 1090 04                        FCB    4
2273                         
2274 1091 0d 0a              MSGS1  FCB    CR,LF
2275 1093 53 31                     FCC    "S1"
2276 1095 04                        FCB    4
2277                         
2278 1096 0d 0a              MSGS9  FCB    CR,LF
2279 1098 53 39 30 33 30 30         FCC    "S9030000FC"
     30 30 46 43
2280 10a2 0d 0a 04                  FCB    CR,LF,4
2281                         
2282 10a5 43 48 41 52 20 4e  MSGCNH FCC    "CHAR NOT HEX" ;USE IN LOAD COMMAND
     4f 54 20 48 45 58
2283 10b1 0d 04                     FCB    CR,4
2284                         
2285                         ;======================================================
2286                         ;INTERRUPT HANDLING CODE
2287 10b3 6e 9f 7f 00        INTADR JMP    [INTVEC]
2288                         
2289                         ;*****
2290 10b7 6e 9f 7f 02        FIRQADR JMP   [FIRQVC]
2291                         
2292                         ;*****
2293 10bb 6e 9f 7f 04        NMIADR JMP    [NMIVEC]
2294                         
2295                         ;*****
2296 10bf 6e 9f 7f 06        RSRVDADR JMP  [RSRVDVC]
2297                         
2298                         ;*****
2299 10c3 7e 04 00           RESADR JMP    START
2300                         
2301                         ;*****
2302 10c6 10 ff 7f 0e        SWIADR STS    SP       ;SAVE STACK POINTER OF PROGRAM BEING DEBUGGED
2303 10ca 6e 9f 7f 08               JMP    [SWIVEC]
2304                         
2305                         ;*****
2306                         SWI2ADR
2307 10ce 10 ff 7f 0e               STS    SP       ;SAVE STACK POINTER OF PROGRAM BEING DEBUGGED
2308 10d2 6e 9f 7f 0a               JMP    [SWI2VC]
2309                         
2310                         ;*****
2311                         SWI3ADR
2312 10d6 10 ff 7f 0e               STS    SP       ;SAVE STACK POINTER OF PROGRAM BEING DEBUGGED
2313 10da 6e 9f 7f 0c               JMP    [SWI3VC]
2314                         
2315                         ;*****
2316                         ;      FILL   $FF, $FFB1-*
2317                         ;      ORG    $FFB1    ;CALCULATED SO INTERRUPT VECTORS BELOW ARE AT CORRECT ADDRESSES
2318                         ;**************************************************
2319                         
2320 10de 7e 0a 53                  JMP    TIMDEL   ;TIME DELAY FOR # OF MS SPECIFIED BY IX
2321 10e1 7e 07 ba                  JMP    CKSUM    ;RETURN CHECKSUM OF AN ADDRESS RANGE IN ACCA
2322 10e4 7e 0d a4                  JMP    GETCHR   ;RETURN (IN ACCB) CHAR POINTED TO BY LINPTR
2323 10e7 7e 0d b2                  JMP    GETLST   ;RETURN (IN ACCA) CHAR POINTED TO BY LISPTR
2324 10ea 7e 0b d8                  JMP    GTRANG   ;PICK UP AN ADDRESS RANGE IN RANGLO & RANGHI
2325 10ed 7e 0c 23                  JMP    NUMBER   ;PICK UP A NUMBER & RETURN IT IN NBRHI & NBRLO
2326 10f0 7e 0b 40                  JMP    SKPDLM   ;SKIP OVER INPUT LINE DELIMITERS
2327 10f3 7e 0b 6d                  JMP    TSTDLM   ;TEST CHAR IN ACCB FOR A DELIMITER
2328 10f6 7e 0b 62                  JMP    TSTEOL   ;TEST CHAR IN ACCA FOR END-OF-LINE
2329 10f9 7e 0a 97                  JMP    COMAND   ;SEARCH SPECIFIED COMMAND LIST FOR A COMMAND
2330 10fc 7e 0b 01                  JMP    TYPCMD   ;TYPES OUT COMMAND NUMBER "COMNUM" IN LIST ACCA
2331 10ff 7e 0c d9                  JMP    OUT1BY   ;DISPLAY THE 1 BYTE NUMBER POINTED AT BY IX
2332 1102 7e 0c e2                  JMP    OUT2BY   ;DISPLAY THE 2 BYTE NUMBER POINTED AT BY IX
2333 1105 7e 0e 9c                  JMP    GETLIN   ;GET A LINE OF INPUT INTO THE TTY BUFFER
2334 1108 7e 0f 5e                  JMP    OUTSTR   ;OUTPUT CHAR STRING IX POINTS TO
2335 110b 7e 0f e5                  JMP    DOCRLF   ;SEND CR-LF WITH DELAY & ZERO LINE COUNT
2336 110e 7e 0f 8d                  JMP    OUTCHR   ;LIKE TOACIA, BUT WITH FOLDING, CR DELAY, & LF INSERTION
2337 1111 7e 0f f9                  JMP    TOACIA   ;SEND ACCA TO ACIA1
2338 1114 7e 0f 6f                  JMP    INPCHR   ;GET A CHAR FROM AN ACIA & RETURN IT IN ACCA
2339 1117 7e 04 27                  JMP    PROMPT   ;TO PROMPT FOR A NEW COMMAND
2340 111a 7e 04 00                  JMP    START    ;START OF MONDEB
2341                         ;**************************************************
2342                         ;INTERRUPT VECTORS
2343 111d 10 bf                     FDB   RSRVDADR  ;RESERVED INTERRUPT
2344 111f 10 d6                     FDB   SWI3ADR   ;SWI3 INTERRUPT
2345 1121 10 ce                     FDB   SWI2ADR   ;SWI2 INTERRUPT
2346 1123 10 b7                     FDB   FIRQADR   ;FAST INTERRUPT
2347 1125 10 b3                     FDB   INTADR    ;REGULAR INTERRUPT
2348 1127 10 c6                     FDB   SWIADR    ;SOFTWARE INTERRUPT
2349 1129 10 bb                     FDB   NMIADR    ;NON-MASKABLE INTERRUPT
2350 112b 10 c3                     FDB   RESADR    ;RESET INTERRUPT
2351                         
2352                         ;**************************************************
2353                         ;VARIABLES FOR INTER-ROUTINE COMMUNICATION
2354 7f00                           ORG    $7F00
2355 7f00                    INTVEC RMB    2        ;INTERRUPT ADDRESS POINTER
2356 7f02                    FIRQVC RMB    2        ;FAST INTERRUPT ADDRESS POINTER
2357 7f04                    NMIVEC RMB    2        ;NON-MASKABLE INTERRUPT ADDRESS POINTER
2358 7f06                    RSRVDVC RMB   2        ;RESERVED INTERRUPT ADDRESS POINTER
2359 7f08                    SWIVEC RMB    2        ;SOFTWARE INTERRUPT ADDRESS POINTER
2360 7f0a                    SWI2VC RMB    2        ;SOFTWARE INTERRUPT2 ADDRESS POINTER
2361 7f0c                    SWI3VC RMB    2        ;SOFTWARE INTERRUPT3 ADDRESS POINTER
2362 7f0e                    SP     RMB    2        ;SAVED STACK POINTER
2363 7f10                    COMADR RMB    2        ;ADDRESS OF BEGINNING OF COMMAND LISTS FOR COMMAND
2364 7f12                    SYNPTR RMB    2        ;INPUT LINE CHARACTER POINTER FOR GOOD SYNTAX
2365 7f14                    LINPTR RMB    2        ;INPUT LINE CHARACTER POINTER (CONTENT = OR > CONTENT OF SYNPTR)
2366 7f16                    BOLFLG RMB    1        ;"BEGINNING OF LINE" FLAG
2367 7f17                    DELIM  RMB    1        ;CHARACTER(S) PERMITTED AS VALID COMMAND/MODIFIER DELIMITER
2368 7f18                    IBCODE RMB    1        ;INPUT BASE (1=HEX, 2=DEC, 3=OCT)
2369 7f19                    DBCODE RMB    1        ;DISPLAY BASE (1=HEX, 2=DEC, 3=OCT, 4=BIN)
2370 7f1a                    DBNBR  RMB    1        ;DISPLAY BASE NUMBER (E.G., 16,10M8M OR 2)
2371                         
2372 7f1b                    NBRHI  RMB    1        ;MOST SIGNIFICANT BYTE OF SCANNED NUMBER
2373 7f1c                    NBRLO  RMB    1        ;LEAST SIGNIFICANT BYTE OF SCANNED NUMBER
2374                         
2375 7f1d                    RANGLO RMB    2        ;RANGE LOWER LIMIT PICKED UP BY GTRANG
2376 7f1f                    RANGHI RMB    2        ;RANGE UPPER LIMIT PICKED UP BY GTRANG
2377                         
2378 7f21                    LASTGO RMB    2        ;LAST SPECIFIED GOTO ADDRESS
2379                         
2380 7f23                    VERFRM RMB    2        ;BEGINNING ADDRESS OF RANGE TO CHECKSUM VERIFY
2381 7f25                    VERTO  RMB    2        ;ENDING ADDRESS OF RANGE TO CHECKSUM VERIFY
2382                         
2383 7f27                    CHKSUM RMB    1        ;CHECKSUM OF RANGE GIVEN IN THE VERIFY COMMAND
2384                         
2385 7f28                    BRKADR RMB    2        ;ADDRESS OF INSERTED BREAKPOINT
2386 7f2a                    BRKINS RMB    1        ;INSTRUCTION WHICH SHOULD BE THERE NORMALLY
2387                         
2388 7f2b                    INPFLG RMB    1        ;ALTERNATE INPUT DESTINATION FLAG
2389 7f2c                    INPADR RMB    2        ;ALTERNATE ADDRESS THAT THE INPUT CHARACTERS ARE TO COME FROM
2390                         
2391 7f2e                    OUTFLG RMB    1        ;ALTERNATE OUTPUT DESTINATION FLAG
2392 7f2f                    OUTADR RMB    2        ;ALTERNATE ADDRESS THAT THE OUTPUT CHARACTERS ARE TO GO TO
2393                         
2394 7f31                    HDXFLG RMB    1        ;HALF-DUPLEX TERMINAL FLAG (IF NON-ZERO, NO ECHO)
2395                         
2396 7f32                    CPLCNT RMB    1        ;"CHARACTERS PER LINE" COUNT
2397 7f33                    CPLMAX RMB    1        ;"CHARACTERS PER LINE" MAXIMUM
2398 7f34                    BUFBEG RMB    2        ;INPUT LINE START OF BUFFER
2399 7f36                    BUFEND RMB    2        ;INPUT LINE END OF BUFFER
2400 7f38                    TTYBUF RMB    72       ;START OF INPUT LINE BUFFER
2401 7f80                    TTYEND RMB    1        ;END OF INPUT LINE BUFFER
2402 7f81                           RMB    56       ;MAIN STACK STORAGE
2403 7fb9                    STACK  RMB    12       ;STACK STORAGE FOR RTI INSTRUCTION
2404                         
2405                         ;TEMPORARY (LOCALLY USED) VARIABLES
2406 7fc5                    TEMP1  RMB    2        ;IN: MAIN
2407 7fc7                    TEMP2  RMB    2        ;IN: MAIN
2408 7fc9                    TEMP3  RMB    2        ;IN: FNDSTR,MAIN
2409 7fcb                    TEMP4  RMB    2        ;IN: MAIN
2410 7fcd                    TEMP5  RMB    2        ;IN: MAIN
2411 7fcf                    TEMP6  RMB    2        ;IN: MAIN
2412 7fd1                    TEMP7  RMB    2        ;IN: MAIN
2413 7fd3                    TEMP8  RMB    2        ;IN: MAIN
2414 7fd5                    TEMP9  RMB    2        ;IN: MAIN
2415 7fd7                    TEMP10 RMB    2        ;IN: MAIN
2416 7fd9                    TEMP11 RMB    2        ;IN: MAIN
2417                         
2418                         ;XTEMP IS NOT TO BE USED TO SAVE IX BETWEEN ROUTINES
2419 7fdb                    XTEMP  RMB    2        ;USED BY DUMP,TYPCMD,OUTNUM
2420 7fdd                    XTEMP1 RMB    2        ;USED BY OUTNUM
2421 7fdf                    XTEMP2 RMB    2        ;USED BY NUMBER
2422 7fe1                    NUMMAT RMB    1        ;USED IN COMMAND
2423 7fe2                    LISNUM RMB    1        ;USED ON COMMAND
2424 7fe3                    COMNUM RMB    1        ;USED IN COMMAND
2425 7fe4                    LISPTR RMB    2        ;USED IN COMMAND
2426 7fe6                    DECDIG RMB    1        ;DECIMAL DIGIT BEING BUILT (DECIMAL OUTPUT BASE)
2427 7fe7                    NUMBHI RMB    1        ;USED BY OUTNUM
2428 7fe8                    NUMBLO RMB    1        ;USED BY OUTNUM
2429 7fe9                    NBR2X  RMB    2        ;USED BY NUMBER
2430 7feb                    TIMCON RMB    2        ;DELAY TIME CONSTANT
2431 7fed                    BYTECT RMB    1        ;RECORD BYTE COUNT USED IN LOAD COMMAND
2432 7fee                    CKSM   RMB    1        ;RECORD CHECKSUM USED IN LOAD COMMAND
2433                         
2434                         ;CONVENIENT EQUIVALENCES FOR LOCAL VARIABLES
2435 7fc5                    MEMADR EQU    TEMP1    ;DISPLAY,SET,SEARCH,TEST
2436 7fc7                    STRNUM EQU    TEMP2    ;FNDSTR
2437 7fc8                    EOSCHR EQU    TEMP2+1  ;FNDSTR
2438                         
2439                         ;FOR "SEARCH" COMMAND
2440 7fc7                    BYTPTR EQU    TEMP2
2441 7fc9                    NBYTES EQU    TEMP3
2442 7fca                    NBRMAT EQU    TEMP3+1
2443 7fcb                    BYTSTR EQU    TEMP4
2444                         
2445                         ;      END
