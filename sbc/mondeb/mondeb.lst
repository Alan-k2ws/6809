0001                         ; This is a port of the MONDEB monitor/debugger to the 6809,
0002                         ; specifically my 6809-based Single Board Computer.
0003                         ;
0004                         ; It is a port of the original 6800 version by Don PEters, with some
0005                         ; additional changes taken from a 6809 version written by Alan R.
0006                         ; Baldwin.
0007                         ;
0008                         ; Jeff Tranter <tranter@pobox.com>
0009                         
0010                                 NAM   MONDEB
0011                         
0012                         ;THIS SOURCE CODE WAS SENT TO WALTER BANKS AT
0013                         ;THE UNIVERSITY OF WATERLOO BY DON PETERS ON PAPER TAPE
0014                         ;CROSS ASSEMBLY WAS DONE ON THE U OF W HONEYWELL 66/60
0015                         ;THE BARCODE AND LISTING WERE SET ON A PHOTON PHOTO-
0016                         ;TYPESETTER DRIVEN BY THE HONEYWELL.
0017                         ;
0018                         ;       M O N D E B  - A MONITOR/DEBUGGER FOR THE M6800 MICROPROCESSOR
0019                         
0020                         ; AUTHOR: DON PETERS
0021                         ; DATE: APRIL 1977
0022                         ; MEMORY REQ'D: 3K BYTES AT HIGH END OF ADDRESS SPACE
0023                         
0024                         ; SEE USER MANUAL FOR CAPABILITIES & INSTRUCTIONS ON USE
0025                         
0026 0400                           ORG     $400    ;DEBUG ORG AT 1K
0027                         ;      ORG    $F000    ;NORMAL ORIGIN AT 60K
0028                         
0029                         
0030                         ;I/O DEVICE ADDRESSES
0031 a001                    ACIA1  EQU    $A001    ;ACIA #1 - MAIN TERMINAL ACIA
0032 a001                    ACIA2  EQU    $A001    ;ACIA #2 - AUXILIARY TERMINAL ACIA
0033                         
0034                         ;OTHER CONSTANTS
0035 000d                    CR     EQU    13       ;CARRIAGE RETURN
0036 000a                    LF     EQU    10       ;LINE FEED
0037                         
0038                         
0039 0400                    START  EQU    *        ;PROGRAM ENTRY POINT
0040 0400 10 ce 7f b9               LDS    #STACK   ;INITIALIZE THE STACK POINTER
0041 0404 10 ff 7f 0e               STS    SP       ;SAVE THE POINTER
0042 0408 bd 0f 21                  JSR    INITAL   ;INITIALIZE VARIABLES
0043                         
0044                         
0045                         ;TYPE OUT MONITOR NAME & VERSION
0046 040b bd 0f e5                  JSR    DOCRLF   ;ADVANCE TO A CLEAN LINE
0047 040e 8e 10 08                  LDX    #MSGHED  ;GET ADDRESS OF HEADER
0048 0411 bd 0f 5e                  JSR    OUTSTR   ;TYPE IT
0049                         
0050                         ;SET UP DESTINATION OF INPUT LINE
0051                         ;DEFINE BEGINNING OF INPUT BUFFER
0052 0414 8e 7f 37                  LDX    #TTYBUF-1   ;GET ADDRESS OF TERMINAL INPUT BUFFER
0053 0417 bf 7f 34                  STX    BUFBEG   ;SAVE IT
0054                         
0055                         ;DEFINE END OF INPUT BUFFER - 72 CHAR CAPACITY, INCL CR
0056 041a 8e 7f 80                  LDX    #TTYEND
0057 041d bf 7f 36                  STX    BUFEND
0058                         
0059                         ;DELIMITER CLASS DEFINITION - SPACE OR COMMA (CODE 3)
0060 0420 86 03                     LDA    #3
0061 0422 b7 7f 17                  STA    DELIM
0062 0425 20 0f                     BRA    PROMP1
0063                         
0064                         ;PREPARE TO GET A NEW COMMAND
0065 0427 bd 0f e5           PROMPT JSR    DOCRLF   ;TYPE CR-LF
0066 042a 7c 7f 16                  INC    BOLFLG   ;SET "BEGINNING OF LINE" FLAG
0067 042d be 7f 12                  LDX    SYNPTR   ;POINT TO CURRENT CHARACTER
0068 0430 a6 84                     LDA    ,X       ;GET IT
0069 0432 81 3b                     CMPA   #';'     ;SEMICOLON?
0070 0434 27 1a                     BEQ    GETCMD   ;CONTINUE SCAN IF IT IS, SKIPPING THE PROMPT
0071                         
0072                         ;TYPE PROMPT
0073 0436 8e 10 1a           PROMP1 LDX    #MSGPRM
0074 0439 bd 0f 5e                  JSR    OUTSTR
0075 043c bd 0e 9c                  JSR    GETLIN  ;GET LINE OF INPUT
0076                         
0077                         ;ABORT LINE ON A CONTROL-C
0078 043f c1 03                     CMPB   #3
0079 0441 27 e4                     BEQ    PROMPT
0080                         
0081                         ;SET SYNTAX SCANNING POINTER TO BEGINNING OF BUFFER/LINE
0082 0443 be 7f 34                  LDX    BUFBEG
0083 0446 bf 7f 12                  STX    SYNPTR
0084                         
0085                         ;REPROMPT ON AN EMPTY LINE (FIRST CHAR = CR, LF, OR ;)
0086 0449 a6 01                     LDA    1,X      ;GET FIRST CHAR
0087 044b bd 0b 62                  JSR    TSTEOL   ;TEST IT
0088 044e 27 d7                     BEQ    PROMPT   ;IF IT IS, PROMPT AGAIN
0089                         
0090                         ;USE LIST 1 WHEN MATCHING
0091 0450 86 01              GETCMD LDA    #1
0092                         
0093                         ;NOW GO FOR A MATCH
0094 0452 bd 0a 97                  JSR    COMAND
0095                         
0096                         ;-AND TEST THE RESULT OF THE SCAN
0097 0455 27 d0                     BEQ    PROMPT   ;REPROMPT IF JUST A CR WAS TYPED
0098 0457 2e 20                     BGT    JMPCMD   ;GOOD COMMAND IF POSITIVE
0099                         
0100                         ;*****
0101                         ;UNRECOGNIZABLE SYNTAX - POINT TO ERROR
0102 0459 be 7f 34           BADSYN LDX    BUFBEG   ;GET START OF LINE
0103                         ;SPACE OVER TO ERROR IN SYNTAX
0104 045c bc 7f 14           BADS1  CPX    LINPTR   ;AT ERROR?
0105 045f 27 07                     BEQ    BADS2
0106 0461 bd 0c cd                  JSR    OUTSP    ;OUTPUT A SPACE
0107 0464 30 01                     LEAX   1,X      ;NO, MOVE ON
0108 0466 20 f4                     BRA    BADS1
0109                         
0110                         ;THE "EXTRA" CHAR "1" IS COMPENSATED FOR BY THE PROMPT CHAR ON THE PRECEDING LINE
0111 0468 86 5e              BADS2  LDA    #'^'     ;AT ERROR - GET AN UP-ARROW
0112 046a bd 0f 8d                  JSR    OUTCHR   ;PRINT IT
0113 046d bd 0f e5                  JSR    DOCRLF
0114 0470 20 c4                     BRA    PROMP1   ;IGNORE ANY SUCCEEDING PACKED COMMANDS
0115                         
0116                         ;*****
0117                         ;THERE SHOULD BE NO MORE CHARACTERS ON THE INPUT LINE
0118                         ;                       (EXCEPT DELIMITERS)
0119 0472 bd 0b 40           NOMORE JSR    SKPDLM
0120 0475 25 b0                     BCS    PROMPT   ;IF CARRY BIT SET, END OF LINE (NORMAL)
0121                         ;THERE IS SOMETHING THERE BUT SHOULDN'T BE
0122 0477 20 e0                     BRA    BADSYN
0123                         
0124                         ;*****
0125                         ;EXECUTE A COMPUTED "GOTO" TO THE PROPER COMMAND
0126 0479 1f 89              JMPCMD TFR    A,B      ;SAVE COMMAND # IN ACCB
0127 047b 48                        ASLA            ;MULTIPLY COMMAND BY 2
0128 047c 34 04                     PSHS   B        ;ABA
0129 047e ab e0                     ADDA  ,S+       ;ACCA NOW HOLDS COMMAND # MULTIPLIED BY 3
0130                         ;ADD IT TO BASE OF JUMP TABLE
0131 0480 c6 04                     LDB    #JMPHI   ;GET HI BYTE OF START OF JUMP TABLE IN ACCB
0132 0482 8b 91                     ADDA   #JMPLO   ;ADD LO BYTE OF START OF JUMP TABLE TO ACCA
0133 0484 c9 00                     ADCB   #0       ;ADD CARRY IF THERE WAS ONE
0134                         ;MOVE ACCA & ACCB TO IX (CODE IS WEIRD, BUT BRIEF)
0135 0486 34 02                     PSHS   A
0136 0488 34 04                     PSHS   B
0137 048a 1f 41                     TFR    S,X      ;PUT ADDRESS OF "GOTO" INTO X
0138 048c ae 84                     LDX    ,X       ;GET THE ADDRESS ITSELF
0139 048e 35 04                     PULS   B        ;RESTORE THE STACK
0140 0490 35 02                     PULS   A
0141 0492 6e 84                     JMP    ,X       ;JUMP TO RIGHT COMMAND
0142                         
0143 0491                    JMPTBL EQU    *-3
0144                         
0145 0004                    JMPHI  EQU    JMPTBL/256
0146 0400                    JMP256 EQU    JMPHI*256
0147 0091                    JMPLO  EQU    JMPTBL-JMP256
0148                         
0149 0494 7e 04 e8                  JMP    REG
0150 0497 7e 05 3d                  JMP    GOTO
0151 049a 7e 05 4f                  JMP    LSEI
0152 049d 7e 05 57                  JMP    LCLI
0153 04a0 7e 05 5f                  JMP    COPY
0154 04a3 7e 05 8d                  JMP    BREAK
0155 04a6 7e 05 ed                  JMP    IBASE
0156 04a9 7e 06 04                  JMP    DBASE
0157 04ac 7e 06 3d                  JMP    CONTIN
0158 04af 7e 06 42                  JMP    DISPLA
0159 04b2 7e 06 ae                  JMP    SET
0160 04b5 7e 07 83                  JMP    VERIFY
0161 04b8 7e 07 cb                  JMP    SEARCH
0162 04bb 7e 08 5c                  JMP    TEST
0163 04be 7e 08 b6                  JMP    INT
0164 04c1 7e 08 be                  JMP    NMI
0165 04c4 7e 08 c6                  JMP    LSWI
0166 04c7 7e 08 ee                  JMP    COMPAR
0167 04ca 7e 09 17                  JMP    DUMP
0168 04cd 7e 09 b4                  JMP    LOAD
0169 04d0 7e 0a 4b                  JMP    DELAY
0170 04d3 7e 0a 5e                  JMP    HELP
0171 04d6 7e 05 5b                  JMP    LCLF
0172 04d9 7e 05 53                  JMP    LSEF
0173 04dc 7e 08 de                  JMP    FIRQ
0174 04df 7e 08 e6                  JMP    RSRVD
0175 04e2 7e 08 ce                  JMP    LSWI2
0176 04e5 7e 08 d6                  JMP    LSWI3
0177                         
0178                         ;*****
0179                         ;REG - DISPLAY REGISTERS
0180 04e8                    REG    EQU    *
0181                         ;PRINT STACK STORED SWI DATA
0182 04e8 be 7f 0e           DISREG LDX    SP       ;GET SAVED STACK POINTER
0183 04eb 30 01                     LEAX   1,X
0184                         ;REGISTER NAME TYPEOUT INITIALIZATION
0185 04ed 7f 7f e3                  CLR    COMNUM   ;START AT BEGINNING OF THE REGISTER NAME LIST
0186                         
0187 04f0 8d 19                     BSR    OUT2     ;TYPE CONDITION CODES
0188 04f2 8d 17                     BSR    OUT2     ;TYPE ACCA
0189 04f4 8d 15                     BSR    OUT2     ;TYPE ACCB
0190 04f6 8d 13                     BSR    OUT2     ;TYPE DP
0191                         
0192 04f8 8d 19                     BSR    OUT4     ;TYPE X REG
0193 04fa 8d 17                     BSR    OUT4     ;TYPE Y REG
0194 04fc 8d 15                     BSR    OUT4     ;TYPE U REG
0195 04fe 8d 13                     BSR    OUT4     ;TYPE PROGRAM COUNTER
0196                         
0197                         ;TYPE THE STACK POINTER LOCATION
0198 0500 8d 19                     BSR    OUT2A4   ;TYPE STACK POINTER ID
0199 0502 8e 7f 0e                  LDX    #SP
0200 0505 bd 0c e2                  JSR    OUT2BY   ;TYPE THE VALUE
0201 0508 7e 04 72                  JMP    NOMORE
0202                         
0203                         ;OUTPUT CONTENT OF A 1 BYTE REGISTER
0204 050b 8d 0e              OUT2   BSR    OUT2A4
0205 050d bd 0c d9                  JSR    OUT1BY
0206 0510 30 01                     LEAX   1,X
0207 0512 39                        RTS
0208                         
0209                         ;OUTPUT CONTENT OF A 2 BYTE REGISTER
0210 0513 8d 06              OUT4   BSR    OUT2A4
0211 0515 bd 0c e2                  JSR    OUT2BY
0212 0518 30 02                     LEAX   2,X      ;SKIP TO NEXT 2 BYTES IN STACK
0213 051a 39                        RTS
0214                         
0215                         ;MISC SETUP FOR REGISTER DISPLAY
0216 051b bd 0c cd           OUT2A4 JSR    OUTSP    ;OUTPUT A SPACE
0217 051e 7c 7f e3                  INC    COMNUM   ;SKIP TO NEXT REGISTER NAME
0218 0521 86 05                     LDA    #5       ;REGISTER NAME IS IN LIST 5
0219 0523 bd 0b 01                  JSR    TYPCMD   ;TYPE IT
0220 0526 bd 0c d3                  JSR    OUTEQ    ;TYPE AN "="
0221 0529 39                        RTS
0222                         
0223                         ;ENTER HERE FROM SOFTWARE INTERRUPT
0224 052a 8e 10 1c           TYPSWI LDX    #MSGSWI
0225 052d bd 0f 5e                  JSR    OUTSTR
0226                         ;DECREMENT PC SO IT POINTS TO "SWI" INSTRUCTION
0227 0530 be 7f 0e                  LDX    SP
0228 0533 6d 0c                     TST    12,X      ;TEST LO BYTE OF PC FOR PENDING BORROW
0229 0535 26 02                     BNE    TYPSW1
0230 0537 6a 0b                     DEC    11,X      ;NEED TO BORROW, DEC HI BYTE OF PC
0231 0539 6a 0c              TYPSW1 DEC    12,X      ;DECR LO BYTE OF PC
0232 053b 20 ab                     BRA    DISREG   ;GO DISPLAY REGISTERS
0233                         ;*****
0234                         ;GOTO - GO TO MEMORY ADDRESS
0235 053d bd 0c 23           GOTO   JSR    NUMBER   ;GET DESTINATION
0236 0540 27 08                     BEQ    GOTO1    ;IF NONE, USE DEFAULT
0237 0542 be 7f 1b                  LDX    NBRHI
0238 0545 bf 7f 21                  STX    LASTGO   ;SAVE IT
0239 0548 6e 84                     JMP    ,X       ;GO TO DESTINATION
0240                         
0241 054a be 7f 21           GOTO1  LDX   LASTGO    ;GET LAST GOTO ADDRESS
0242 054d 6e 84                     JMP   ,X        ;GO TO IT
0243                         
0244                         ;*****
0245                         ;SEI - SET INTERRUPT MASK
0246 054f 1a 10              LSEI   ORCC   #$10     ;SEI
0247 0551 20 37                     BRA    COPY3
0248                         
0249                         ;*****
0250                         ;SEF - SET FAST INTERRUPT MASK
0251 0553 1a 40              LSEF   ORCC   #$40     ;SEF
0252 0555 20 33                     BRA    COPY3
0253                         
0254                         ;*****
0255                         ;CLI - CLEAR INTERRUPT MASK
0256 0557 1c ef              LCLI   ANDCC  #$EF     ;CLI
0257 0559 20 2f                     BRA    COPY3
0258                         
0259                         ;*****
0260                         ;CLF - CLEAR FAST INTERRUPT MASK
0261 055b 1c ef              LCLF   ANDCC  #$EF     ;CLF
0262 055d 20 2b                     BRA    COPY3
0263                         
0264                         ;*****
0265                         ;COPY - COPY FROM ONE LOCATION TO ANOTHER
0266 055f bd 0b d8           COPY   JSR    GTRANG   ;GET SOURCE RANGE INTO RANGLO & RANGHI
0267 0562 2f 23                     BLE    COPY2    ;ERROR IF NO SOURCE
0268 0564 bd 0c 23                  JSR    NUMBER   ;GET DESTINATION
0269 0567 2f 1e                     BLE    COPY2    ;ERROR IF NO DESTINATION
0270                         
0271 0569 be 7f 1d                  LDX    RANGLO   ;GET SOURCE ADDRESS POINTER
0272 056c a6 84              COPY1  LDA    ,X       ;GET BYTE FROM SOURCE
0273 056e be 7f 1b                  LDX    NBRHI    ;GET DESTINATION ADDRESS POINTER
0274 0571 a7 84                     STA    ,X       ;SAVE BYTE IN DESTINATION
0275 0573 30 01                     LEAX   1,X      ;INC DESTINATION POINTER
0276 0575 bf 7f 1b                  STX    NBRHI    ;SAVE IT
0277 0578 be 7f 1d                  LDX    RANGLO   ;GET SOURCE ADDRESS POINTER
0278 057b bc 7f 1f                  CPX    RANGHI   ;COMPARE TO END OF INPUT RANGE
0279 057e 27 0a                     BEQ    COPY3    ;DONE IF EQUAL
0280 0580 30 01                     LEAX   1,X      ;NOT EQUAL, INC SOURCE POINTER
0281 0582 bf 7f 1d                  STX    RANGLO   ;SAVE IT
0282 0585 20 e5                     BRA    COPY1    ;LOOP FOR NEXT BYTE
0283                         
0284 0587 7e 04 59           COPY2  JMP    BADSYN   ;BAD SYNTAX
0285 058a 7e 04 72           COPY3  JMP    NOMORE   ;SHOULD BE NO MORE ON THE INPUT LINE
0286                         
0287                         ;*****
0288                         ;BREAK - SET BREAKPOINT AT SPECIFIED ADDRESS & REMOVE OLD ONE
0289 058d bd 0c 23           BREAK  JSR    NUMBER   ;GET BREAKPOINT LOCATION
0290 0590 2b 31                     BMI    BREAK3   ;IF NOT NUMERIC, LOOK FOR "?"
0291 0592 27 1f                     BEQ    BREAK2   ;IF NO MODIFIER, REMOVE OLD BREAKPOINT
0292                         
0293                         ;*****
0294                         ;CHECK IF A "SWI" IS STORED AT THE BREAK ADDRESS
0295 0594 be 7f 28                  LDX    BRKADR   ;GET CURRENT BREAK ADDRESS
0296 0597 a6 84                     LDA    ,X       ;AND THE CHAR THERE
0297 0599 81 3f                     CMPA   #$3F     ;COMPARE TO "SWI"
0298 059b 26 05                     BNE    BREAK1   ;EQUAL?
0299                         ;YES, RESTORE THE OLD INSTRUCTION
0300 059d b6 7f 2a                  LDA    BRKINS   ;GET IT
0301 05a0 a7 84                     STA    ,X       ;RESTORE IT
0302                         
0303                         ;PUT BREAK AT NEWLY SPECIFIED LOCATION
0304 05a2 be 7f 1b           BREAK1 LDX    NBRHI    ;GET NEW BREAKPOINT (BREAK ADDRESS)
0305 05a5 bf 7f 28                  STX    BRKADR   ;SAVE IT
0306 05a8 a6 84                     LDA    ,X       ;GET INSTRUCTION STORED THERE
0307 05aa b7 7f 2a                  STA    BRKINS   ;SAVE IT
0308 05ad 86 3f                     LDA    #$3F     ;GET CODE FOR SOFTWARE INTERRUPT
0309 05af a7 84                     STA    ,X       ;PUT IT AT BREAKPOINT
0310 05b1 20 34                     BRA    BREAK5   ;ALL DONE
0311                         
0312                         ;REMOVE BREAKPOINT
0313 05b3 be 7f 28           BREAK2 LDX    BRKADR   ;GET ADDRESS OF BREAK
0314 05b6 a6 84                     LDA    ,X       ;GET INST. THERE
0315 05b8 81 3f                     CMPA   #$3F     ;SWI?
0316 05ba 26 2b                     BNE    BREAK5   ;IF NOT,, RETURN & PROMPT
0317 05bc b6 7f 2a                  LDA    BRKINS   ;WAS A SWI - GET PREVIOUS INST.
0318 05bf a7 84                     STA    ,X       ;& RESTORE IT
0319 05c1 20 24                     BRA    BREAK5
0320                         
0321                         ;LOOK FOR A QUESTION MARK IN LIST 4
0322 05c3 86 04              BREAK3 LDA    #4
0323 05c5 bd 0a 97                  JSR    COMAND   ;SCAN FOR IT
0324 05c8 2f 20                     BLE    BREAK6   ;BAD SYNTAX IF NOT "?"
0325 05ca be 7f 28                  LDX    BRKADR   ;IT IS, GET BREAK ADDRESS
0326 05cd a6 84                     LDA    ,X       ;GET INSTRUCTION THERE
0327 05cf 81 3f                     CMPA   #$3F     ;IS IT A "SWI"?
0328 05d1 27 08                     BEQ    BREAK4   ;IF YES, SAY SO
0329                         ;NO BREAKPOINT SET
0330 05d3 8e 10 2b                  LDX    #MSGNBR  ;GET THAT MESSAGE
0331 05d6 bd 0f 5e                  JSR    OUTSTR   ;SAY IT
0332 05d9 20 0c                     BRA    BREAK5
0333                         ;BREAKPOINT SET
0334 05db 8e 10 33           BREAK4 LDX    #MSGBAT  ;GET THAT MESSAGE
0335 05de bd 0f 5e                  JSR    OUTSTR   ;SAY IT
0336 05e1 8e 7f 28                  LDX    #BRKADR  ;GET BREAK ADDRESS
0337 05e4 bd 0c e2                  JSR    OUT2BY   ;TYPE IT
0338                         
0339 05e7 7e 04 72           BREAK5 JMP    NOMORE
0340 05ea 7e 04 59           BREAK6 JMP    BADSYN
0341                         
0342                         ;*****
0343                         ;IBASE - SET INPUT BASE
0344                         ;LOOK FOR HEX, DEC, OR OCT IN LIST #3
0345 05ed 86 03              IBASE  LDA    #3
0346 05ef bd 0a 97                  JSR    COMAND
0347 05f2 2b 09                     BMI    IBASE2   ;UNRECOGNIZABLE BASE, TRY "?"
0348 05f4 2e 02                     BGT    IBASE1
0349 05f6 86 01                     LDA    #1       ;NO BASE GIVEN - DEFAULT TO HEX
0350 05f8 b7 7f 18           IBASE1 STA    IBCODE   ;SAVE BASE CODE
0351 05fb 20 ea                     BRA    BREAK5
0352                         
0353                         ;LOOK FOR "?" IN LIST #4
0354 05fd b6 7f 18           IBASE2 LDA    IBCODE   ;GET IB CODE IN CASE ITS NEEDED
0355 0600 34 02                     PSHS   A        ;SAVE IT ON STACK TEMPORARILY
0356 0602 20 26                     BRA    DBASE4
0357                         
0358                         ;*****
0359                         ;DBASE - SET DISPLAY BASE
0360                         ;LOOK FOR HEX,DEC,OCT OR BIN IN LIST #3
0361 0604 86 03              DBASE  LDA    #3
0362 0606 bd 0a 97                  JSR    COMAND
0363 0609 2b 1a                     BMI    DBASE3   ;UNRECOGNIZABLE BASE, TRY "?"
0364 060b 2e 02                     BGT    DBASE1
0365 060d 86 01                     LDA    #1       ;NO BASE GIVEN - DEFAULT TO HEX
0366 060f b7 7f 19           DBASE1 STA    DBCODE
0367                         
0368                         ;COMPUTE THE NUMERIC DISPLAY BASE (FOR THE "DISPLAY" COMMAND)
0369 0612 8e 06 20                  LDX    #DBTBL-1 ;POINT TO HEAD OF DISPLAY BASE TABLE
0370 0615 30 01              DBASE2 LEAX   1,X      ;INC TABLE POINTER
0371 0617 4a                        DECA            ;DECR DISPLAY BASE CODE
0372 0618 26 fb                     BNE    DBASE2   ;LOOP IF NOT EQUAL
0373 061a a6 84                     LDA    ,X       ;EQUAL - GET NUMERIC BASE FROM TABLE
0374 061c b7 7f 1a                  STA    DBNBR    ;SAVE IT
0375 061f 20 c6                     BRA    BREAK5   ;DONE
0376                         
0377                         ;DISPLAY BASE TABLE
0378 0621 10                 DBTBL  FCB    16
0379 0622 0a                        FCB    10
0380 0623 08                        FCB    8
0381 0624 02                        FCB    2
0382                         
0383                         ;LOOK FOR "?" IN LIST #4
0384 0625 b6 7f 19           DBASE3 LDA    DBCODE   ;GET DB CODE IN CASE ITS NEEDED
0385 0628 34 02                     PSHS   A        ;SAVE IT ON STACK TEMPORARILY
0386 062a 86 04              DBASE4 LDA    #4
0387 062c bd 0a 97                  JSR    COMAND
0388 062f 35 04                     PULS   B        ;RETRIEVE INPUT BASE/DISPLAY BASE CODE
0389 0631 2f b7                     BLE    BREAK6   ;ERROR IF THE "SOMETHING" WAS NOT AN "?"
0390                         ;SET UP FOR TYPEOUT OF BASE CODE
0391 0633 86 03                     LDA    #3       ;ITS IN LIST
0392 0635 f7 7f e3                  STB    COMNUM   ;STORE BASE CODE
0393 0638 bd 0b 01                  JSR    TYPCMD   ;TYPE OUT BASE
0394 063b 20 aa                     BRA    BREAK5
0395                         ;*****
0396                         ;CONTINUE - CONTINUE FROM A "SWI"
0397                         ;RETURN TO LOCATION WHERE SWI WAS
0398 063d 10 fe 7f 0e        CONTIN LDS    SP       ;IN CASE SP WAS MODIFIED VIA SET COMMAND
0399 0641 3b                        RTI
0400                         
0401                         ;*****
0402                         ;DISPLAY - DISPLAY MEMORY DATA
0403 0642 bd 0b d8           DISPLA JSR    GTRANG   ;GET MEMORY DISPLAY RANGE
0404 0645 2f 61                     BLE    DISPL9   ;ADDRESS IS REQUIRED
0405                         
0406                         ;INITIALIZE ADDRESS POINTER TO START OF MEMORY
0407 0647 be 7f 1d                  LDX    RANGLO
0408 064a bf 7f c5                  STX    MEMADR
0409                         
0410                         ;SEARCH LIST 6 FOR DISPLAY MODIFIERS "DATA" OR "USED"
0411 064d 86 06                     LDA    #6
0412 064f bd 0a 97                  JSR    COMAND
0413 0652 2b 54                     BMI    DISPL9   ;ANY OTHER MODIFIER IS ILLEGAL
0414                         ;ADJ DISPLAY MODIFIER CODE SO THAT: -1=ADDR & DATA, 0=DATA, I=USED
0415 0654 4a                        DECA
0416 0655 b7 7f e3                  STA    COMNUM   ;SAVE FOR LATER TESTS
0417                         ;INIT "DATA VALUES PER LINE" COUNTER
0418 0658 5f                        CLRB
0419 0659 5c                        INCB
0420 065a 8e 7f c5           DISPL1 LDX    #MEMADR
0421 065d 7d 7f e3                  TST    COMNUM   ;WHICH DISPLAY OPTION?
0422 0660 2b 2c                     BMI    DISPL6   ;IF "ADDRESS & DATA", GO THERE
0423                         
0424                         ;OUTPUT DATA WITH ADDRESS ONLY AT LINE BEGINNING
0425 0662 5a                        DECB            ;COUNT DATA VALUES PER LINE
0426 0663 26 0c                     BNE    DISPL2   ;IF COUNT NOT UP, SKIP ADDRESS OUTPUT
0427                         
0428 0665 bd 0f e5                  JSR    DOCRLF   ;GET TO LINE BEGINNING
0429 0668 bd 0c e2                  JSR    OUT2BY   ;OUTPUT ADDRESS
0430 066b bd 0c cd                  JSR    OUTSP    ;AND A SPACE
0431 066e f6 7f 1a                  LDB    DBNBR    ;RESET LINE COUNTER
0432                         
0433 0671 be 7f c5           DISPL2 LDX    MEMADR   ;POINT TO DATA AT THAT ADDRESS
0434 0674 7d 7f e3                  TST    COMNUM   ;WANT "DATA" OPTION?
0435 0677 2e 05                     BGT    DISPL3   ;IF NOT, GO TO "USES" CODE
0436                         
0437                         ;"DATA" OPTION
0438 0679 bd 0c cd                  JSR    OUTSP    ;OUTPUT PRECEDING SPACE
0439 067c 20 1b                     BRA    DISPL7
0440                         ;"USED" OPTION
0441 067e a6 84              DISPL3 LDA    ,X       ;GET THE DATA
0442 0680 4d                        TSTA            ;EXAMINE IT FOR ZERO
0443 0681 26 04                     BNE    DISPL4
0444 0683 86 2e                     LDA    #'.'     ;ITS ZERO, GET A "."
0445 0685 20 02                     BRA    DISPL5
0446 0687 86 2b              DISPL4 LDA    #'+'     ;ITS NON-ZERO. GET A "+"
0447 0689 bd 0f 8d           DISPL5 JSR    OUTCHR   ;OUTPUT THE "." OR "+"
0448 068c 20 0e                     BRA    DISPL8
0449                         
0450 068e bd 0c cd           DISPL6 JSR    OUTSP    ;OUTPUT A PRECEEDING SPACE
0451 0691 bd 0c e2                  JSR    OUT2BY   ;TYPE ADDRESS
0452 0694 bd 0c d3                  JSR    OUTEQ    ;TYPE "="
0453 0697 ae 84                     LDX    ,X       ;GET CONTENT
0454 0699 bd 0c d9           DISPL7 JSR    OUT1BY   ;TYPE IT
0455                         
0456 069c bc 7f 1f           DISPL8 CPX    RANGHI   ;ARE WE DONE?
0457 069f 27 0a                     BEQ    DISP10   ;IF YES, BACK TO PROMPT
0458 06a1 30 01                     LEAX   1,X      ;NO, INC MEMORY ADDRESS
0459 06a3 bf 7f c5                  STX    MEMADR   ;SAVE IT
0460 06a6 20 b2                     BRA    DISPL1
0461                         
0462 06a8 7e 04 59           DISPL9 JMP    BADSYN
0463 06ab 7e 04 72           DISP10 JMP    NOMORE
0464                         
0465                         ;*****
0466                         ;SET - SET MEMORY LOCATIONS
0467 06ae bd 0b d8           SET    JSR    GTRANG   ;GET MEMORY LOCATION/RANGE
0468 06b1 2b 52                     BMI    SET5     ;IF NOT AN ADDRESS, LOOK FOR A REGISTER NAME
0469 06b3 27 f3                     BEQ    DISPL9   ;AN ADDRESS MODIFIER IS REQUIRED
0470                         
0471                         ;RANGE OF ADDRESSES SPECIFIED?
0472 06b5 be 7f 1d                  LDX    RANGLO
0473 06b8 bc 7f 1f                  CPX    RANGHI
0474 06bb 27 13                     BEQ    SET2     ;IF SINGLE ADDRESS, SET UP ADDRESSES INDIVIDUALLY
0475                         ;SET A RANGE OF ADDRESSES TO A SINGLE VALUE
0476 06bd bd 0c 23                  JSR    NUMBER   ;GET THAT VALUE
0477 06c0 2f e6                     BLE    DISPL9   ;ITS REQUIRED
0478 06c2 b6 7f 1c                  LDA    NBRLO    ;PUT IT IN ACCA
0479 06c5 a7 84              SET1   STA    ,X       ;STORE IT IN DESTINATION
0480 06c7 bc 7f 1f                  CPX    RANGHI   ;END OF RANGE HIT?
0481 06ca 27 df                     BEQ    DISP10   ;IF YES,ALL DONE
0482 06cc 30 01                     LEAX   1,X      ;NO, ON TO NEXT ADDRESS IN RANGE
0483 06ce 20 f5                     BRA    SET1     ;LOOP TO SET IT
0484                         ;SET ADDRESSES UP INDIVIDUALLY
0485 06d0 bf 7f c5           SET2   STX    MEMADR   ;SAVE MEMORY LOC
0486 06d3 bd 0c 23           SET3   JSR    NUMBER   ;GET DATA TO PUT THERE
0487 06d6 27 0e                     BEQ    SET4     ;END OF LINE?
0488 06d8 2d ce                     BLT    DISPL9   ;ABORT IF BAD SYNTAX
0489 06da b6 7f 1c                  LDA    NBRLO    ;LOAD DATA BYTE
0490 06dd be 7f c5                  LDX    MEMADR   ;LOAD ADDRESS
0491 06e0 a7 84                     STA    ,X       ;STORE DATA
0492                         
0493                         ;INCREMENT ADDRESS IN CASE USER WANTS TO INDIVIDUALLY SET SEVERAL
0494                         ;SUCCESSIVE LOCATIONS
0495 06e2 30 01                     LEAX   1,X
0496 06e4 20 ea                     BRA    SET2
0497                         
0498                         ;END OF LINE - WAS IT TERMINATED WITH A LINE FEED?
0499 06e6 be 7f 12           SET4   LDX    SYNPTR   ;POINT TO END OF LINE
0500 06e9 a6 84                     LDA    ,X       ;GET CHAR THERE
0501 06eb 81 0a                     CMPA   #LF      ;LINE FEED?
0502 06ed 10 26 00 8f               LBNE   SET12    ;IF NOT, BACK TO PROMPT
0503 06f1 8e 7f c5                  LDX    #MEMADR  ;YES, GET NEXT ADDRESS TO BE SET
0504 06f4 bd 0c e2                  JSR    OUT2BY   ;TYPE IT
0505 06f7 bd 0c cd                  JSR    OUTSP    ;AND A SPACE
0506 06fa bd 0e 9c                  JSR    GETLIN   ;GET A NEW LINE
0507 06fd be 7f 34                  LDX    BUFBEG   ;GET BUFFER BEGINNING
0508 0700 bf 7f 12                  STX    SYNPTR   ;EQUATE IT TO SYNTAX SCAN POINTER
0509 0703 20 ce                     BRA    SET3     ;GO PICK UP DATA
0510                         
0511                         
0512                         ;LOOK FOR (REGISTER NAME, REGISTER VALUE) PAIRS
0513 0705 86 05              SET5   LDA    #5
0514 0707 bd 0a 97                  JSR    COMAND   ;PICK UP A REGISTER NAME
0515 070a 2b 71                     BMI    SET11    ;ERROR IF UNRECOGNIZABLE
0516 070c 27 72                     BEQ    SET12    ;DONE IF END OF LINE
0517 070e 34 02                     PSHS   A        ;SAVE REGISTER NAME(NUMBER)
0518 0710 bd 0c 23                  JSR    NUMBER   ;GET NEW REGISTER VALUE
0519 0713 35 02                     PULS   A        ;RESTORE REGISTER NAME(NUMBER)
0520 0715 2f 66                     BLE    SET11    ;GOT GOOD REGISTER VALUE?
0521 0717 be 7f 0e                  LDX    SP       ;YES, POINT TO TOP OF STACK
0522 071a f6 7f 1c                  LDB    NBRLO    ;GET REGISTER VALUE
0523                         
0524                         ;CONDITION CODES
0525 071d 81 01                     CMPA   #1
0526 071f 26 04                     BNE    SET6
0527 0721 e7 01                     STB    1,X
0528 0723 20 e0                     BRA    SET5
0529                         ;ACCA
0530 0725 81 02              SET6   CMPA   #2
0531 0727 26 04                     BNE    SET7
0532 0729 e7 02                     STB    2,X
0533 072b 20 d8                     BRA    SET5
0534                         
0535                         ;ACCB
0536 072d 81 03              SET7   CMPA   #3
0537 072f 26 04                     BNE    SET7A
0538 0731 e7 03                     STB    3,X
0539 0733 20 d0                     BRA    SET5
0540                         
0541                         ;DP
0542 0735 81 04              SET7A  CMPA   #4
0543 0737 26 04                     BNE    SET8
0544 0739 e7 04                     STB    4,X
0545 073b 20 c8                     BRA    SET5
0546                         
0547                         ;X
0548 073d 81 05              SET8   CMPA   #5
0549 073f 26 09                     BNE    SET8A
0550 0741 b6 7f 1b                  LDA    NBRHI
0551 0744 a7 05                     STA    5,X      ;UPDATE HI BYTE
0552 0746 e7 06                     STB    6,X      ;UPDATE LO BYTE
0553 0748 20 bb                     BRA    SET5
0554                         
0555                         ;Y
0556 074a 81 06              SET8A  CMPA   #6
0557 074c 26 09                     BNE    SET8B
0558 074e b6 7f 1b                  LDA    NBRHI
0559 0751 a7 07                     STA    7,X      ;UPDATE HI BYTE
0560 0753 e7 08                     STB    8,X      ;UPDATE LO BYTE
0561 0755 20 ae                     BRA    SET5
0562                         
0563                         ;U
0564 0757 81 07              SET8B  CMPA   #7
0565 0759 26 09                     BNE    SET9
0566 075b b6 7f 1b                  LDA    NBRHI
0567 075e a7 09                     STA    9,X      ;UPDATE HI BYTE
0568 0760 e7 0a                     STB    10,X     ;UPDATE LO BYTE
0569 0762 20 a1                     BRA    SET5
0570                         
0571                         ;PC
0572 0764 81 08              SET9   CMPA   #8
0573 0766 26 09                     BNE    SET10
0574 0768 b6 7f 1b                  LDA    NBRHI
0575 076b a7 0b                     STA    11,X     ;UPDATE HI BYTE
0576 076d e7 0c                     STB    12,X     ;UPDATE LO BYTE
0577 076f 20 94                     BRA    SET5
0578                         
0579                         ;S
0580 0771 81 09              SET10  CMPA   #9
0581 0773 26 08                     BNE    SET11
0582 0775 be 7f 1b                  LDX    NBRHI    ;DON'T NEED IX TO SET SP
0583 0778 bf 7f 0e                  STX    SP
0584 077b 20 88                     BRA    SET5
0585                         
0586 077d 7e 04 59           SET11  JMP    BADSYN
0587 0780 7e 04 72           SET12  JMP    NOMORE
0588                         ;*****
0589                         ;VERIFY - CHECKSUM VERIFY A BLOCK OF MEMORY
0590 0783 bd 0b d8           VERIFY JSR    GTRANG   ;GET A NUMBER RANGE
0591 0786 27 1b                     BEQ    VERIF1   ;NO MODIFIER MEANS CHECK WHAT WE HAVE
0592 0788 2b f3                     BMI    SET11    ;ANYTHING ELSE IS ILLEGAL
0593                         ;GOOD RANGE GIVEN, TRANSFER IT TO CHECKSUM ADDRESSES
0594 078a be 7f 1d                  LDX    RANGLO
0595 078d bf 7f 23                  STX    VERFRM
0596 0790 be 7f 1f                  LDX    RANGHI
0597 0793 bf 7f 25                  STX    VERTO
0598                         
0599 0796 8d 22                     BSR    CKSUM    ;COMPUTE CHECKSUM
0600 0798 b7 7f 27                  STA    CHKSUM   ;SAVE IT
0601 079b 8e 7f 27                  LDX    #CHKSUM  ;TYPE THE CHECKSUM
0602 079e bd 0c d9                  JSR    OUT1BY
0603 07a1 20 dd                     BRA    SET12
0604                         
0605                         ;NO MODIFIER GIVEN - JUST VERIFY CHECKSUM
0606 07a3 8d 15              VERIF1 BSR    CKSUM    ;COMPUTE CHECKSUM
0607 07a5 b1 7f 27                  CMPA   CHKSUM   ;SAME AS STORED CHECKSUM?
0608 07a8 26 08                     BNE    VERIF2
0609                         
0610                         ;THEY VERIFY - SAY SO
0611 07aa 8e 10 3a                  LDX    #MSGVER
0612 07ad bd 0f 5e                  JSR    OUTSTR
0613 07b0 20 ce                     BRA    SET12
0614                         
0615                         ;THEY DON'T - SAY SO
0616 07b2 8e 10 3d           VERIF2 LDX    #MSGNVE
0617 07b5 bd 0f 5e                  JSR    OUTSTR
0618 07b8 20 c6                     BRA    SET12
0619                         
0620                         ;COMPUTE THE CHECKSUM FROM ADDRESSES VERFRM TO VERTO
0621                         ;RETURN THE CHECKSUM IN ACCA
0622 07ba 4f                 CKSUM  CLRA            ;INIT CHECKSUM TO ZERO
0623 07bb be 7f 23                  LDX    VERFRM   ;GET FIRST ADDRESS
0624 07be 30 1f                     LEAX   -1,X     ;INIT TO ONE LESS
0625 07c0 30 01              CKSUM1 LEAX   1,X      ;START OF CHECKSUM LOOP
0626 07c2 ab 84                     ADDA   ,X       ;UPDATE CHECKSUM IN ACCA WITH BYTE POINTED TO
0627 07c4 bc 7f 25                  CPX    VERTO    ;HIT END OF RANGE?
0628 07c7 26 f7                     BNE    CKSUM1   ;IF NOT, LOOP BACK
0629 07c9 43                        COMA            ;COMPLEMENT THE SUM
0630 07ca 39                        RTS             ;RETURN WITH IT
0631                         ;*****
0632                         ;SEARCH - SEARCH MEMORY FOR A BYTE STRING
0633                         
0634                         ;GLOBAL VARIABLES USED
0635                         ;LINPTR - INPUT LINE CHARACTER POINTER
0636                         ;LISPTR - COMMAND LIST CHARACTER POINTER
0637                         ;RANGLO - "SEARCH FROM" ADDRESS
0638                         ;RANGHI - "SEARCH TO" ADDRESS
0639                         
0640                         ;LOCAL VARIABLES USE
0641                         ;MEMADR - STARTING MEMORY ADDRESS WHERE A MATCH OCCURRED
0642                         ;BYTPTR - ADDRESS POINTER USED TO FILL BYTSTR AND SUBSTR BUFFERS
0643                         ;NBYTES - NUMBER OF BYTES IN BYTE STRING
0644                         ;NBRMAT - NUMBER OF CHARS THAT MATCH SO FAR IN THE MATCHING PROCESS
0645                         ;BYTSTR - STARTING ADDRESS OF 6 CHARACTER BYTE STRING BUFFER
0646                         
0647                         ;THE SEARCH STRING OCCUPIES TEMP4, TEMP5, & TEMP6 (6 BYTES MAX)
0648                         
0649                         ;GET SEARCH RANGE BEGINNING (RANGLO) & END (RANGHI)
0650 07cb bd 0b d8           SEARCH JSR    GTRANG
0651 07ce 10 2f 00 84               LBLE   SEARC9   ;ABORT IF NO PAIR
0652                         
0653                         ;INITIALIZED BYTE STRING POINTER
0654 07d2 8e 7f cb                  LDX    #BYTSTR  ;GET START OF BYTE STRING TO SEARCH FOR
0655 07d5 bf 7f c7                  STX    BYTPTR   ;SET POINTER TO IT
0656                         
0657 07d8 7f 7f c9                  CLR    NBYTES   ;ZERO # OF BYES IN BYTE STRING
0658                         
0659                         ;GET BYTE STRING
0660 07db bd 0c 23           SEARC1 JSR    NUMBER   ;GET A BYTE
0661 07de 27 1b                     BEQ    SEARC2   ;BEGIN SEARCH IF EOL
0662 07e0 2d 74                     BLT    SEARC9
0663                         
0664                         ;GOOD BYTE, ADD IT TO STRING
0665 07e2 7c 7f c9                  INC    NBYTES   ;COUNT THIS BYTE
0666                         ;DON'T ACCEPT OVER 6 BYTES
0667 07e5 b6 7f c9                  LDA    NBYTES
0668 07e8 81 06                     CMPA   #6
0669 07ea 2e 6a                     BGT    SEARC9
0670                         
0671 07ec b6 7f 1c                  LDA    NBRLO    ;GET (LOW ORDER) BYTE
0672 07ef be 7f c7                  LDX    BYTPTR   ;GET BYTE POINTER
0673 07f2 a7 84                     STA    ,X       ;SAVE BYTE
0674 07f4 30 01                     LEAX   1,X      ;MOVE BYTE POINTER TO NEXT LOCATION IN STRING
0675 07f6 bf 7f c7                  STX    BYTPTR   ;SAVE IT
0676 07f9 20 e0                     BRA    SEARC1
0677                         
0678                         ;BEGIN SEARCH FOR BYTE STRING
0679                         ;IS # OF BYTES TO LOOK FOR >0
0680 07fb 7d 7f c9           SEARC2 TST    NBYTES
0681 07fe 27 56                     BEQ    SEARC9   ;IF NOT, BAD SYNTAX
0682                         
0683                         ;MAKE USE OF INPUT LINE CHARACTER FETCH & COMMAND LIST CHAR FETCH ROUTINES
0684                         
0685                         ;INITIALIZE MEMORY POINTER TO START OF SEARCH RANGE
0686 0800 be 7f 1d                  LDX    RANGLO
0687 0803 30 1f                     LEAX   -1,X
0688 0805 bf 7f 14                  STX    LINPTR
0689                         
0690                         ;INITIALIZE BYTE POINTER TO START OF BYTE STRING
0691 0808 8e 7f ca           SEARC3 LDX    #BYTSTR-1
0692 080b bf 7f e4                  STX    LISPTR
0693                         
0694 080e 7f 7f ca                  CLR    NBRMAT   ;SET "NUMBER OF BYTES THAT MATCHED" TO ZERO
0695                         ;GET BYTE FROM BYTE STRING & RETURN IT IN ACCA
0696 0811 bd 0d b2                  JSR    GETLST
0697                         ;GET BYTE FROM MEMORY RANGE & RETURN IT IN ACCB
0698 0814 bd 0d a4           SEARC4 JSR    GETCHR
0699                         
0700 0817 34 04                     PSHS   B        ;CBA
0701 0819 a1 e0                     CMPA   ,S+      ;COMPARE MEMORY & BYTE STRING CHARACTERS
0702 081b 27 07                     BEQ    SEARC5   ;IF NO MATCH, TEST FOR RANGE END
0703 081d bc 7f 1f                  CPX    RANGHI   ;HAVE WE REACHED THE RANGE SEARCH UPPER LIMIT?
0704 0820 27 37                     BEQ    SEAR10   ;YES, GO PROMPT FOR NEXT COMMAND
0705 0822 20 f0                     BRA    SEARC4
0706                         
0707                         ;MATCH ACHIEVED - SAVE ADDRESS OF MATCH
0708 0824 bf 7f c5           SEARC5 STX    MEMADR
0709 0827 7c 7f ca           SEARC6 INC    NBRMAT   ;BUMP NUMBER MATCHED
0710 082a b6 7f ca                  LDA    NBRMAT
0711 082d b1 7f c9                  CMPA   NBYTES   ;HAVE ALL CHARACTERS MATCHED?
0712 0830 27 19                     BEQ    SEARC8   ;IF SO, MATCH ACHIEVED
0713                         ;HAVEN'T MATCHED ALL YET, GO GET NEXT PAIR EVEN IF PAST "SEARCH TO" ADDRESS
0714 0832 bd 0d b2                  JSR    GETLST
0715 0835 bd 0d a4                  JSR    GETCHR
0716 0838 34 04                     PSHS   B        ;CBA
0717 083a a1 e0                     CMPA   ,S+
0718 083c 27 e9                     BEQ    SEARC6
0719                         ;MISMATCH ON SOME BYTE PAST THE FIRST ONE
0720                         ;RESET THE MEMORY POINTER TO GET NEXT UNTESTED MEMORY LOCATION
0721 083e be 7f c5           SEARC7 LDX    MEMADR
0722                         ;THIS TEST HANDLES SPECIAL CASE OF A MATCH ON RANGE END
0723 0841 bc 7f 1f                  CPX    RANGHI
0724 0844 27 13                     BEQ    SEAR10
0725 0846 bf 7f 14                  STX    LINPTR
0726                         ;GO RESET THE BYTE STRING POINTER
0727 0849 20 bd                     BRA    SEARC3
0728                         
0729                         ;MATCH ON BYTE STRING ACHIEVED, TYPE OUT MEMORY ADDRESS
0730 084b 8e 7f c5           SEARC8 LDX    #MEMADR
0731 084e bd 0c e2                  JSR    OUT2BY
0732 0851 bd 0c cd                  JSR    OUTSP    ;AND A SPACE
0733                         ;ASSUME A MISMATCH (I.E., RESET MEMORY & BYTE STRING POINTERS & CONTINUE
0734 0854 20 e8                     BRA    SEARC7
0735                         
0736 0856 7e 04 59           SEARC9 JMP    BADSYN
0737 0859 7e 04 72           SEAR10 JMP    NOMORE
0738                         
0739                         ;*****
0740                         ;TEST - TEST RAM FOR BAD BYTES
0741                         ;GET AN ADDRESS RANGE
0742 085c bd 0b d8           TEST   JSR    GTRANG
0743 085f 2f f5                     BLE    SEARC9   ;ABORT IF NO PAIR
0744                         ;RANGLO HOLS STARTING ADDRESS OF RANGE
0745                         ;RANGHI HOLDS ENDING ADDRESS OF RANGE
0746 0861 be 7f 1d                  LDX    RANGLO
0747 0864 bf 7f c5                  STX    MEMADR
0748                         ;GET BYTE STORED AT TEST LOCATION & SAVE IT
0749 0867 a6 84              TEST1  LDA    ,X
0750 0869 34 02                     PSHS   A
0751                         
0752 086b 6f 84                     CLR    ,X       ;ZERO THE LOCATION
0753 086d 6d 84                     TST    ,X       ;TEST IT
0754 086f 27 05                     BEQ    TEST2    ;OK IF = ZERO
0755                         
0756                         ;CAN'T CLEAR LOCATION
0757 0871 8e 10 4d                  LDX    #MSGCCL
0758 0874 20 20                     BRA    TEST4
0759                         
0760 0876 6a 84              TEST2  DEC    ,X       ;SET LOCATION TO FF
0761 0878 86 ff                     LDA    #$FF
0762 087a a1 84                     CMPA   ,X       ;DID IT GET SET TO FF?
0763 087c 27 05                     BEQ    TEST3
0764                         
0765                         ;CAN'T SET LOCATION TO ONE'S
0766 087e 8e 10 59                  LDX    #MSGCSO
0767 0881 20 13                     BRA    TEST4
0768                         
0769 0883 be 7f c5           TEST3  LDX    MEMADR   ;GET LOCATION BEING TESTED
0770 0886 35 02                     PULS   A
0771 0888 a7 84                     STA    ,X       ;RESTORE PREVIOUS CONTENT
0772                         
0773                         ;HIT END OF TEST RANGE?
0774 088a bc 7f 1f                  CPX    RANGHI
0775 088d 27 ca                     BEQ    SEAR10   ;YES, ALL DONE
0776                         
0777                         ;NO, MOVE TO TEST NEXT LOCATION
0778 088f 30 01                     LEAX   1,X
0779 0891 bf 7f c5                  STX    MEMADR
0780 0894 20 d1                     BRA    TEST1
0781                         
0782                         ;*LOCATION IS BAD
0783 0896 bf 7f c9           TEST4  STX    TEMP3    ;SAVE ERROR MESSAGE TEMPORARILY
0784                         
0785 0899 8e 7f c5                  LDX    #MEMADR
0786 089c bd 0c e2                  JSR    OUT2BY   ;TYPE OUT BAD ADDRESS.
0787 089f bd 0c d3                  JSR    OUTEQ    ;AN EQUAL SIGN
0788                         
0789 08a2 be 7f c5                  LDX    MEMADR
0790 08a5 bd 0c d9                  JSR    OUT1BY   ;ITS CONTENT.
0791 08a8 bd 0c cd                  JSR    OUTSP    ;A SPACE.
0792 08ab be 7f c9                  LDX    TEMP3
0793 08ae bd 0f 5e                  JSR    OUTSTR   ;AND THE TYPE OF ERROR
0794                         
0795 08b1 bd 0f e5                  JSR    DOCRLF   ;SEND CR-LF
0796 08b4 20 cd                     BRA    TEST3
0797                         ;*****
0798                         ;INT - SET UP INTERRUPT POINTER
0799 08b6 bd 0c 18           INT    JSR    NUMINX   ;GET POINTER IN IX
0800 08b9 bf 7f 00                  STX    INTVEC   ;SAVE IT
0801 08bc 20 4c                     BRA    COMPA1
0802                         
0803                         ;*****
0804                         ;NMI - SET UP NON-MASKABLE INTERRUPT POINTER
0805 08be bd 0c 18           NMI    JSR    NUMINX   ;GET POINTER IN IX
0806 08c1 bf 7f 04                  STX    NMIVEC   ;SAVE IT
0807 08c4 20 44                     BRA    COMPA1
0808                         
0809                         ;*****
0810                         ;SWI - SET UP SWI POINTER
0811 08c6 bd 0c 18           LSWI   JSR    NUMINX   ;GET POINTER TO IX
0812 08c9 bf 7f 08                  STX    SWIVEC   ;SAVE IT
0813 08cc 20 3c                     BRA    COMPA1
0814                         
0815                         ;*****
0816                         ;SWI2 - SET UP SWI2 POINTER
0817 08ce bd 0c 18           LSWI2  JSR    NUMINX   ;GET POINTER TO IX
0818 08d1 bf 7f 0a                  STX    SWI2VC   ;SAVE IT
0819 08d4 20 34                     BRA    COMPA1
0820                         
0821                         ;*****
0822                         ;SWI3 - SET UP SW3 POINTER
0823 08d6 bd 0c 18           LSWI3  JSR    NUMINX   ;GET POINTER TO IX
0824 08d9 bf 7f 0c                  STX    SWI3VC   ;SAVE IT
0825 08dc 20 2c                     BRA    COMPA1
0826                         
0827                         ;*****
0828                         ;FIRQ - SET UP FAST INTERRUPT POINTER
0829 08de bd 0c 18           FIRQ   JSR    NUMINX   ;GET POINTER IN IX
0830 08e1 bf 7f 02                  STX    FIRQVC   ;SAVE IT
0831 08e4 20 24                     BRA    COMPA1
0832                         
0833                         ;*****
0834                         ;RSRVD - SET UP RESERVED INTERRUPT POINTER
0835 08e6 bd 0c 18           RSRVD  JSR    NUMINX   ;GET POINTER IN IX
0836 08e9 bf 7f 06                  STX    RSRVDVC  ;SAVE IT
0837 08ec 20 1c                     BRA    COMPA1
0838                         
0839                         ;*****
0840                         ;COMPARE - OUTPUT SUM & DIFFERENCE OF TWO INPUT NUMBERS
0841 08ee bd 0c 18           COMPAR JSR    NUMINX   ;GET FIRST NUMBER
0842 08f1 bf 7f 1d                  STX    RANGLO   ;PUT IT IN RANGLO
0843                         
0844 08f4 bd 0c 18                  JSR    NUMINX   ;GET SECOND NUMBER
0845 08f7 bf 7f 1b                  STX    NBRHI    ;SAVE IT IN NBRHI
0846                         
0847                         ;COMPUTE AND OUTPUT THE SUM
0848 08fa bd 0b b2                  JSR    SUMNUM   ;COMPUTE SUM
0849 08fd 8e 10 6b                  LDX    #MSGSIS  ;GETS ITS TITLE
0850 0900 8d 0b                     BSR    OUTSD    ;OUTPUT TITLE & SUM
0851                         
0852 0902 bd 0b c5                  JSR    DIFNUM   ;COMPUTE DIFFERENCE
0853 0905 8e 10 73                  LDX    #MSGDIS  ;GET ITS TITLE
0854 0908 8d 03                     BSR    OUTSD    ;OUTPUT TITLE & DIFFERENCE
0855                         
0856 090a 7e 04 72           COMPA1 JMP    NOMORE
0857                         
0858                         ;COMPUTE AND OUTPUT THE RESULT
0859 090d bd 0f 5e           OUTSD  JSR    OUTSTR   ;OUTPUT IT
0860 0910 8e 7f 1f                  LDX    #RANGHI  ;GET RESULT
0861 0913 bd 0c e2                  JSR    OUT2BY   ;DISPLAY RESULT
0862 0916 39                        RTS
0863                         ;*****
0864                         ;DUMP - DUMP A PORTION OF MEMORY, IN MIKBUG FORMAT, TO A SPECIFIED ACIA ADDRESS
0865                         
0866                         ;GET ADDRESS RANGE: START IN RANGLO (2 BYTES), END IN RANGHI (2 BYTES)
0867                         ;IF NO ADDRESS RANGE IS GIVEN, USE WHATEVER IS IN RANGLO & RANGHI
0868 0917 bd 0b d8           DUMP   JSR    GTRANG
0869                         
0870 091a 7f 7f cd                  CLR    TEMP5    ;INITIALIZE TO DUMP TO TERMINAL
0871                         
0872                         ;LOOK FOR A "TO" MODIFIER
0873 091d 86 02              DUMP1  LDA    #2
0874 091f bd 0a 97                  JSR    COMAND
0875 0922 27 15                     BEQ    DUMP4
0876 0924 10 2f 00 80        DUMP2  LBLE   DUMP10   ;ERROR IF BAD SYNTAX
0877 0928 81 01                     CMPA   #1       ;TO?
0878 092a 27 02                     BEQ    DUMP3
0879 092c 20 ef                     BRA    DUMP1    ;GO LOOK FOR ANOTHER MODIFIER
0880                         
0881 092e bd 0c 18           DUMP3  JSR    NUMINX   ;GET "TO" ADDRESS
0882 0931 bf 7f 2f                  STX    OUTADR   ;SAVE IT
0883 0934 7c 7f cd                  INC    TEMP5    ;REMEMBER THIS
0884 0937 20 e4                     BRA    DUMP1    ;GO LOOK FOR ANOTHER MODIFIER
0885                         
0886 0939 7d 7f cd           DUMP4  TST    TEMP5
0887 093c 27 03                     BEQ    DUMP5
0888 093e 7c 7f 2e                  INC    OUTFLG   ;SET FLAG FOR PROPER OUTPUT DEVICE
0889 0941 8d 68              DUMP5  BSR    NULLS    ;SEND SOME NULLS
0890                         
0891                         ;MIKBUG MODE
0892                         ;OUTPUT AN "S0" TYPE RECORD
0893 0943 8e 10 7e                  LDX    #MSGS0
0894 0946 bd 0f 5e                  JSR    OUTSTR
0895                         
0896                         ;COMPUTER # OF BYTES TO OUTPUT (RANGE END - RANGE START + 1)
0897                         ;SUBTRACT LO BYTES
0898 0949 b6 7f 20           DUMP6  LDA    RANGHI+1
0899 094c b0 7f 1e                  SUBA   RANGLO+1
0900                         ;SUBTRACT HI BYTES
0901 094f f6 7f 1f                  LDB    RANGHI
0902 0952 f2 7f 1d                  SBCB   RANGLO
0903                         ;NON-ZERO HI BYTE IMPLIES LOTS TO OUTPUT
0904 0955 26 04                     BNE    DUMP7
0905                         ;HI BYTE DIFF IS ZERO
0906 0957 81 10                     CMPA   #16      ;LO BYTE OF DIFF 0 TO 15
0907 0959 25 02                     BCS    DUMP8    ;IF YES, TO DUMP8
0908 095b 86 0f              DUMP7  LDA    #15      ;NO, LO BYTE IS 16-255; SET BYTES TO 15
0909                         ;TO GET FRAME COUNT, ADD 1 (DIFF OF 0 IMPLIES 1 OUTPUT) + # OF DATA BYTES,
0910                         ; + 2 ADDR BYTES + 1 CHECKSUM BYTE
0911 095d 8b 04              DUMP8  ADDA   #4
0912 095f b7 7f c9                  STA    TEMP3    ;TEMP3 IS THE FRAME COUNT
0913 0962 80 03                     SUBA   #3
0914 0964 b7 7f cb                  STA    TEMP4    ;TEMP4 IS THE RECORD BYTE COUNT
0915                         ;OUTPUT A MIKBUG "S1" HEADER DATA RECORD
0916 0967 8e 10 91                  LDX    #MSGS1
0917 096a bd 0f 5e                  JSR    OUTSTR
0918 096d 5f                        CLRB            ;ZERO CHECKSUM
0919                         ;PUNCH FRAME COUNT
0920 096e 8e 7f c9                  LDX    #TEMP3
0921 0971 8d 39                     BSR    OUTP2
0922                         
0923                         ;PUNCH ADDRESS
0924 0973 8e 7f 1d                  LDX    #RANGLO
0925 0976 8d 34                     BSR    OUTP2
0926 0978 8d 32                     BSR    OUTP2
0927                         
0928                         ;OUTPUT DATA
0929 097a be 7f 1d                  LDX    RANGLO
0930 097d 8d 2d              DUMP9  BSR    OUTP2    ;OUTPUT DATA BYTE
0931 097f 7a 7f cb                  DEC    TEMP4    ;DEC BYTE COUNT
0932 0982 26 f9                     BNE    DUMP9
0933                         
0934                         ;COMPLEMENT AND PUNCH THE CHECKSUM
0935 0984 bf 7f 1d                  STX    RANGLO   ;SAVE MEMORY POINTER
0936 0987 53                        COMB            ;COMPLEMENT CHECKSUM
0937 0988 34 04                     PSHS   B        ;PUT IT ON STACK
0938 098a 1f 41                     TFR    S,X      ;LET IX POINT TO IT
0939 098c 8d 1e                     BSR    OUTP2    ;OUTPUT CHECKSUM
0940 098e 35 04                     PULS   B        ;PULL IT OFF STACK
0941 0990 be 7f 1d                  LDX    RANGLO   ;RESTORE MEMORY POINTER
0942 0993 30 1f                     LEAX   -1,X
0943 0995 bc 7f 1f                  CPX    RANGHI   ;HIT END OF RANGE?
0944 0998 26 af                     BNE    DUMP6
0945                         
0946                         ;YES, OUTPUT AN "S9" RECORD
0947 099a 8e 10 96                  LDX    #MSGS9
0948 099d bd 0f 5e                  JSR    OUTSTR
0949 09a0 8d 09                     BSR    NULLS    ;GENERATE BLANK TAPE
0950 09a2 7f 7f 2e                  CLR    OUTFLG   ;SET TO TERMINAL OUTPUT
0951 09a5 7e 04 72                  JMP    NOMORE   ;ALL DONE
0952 09a8 7e 04 59           DUMP10 JMP    BADSYN   ;BAD SYNTAX
0953                         
0954                         ;SEND A STRING OF NULLS
0955 09ab 39                 NULLS  RTS
0956                         
0957                         ;OUTPUT A BYTE POINTED TO BY IX AS 2 HEX CHARACTERS
0958 09ac eb 84              OUTP2  ADDB   ,X       ;UPDATE CHECKSUM
0959 09ae bd 0c d9                  JSR    OUT1BY
0960 09b1 30 01                     LEAX   1,X
0961 09b3 39                        RTS
0962                         ;*****
0963                         ;LOAD - LOAD A MIKBUG TAPE
0964                         ;LOOK FOR A "FROM" MODIFIER
0965 09b4 86 07              LOAD   LDA    #7       ;IN LIST 7
0966 09b6 bd 0a 97                  JSR    COMAND
0967 09b9 2b ed                     BMI    DUMP10   ;ERROR, UNRECOGNIZABLE MODIFIER
0968 09bb 27 09                     BEQ    LOAD1
0969                         
0970 09bd bd 0c 18                  JSR    NUMINX   ;GET "FROM" ADDRESS
0971 09c0 bf 7f 2c                  STX    INPADR   ;SAVE IT
0972 09c3 7c 7f 2b                  INC    INPFLG   ;SET FLAG FOR NON-TERMINAL ACIA
0973                         
0974                         ;KEEP READING CHARACTERS UNTIL AN "S" IS READ
0975 09c6 bd 0f 6f           LOAD1  JSR    INPCHR   ;GET A CHAR
0976 09c9 81 53                     CMPA   #'S'     ;IS IT AN S?
0977 09cb 26 f9                     BNE    LOAD1
0978                         
0979                         ;GOT AN "S", EXAMINE NEXT CHARACTER
0980 09cd bd 0f 6f                  JSR   INPCHR
0981 09d0 81 39                     CMPA   #'9'     ;DONE IF ITS A "9"
0982 09d2 27 2f                     BEQ    LOAD4
0983                         
0984 09d4 81 31                     CMPA   #'1'     ;IS IT A "1"?
0985 09d6 26 ee                     BNE    LOAD1    ;IF NOT, LOOK FOR NEXT "S"
0986                         ;VALID S1 RECORD
0987 09d8 7f 7f ee                  CLR    CKSM     ;CLEAR CHECKSUM
0988                         ;READ RECORD BYTE COUNT
0989 09db bd 0a 17                  JSR    RDBYTE
0990 09de 80 02                     SUBA   #2
0991 09e0 b7 7f ed                  STA    BYTECT   ;SAVE COUNT MINUS 2 ADDRESS BYTES
0992                         
0993 09e3 8d 24                     BSR    BLDADR   ;BUILD ADDRESS
0994                         
0995 09e5 8d 30              LOAD2  BSR    RDBYTE   ;READ A DATA BYTE INTO ACCA
0996 09e7 7a 7f ed                  DEC    BYTECT   ;COUNT IT
0997 09ea 27 06                     BEQ    LOAD3    ;IF DONE WITH RECORD, CHECK CHECKSUM
0998 09ec a7 84                     STA    ,X       ;NOT DONE, STORE BYTE IN MEMORY
0999 09ee 30 01                     LEAX   1,X      ;ON TO NEXT MEMORY ADDRESS
1000 09f0 20 f3                     BRA    LOAD2
1001                         
1002                         ;RECORD READ IN COMPLETE
1003 09f2 7c 7f ee           LOAD3  INC    CKSM     ;TEST CHECKSUM BY ADDING 1
1004 09f5 27 cf                     BEQ    LOAD1    ;IF OK, RESULT SHOULD BE ZERO
1005                         
1006                         ;RECORD CHECKSUM ERROR
1007 09f7 8e 10 3d                  LDX    #MSGNVE  ;SAY SO
1008 09fa bd 0f 5e                  JSR    OUTSTR
1009 09fd 8e 7f c5                  LDX    #TEMP1   ;GET RECORD ADDRESS OF IT
1010 0a00 bd 0c e2                  JSR    OUT2BY   ;TYPE IT TOO
1011 0a03 7f 7f 2b           LOAD4  CLR    INPFLG   ;RESET FLAG TO NORMAL TERMINAL INPUT
1012 0a06 7e 04 72                  JMP    NOMORE
1013                         
1014                         ;BUILD ADDRESS
1015 0a09 8d 0c              BLDADR BSR    RDBYTE
1016 0a0b b7 7f c5                  STA    TEMP1
1017 0a0e 8d 07                     BSR    RDBYTE
1018 0a10 b7 7f c6                  STA    TEMP1+1
1019 0a13 be 7f c5                  LDX    TEMP1
1020 0a16 39                        RTS
1021 0a17 8d 15              RDBYTE BSR    INHEX    ;GET LEFT HEX DIGIT
1022                         ;MOVE TO HI 4 BITS
1023 0a19 48                        ASLA
1024 0a1a 48                        ASLA
1025 0a1b 48                        ASLA
1026 0a1c 48                        ASLA
1027 0a1d 1f 89                     TFR    A,B      ;SAVE IT IN ACCA
1028 0a1f 8d 0d                     BSR    INHEX    ;GET RIGHT HEX DIGIT
1029 0a21 34 04                     PSHS   B
1030 0a23 ab e0                     ADDA   ,S+      ;COMBINE THEM IN ACCA
1031                         ;UPDATE THE CHECKSUM
1032 0a25 1f 89                     TFR    A,B
1033 0a27 fb 7f ee                  ADDB   CKSM
1034 0a2a f7 7f ee                  STB    CKSM
1035 0a2d 39                        RTS
1036                         
1037                         ;INPUT A HEX CHAR & CONVERT TO INTERNAL FORM
1038 0a2e bd 0f 6f           INHEX  JSR    INPCHR   ;INPUT A CHAR
1039 0a31 80 30                     SUBA   #$30
1040 0a33 2b 0f                     BMI    INHEX2   ;NOT HEX IF BELOW ASCII "1"
1041 0a35 81 09                     CMPA   #$09
1042 0a37 2f 0a                     BLE    INHEX1   ;OK IF ASCII "9" OR LESS
1043 0a39 81 11                     CMPA   #$11     ;BELOW ASCII "A"?
1044 0a3b 2b 07                     BMI    INHEX2   ;ERROR IF IT IS
1045 0a3d 81 16                     CMPA   #$16     ;OVER ASCII "F"?
1046 0a3f 2e 03                     BGT    INHEX2   ;ERROR IF IT IS
1047 0a41 80 07                     SUBA   #7       ;CONVERT ASCII A-F TO HEX A-F
1048 0a43 39                 INHEX1 RTS
1049                         ;ERROR - CHAR NOT HEX, SAY SO
1050 0a44 8e 10 a5           INHEX2 LDX    #MSGCNH
1051 0a47 bd 0f 5e                  JSR    OUTSTR
1052 0a4a 39                        RTS
1053                         
1054                         ;*****
1055                         ;DELAY - DELAY SPECIFIED # OF MILLISECONDS
1056 0a4b bd 0c 18           DELAY  JSR    NUMINX   ;GET DELAY TIME
1057 0a4e 8d 03                     BSR    TIMDEL
1058 0a50 7e 04 72                  JMP    NOMORE
1059                         
1060                         ;**
1061                         ;TIME DELAY SUBROUTINE
1062                         ;IX IS INPUT AS THE # OF MILLISECONDS TO DELAY
1063                         ;ACCA IS ALTERED
1064                         ;ACCB IS PRESERVED
1065                         ;ADJ TIMCON SO (6*TIMCON*CYCLE TIME=1 MS)
1066 0a53 b6 7f eb           TIMDEL LDA    TIMCON
1067                         ;ENTER A 6 CYCLE LOOP
1068 0a56 4a                 TIMDE1 DECA
1069 0a57 26 fd                     BNE    TIMDE1
1070 0a59 30 1f                     LEAX   -1,X     ;DECREMENT MILLISECOND COUNTER
1071 0a5b 26 f6                     BNE    TIMDEL
1072 0a5d 39                        RTS
1073                         
1074                         ;HELP COMMAND
1075 0a5e bd 0f e5           HELP   JSR    DOCRLF   ;NEXT LINE
1076 0a61 8e 0d bd                  LDX    #COMLST  ;COMMAND LIST
1077                         
1078 0a64 c6 04              HEL1   LDB    #4       ;COMMANDS PER LINE
1079 0a66 f7 7f c5                  STB    TEMP1
1080                         
1081 0a69 c6 0c              HEL2   LDB    #12      ;POSITIONS PER COMMAND
1082                                                ;MUST BE LARGER THAN LONGEST COMMAND
1083 0a6b a6 80              HEL3   LDA    ,X+      ;GET CHARACTER
1084 0a6d 81 0d                     CMPA   #CR      ;<CR> IS END OF COMMAND
1085 0a6f 27 06                     BEQ    HEL4
1086 0a71 bd 0f 8d                  JSR    OUTCHR   ;PRINT COMMAND CHARACTER
1087 0a74 5a                        DECB
1088 0a75 26 f4                     BNE    HEL3
1089                         
1090 0a77 a6 84              HEL4   LDA    ,X       ;GET CHARACTER
1091 0a79 81 0a                     CMPA   #LF      ;<LF> IS END OF LIST
1092 0a7b 27 14                     BEQ    HEL6     ;FINISHED
1093 0a7d 7a 7f c5                  DEC    TEMP1    ;PER LINE DONE ?
1094 0a80 26 05                     BNE    HEL5     ;NO - SKIP
1095                         
1096 0a82 bd 0f e5                  JSR    DOCRLF   ;NEXT LINE
1097 0a85 20 dd                     BRA    HEL1
1098                         
1099 0a87 86 20              HEL5   LDA    #' '     ;SPACE
1100 0a89 bd 0f 8d                  JSR    OUTCHR
1101 0a8c 5a                        DECB
1102 0a8d 26 f8                     BNE    HEL5
1103 0a8f 20 d8                     BRA    HEL2
1104                         
1105 0a91 bd 0f e5           HEL6   JSR    DOCRLF   ;NEXT LINE
1106 0a94 7e 04 72                  JMP    NOMORE
1107                         
1108                         ;====================================================
1109                         
1110                         ;  C O M M A N D     L I S T     S C A N N I N G    R O U T I N E
1111                         
1112                         ;THIS ROUTINE SEEKS A MATCH OF THE CHARACTERS POINTED AT
1113                         ;BY THE INPUT LINE SCANNING POINTER TO ONE OF THE COMMANDS
1114                         ;IN A LIST SPECIFIED BY ACCA.
1115                         ;
1116                         ; AS FOLLOWS:
1117                         ;
1118                         ;      ACCA=-1: THE MATCH WAS UNSUCCESSFUL.  THE SYNTAX
1119                         ;               POINTER (SYNPTR) WAS NOT UPDATED (ADVANCED).
1120                         ;
1121                         ;      ACCA= 0: THE MATCH WAS UNSUCCESSFUL SINCE THERE WERE
1122                         ;               NO MORE CHARACTERS, I.E., THE END OF THE
1123                         ;               LINE WAS REACHED.
1124                         ;
1125                         ;      ACCA=+N: SUCCESSFUL MATCH.  THE SYNTAX POINTER WAS UPDATED
1126                         ;               TO THE FIRST CHARACTER FOLLOWING THE COMMAND
1127                         ;               DELIMITER.  ACCA HOLDS THE NUMBER OF THE
1128                         ;               COMMAND MATCHED.
1129                         ;GLOBAL VARIABLES FOR EXTERNAL COMMUNICATION
1130                         ;SYNPTR - GOOD SYNTAX INPUT CHAR LINE POINTER
1131                         ;LINPTR - INPUT LINE CHARACTER POINTER
1132                         ;DELIM - CLASS OF PERMISSIBLE COMMAND DELIMITERS
1133                         
1134                         ;TEMPORARY 2 BYTE INTERNAL VARIABLES
1135                         ;LISPTR - COMMAND LIST CHARACTER POINTER
1136                         
1137                         ;TEMPORARY 1 BYTE INTERNAL VARIABLES
1138                         ;NUMMAT - NUMBER OF CHARACTERS THAT SUCCESSFULLY MATCH
1139                         ;LISNUM - # OF LIST WITHIN WHICH A MATCH WILL BE SOUGHT
1140                         ;COMNUM - COMMAND NUMBER MATCHED
1141                         
1142                         ;CONSTANTS USED
1143                         ;CR - CARRIAGE RETURN
1144                         ;LF - LINE FEED
1145                         
1146                         ;ACCB & IX ARE NOT PRESERVED.
1147                         
1148 0a97 b7 7f e2           COMAND STA    LISNUM   ;SAVE LIST # TO MATCH WITHIN
1149                         ;TEST IF WE ARE AT THE END OF THE LINE
1150 0a9a bd 0b 40                  JSR    SKPDLM
1151 0a9d 24 02                     BCC    INILST
1152 0a9f 4f                        CLRA
1153 0aa0 39                        RTS
1154                         
1155                         ;INITIALIZE THE COMMAND LIST POINTER TO ONE LESS THAN
1156                         ;                       THE BEGINNING OF THE COMMAND LISTS
1157 0aa1 be 7f 10           INILST LDX    COMADR   ;ENTRY POINT
1158                         
1159                         ;MOVE TO THE BEGINNING OF THE DESIRED COMMAND LIST
1160 0aa4 b6 7f e2                  LDA    LISNUM   ;SEARCH FOR "STRING" # LISNUM
1161 0aa7 c6 0a                     LDB    #LF      ;USE LF AS A "STRING" TERMINATOR
1162 0aa9 8d 7c                     BSR    FNDSTR
1163 0aab bf 7f e4                  STX    LISPTR
1164                         
1165                         ;THE LIST POINTER, LISPTR, NOW POINTS TO ONE LESS THAN THE FIRST CHARACTER
1166                         ;OF THE FIRST COMMAND IN THE DESIRED LIST.
1167 0aae 7f 7f e3                  CLR    COMNUM
1168                         
1169                         ;RESET INPUT LINE POINTER TO: 1) BEGINNING OF LINE, OR TO
1170                         ;  2) POINT WHERE LAST SUCCESSFUL SCAN TERMINATED
1171 0ab1 7c 7f e3           CMD3   INC    COMNUM
1172 0ab4 be 7f 12                  LDX    SYNPTR
1173 0ab7 bf 7f 14                  STX    LINPTR
1174 0aba 7f 7f e1                  CLR    NUMMAT   ;CLEAR NUMBER OF CHARACTERS MATCHED
1175                         
1176 0abd bd 0d a4           CMD4   JSR    GETCHR   ;GET INPUT LINE CHAR IN ACCB
1177 0ac0 bd 0b 6d                  JSR    TSTDLM   ;TEST FOR A DELIMITER
1178 0ac3 26 16                     BNE    MATCH    ;SUCCESS (FOUND DELIMITER) IF NOT = ZERO
1179 0ac5 bd 0d b2                  JSR    GETLST   ;GET COMMAND LIST CHAR IN ACCA
1180 0ac8 81 0a                     CMPA   #LF      ;HAS END OF COMMAND LIST BEEN REACHED?
1181 0aca 27 19                     BEQ    NMATCH   ;IF SO, POTENTIAL MATCH FAILURE
1182 0acc 81 0d                     CMPA   #CR      ;HAS END OF COMMAND BEEN REACHED?
1183 0ace 27 15                     BEQ    NMATCH   ;IF SO, POTENTIAL MATCH FAILURE
1184                         
1185 0ad0 34 04                     PSHS   B        ;CBA
1186 0ad2 a1 e0                     CMPA   ,S+      ;COMPARE THE TWO CHARACTERS
1187 0ad4 26 1b                     BNE    NEXCOM   ;MATCH NOT POSSIBLE ON THIS COMMAND
1188                         
1189                         ;THEY MATCH, COMPARE THE SUCCEEDING CHARACTERS
1190 0ad6 7c 7f e1                  INC    NUMMAT   ;INC NUMBER OF CHARACTERS MATCHED
1191 0ad9 20 e2                     BRA    CMD4
1192                         
1193                         ;***
1194                         ;SUCCESSFUL MATCH - RETURN COMMAND NUMBER MATCHED IN ACCA
1195 0adb b6 7f e3           MATCH  LDA    COMNUM
1196 0ade be 7f 14                  LDX    LINPTR
1197 0ae1 bf 7f 12                  STX    SYNPTR   ;UPDATE GOOD SYNTAX POINTER
1198 0ae4 39                        RTS
1199                         
1200                         ;***
1201                         ;NO MATCH
1202                         ;DID AT LEAST ONE MATCH?
1203 0ae5 7d 7f e1           NMATCH TST    NUMMAT
1204 0ae8 27 07                     BEQ    NEXCOM   ;TO NEXT COMMAND IF NONE MATCHED
1205                         
1206                         ;AT LEAST ONE MATCHED - TEST FOR DELIMITER (NON-MATCHING CHAR)
1207 0aea bd 0b 6d                  JSR    TSTDLM
1208 0aed 26 ec                     BNE    MATCH    ;IF A DELIMITER, MATCH HAS BEEN ACHIEVED
1209 0aef a6 84                     LDA    ,X       ;RETRIEVE LAST CHARACTER
1210                         ;
1211                         ;ILLEGAL DELIMITER
1212                         
1213                         ;MOVE TO NEXT COMMAND WITHIN LIST
1214 0af1 81 0a              NEXCOM CMPA   #LF      ;END OF THIS LIST?
1215 0af3 27 09                     BEQ    MFAIL    ;IF SO, NOTHING ON LIST MATCHED
1216 0af5 81 0d                     CMPA   #CR      ;IS IT A CR?
1217 0af7 27 b8                     BEQ    CMD3     ;YES, NEXT COMMAND
1218 0af9 bd 0d b2                  JSR    GETLST   ;GET NEXT COMMAND LIST CHARACTER
1219 0afc 20 f3                     BRA    NEXCOM   ;NO, GET TO END OF COMMAND
1220                         
1221                         ;***
1222                         ;MATCH FAILURE - NO MATCH POSSIBLE WITHIN THIS LIST
1223 0afe 4f                 MFAIL  CLRA            ;MATCH FAILURE
1224 0aff 4a                        DECA            ;NO MATCH POSSIBLE WITHIN THIS LIST
1225 0b00 39                        RTS
1226                         
1227                         ;======================================================
1228                         ;THIS ROUTINE TYPES OUT COMMAND NUMBER "COMNUM"
1229                         ;THE LIST IS SPECIFIED IN ACCA
1230                         ;ACCB & IX ARE PRESERVED
1231 0b01 bf 7f db           TYPCMD STX    XTEMP
1232 0b04 34 04                     PSHS   B
1233 0b06 8e 0d bc                  LDX    #COMLST-1 ;MOVE TO HEAD OF COMMAND LISTS
1234 0b09 c6 0a                     LDB    #LF      ;AND LIST TERMINATOR
1235 0b0b 8d 1a                     BSR    FNDSTR   ;GO TO HEAD OF DESIRED LIST
1236 0b0d b6 7f e3                  LDA    COMNUM   ;GET COMMAND NUMBER
1237 0b10 c6 0d                     LDB    #CR      ;GET COMMAND TERMINATOR
1238 0b12 8d 13                     BSR    FNDSTR   ;GO TO HEAD OF DESIRED COMMAND
1239                         
1240 0b14 30 01              TYPCM1 LEAX   1,X      ;MOVE TO NEXT CHARACTER
1241 0b16 a6 84                     LDA    ,X       ;GET A COMMAND CHARACTER
1242 0b18 81 0d                     CMPA   #CR      ;IS IT A COMMAND TERMINATOR?
1243 0b1a 27 05                     BEQ    TYPCM2   ;IF SO, RETURN
1244 0b1c bd 0f 8d                  JSR    OUTCHR   ;NO, TYPE IT
1245 0b1f 20 f3                     BRA    TYPCM1
1246                         
1247 0b21 be 7f db           TYPCM2 LDX    XTEMP
1248 0b24 35 04                     PULS   B
1249 0b26 39                        RTS
1250                         
1251                         ;======================================================
1252                         ;MOVE TO BEGINNING OF DESIRED STRING NUMBER (IN ACCA)
1253                         ;EACH STRING IS TERMINATED BY AN END OF STRING CHARACTER (IN ACCB)
1254                         ;THE INDEX REGISTER IS ASSUMED INITIALIZED POINTING TO
1255                         ;ONE LESS THAT THE FIRST CHARACTER OF THE FIRST STRING
1256                         ;ACCA, ACCB & IX ARE NOT PRESERVED
1257                         ;LOCAL VARIABLES
1258                         ;STRNUM - STRING # TO FIND
1259                         ;EOSCHR - "END OF STRING" CHARACTER
1260                         
1261 0b27 b7 7f c7           FNDSTR STA    STRNUM   ;SAVE STRING NUMBER
1262 0b2a f7 7f c8                  STB    EOSCHR   ;SAVE TERMINATOR
1263 0b2d 5f                        CLRB
1264 0b2e 5c                 FNDST1 INCB            ;STRING 1 IS THE FIRST STRING
1265 0b2f f1 7f c7                  CMPB   STRNUM   ;IS THIS THE RIGHT STRING?
1266 0b32 27 0b                     BEQ    FNDST3   ;IF SO, DONE
1267                         
1268                         ;NO, SWALLOW UP CHARACTERS UNTIL AND END OF STRING CHAR IS HIT
1269 0b34 30 01              FNDST2 LEAX   1,X      ;BUMP POINTER TO NEXT ONE
1270 0b36 a6 84                     LDA    ,X       ;GET CHAR POINTED AT
1271 0b38 b1 7f c8                  CMPA   EOSCHR   ;END OF STRING HIT?
1272 0b3b 27 f1                     BEQ    FNDST1   ;IF IT IS, BUMP THE STRING COUNTER
1273 0b3d 20 f5                     BRA    FNDST2   ;NO, MOVE ON TO NEXT CHAR
1274 0b3f 39                 FNDST3 RTS             ;IX SET PROPERLY, RETURN
1275                         
1276                         ;======================================================
1277                         ;SKIP LEADING DELIMITERS
1278                         ;THIS ROUTINE SHOULD BE CALLED PRIOR TO SCANNING FOR ANY INFORMATION
1279                         ;ON THE INPUT LINE
1280                         ;THE CURRENT CHARACTER IS IGNORED IF THE SCANNING POINTER IS AT THE
1281                         ;BEGINNING OF A LINE.  IF NOT, THE SCANNING POINTER SKIPS OVER SPACES
1282                         ;AND COMMAS UNTIL AN END OF LINE OR NON-DELIMITER IS FOUND.
1283                         ;THE CARRY BIT IS SET IF AN END OF LINE IS ENCOUNTERED.
1284                         
1285                         ;ACCA, ACCB & IX ARE NOT PRESERVED
1286                         
1287 0b40 1c fe              SKPDLM ANDCC  #$FE     ;CLC
1288 0b42 7d 7f 16                  TST    BOLFLG   ;AT BEGINNING OF LINE?
1289 0b45 2e 0c                     BGT    SKPDL2
1290                         
1291                         ;LOOK AT CURRENT INPUT CHARACTER
1292 0b47 be 7f 12           SKPDL1 LDX    SYNPTR   ;GET POINTER TO IT
1293 0b4a a6 84                     LDA    ,X       ;GET CHAR
1294 0b4c 8d 14                     BSR    TSTEOL   ;TEST FOR END OF LINE
1295 0b4e 26 03                     BNE    SKPDL2
1296 0b50 1a 01                     ORCC   #$01     ;SEC YES, END HIT, SET CARRY
1297 0b52 39                        RTS
1298                         ;"PEEK" AT NEXT CHAR IN LINE
1299 0b53 e6 01              SKPDL2 LDB    1,X     ;GET IT
1300 0b55 8d 16                     BSR    TSTDLM  ;SEE IF ITS A DELIMITER
1301 0b57 26 01                     BNE    SKPDL3
1302 0b59 39                        RTS            ;ITS NOT, RETURN
1303                         
1304                         ;NEXT CHAR IS A DELIMITER
1305 0b5a bd 0d a4           SKPDL3 JSR    GETCHR   ;MOVE TO NEXT CHAR IN INPUT LINE
1306 0b5d bf 7f 12                  STX    SYNPTR   ;UPDATE SYNTAX POINTER
1307 0b60 20 e5                     BRA    SKPDL1   ;GO TEST FOR END OF LINE
1308                         
1309                         ;======================================================
1310                         ;TEST FOR END-OF-LINE CHARACTER
1311                         ;Z BIT OF CC REG SET IF CHAR IN ACCA IS A TERMINATOR
1312                         ;ACCA, ACCB, & IX ARE PRESERVED
1313 0b62 81 0d              TSTEOL CMPA   #CR      ;CARRIAGE RETURN?
1314 0b64 27 06                     BEQ    TSTEO1
1315 0b66 81 0a                     CMPA   #LF      ;LINE FEED? (CONTINUED LINES)
1316 0b68 27 02                     BEQ     TSTEO1
1317 0b6a 81 3b                     CMPA    #';'    ;FOR SEVERAL COMMANDS ON ONE LINE
1318 0b6c 39                 TSTEO1 RTS
1319                         
1320                         ;======================================================
1321                         ;CHECK THE CHARACTER IN ACCB
1322                         ;AGAINST THE DELIMITER(S) SPECIFIED BY VARIABLE DELIM
1323                         ;ACCB & IX ARE PRESERVED
1324                         ;ACCA IS SET TO 0 IF ACCB IS NOT A DELIMITER, TO 1 IF IT IS
1325                         ;  IF DELIM=1, SPACE IS DELIMITER
1326                         ;  IF DELIM-2, COMMA IS DELIMITER
1327                         ;  IF DELIM=3, SPACE OR COMMAND IS DELIMITER
1328                         ;  IF DELIM=4, ANY NON-ALPHANUMERIC IS A DELIMITER
1329                         ;TEST FOR END-OF-LINE (LOGICAL OR PHYSICAL)
1330 0b6d 34 04              TSTDLM PSHS   B
1331 0b6f 1f 98                     TFR    B,A
1332 0b71 8d ef                     BSR    TSTEOL
1333 0b73 35 04                     PULS   B
1334 0b75 27 35                     BEQ    DLMYES
1335                         
1336 0b77 b6 7f 17                  LDA    DELIM
1337 0b7a 81 01                     CMPA   #1
1338 0b7c 26 06                     BNE    ISDLM2
1339 0b7e c1 20                     CMPB   #32      ;WANT A SPACE - IS IT?
1340 0b80 26 2d                     BNE    DLMNO
1341 0b82 20 28                     BRA    DLMYES
1342                         
1343 0b84 81 02              ISDLM2 CMPA   #2
1344 0b86 26 06                     BNE    ISDLM3
1345 0b88 c1 2c              TSTCMA CMPB   #','     ;WANT A COMMA - IS IT?
1346 0b8a 26 23                     BNE    DLMNO
1347 0b8c 20 1e                     BRA    DLMYES
1348 0b8e 81 03              ISDLM3 CMPA   #3
1349 0b90 26 06                     BNE    ISDLM4
1350 0b92 c1 20                     CMPB   #32      ;WANT EITHER, IS IT A SPACE?
1351 0b94 27 16                     BEQ    DLMYES
1352 0b96 20 f0                     BRA    TSTCMA   ;OR A COMMA?
1353                         
1354 0b98 81 04              ISDLM4 CMPA   #4
1355 0b9a 26 15                     BNE    ERROR    ;ERROR IF DELIM NOT 1-4
1356                         ;TEST IF CHAR IS 0 TO 9 INCLUSIVE
1357 0b9c c1 30                     CMPB   #'0'
1358 0b9e 2d 0c                     BLT    DLMYES
1359 0ba0 c1 39                     CMPB   #'9'
1360 0ba2 2f 0b                     BLE    DLMNO
1361                         
1362                         ;TEST IF CHAR IS A TO 9 INCLUSIVE
1363 0ba4 c1 41                     CMPB   #'A'
1364 0ba6 2d 04                     BLT    DLMYES
1365 0ba8 c1 5a                     CMPB   #'Z'
1366 0baa 2f 03                     BLE    DLMNO
1367                         ;OVER Z - ITS A DELIMITER
1368                         
1369                         ;CHAR IN ACCB IS A DELIMITER
1370 0bac 86 01              DLMYES LDA    #1
1371 0bae 39                        RTS
1372                         
1373                         ;CHAR IN ACCB IS NOT A DELIMITER
1374 0baf 4f                 DLMNO  CLRA
1375 0bb0 39                        RTS
1376                         
1377                         ;ERROR IN SPECIFYING DELIMITER CLASS
1378 0bb1 3f                 ERROR  SWI             ;HAVE MONITOR TYPE OUT PERTINENT STATISTICS
1379                         
1380                         ;=====================================================
1381                         ;ADD THE 2 BYE NUMBER STORED IN (RANGLO,RANGLO+1) TO THE NUMBER
1382                         ;STORED IN (NBRHI,NBRLO) AND PUT THE RESULT IN (RANGHI,RANGHI+1)
1383                         ;ACCB & IX ARE PRESERVED
1384                         ;ACCA IS ALTERED
1385                         
1386                         ;ADD LO ORDER BYTES
1387 0bb2 b6 7f 1e           SUMNUM LDA    RANGLO+1
1388 0bb5 bb 7f 1c                  ADDA   NBRLO
1389 0bb8 b7 7f 20                  STA    RANGHI+1
1390                         
1391                         ;ADD HI ORDER BYTES
1392 0bbb b6 7f 1d                  LDA    RANGLO
1393 0bbe b9 7f 1b                  ADCA   NBRHI
1394 0bc1 b7 7f 1f                  STA    RANGHI
1395 0bc4 39                        RTS
1396                         
1397                         ;========================================================
1398                         ;SUBTRACT THE TWO BYTE NUMBER STORED IN (NBRHI,NBRLO) FROM THE
1399                         ;TWO BYTE NUMBER STORED IN (RANGLO,RANGLO+1) AND PUT THE
1400                         ;RESULT IN (RANGHI,RANGHI+1)
1401                         ;ACCB & IX ARE PRESERVED
1402                         ;ACCA IS ALTERED
1403                         
1404                         ;SUBTRACT LO ORDER BYTES
1405 0bc5 b6 7f 1e           DIFNUM LDA    RANGLO+1
1406 0bc8 b0 7f 1c                  SUBA   NBRLO
1407 0bcb b7 7f 20                  STA    RANGHI+1
1408                         
1409                         ;SUBTRACT HI ORDER BYES
1410 0bce b6 7f 1d                  LDA    RANGLO
1411 0bd1 b2 7f 1b                  SBCA   NBRHI
1412 0bd4 b7 7f 1f                  STA    RANGHI
1413 0bd7 39                        RTS
1414                         
1415                         ;======================================================
1416                         ;THIS ROUTINE SCANS THE INPUT LINE FOR A PAIR OF NUMBERS
1417                         ;REPRESENTING AN ADDRESS RANGE.  A COLON SEPARATING THE
1418                         ;PAIR IMPLIES "THRU", WHILE AN "!" IMPLIED "THRU THE FOLLOWING"
1419                         ;E.G., 100:105 IS EQUIVALENT TO 100!5
1420                         ;A SINGLE NUMBER IMPLIES A RANGE OF 1
1421                         ;
1422                         ;ON RETURN (RANGLO,RANGLO+1) HOLDS THE RANGE START, AND
1423                         ;          (RANGHI,RANGHI+1) HOLDS THE RANGE END.
1424                         ;ACCA, ACCB, & IX ARE NOT PRESERVED
1425                         
1426 0bd8 8d 49              GTRANG BSR    NUMBER   ;PICK UP FIRST NUMBER
1427 0bda 2e 03                     BGT    GTRAN1
1428 0bdc 2d 09                     BLT    GTRAN2
1429 0bde 39                        RTS             ;NOTHING MORE ON INPUT LINE
1430                         
1431                         ;GOOD SINGLE NUMBER - TRANSFER IT TO RANGLO
1432 0bdf be 7f 1b           GTRAN1 LDX    NBRHI
1433 0be2 bf 7f 1d                  STX    RANGLO
1434 0be5 20 0d                     BRA    GTRAN3   ;AND TO RANGHI
1435                         
1436                         ;BAD NUMBER, BUT IS IT BAD DUE TO A ":" OR "!" DELIMITER?
1437 0be7 be 7f 14           GTRAN2 LDX    LINPTR
1438 0bea a6 84                     LDA    ,X
1439 0bec 81 3a                     CMPA   #':'     ;WAS IT A COLON
1440 0bee 26 0c                     BNE    GTRAN4   ;IF NOT, GO TEST FOR "!"
1441                         
1442 0bf0 8d 1a                     BSR    GTRAN8   ;WAS ":", PROCESS NUMBER & GET NEXT ONE
1443 0bf2 2f 0e                     BLE    GTRAN5   ;ILLEGAL IF END OF LINE OR NON-NUMERIC
1444                         
1445                         ;TRANSFER SECOND NUMBER TO RANGHI
1446 0bf4 be 7f 1b           GTRAN3 LDX    NBRHI
1447 0bf7 bf 7f 1f                  STX    RANGHI
1448 0bfa 20 0d                     BRA    GTRAN7
1449                         
1450 0bfc 81 21              GTRAN4 CMPA   #'!'     ;WAS DELIMITER A "!"?
1451 0bfe 27 03                     BEQ    GTRAN6   ;IF YES, GET 2ND NUMBER
1452                         
1453                         ;ILLEGAL DELIMITER, RETURN
1454 0c00 4f                        CLRA
1455 0c01 4a                        DECA
1456 0c02 39                 GTRAN5 RTS
1457                         
1458 0c03 8d 07              GTRAN6 BSR    GTRAN8   ;WAS "!", PROCESS FIRST NUMBER & GET NEXT ONE
1459 0c05 2f fb                     BLE    GTRAN5
1460 0c07 8d a9                     BSR    SUMNUM   ;COMPUTE RANGE END, PUT INTO RANGHI
1461                         
1462                         ;SUCCESSFUL EXIT
1463 0c09 86 01              GTRAN7 LDA    #1
1464 0c0b 39                        RTS
1465                         
1466                         ;UPDATE SYNTAX POINTER, MOVE FIRST NUMBER TO RANGLO, & GET 2ND NUMBER
1467 0c0c bf 7f 12           GTRAN8 STX    SYNPTR   ;UPDATE SYNTAX POINTER
1468 0c0f be 7f 1b                  LDX    NBRHI    ;GET FIRST NUMBER OF THE PAIR
1469 0c12 bf 7f 1d                  STX    RANGLO   ;SAVE IT IN "LOW RANGE" VALUE
1470 0c15 8d 0c                     BSR    NUMBER   ;PICK UP THE SECOND NUMBER OF THE PAIR
1471 0c17 39                        RTS
1472                         
1473                         ;======================================================
1474                         ;GET A 2 BYTE NUMBER & RETURN IT IN THE INDEX REGISTER
1475 0c18 8d 09              NUMINX BSR    NUMBER
1476 0c1a 2e 03                     BGT    NUMIN1
1477 0c1c 7e 04 59                  JMP    BADSYN
1478 0c1f be 7f 1b           NUMIN1 LDX    NBRHI
1479 0c22 39                        RTS
1480                         
1481                         ;======================================================
1482                         ;SCAN FOR A NUMBER
1483                         ;RETURN THE MOST SIGNIFICANT BYTE IN NBRHI
1484                         ;  AND THE LEAST SIGNIFICANT BYTE IN NBRLO
1485                         ;THE RESULT OF THE SCAN FOR A NUMBER IF RETURNED IN
1486                         ;ACCA AS FOLLOWS:
1487                         ;
1488                         ;      ACCA=-1: THE MATCH WAS UNSUCCESSFUL.  THE SYNTAX
1489                         ;               POINTER (SYNPTR) WAS NOT UPDATED.
1490                         ;
1491                         ;      ACCA= 0: THE MATCH WAS UNSUCCESSFUL SINCE THERE WERE NO
1492                         ;               MORE CHARACTERS. (I.E., THE END OF THE
1493                         ;               LINE WAS ENCOUNTERED.)
1494                         ;
1495                         ;      ACCA=+1: THE SCAN WAS SUCCESSFUL.  THE SYNTAX POINTER
1496                         ;               WAS UPDATED TO THE FIRST CHARACTER FOLLOWING
1497                         ;               THE COMMAND.
1498                         
1499                         ;IX IS PRESERVED
1500                         ;GLOBAL VARIABLES FOR EXTERNAL COMMUNICATION
1501                         ;NBRHI - NUMBER HI BYTE
1502                         ;NBRLO - NUMBER LO BYTE
1503                         ;IBCODE - INPUT BASE CODE
1504                         ;DBCODE - DISPLAY BASE CODE
1505                         
1506                         ;LOCAL VARIABLES
1507                         ;NBR2X - USED IN DECIMAL CONVERSION
1508                         ;XTEMP2 - SAVES IX
1509                         
1510                         ;INITIALIZE BOTH BYTES TO ZERO
1511 0c23 bf 7f df           NUMBER STX    XTEMP2   ;SAVE IX
1512 0c26 7f 7f 1b                  CLR    NBRHI
1513 0c29 7f 7f 1c                  CLR    NBRLO
1514                         
1515                         ;INITIALIZE THE LINE SCANNING POINTER
1516 0c2c be 7f 12                  LDX    SYNPTR
1517 0c2f bf 7f 14                  STX    LINPTR
1518                         
1519                         ;ARE WE AT END OF LINE?
1520 0c32 bd 0b 40                  JSR    SKPDLM
1521 0c35 24 05                     BCC    NUMLUP
1522 0c37 be 7f df                  LDX    XTEMP2
1523 0c3a 4f                        CLRA            ;YES, ZERO ACCA
1524 0c3b 39                        RTS
1525                         
1526 0c3c bd 0d a4           NUMLUP JSR    GETCHR   ;GET A CHARACTER FROM THE INPUT LINE INTO ACCB
1527                         
1528                         ;TEST FOR A DELIMITER
1529 0c3f bd 0b 6d                  JSR    TSTDLM
1530 0c42 26 65                     BNE    GUDNUM   ;GOOD DELIMITER IF ACCA NON-ZERO
1531                         
1532                         ;NOT A DELIMITER, TEST IF CHARACTER IS < ASCII 0
1533 0c44 c0 30                     SUBB   #'0'     ;SUBTRACT ASCII 0
1534 0c46 2b 6d                     BMI    CONERR   ;ERROR IF LESS
1535                         
1536                         ;DETERMINE INPUT BASE & GO TO RIGHT ROUTINE
1537 0c48 b6 7f 18                  LDA    IBCODE
1538 0c4b 81 01                     CMPA   #1
1539 0c4d 27 08                     BEQ    HEXNUM
1540                         
1541 0c4f 81 02                     CMPA   #2
1542 0c51 27 1e                     BEQ    DECNUM
1543                         
1544 0c53 81 03                     CMPA   #3
1545 0c55 27 41                     BEQ    OCTNUM
1546                         
1547                         ;DEFAULT AN ILLEGAL INPUT BASE TO HEX
1548                         ;*****
1549                         ;INPUT A HEX NUMBER
1550                         ;TEST FOR A LEGAL DIGIT
1551 0c57 c1 09              HEXNUM CMPB   #$09
1552 0c59 2f 0a                     BLE    HEXN1    ;OR IF 9 OR LESS
1553 0c5b c1 11                     CMPB   #$11
1554 0c5d 2b 56                     BMI    CONERR    ;NOT HEX IF < A
1555 0c5f c1 16                     CMPB   #$16
1556 0c61 2e 52                     BGT    CONERR    ;NOT HEX IF > F
1557 0c63 c0 07                     SUBB   #7        ;MOVE A-F ABOVE 0-9
1558                         
1559                         ;SHIFT LO & HI BYTES LEFT 4 BITS
1560 0c65 8d 54              HEXN1  BSR    SHIFT2
1561 0c67 8d 52                     BSR    SHIFT2
1562                         
1563 0c69 fa 7f 1c                  ORB    NBRLO
1564 0c6c f7 7f 1c                  STB    NBRLO
1565                         
1566 0c6f 20 cb                     BRA    NUMLUP
1567                         
1568                         ;*****
1569                         ;INPUT A DECIMAL NUMBER
1570                         ;TEST FOR A LEGAL DIGIT
1571 0c71 c1 09              DECNUM CMPB   #$09
1572 0c73 2e 40                     BGT    CONERR   ;NOT DECIMAL IF > 9
1573                         
1574                         ;MULTIPLE SAVED VALUE BY 10 & ADD IN NEW DIGIT
1575                         ;NOTE THAT 10X=2X+8x
1576                         ;MULTIPLY CURRENT NUMBER BY 2 TO GET 2X VALUE
1577 0c75 8d 49                     BSR    SHIFT
1578                         ;SAVE THIS *2 NUMBER TEMPORARILY
1579 0c77 be 7f 1b                  LDX    NBRHI
1580 0c7a bf 7f e9                  STX    NBR2X
1581                         ;MULTIPLY THIS # BY 4 TO GET 8X VALUE
1582 0c7d 8d 3c                     BSR    SHIFT2
1583                         ;(NBRHI,NBRLO) NOW HOLDS *8
1584                         ;GENERATE DIGIT+8x+2x
1585 0c7f 4f                        CLRA            ;ACCA WILL HOLD MS BYTE
1586 0c80 fb 7f ea                  ADDB   NBR2X+1  ;ADD 2X LS BYTE TO DIGIT
1587 0c83 b9 7f e9                  ADCA   NBR2X    ;ADD 2X MS BYTE
1588 0c86 25 2d                     BCS    CONERR   ;CARRY OUT OF MS BYTE IS AN ERROR
1589 0c88 fb 7f 1c                  ADDB   NBRLO    ;ADD 8X LS BYTE
1590 0c8b b9 7f 1b                  ADCA   NBRHI    ;ADD 8X MS BYTE
1591 0c8e 25 25                     BCS    CONERR   ;CARRY OUT OF MS BYTE IS AN ERROR
1592 0c90 f7 7f 1c                  STB    NBRLO    ;SAVE FINAL LS BYTE
1593 0c93 b7 7f 1b                  STA    NBRHI    ;SAVE FINAL MS BYTE
1594                         
1595 0c96 20 a4                     BRA    NUMLUP
1596                         ;*****
1597                         ;INPUT AN OCTAL NUMBER
1598 0c98 c1 07              OCTNUM CMPB   #$07
1599 0c9a 2e 19                     BGT    CONERR   ;NOT OCTAL IF > 7
1600                         
1601                         ;SHIFT HI & LO BYTES 2 PLACES LEFT - CARRY OUT OF HI BYTE IS ILLEGAL
1602 0c9c 8d 1d                     BSR    SHIFT2
1603 0c9e 8d 20                     BSR    SHIFT
1604                         
1605 0ca0 fa 7f 1c                  ORB    NBRLO    ;ADD IN NEW DIGIT
1606 0ca3 f7 7f 1c                  STB    NBRLO
1607                         
1608 0ca6 7e 0c 3c                  JMP    NUMLUP
1609                         
1610                         ;*****
1611                         ;GOOD NUMBER - SCAN WAS SUCCESSFUL
1612                         ;UPDATE GOOD SYNTAX LINE POINTER
1613 0ca9 be 7f 14           GUDNUM LDX    LINPTR
1614 0cac bf 7f 12                  STX    SYNPTR
1615 0caf be 7f df                  LDX    XTEMP2
1616 0cb2 86 01                     LDA    #1       ;SET "GOOD SCAN" FLAG
1617 0cb4 39                        RTS
1618                         
1619                         ;*****
1620                         ;CONVERSION ERROR - SCAN WAS UNSUCCESSFUL
1621 0cb5 be 7f df           CONERR LDX    XTEMP2
1622 0cb8 4f                        CLRA
1623 0cb9 4a                        DECA
1624 0cba 39                        RTS
1625                         ;----------------------------------
1626                         ;SHIFT LEFT 2 POSITIONS
1627 0cbb 8d 03              SHIFT2 BSR    SHIFT
1628 0cbd 8d 01                     BSR    SHIFT
1629 0cbf 39                        RTS
1630                         ;----------------------------------
1631                         ;SHIFT A TWO BYTE NUMBER LEFT ONE POSITION
1632 0cc0 78 7f 1c           SHIFT  ASL    NBRLO
1633 0cc3 79 7f 1b                  ROL    NBRHI
1634 0cc6 25 01                     BCS    SHFTER
1635 0cc8 39                        RTS
1636                         ;ERROR - HI ORDER BYTE OVERFLOW
1637                         ;ABORT NUMBER ROUTINE DIRECTLY THRU STACK ADJ. & A JUMP
1638 0cc9 32 62              SHFTER LEAS   2,S
1639 0ccb 20 e8                     BRA    CONERR
1640                         
1641                         ;======================================================
1642                         ;OUTPUT A SPACE
1643 0ccd 86 20              OUTSP  LDA    #$20
1644 0ccf bd 0f 8d                  JSR    OUTCHR
1645 0cd2 39                        RTS
1646                         
1647                         ;======================================================
1648                         ;OUTPUT AN "=" SIGN
1649 0cd3 86 3d              OUTEQ  LDA    #'='
1650 0cd5 bd 0f 8d                  JSR    OUTCHR
1651 0cd8 39                        RTS
1652                         
1653                         ;======================================================
1654                         ;OUTPUT A 1 BYTE NUMBER
1655                         ;ACCA, ACCB, & IX ARE PRESERVED
1656 0cd9 34 04              OUT1BY PSHS   B
1657 0cdb c6 01                     LDB    #1
1658 0cdd 8d 0c                     BSR    OUTNUM
1659 0cdf 35 04                     PULS   B
1660 0ce1 39                        RTS
1661                         
1662                         ;======================================================
1663                         ;OUTPUT A 2 BYTE NUMBER
1664                         ;ACCA, ACCB, & IX ARE PRESERVED
1665 0ce2 34 04              OUT2BY PSHS   B
1666 0ce4 c6 02                     LDB    #2
1667 0ce6 8d 03                     BSR    OUTNUM
1668 0ce8 35 04                     PULS   B
1669 0cea 39                        RTS
1670                         
1671                         ;======================================================
1672                         ;DISPLAY THE NUMBER POINTED AT BY THE ADDRESS IN THE INDEX REGISTER
1673                         ;AND OUTPUT IT ACCORDING TO THE BASE SPECIFIED IN "DBCODE"
1674                         ;LEADING ZEROES ARE INCLUDED
1675                         ;ACCA & IX ARE PRESERVED
1676                         ;ACCB IS INPUT AS THE NUMBER OF BYTES COMPRISING THE NUMBER
1677                         ;GLOBAL VARIABLES FOR EXTERNAL COMMUNICATION
1678                         ;IBCODE - INPUT BASE CODE
1679                         ;DBCODE - DISPLAY BASE CODE
1680                         
1681                         ;LOCAL VARIABLES
1682                         ;DECDIG - DECIMAL DIGIT BEING BUILT
1683                         ;NUMBHI - HI BYTE OF NUMBER BEING OUTPUT
1684                         ;NUMBLO - LO BYTE OF NUMBER BEING OUTPUT
1685                         
1686 0ceb bf 7f dd           OUTNUM STX    XTEMP1
1687 0cee 34 02                     PSHS   A
1688 0cf0 ae 84                     LDX    ,X       ;GET THE TO BYTES AT THAT ADDRESS
1689 0cf2 bf 7f e7                  STX    NUMBHI   ;PUT THEM IN A SCRATCH AREA FOR PROCESSING
1690 0cf5 b6 7f 19                  LDA    DBCODE   ;GET DISPLAY BASE
1691                         
1692 0cf8 81 01                     CMPA   #1
1693 0cfa 27 0c                     BEQ    OUTHEX
1694 0cfc 81 02                     CMPA   #2
1695 0cfe 27 1e                     BEQ    OUTDEC
1696 0d00 81 03                     CMPA   #3
1697 0d02 27 61                     BEQ    OUTOCT
1698 0d04 81 04                     CMPA   #4
1699 0d06 27 7b                     BEQ    OUTBIN
1700                         
1701                         ;*****
1702                         ;OUTPUT A HEX NUMBER
1703 0d08 58                 OUTHEX ASLB            ;1 BYTE=2 CHARS, 2 BYTES=4 CHARS
1704                         ;GET NEXT 4 BITS
1705 0d09 bd 0d 97           DISNU1 JSR    LSH2
1706 0d0c bd 0d 97                  JSR    LSH2
1707                         
1708 0d0f 84 0f                     ANDA   #$F      ;EXTRACT 4 BITS
1709 0d11 81 09                     CMPA   #9
1710 0d13 2f 02                     BLE    DISNU2
1711 0d15 8b 07                     ADDA   #7       ;CONVERT 10:15 TO A:F
1712                         
1713 0d17 8d 78              DISNU2 BSR    OUTIT
1714 0d19 5a                        DECB
1715 0d1a 26 ed                     BNE    DISNU1
1716 0d1c 20 37                     BRA    OUTDE5
1717                         
1718                         ;*****
1719                         ;OUTPUT A DECIMAL NUMBER
1720 0d1e 5a                 OUTDEC DECB            ;TEST # OF BYTES TO OUTPUT
1721 0d1f 27 0b                     BEQ    OUTDE1
1722                         ;INITIALIZE FOR OUTPUT OF A 2 BYTE NUMBER
1723 0d21 8e 0d 5b                  LDX    #C10K
1724 0d24 b6 7f e7                  LDA    NUMBHI
1725 0d27 f6 7f e8                  LDB    NUMBLO
1726 0d2a 20 07                     BRA    OUTDE2
1727                         
1728                         ;INITIALIZE FOR OUTPUT OF A 1 BYTE NUMBER
1729 0d2c 8e 0d 5f           OUTDE1 LDX    #C100
1730 0d2f 4f                        CLRA
1731 0d30 f6 7f e7                  LDB    NUMBHI
1732                         
1733 0d33 7f 7f e6           OUTDE2 CLR    DECDIG   ;CLEAR THE DIGIT TO OUTPUT
1734                         
1735                         ;SUBTRACT THE POWER OF 10 CONVERSION CONSTANT
1736 0d36 e0 01              OUTDE3 SUBB   1,X
1737 0d38 a2 84                     SBCA   0,X
1738 0d3a 25 05                     BCS    OUTDE4   ;TEST FOR BORROW (CARRY)
1739                         
1740 0d3c 7c 7f e6                  INC    DECDIG   ;NO BORROW YET - INC DIGIT BEING BUILT
1741 0d3f 20 f5                     BRA    OUTDE3   ;REPEAT LOOP
1742                         ;BORROW GENERATED - CANCEL LAST SUBTRACTION
1743 0d41 eb 01              OUTDE4 ADDB   1,X
1744 0d43 a9 84                     ADCA   0,X
1745                         
1746                         ;BUILDING OF DIGIT TO OUTPUT COMPLETE - PRINT IT
1747 0d45 34 02                     PSHS   A        ;SAVE LO BYTE OF NUMBER BEING OUTPUT
1748 0d47 b6 7f e6                  LDA    DECDIG   ;GET DIGIT
1749 0d4a 8d 45                     BSR    OUTIT    ;PRINT IT
1750 0d4c 35 02                     PULS   A        ;RESTORE LO BYTE
1751                         ;GET NEXT LOWER POWER OF 10
1752 0d4e 30 02                     LEAX   2,X
1753 0d50 8c 0d 65                  CPX    #C10K+10 ;ARE WE THRU WITH UNITS CONVERSION?
1754 0d53 26 de                     BNE    OUTDE2   ;IF NOT, BACK TO GET NEXT DIGIT
1755 0d55 35 02              OUTDE5 PULS   A        ;IF YES, RESTORE REGISTERS & RETURN
1756 0d57 be 7f dd                  LDX    XTEMP1
1757 0d5a 39                        RTS
1758                         
1759                         ;DECIMAL OUTPUT CONVERSION CONSTANTS
1760 0d5b 27 10              C10K   FDB    10000
1761 0d5d 03 e8                     FDB    1000
1762 0d5f 00 64              C100   FDB    100
1763 0d61 00 0a                     FDB    10
1764 0d63 00 01                     FDB    1
1765                         
1766                         ;*****
1767                         ;OUTPUT AN OCTAL NUMBER
1768                         ;FIRST DIGIT IS A ONE OR A ZERO
1769 0d65 58                 OUTOCT ASLB            ;FIRST APPROXIMATION OF # OF DIGITS TO OUTPUT
1770 0d66 4f                        CLRA
1771 0d67 c1 02                     CMPB   #2
1772 0d69 2e 06                     BGT    OUTOC1
1773 0d6b 8d 2a                     BSR    LSH2     ;1 BYTE - GET FIRST 2 BITS
1774 0d6d 8d 22                     BSR    OUTIT
1775 0d6f 20 05                     BRA    DISNU3   ;GO OUTPUT LAST 2 DIGITS
1776                         ;TWO BYTE # - OUTPUT HI ORDER BIT/DIGIT
1777 0d71 8d 29              OUTOC1 BSR    LEFSHF
1778 0d73 8d 1c                     BSR    OUTIT
1779 0d75 5c                        INCB           ;5 MORE DIGITS TO GO
1780                         ;GET NEXT 3 BITS
1781 0d76 8d 1f              DISNU3 BSR    LSH2
1782 0d78 8d 22                     BSR    LEFSHF
1783                         
1784 0d7a 84 07                     ANDA   #7      ;EXTRACT 3 BITS
1785 0d7c 8d 13                     BSR    OUTIT
1786 0d7e 5a                        DECB           ;COUNT THIS DIGIT
1787 0d7f 26 f5                     BNE    DISNU3  ;ARE WE DONE?
1788 0d81 20 d2                     BRA    OUTDE5  ;YES
1789                         ;*****
1790                         ;OUTPUT A BINARY NUMBER
1791 0d83 58                 OUTBIN ASLB
1792 0d84 58                        ASLB
1793 0d85 58                        ASLB
1794                         ;GET NEXT BIT
1795 0d86 8d 14              DISNU4 BSR    LEFSHF
1796 0d88 84 01                     ANDA   #1       ;EXTRACT THE BIT
1797                         
1798 0d8a 8d 05                     BSR    OUTIT    ;OUTPUT IT
1799 0d8c 5a                        DECB            ;COUNT IT
1800 0d8d 26 f7                     BNE    DISNU4   ;ARE WE DONE?
1801 0d8f 20 c4                     BRA    OUTDE5   ;YES
1802                         
1803                         ;**
1804                         ;CONVERT TO A NUMERIC ASCII DIGIT & OUTPUT IT
1805 0d91 8b 30              OUTIT  ADDA   #$30
1806 0d93 bd 0f 8d                  JSR    OUTCHR
1807 0d96 39                        RTS
1808                         ;**
1809                         ;LEFT SHIFT 2 BITS
1810 0d97 8d 03              LSH2   BSR    LEFSHF
1811 0d99 8d 01                     BSR    LEFSHF
1812 0d9b 39                        RTS
1813                         
1814                         ;**
1815                         ;LEFT SHIFT THE 3 BYTE NUMBER 1 BIT
1816 0d9c 78 7f e8           LEFSHF ASL    NUMBLO
1817 0d9f 79 7f e7                  ROL    NUMBHI
1818 0da2 49                        ROLA
1819 0da3 39                        RTS
1820                         
1821                         ;======================================================
1822                         ;THIS ROUTINE GETS THE NEXT CHARACTER FROM THE INPUT LINE BUFFER
1823                         ;ACCA IS PRESERVED
1824                         ;ACCB IS LOADED WITH THE CHARACTER
1825                         ;IX IS INCREMENTED & LEFT POINTING TO THE CHARACTER RETURNED
1826 0da4 be 7f 14           GETCHR LDX    LINPTR
1827 0da7 30 01                     LEAX   1,X
1828 0da9 e6 84                     LDB    ,X
1829 0dab bf 7f 14                  STX    LINPTR
1830 0dae 7f 7f 16                  CLR    BOLFLG   ;SET FLAG TO NOT AT "BEGINNING OF LINE"
1831 0db1 39                        RTS
1832                         
1833                         ;======================================================
1834                         ;THIS ROUTINE GETS THE NEXT CHARACTER IN THE COMMAND LISTS
1835                         ;ACCA IS THE CHARACTER RETRIEVED
1836                         ;ACCB IS PRESERVED
1837                         ;IX IS INCREMENTED & LEFT POINTING TO THE CHARACTER RETURNED
1838 0db2 be 7f e4           GETLST LDX    LISPTR   ;GET CURRENT LIST POINTER
1839 0db5 30 01                     LEAX   1,X      ;MOVE POINTER TO NEXT CHAR
1840 0db7 a6 84                     LDA    ,X       ;GET CHARACTER POINTED AT
1841 0db9 bf 7f e4                  STX    LISPTR   ;SAVE POINTER
1842 0dbc 39                        RTS             ;AND RETURN
1843                         
1844                         ;======================================================
1845                         ; COMMAND LISTS
1846                         ;  A CARRIAGE RETURN SIGNIFIES END-OF-COMMAND
1847                         ;  A LINE FEED SIGNIFIES END-OF-COMMAND-LST
1848                         ;LIST 1 - MAJOR COMMANDS
1849 0dbd                    COMLST EQU    *
1850 0dbd 52 45 47                  FCC    "REG"    ; DISPLAY REGISTERS
1851 0dc0 0d                        FCB    CR
1852 0dc1 47 4f 54 4f               FCC    "GOTO"   ;GO TO MEMORY ADDRESS
1853 0dc5 0d                        FCB    CR
1854 0dc6 53 45 49                  FCC    "SEI"    ;SET INTERRUPT MASK
1855 0dc9 0d                        FCB    CR
1856 0dca 43 4c 49                  FCC    "CLI"    ; CLEAR INTERRUPT MAST
1857 0dcd 0d                        FCB    CR
1858 0dce 43 4f 50 59               FCC    "COPY"   ;COPY FROM ONE LOCATION TO ANOTHER
1859 0dd2 0d                        FCB    CR
1860 0dd3 42 52 45 41 4b            FCC    "BREAK"  ;SET BREAKPOINT (SWI CODE)
1861 0dd8 0d                        FCB    CR
1862 0dd9 49 42 41 53 45            FCC    "IBASE"  ;SET INPUT BASE
1863 0dde 0d                        FCB    CR
1864 0ddf 44 42 41 53 45            FCC    "DBASE"  ;SET DISPLAY BASE
1865 0de4 0d                        FCB    CR
1866 0de5 43 4f 4e 54 49 4e         FCC    "CONTINUE" ;CONTINUE FROM "SWI"
     55 45
1867 0ded 0d                        FCB    CR
1868 0dee 44 49 53 50 4c 41         FCC    "DISPLAY" ;DISPLAY MEMORY DATA
     59
1869 0df5 0d                        FCB    CR
1870 0df6 53 45 54                  FCC    "SET"    ;SET MEMORY DATA
1871 0df9 0d                        FCB    CR
1872 0dfa 56 45 52 49 46 59         FCC    "VERIFY" ;VERIFY THAT MEMORY CONTENT IS UNCHANGED
1873 0e00 0d                        FCB    CR
1874 0e01 53 45 41 52 43 48         FCC    "SEARCH" ;SEARCH MEMORY FOR A BYTE STRING
1875 0e07 0d                        FCB    CR
1876 0e08 54 45 53 54               FCC    "TEST"   ;TEST A RANGE OF MEMORY
1877 0e0c 0d                        FCB    CR
1878 0e0d 49 4e 54                  FCC    "INT"    ;SET INTERRUPT POINTER
1879 0e10 0d                        FCB    CR
1880 0e11 4e 4d 49                  FCC    "NMI"    ;SET NON-MASKABLE INTERRUPT POINTER
1881 0e14 0d                        FCB    CR
1882 0e15 53 57 49                  FCC    "SWI"    ;SET SOFTWARE INTERRUPT POINTER
1883 0e18 0d                        FCB    CR
1884 0e19 43 4f 4d 50 41 52         FCC    "COMPARE" ;PRINT SUM & DIFFERENCE OF 2 NUMBERS
     45
1885 0e20 0d                        FCB    CR
1886 0e21 44 55 4d 50               FCC    "DUMP"   ;DUMP MEMORY IN MIKBUG OR IMAGE FORMAT
1887 0e25 0d                        FCB    CR
1888 0e26 4c 4f 41 44               FCC    "LOAD"   ;LOAD MIKBUG TAPE
1889 0e2a 0d                        FCB    CR
1890 0e2b 44 45 4c 41 59            FCC    "DELAY"  ;DELAY SPECIFIED # OF MSECS
1891 0e30 0d                        FCB    CR
1892 0e31 48 45 4c 50               FCC    "HELP"   ;HELP LISTING
1893 0e35 0d                        FCB    CR
1894 0e36 43 4c 46                  FCC    "CLF"    ;CLEAR FAST INTERRUPT MASK
1895 0e39 0d                        FCB    CR
1896 0e3a 53 45 46                  FCC    "SEF"    ;SET FAST INTERRUPT MASK
1897 0e3d 0d                        FCB    CR
1898 0e3e 46 49 52 51               FCC    "FIRQ"   ;SET FAST INTERRUPT POINTER
1899 0e42 0d                        FCB    CR
1900 0e43 52 53 52 56 44            FCC    "RSRVD"  ;SET RESERVED INTERRUPT POINTER
1901 0e48 0d                        FCB    CR
1902 0e49 53 57 49 32               FCC    "SWI2"   ;SET SWI2 INTERRUPT POINTER
1903 0e4d 0d                        FCB    CR
1904 0e4e 53 57 49 33               FCC    "SWI3"   ;SET SWI3 INTERRUPT POINTER
1905 0e52 0d                        FCB    CR
1906 0e53 0a                        FCB    LF       ;END OF LIST 1
1907                         
1908                         ;LIST 2 - MODIFIER TO DUMP
1909 0e54 54 4f                     FCC    "TO"     ;DESTINATION ACIA
1910 0e56 0d                        FCB    CR
1911 0e57 0a                        FCB    LF       ;END OF LIST 2
1912                         
1913                         ;LIST 3 - NUMBER BASE SPECIFIERS
1914 0e58 48 45 58                  FCC    "HEX"    ;BASE 16
1915 0e5b 0d                        FCB    CR
1916 0e5c 44 45 43                  FCC    "DEC"    ;BASE 10
1917 0e5f 0d                        FCB    CR
1918 0e60 4f 43 54                  FCC    "OCT"    ;BASE 8
1919 0e63 0d                        FCB    CR
1920 0e64 42 49 4e                  FCC    "BIN"    ;BASE 2
1921 0e67 0d                        FCB    CR
1922 0e68 0a                        FCB    LF       ;END OF LIST 3
1923                         
1924                         ;LIST 4 - INFORMATION REQUEST
1925 0e69 3f                        FCC    "?"
1926 0e6a 0d                        FCB    CR
1927 0e6b 0a                        FCB    LF       ; END OF LIST 4
1928                         
1929                         ;LIST 5 - REGISTER NAMES
1930 0e6c 2e 43 43                  FCC    ".CC"
1931 0e6f 0d                        FCB    CR
1932 0e70 2e 41                     FCC    ".A"
1933 0e72 0d                        FCB    CR
1934 0e73 2e 42                     FCC    ".B"
1935 0e75 0d                        FCB    CR
1936 0e76 2e 44 50                  FCC    ".DP"
1937 0e79 0d                        FCB    CR
1938 0e7a 2e 58                     FCC    ".X"
1939 0e7c 0d                        FCB    CR
1940 0e7d 2e 59                     FCC    ".Y"
1941 0e7f 0d                        FCB    CR
1942 0e80 2e 55                     FCC    ".U"
1943 0e82 0d                        FCB    CR
1944 0e83 2e 50 43                  FCC    ".PC"
1945 0e86 0d                        FCB    CR
1946 0e87 2e 53                     FCC    ".S"
1947 0e89 0d                        FCB    CR
1948 0e8a 0a                        FCB    LF       ;END OF LIST 5
1949                         
1950                         ;LIST 6 - MODIFIERS TO "DISPLAY"
1951 0e8b 44 41 54 41               FCC    "DATA"
1952 0e8f 0d                        FCB    CR
1953 0e90 55 53 45 44               FCC    "USED"
1954 0e94 0d                        FCB    CR
1955 0e95 0a                        FCB    LF       ;END OF LIST 6
1956                         
1957                         ;LIST 7 - MODIFIER TO "LOAD"
1958 0e96 46 52 4f 4d               FCC    "FROM"   ;SOURCE ACIA
1959 0e9a 0d                        FCB    CR
1960 0e9b 0a                        FCB    LF       ;END OF LIST 7
1961                         
1962                         ;======================================================
1963                         
1964                         ; THIS ROUTINE CONSTRUCTS A LINE OF INPUT BY GETTING ALL INPUT
1965                         ; CHARACTERS UP TO AND INCLUDING A CARRIAGE RETURN (WHICH THEN
1966                         ; DESIGNATES "END OF LINE").
1967                         ; TYPING RUBOUT WILL DELETE THE PREVIOUS CHARACTER
1968                         ; TYPING CONTROL-C WILL ABORT THE LINE
1969                         ; TYPING CONTROL-Z WILL USE THE PREVIOUS LINE
1970                         ; THE INPUT LINE IS STORED BEGINNING AT THE ADDRESS STORED IN BUFBEG
1971                         ; AND ENDING AT THE ADDRESS STORED IN BUFEND
1972                         ;ACCA, ACCB, & IX ARE NOT PRESERVED
1973                         ;
1974                         ;GLOBAL VARIABLES
1975                         ;BUFBEG - INPUT LINE START OF BUFFER
1976                         ;BUFEND - INPUT LINE END OF BUFFER
1977                         
1978                         ;LOCAL CONSTANTS
1979 005c                    BAKSLA EQU    92       ;A BACKSLASH
1980 0008                    DELETE EQU    8        ;CODE TO DELETE THE PREVIOUS CHARACTER (BACKSPACE)
1981                         ;
1982                         ;
1983                         ;*** ROUTINE ENTRY POINT
1984                         
1985 0e9c be 7f 34           GETLIN LDX    BUFBEG   ;SET POINTER TO ONE LESS THAN THE BEGINNING OF THE LINE BUFFER
1986 0e9f 5f                        CLRB            ;ACCB HOLS THE LAST INPUT CHAR
1987                         
1988 0ea0 bc 7f 36           NXTCHR CPX    BUFEND   ;CHECK CURRENT LINE END AGAINST BUFFER END
1989 0ea3 26 09                     BNE    GETIT
1990                         
1991                         ;LINE TOO LONG - ABORT IT AS IF A CONTROL-C HAD BEEN TYPED
1992 0ea5 8e 10 22                  LDX    #MSGLTL  ;GET MESSAGE
1993 0ea8 bd 0f 5e                  JSR    OUTSTR   ;OUTPUT IT
1994 0eab c6 03                     LDB    #3       ;PUT CTL-C IN ACCB
1995 0ead 39                        RTS
1996                         
1997 0eae bd 0f 6f           GETIT  JSR    INPCHR   ;GET A CHARACTER (RETURNED IN ACCA)
1998 0eb1 84 7f                     ANDA   #127     ;DROP PARITY BIT
1999                         
2000                         ;CONTROL-Z COPIES FROM PRESENT POSITION TO PREVIOUS END OF LINE
2001 0eb3 81 1a                     CMPA   #26      ;IS CHAR A CONTROL-A?
2002 0eb5 26 04                     BNE    TSTCR
2003 0eb7 bd 0f e5                  JSR    DOCRLF   ;YES, TYPE CR-LF
2004 0eba 39                        RTS
2005 0ebb 81 0d              TSTCR  CMPA   #13      ;IS CHAR A CR?
2006 0ebd 27 04                     BEQ    TSTCR1
2007 0ebf 81 0a                     CMPA   #10      ;OR A LF?
2008 0ec1 26 0d                     BNE    NOTEOL
2009 0ec3 30 01              TSTCR1 LEAX   1,X
2010 0ec5 a7 84                     STA    ,X       ;YES, STORE THE TERMINATOR
2011 0ec7 7d 7f 31                  TST    HDXFLG   ;TEST FOR HALF-DUPLEX TERMINAL
2012 0eca 26 03                     BNE    TSTCR2
2013 0ecc bd 0f e5                  JSR    DOCRLF   ;TYPE CR-LF
2014 0ecf 39                 TSTCR2 RTS             ;NOW RETURN
2015                         
2016 0ed0 81 03              NOTEOL CMPA   #3       ;IS CHAR A CONTROL-C?
2017 0ed2 26 08                     BNE    NOTCTC
2018                         ;ECHO AN UP-ARROW
2019 0ed4 1f 89                     TFR    A,B      ;RETURN CONTROL-C IN ACCB
2020 0ed6 86 5e                     LDA    #'^'
2021 0ed8 bd 0f 8d                  JSR    OUTCHR
2022 0edb 39                        RTS
2023                         
2024 0edc 81 08              NOTCTC CMPA   #DELETE  ;NO, IS IT DELETE
2025 0ede 27 29                     BEQ    RUBNOW   ;IF YES, GO TO RUBNOW
2026                         
2027                         ;CONVERT LOWER CASE TO UPPER CASE
2028 0ee0 81 60                     CMPA   #$60     ;BELOW L.C. A?
2029 0ee2 23 06                     BLS    STORIT
2030 0ee4 81 7a                     CMPA   #$7A     ;ABOVE L.C. Z?
2031 0ee6 22 02                     BHI    STORIT
2032 0ee8 80 20                     SUBA   #32      ;CONVERT L.C. ALPHABETIC TO U.C.
2033                         
2034 0eea 30 01              STORIT LEAX   1,X      ;NOT A DELETE, SO ADVANCE TO NEXT CHARACTER
2035 0eec a7 84                     STA    ,X       ;STORE IT IN INPLIN
2036                         
2037 0eee c1 08                     CMPB   #DELETE  ;IS LAST CHAR A DELETE?
2038 0ef0 27 04                     BEQ    OUTBAK   ;IF SO. GO TO OUTBAK
2039 0ef2 1f 89                     TFR    A,B      ;ITS NOT, UPDATE LAST CHAR
2040 0ef4 20 09                     BRA    ECHO     ;GO ECHO IT
2041                         
2042                         ;LAST CHAR WAS A DELETE, BUT THIS ONE ISN'T
2043 0ef6 1f 89              OUTBAK TFR    A,B      ;UPDATE LAST CHAR
2044 0ef8 86 5c                     LDA    #BAKSLA  ;PRINT A -
2045 0efa bd 0f 8d                  JSR    OUTCHR   ;BACKSLASH
2046 0efd 1f 98                     TFR    B,A      ;RESTORE CURRENT CHAR FOR ECHO
2047 0eff 7d 7f 31           ECHO   TST    HDXFLG   ;TEST FOR HALF DUPLEX TERMINAL
2048 0f02 26 03                     BNE    ECHO1
2049 0f04 bd 0f 8d                  JSR    OUTCHR   ;NOW ECHO IT
2050 0f07 20 97              ECHO1  BRA    NXTCHR   ;GET ANOTHER
2051                         ;
2052                         ; CURRENT CHARACTER IS A DELETE
2053                         ; TEST LINE LENGTH - IT ITS ZERO, IGNORE THIS DELETE SINCE
2054                         ; WE CAN'T DELETE PRIOR TO FIRST CHARACTER IN INPUT LINE
2055 0f09 bc 7f 34           RUBNOW CPX    BUFBEG
2056 0f0c 27 92                     BEQ    NXTCHR
2057 0f0e c1 08                     CMPB   #DELETE  ;WAS LAST CHAR A DELETE?
2058 0f10 27 07                     BEQ    LASWAS
2059                         
2060                         ;LAST CHAR WASN'T A DELETE
2061 0f12 1f 89                    TFR     A,B      ;UPDATE LAST CHAR (WITH A DELETE)
2062 0f14 86 5c                    LDA     #BAKSLA  ;PRINT A -
2063 0f16 bd 0f 8d                 JSR     OUTCHR   ;BACKSLASH
2064                         ;LAST CHAR WAS A DELETE
2065 0f19 a6 84              LASWAS LDA    ,X       ;GET THE CHAR TO BE DELETED
2066 0f1b 30 1f                     LEAX   -1,X     ;DECREMENT LINE POINTER
2067 0f1d 20 e0                     BRA    ECHO     ;ECHO DELETED CHARACTER
2068                         
2069                         ;======================================================
2070                         ;INITIALIZATION ROUTINE
2071                         ;DISABLE INTERRUPTS
2072 0f1f 1a 10                     ORCC   #$10     ;SEI
2073 0f21 86 01              INITAL LDA    #1
2074 0f23 b7 7f 18                  STA    IBCODE   ;SET INPUT BASE TO HEX
2075 0f26 b7 7f 19                  STA    DBCODE   ;SET DISPLAY BASE TO HEX
2076                         ;SET UP DISPLAY BASE NUMBER
2077 0f29 86 10                     LDA    #16
2078 0f2b b7 7f 1a                  STA    DBNBR
2079                         ;MAX # OF CHARACTERS PER LINE
2080 0f2e 86 48                     LDA    #72
2081 0f30 b7 7f 33                  STA    CPLMAX
2082 0f33 7f 7f 2b                  CLR    INPFLG   ;DEFAULT INPUT FROM THE TERMINAL
2083 0f36 7f 7f 2e                  CLR    OUTFLG   ;DEFAULT OUTPUT TO THE TERMINAL
2084 0f39 7f 7f 31                  CLR    HDXFLG   ;CLEAR HALF-DUPLEX FLAG
2085                         ;INITIALIZE ACIA1 & ACIA2 TO 8 BITS AND NO PARITY
2086                         ;RESET BOTH
2087 0f3c 86 03                     LDA    #3
2088 0f3e b7 a0 00                  STA    ACIA1-1
2089 0f41 b7 a0 00                  STA    ACIA2-1
2090                         ;SET EM UP
2091 0f44 86 15                     LDA    #$15
2092 0f46 b7 a0 00                  STA    ACIA1-1
2093 0f49 b7 a0 00                  STA    ACIA2-1
2094                         ;SET UP SWI INTERRUPT ADDRESS POINTER
2095 0f4c 8e 05 2a                  LDX    #TYPSWI  ;TYPE "SWI" & DO "REG" COMMAND
2096 0f4f bf 7f 08                  STX    SWIVEC
2097                         ;INITIALIZE TO MONDEB'S COMMAND LISTS
2098 0f52 8e 0d bc                  LDX    #COMLST-1
2099 0f55 bf 7f 10                  STX    COMADR
2100                         ;TIME CONSTANT FOR A 2 MICROSECOND CLOCK
2101 0f58 86 00                     LDA    #256
2102 0f5a b7 7f eb                  STA    TIMCON
2103 0f5d 39                        RTS
2104                         
2105                         ;======================================================
2106                         ;OUTPUT A CHARACTER STRING WHICH BEGINS AT THE ADDRESS IN THE INDEX REGISTER
2107                         ;ACCA & ACCB ARE PRESERVED
2108                         ;IX IS LEFT POINTING TO THE STRING TERMINATOR
2109 0f5e 34 02              OUTSTR PSHS   A
2110 0f60 a6 84              OUTST1 LDA    ,X       ;GET CHAR POINTED TO
2111 0f62 81 04                     CMPA   #4       ;IS IT A STRING TERMINATOR?
2112 0f64 27 06                     BEQ    OUTEND   ;DONE IF IT IS
2113 0f66 8d 25                     BSR    OUTCHR   ;ISN'T, OUTPUT IT
2114 0f68 30 01                     LEAX   1,X      ;ON TO NEXT CHARACTER
2115 0f6a 20 f4                     BRA    OUTST1
2116 0f6c 35 02              OUTEND PULS   A
2117 0f6e 39                        RTS             ;RETURN
2118                         
2119                         ;======================================================
2120                         ;INPUT A CHARACTER FROM AN ACIA TO ACCA
2121                         ;IF INPFLG = 0, INPUT IS FROM TERMINAL ACIA
2122                         ;IF INPFLG = 0, INPUT IS FROM ANY ACIA
2123                         ;ACCB & IX ARE PRESERVED
2124                         
2125 0f6f bf 7f db           INPCHR STX    XTEMP    ;SAVE IX
2126 0f72 7d 7f 2b                  TST    INPFLG   ;TEST INPUT SOURCE FLAG
2127 0f75 26 05                     BNE    INPCH1
2128                         ;INPFLG=0: INPUT FROM TERMINAL ACIA
2129 0f77 8e a0 01                  LDX    #ACIA1
2130 0f7a 20 03                     BRA    INPCH2
2131                         ;INPFLG=1: INPUT FROM ANY ACIA
2132 0f7c be 7f 2c           INPCH1 LDX    INPADR   ;GET ITS ADDRESS
2133 0f7f 30 1f              INPCH2 LEAX   -1,X     ;POINT TO CONTROL REG
2134 0f81 a6 84              INPCH3 LDA    ,X       ;GET ACIA STATUS BYTE
2135 0f83 85 01                     BITA   #1       ;CHAR WAITING?
2136 0f85 27 fa                     BEQ    INPCH3   ;IF NOT, TRY AGAIN
2137 0f87 a6 01                     LDA    1,X      ;YES, GET IT
2138 0f89 be 7f db                  LDX    XTEMP    ;RESTORE IX
2139 0f8c 39                        RTS
2140                         
2141                         ;======================================================
2142                         ;OUTPUT THE CHARACTER IN ACCA TO THE DESIRED OUTPUT DEVICE/LOCATION
2143                         ; IF OUTFLG = 0, OUTPUT IS TO TERMINAL
2144                         ; IF OUTFLG = 1, OUTPUT IS TO ACIA ADDRESS STORED IN OUTADR
2145                         ; IF OUTFLG = 2, OUTPUT IS TO ADDRESS IN OUTADR & THIS ADDR IS THEN INCREMENTED
2146                         ;ACCA, ACCB, & IX ARE PRESERVED
2147 0f8d 34 04              OUTCHR PSHS   B        ;SAVE ACCB
2148 0f8f 7d 7f 2e                  TST    OUTFLG   ;TEST OUTPUT DESTINATION FLAG
2149 0f92 27 24                     BEQ    OUTCH4   ;SKIP THIS CODE IF TERMINAL OUTPUT
2150                         
2151                         ;OUTPUT TO SOMETHING OTHER THAN THE TERMINAL
2152 0f94 bf 7f db                 STX     XTEMP    ;SAVE IX
2153 0f97 be 7f 2f                 LDX     OUTADR   ;GET OUTPUT CHAR DESTINATION ADDRESS
2154 0f9a c6 02                    LDB     #2
2155 0f9c f1 7f 2e                 CMPB    OUTFLG
2156 0f9f 27 0a                    BEQ     OUTCH2
2157                         
2158                         ;OUTFLG = 1: ANY ACIA OUTPUT
2159 0fa1 30 1f                     LEAX   -1,X     ;POINT TO ACIA STATUS REG
2160 0fa3 e5 84              OUTCH1 BITB   ,X       ;TEST TDRE BIT
2161 0fa5 27 fc                     BEQ    OUTCH1   ;LOOP IF NOT READY TO ACCEPT A NEW CHAR
2162 0fa7 a7 01                     STA    1,X      ;NOW READY - SEND IT
2163 0fa9 20 07                     BRA    OUTCH3
2164                         
2165                         ;OUTCLF = 2: MEMORY OUTPUT
2166 0fab a7 84              OUTCH2 STA    ,X       ;SAVE CHAR IN MEMORY
2167 0fad 30 01                     LEAX   1,X
2168 0faf bf 7f 2f                  STX    OUTADR   ; UPDATE OUTPUT ADDRESS
2169                         
2170 0fb2 be 7f db           OUTCH3 LDX    XTEMP    ;RESTORE IX
2171 0fb5 35 04                     PULS   B        ;RESTORE ACCB
2172 0fb7 39                        RTS
2173                         
2174                         ;OUTFLG = 0: TERMINAL ACIA OUTPUT
2175                         ;IGNORE LINE FEEDS
2176 0fb8 81 0a              OUTCH4 CMPA   #LF
2177 0fba 26 03                     BNE    OUTCH5
2178 0fbc 35 04                     PULS   B
2179 0fbe 39                        RTS
2180                         
2181 0fbf 81 0d              OUTCH5 CMPA   #CR      ;TEST FOR CARRIAGE RETURN
2182 0fc1 26 05                     BNE    OUTCH6
2183 0fc3 8d 20                     BSR    DOCRLF
2184 0fc5 35 04                     PULS   B
2185 0fc7 39                        RTS
2186                         
2187 0fc8 f6 7f 32           OUTCH6 LDB    CPLCNT   ;GET "CHARACTERS PER LINE" COUNT
2188 0fcb f1 7f 33                  CMPB   CPLMAX   ;COMPARE TO MAX PERMISSIBLE
2189 0fce 2c 0b                     BGE    OUTCH7   ;SEND CR-LF IF GREATER
2190                         ;LESS THAN MAX, BUT ALSO SEND CR-LF IF 10 FROM END AND PRINTING A SPACE
2191 0fd0 cb 0a                     ADDB   #10
2192 0fd2 f1 7f 33                  CMPB   CPLMAX
2193 0fd5 2d 06                     BLT    OUTCH8
2194 0fd7 81 20                     CMPA   #$20     ;NEAR END, TEST IF ABOUT TO PRINT A SPACE
2195 0fd9 26 02                     BNE    OUTCH8
2196                         
2197                         ;TERMINAL LINE FULL OR NEARLY FULL - INTERJECT A CR-LF
2198 0fdb 8d 08              OUTCH7 BSR    DOCRLF
2199 0fdd 7c 7f 32           OUTCH8 INC    CPLCNT   ;BUMP COUNTER
2200 0fe0 8d 17                     BSR    TOACIA   ;SEND IT TO ACIA1
2201 0fe2 35 04                     PULS   B
2202 0fe4 39                        RTS
2203                         
2204                         ;======================================================
2205                         ;SEND A CARRIAGE RETURN-LINE FEED TO THE TERMINAL
2206                         ;ACCA, ACCB, & IX ARE PRESERVED
2207 0fe5 34 02              DOCRLF PSHS   A
2208 0fe7 34 04                     PSHS   B
2209 0fe9 86 0d                     LDA    #CR
2210 0feb 8d 0c                     BSR    TOACIA
2211 0fed 86 0a                     LDA    #LF
2212 0fef 8d 08                     BSR    TOACIA
2213 0ff1 7f 7f 32                  CLR    CPLCNT   ;ZERO "CHARACTERS PER LINE" COUNT
2214 0ff4 35 04                     PULS   B
2215 0ff6 35 02                     PULS   A
2216 0ff8 39                        RTS
2217                         
2218                         ;======================================================
2219                         ;PUT CHAR IN ACCA INTO TERMINAL ACIA
2220                         ;ACCA, ACCB, & IX ARE PRESERVED
2221 0ff9 34 02              TOACIA PSHS   A        ;SAVE CHAR
2222 0ffb 86 02                     LDA    #2       ;GET ACIA TRANSMIT REG STATUS BIT
2223 0ffd b5 a0 00           TOACI1 BITA   ACIA1-1  ;REGISTER EMPTY?
2224 1000 27 fb                     BEQ    TOACI1   ;IF NOT, LOOP BACK
2225 1002 35 02                     PULS   A        ;YES, RESTORE CHARACTER
2226 1004 b7 a0 01                  STA    ACIA1    ;SEND IT
2227 1007 39                        RTS
2228                         
2229                         ;======================================================
2230                         ;MISC TEST
2231 1008 4d 4f 4e 44 45 42  MSGHED FCC    "MONDEB 6809 1.00" ;MONITOR HEADER TYPEOUT
     20 36 38 30 39 20
     31 2e 30 30
2232 1018 0d 04                     FCB    CR,4
2233                         
2234 101a 2a                 MSGPRM FCC   "*"        ;PROMPT STRING
2235 101b 04                        FCB    4
2236                         
2237 101c 0d                 MSGSWI FCB    CR
2238 101d 53 57 49 3a               FCC    "SWI:"
2239 1021 04                        FCB    4
2240                         
2241 1022 54 4f 4f 20 4c 4f  MSGLTL FCC    "TOO LONG" ; TYPED IF INPUT LINE IS TOO LONG
     4e 47
2242 102a 04                        FCB    4
2243                         
2244 102b 4e 4f 54 20 53 45  MSGNBR FCC    "NOT SET" ; BREAK NOT SET
     54
2245 1032 04                        FCB    4
2246                         
2247 1033 53 45 54 20 40 20  MSGBAT FCC    "SET @ " ; BREAK AT -
2248 1039 04                        FCB    4
2249                         
2250 103a 4f 4b              MSGVER FCC    "OK"     ;CHECKSUM VERIFIES
2251 103c 04                        FCB    4
2252                         
2253 103d 43 48 45 43 4b 53  MSGNVE FCC    "CHECKSUM ERROR " ; FOR VERIFY & LOAD COMMANDS
     55 4d 20 45 52 52
     4f 52 20
2254 104c 04                        FCB    4
2255                         
2256 104d 43 41 4e 27 54 20  MSGCCL FCC    "CAN'T CLEAR" ; TEST COMMAND
     43 4c 45 41 52
2257 1058 04                        FCB    4
2258                         
2259 1059 43 41 4e 27 54 20  MSGCSO FCC    "CAN'T SET TO ONES" ; TEST COMMAND
     53 45 54 20 54 4f
     20 4f 4e 45 53
2260 106a 04                        FCB    4
2261                         
2262 106b 53 55 4d 20 49 53  MSGSIS FCC    "SUM IS " ; COMPARE COMMAND
     20
2263 1072 04                        FCB    4
2264                         
2265 1073 2c 20 44 49 46 46  MSGDIS FCC    ", DIFF IS " ; COMPARE COMMAND
     20 49 53 20
2266 107d 04                        FCB    4
2267                         
2268 107e 0d 0a              MSGS0  FCB    CR,LF
2269 1080 53 30 30 36 30 30         FCC    "S00600004844521B"
     30 30 34 38 34 34
     35 32 31 42
2270 1090 04                        FCB    4
2271                         
2272 1091 0d 0a              MSGS1  FCB    CR,LF
2273 1093 53 31                     FCC    "S1"
2274 1095 04                        FCB    4
2275                         
2276 1096 0d 0a              MSGS9  FCB    CR,LF
2277 1098 53 39 30 33 30 30         FCC    "S9030000FC"
     30 30 46 43
2278 10a2 0d 0a 04                  FCB    CR,LF,4
2279                         
2280 10a5 43 48 41 52 20 4e  MSGCNH FCC    "CHAR NOT HEX" ;USE IN LOAD COMMAND
     4f 54 20 48 45 58
2281 10b1 0d 04                     FCB    CR,4
2282                         
2283                         ;======================================================
2284                         ;INTERRUPT HANDLING CODE
2285 10b3 6e 9f 7f 00        INTADR JMP    [INTVEC]
2286                         
2287                         ;*****
2288 10b7 6e 9f 7f 02        FIRQADR JMP   [FIRQVC]
2289                         
2290                         ;*****
2291 10bb 6e 9f 7f 04        NMIADR JMP    [NMIVEC]
2292                         
2293                         ;*****
2294 10bf 6e 9f 7f 06        RSRVDADR JMP  [RSRVDVC]
2295                         
2296                         ;*****
2297 10c3 7e 04 00           RESADR JMP    START
2298                         
2299                         ;*****
2300 10c6 10 ff 7f 0e        SWIADR STS    SP       ;SAVE STACK POINTER OF PROGRAM BEING DEBUGGED
2301 10ca 6e 9f 7f 08               JMP    [SWIVEC]
2302                         
2303                         ;*****
2304                         SWI2ADR
2305 10ce 10 ff 7f 0e               STS    SP       ;SAVE STACK POINTER OF PROGRAM BEING DEBUGGED
2306 10d2 6e 9f 7f 0a               JMP    [SWI2VC]
2307                         
2308                         ;*****
2309                         SWI3ADR
2310 10d6 10 ff 7f 0e               STS    SP       ;SAVE STACK POINTER OF PROGRAM BEING DEBUGGED
2311 10da 6e 9f 7f 0c               JMP    [SWI3VC]
2312                         
2313                         ;*****
2314                         ;      FILL   $FF, $FFB1-*
2315                         ;      ORG    $FFB1    ;CALCULATED SO INTERRUPT VECTORS BELOW ARE AT CORRECT ADDRESSES
2316                         ;**************************************************
2317                         
2318 10de 7e 0a 53                  JMP    TIMDEL   ;TIME DELAY FOR # OF MS SPECIFIED BY IX
2319 10e1 7e 07 ba                  JMP    CKSUM    ;RETURN CHECKSUM OF AN ADDRESS RANGE IN ACCA
2320 10e4 7e 0d a4                  JMP    GETCHR   ;RETURN (IN ACCB) CHAR POINTED TO BY LINPTR
2321 10e7 7e 0d b2                  JMP    GETLST   ;RETURN (IN ACCA) CHAR POINTED TO BY LISPTR
2322 10ea 7e 0b d8                  JMP    GTRANG   ;PICK UP AN ADDRESS RANGE IN RANGLO & RANGHI
2323 10ed 7e 0c 23                  JMP    NUMBER   ;PICK UP A NUMBER & RETURN IT IN NBRHI & NBRLO
2324 10f0 7e 0b 40                  JMP    SKPDLM   ;SKIP OVER INPUT LINE DELIMITERS
2325 10f3 7e 0b 6d                  JMP    TSTDLM   ;TEST CHAR IN ACCB FOR A DELIMITER
2326 10f6 7e 0b 62                  JMP    TSTEOL   ;TEST CHAR IN ACCA FOR END-OF-LINE
2327 10f9 7e 0a 97                  JMP    COMAND   ;SEARCH SPECIFIED COMMAND LIST FOR A COMMAND
2328 10fc 7e 0b 01                  JMP    TYPCMD   ;TYPES OUT COMMAND NUMBER "COMNUM" IN LIST ACCA
2329 10ff 7e 0c d9                  JMP    OUT1BY   ;DISPLAY THE 1 BYTE NUMBER POINTED AT BY IX
2330 1102 7e 0c e2                  JMP    OUT2BY   ;DISPLAY THE 2 BYTE NUMBER POINTED AT BY IX
2331 1105 7e 0e 9c                  JMP    GETLIN   ;GET A LINE OF INPUT INTO THE TTY BUFFER
2332 1108 7e 0f 5e                  JMP    OUTSTR   ;OUTPUT CHAR STRING IX POINTS TO
2333 110b 7e 0f e5                  JMP    DOCRLF   ;SEND CR-LF WITH DELAY & ZERO LINE COUNT
2334 110e 7e 0f 8d                  JMP    OUTCHR   ;LIKE TOACIA, BUT WITH FOLDING, CR DELAY, & LF INSERTION
2335 1111 7e 0f f9                  JMP    TOACIA   ;SEND ACCA TO ACIA1
2336 1114 7e 0f 6f                  JMP    INPCHR   ;GET A CHAR FROM AN ACIA & RETURN IT IN ACCA
2337 1117 7e 04 27                  JMP    PROMPT   ;TO PROMPT FOR A NEW COMMAND
2338 111a 7e 04 00                  JMP    START    ;START OF MONDEB
2339                         ;**************************************************
2340                         ;INTERRUPT VECTORS
2341 111d 10 bf                     FDB   RSRVDADR  ;RESERVED INTERRUPT
2342 111f 10 d6                     FDB   SWI3ADR   ;SWI3 INTERRUPT
2343 1121 10 ce                     FDB   SWI2ADR   ;SWI2 INTERRUPT
2344 1123 10 b7                     FDB   FIRQADR   ;FAST INTERRUPT
2345 1125 10 b3                     FDB   INTADR    ;REGULAR INTERRUPT
2346 1127 10 c6                     FDB   SWIADR    ;SOFTWARE INTERRUPT
2347 1129 10 bb                     FDB   NMIADR    ;NON-MASKABLE INTERRUPT
2348 112b 10 c3                     FDB   RESADR    ;RESET INTERRUPT
2349                         
2350                         ;**************************************************
2351                         ;VARIABLES FOR INTER-ROUTINE COMMUNICATION
2352 7f00                           ORG    $7F00
2353 7f00                    INTVEC RMB    2        ;INTERRUPT ADDRESS POINTER
2354 7f02                    FIRQVC RMB    2        ;FAST INTERRUPT ADDRESS POINTER
2355 7f04                    NMIVEC RMB    2        ;NON-MASKABLE INTERRUPT ADDRESS POINTER
2356 7f06                    RSRVDVC RMB   2        ;RESERVED INTERRUPT ADDRESS POINTER
2357 7f08                    SWIVEC RMB    2        ;SOFTWARE INTERRUPT ADDRESS POINTER
2358 7f0a                    SWI2VC RMB    2        ;SOFTWARE INTERRUPT2 ADDRESS POINTER
2359 7f0c                    SWI3VC RMB    2        ;SOFTWARE INTERRUPT3 ADDRESS POINTER
2360 7f0e                    SP     RMB    2        ;SAVED STACK POINTER
2361 7f10                    COMADR RMB    2        ;ADDRESS OF BEGINNING OF COMMAND LISTS FOR COMMAND
2362 7f12                    SYNPTR RMB    2        ;INPUT LINE CHARACTER POINTER FOR GOOD SYNTAX
2363 7f14                    LINPTR RMB    2        ;INPUT LINE CHARACTER POINTER (CONTENT = OR > CONTENT OF SYNPTR)
2364 7f16                    BOLFLG RMB    1        ;"BEGINNING OF LINE" FLAG
2365 7f17                    DELIM  RMB    1        ;CHARACTER(S) PERMITTED AS VALID COMMAND/MODIFIER DELIMITER
2366 7f18                    IBCODE RMB    1        ;INPUT BASE (1=HEX, 2=DEC, 3=OCT)
2367 7f19                    DBCODE RMB    1        ;DISPLAY BASE (1=HEX, 2=DEC, 3=OCT, 4=BIN)
2368 7f1a                    DBNBR  RMB    1        ;DISPLAY BASE NUMBER (E.G., 16,10M8M OR 2)
2369                         
2370 7f1b                    NBRHI  RMB    1        ;MOST SIGNIFICANT BYTE OF SCANNED NUMBER
2371 7f1c                    NBRLO  RMB    1        ;LEAST SIGNIFICANT BYTE OF SCANNED NUMBER
2372                         
2373 7f1d                    RANGLO RMB    2        ;RANGE LOWER LIMIT PICKED UP BY GTRANG
2374 7f1f                    RANGHI RMB    2        ;RANGE UPPER LIMIT PICKED UP BY GTRANG
2375                         
2376 7f21                    LASTGO RMB    2        ;LAST SPECIFIED GOTO ADDRESS
2377                         
2378 7f23                    VERFRM RMB    2        ;BEGINNING ADDRESS OF RANGE TO CHECKSUM VERIFY
2379 7f25                    VERTO  RMB    2        ;ENDING ADDRESS OF RANGE TO CHECKSUM VERIFY
2380                         
2381 7f27                    CHKSUM RMB    1        ;CHECKSUM OF RANGE GIVEN IN THE VERIFY COMMAND
2382                         
2383 7f28                    BRKADR RMB    2        ;ADDRESS OF INSERTED BREAKPOINT
2384 7f2a                    BRKINS RMB    1        ;INSTRUCTION WHICH SHOULD BE THERE NORMALLY
2385                         
2386 7f2b                    INPFLG RMB    1        ;ALTERNATE INPUT DESTINATION FLAG
2387 7f2c                    INPADR RMB    2        ;ALTERNATE ADDRESS THAT THE INPUT CHARACTERS ARE TO COME FROM
2388                         
2389 7f2e                    OUTFLG RMB    1        ;ALTERNATE OUTPUT DESTINATION FLAG
2390 7f2f                    OUTADR RMB    2        ;ALTERNATE ADDRESS THAT THE OUTPUT CHARACTERS ARE TO GO TO
2391                         
2392 7f31                    HDXFLG RMB    1        ;HALF-DUPLEX TERMINAL FLAG (IF NON-ZERO, NO ECHO)
2393                         
2394 7f32                    CPLCNT RMB    1        ;"CHARACTERS PER LINE" COUNT
2395 7f33                    CPLMAX RMB    1        ;"CHARACTERS PER LINE" MAXIMUM
2396 7f34                    BUFBEG RMB    2        ;INPUT LINE START OF BUFFER
2397 7f36                    BUFEND RMB    2        ;INPUT LINE END OF BUFFER
2398 7f38                    TTYBUF RMB    72       ;START OF INPUT LINE BUFFER
2399 7f80                    TTYEND RMB    1        ;END OF INPUT LINE BUFFER
2400 7f81                           RMB    56       ;MAIN STACK STORAGE
2401 7fb9                    STACK  RMB    12       ;STACK STORAGE FOR RTI INSTRUCTION
2402                         
2403                         ;TEMPORARY (LOCALLY USED) VARIABLES
2404 7fc5                    TEMP1  RMB    2        ;IN: MAIN
2405 7fc7                    TEMP2  RMB    2        ;IN: MAIN
2406 7fc9                    TEMP3  RMB    2        ;IN: FNDSTR,MAIN
2407 7fcb                    TEMP4  RMB    2        ;IN: MAIN
2408 7fcd                    TEMP5  RMB    2        ;IN: MAIN
2409 7fcf                    TEMP6  RMB    2        ;IN: MAIN
2410 7fd1                    TEMP7  RMB    2        ;IN: MAIN
2411 7fd3                    TEMP8  RMB    2        ;IN: MAIN
2412 7fd5                    TEMP9  RMB    2        ;IN: MAIN
2413 7fd7                    TEMP10 RMB    2        ;IN: MAIN
2414 7fd9                    TEMP11 RMB    2        ;IN: MAIN
2415                         
2416                         ;XTEMP IS NOT TO BE USED TO SAVE IX BETWEEN ROUTINES
2417 7fdb                    XTEMP  RMB    2        ;USED BY DUMP,TYPCMD,OUTNUM
2418 7fdd                    XTEMP1 RMB    2        ;USED BY OUTNUM
2419 7fdf                    XTEMP2 RMB    2        ;USED BY NUMBER
2420 7fe1                    NUMMAT RMB    1        ;USED IN COMMAND
2421 7fe2                    LISNUM RMB    1        ;USED ON COMMAND
2422 7fe3                    COMNUM RMB    1        ;USED IN COMMAND
2423 7fe4                    LISPTR RMB    2        ;USED IN COMMAND
2424 7fe6                    DECDIG RMB    1        ;DECIMAL DIGIT BEING BUILT (DECIMAL OUTPUT BASE)
2425 7fe7                    NUMBHI RMB    1        ;USED BY OUTNUM
2426 7fe8                    NUMBLO RMB    1        ;USED BY OUTNUM
2427 7fe9                    NBR2X  RMB    2        ;USED BY NUMBER
2428 7feb                    TIMCON RMB    2        ;DELAY TIME CONSTANT
2429 7fed                    BYTECT RMB    1        ;RECORD BYTE COUNT USED IN LOAD COMMAND
2430 7fee                    CKSM   RMB    1        ;RECORD CHECKSUM USED IN LOAD COMMAND
2431                         
2432                         ;CONVENIENT EQUIVALENCES FOR LOCAL VARIABLES
2433 7fc5                    MEMADR EQU    TEMP1    ;DISPLAY,SET,SEARCH,TEST
2434 7fc7                    STRNUM EQU    TEMP2    ;FNDSTR
2435 7fc8                    EOSCHR EQU    TEMP2+1  ;FNDSTR
2436                         
2437                         ;FOR "SEARCH" COMMAND
2438 7fc7                    BYTPTR EQU    TEMP2
2439 7fc9                    NBYTES EQU    TEMP3
2440 7fca                    NBRMAT EQU    TEMP3+1
2441 7fcb                    BYTSTR EQU    TEMP4
2442                         
2443                         ;      END
